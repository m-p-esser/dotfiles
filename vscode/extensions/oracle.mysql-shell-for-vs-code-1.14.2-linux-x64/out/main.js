"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/ws/lib/stream.js"(exports, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream2(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data))
          ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused)
          ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream2;
  }
});

// node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "node_modules/ws/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i63 = 0; i63 < list.length; i63++) {
        const buf = list[i63];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i63 = 0; i63 < length; i63++) {
        output[offset + i63] = source[i63] ^ mask[i63 & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i63 = 0; i63 < buffer.length; i63++) {
        buffer[i63] ^= mask[i63 & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bufferUtil.mask(source, mask, output, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports, module2) {
    "use strict";
    var { isUtf8 } = require("buffer");
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i63 = 0;
      while (i63 < len) {
        if ((buf[i63] & 128) === 0) {
          i63++;
        } else if ((buf[i63] & 224) === 192) {
          if (i63 + 1 === len || (buf[i63 + 1] & 192) !== 128 || (buf[i63] & 254) === 192) {
            return false;
          }
          i63 += 2;
        } else if ((buf[i63] & 240) === 224) {
          if (i63 + 2 >= len || (buf[i63 + 1] & 192) !== 128 || (buf[i63 + 2] & 192) !== 128 || buf[i63] === 224 && (buf[i63 + 1] & 224) === 128 || // Overlong
          buf[i63] === 237 && (buf[i63 + 1] & 224) === 160) {
            return false;
          }
          i63 += 3;
        } else if ((buf[i63] & 248) === 240) {
          if (i63 + 3 >= len || (buf[i63 + 1] & 192) !== 128 || (buf[i63 + 2] & 192) !== 128 || (buf[i63 + 3] & 192) !== 128 || buf[i63] === 240 && (buf[i63 + 1] & 240) === 128 || // Overlong
          buf[i63] === 244 && buf[i63 + 1] > 143 || buf[i63] > 244) {
            return false;
          }
          i63 += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    module2.exports = {
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module2.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver2 = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n,
            buf.length - n
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n,
              buf.length - n
            );
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
          }
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            this._loop = false;
            return error(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          }
        } else {
          this._loop = false;
          return error(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
          }
        } else if (this._masked) {
          this._loop = false;
          return error(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      /**
       * Payload length has been read.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(
                error(
                  RangeError,
                  "Max payload size exceeded",
                  false,
                  1009,
                  "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
                )
              );
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @return {(Error|undefined)} A possible error
       * @private
       */
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data, true);
          } else {
            const buf = concat(fragments, messageLength);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              this._loop = false;
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("message", buf, false);
          }
        }
        this._state = GET_INFO;
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("conclude", code, buf);
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver2;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(
        prefix ? `Invalid WebSocket frame: ${message}` : message
      );
      Error.captureStackTrace(err, error);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports, module2) {
    "use strict";
    var net2 = require("net");
    var tls = require("tls");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var Sender2 = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {(net.Socket|tls.Socket)} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions2, generateMask) {
        this._extensions = extensions2 || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            randomFillSync(mask, 0, 4);
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask)
          return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking)
          return [target, data];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            [kByteLength]: byteLength,
            fin: options.fin,
            generateMask: this._generateMask,
            mask: options.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data, this._compress, opts, cb]);
          } else {
            this.dispatch(data, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            _Sender.frame(data, {
              [kByteLength]: byteLength,
              fin: options.fin,
              generateMask: this._generateMask,
              mask: options.mask,
              maskBuffer: this._maskBuffer,
              opcode,
              readOnly,
              rsv1: false
            }),
            cb
          );
        }
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_3, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function")
              cb(err);
            for (let i63 = 0; i63 < this._queue.length; i63++) {
              const params = this._queue[i63];
              const callback = params[params.length - 1];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(_Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender2;
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event5 = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event5.prototype, "target", { enumerable: true });
    Object.defineProperty(Event5.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event5 {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event5 {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event5 {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event5("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event: Event5,
      EventTarget,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i63 = 0;
      for (; i63 < header.length; i63++) {
        code = header.charCodeAt(i63);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i63;
          } else if (i63 !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1)
              end = i63;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i63}`);
            }
            if (end === -1)
              end = i63;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i63}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i63;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i63;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i63}`);
            }
            if (end === -1)
              end = i63;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i63);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i63}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i63}`);
            }
            if (start === -1)
              start = i63;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i63;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i63;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i63}`);
            }
          } else if (code === 34 && header.charCodeAt(i63 - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i63;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i63;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i63}`);
            }
            if (end === -1)
              end = i63;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i63}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i63;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions2) {
      return Object.keys(extensions2).map((extension) => {
        let configurations = extensions2[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k3) => {
              let values = params[k3];
              if (!Array.isArray(values))
                values = [values];
              return values.map((v3) => v3 === true ? k3 : `${k3}=${v3}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports, module2) {
    "use strict";
    var EventEmitter5 = require("events");
    var https = require("https");
    var http = require("http");
    var net2 = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Readable } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver2 = require_receiver();
    var Sender2 = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket3 = class _WebSocket extends EventEmitter5 {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      /**
       * This deviates from the WHATWG interface since ws doesn't support the
       * required default "blob" type (instead we define a custom "nodebuffer"
       * type).
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver2({
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        this._sender = new Sender2(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === _WebSocket.CLOSED)
          return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain)
          this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED)
          return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket3, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket3.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket3, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket3.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket3, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket3.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket3, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket3.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket3.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket3.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute])
              return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function")
            return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket3.prototype.addEventListener = addEventListener;
    WebSocket3.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket3;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        try {
          parsedUrl = new URL2(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
        websocket._url = address;
      }
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request = isSecure ? https.request : http.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost)
              delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted])
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket3.CONNECTING)
          return;
        req = websocket._req = null;
        if (res.headers.upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions2;
          try {
            extensions2 = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions2);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions2[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      req.end();
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket3.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net2.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net2.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket3.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused)
        websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket3.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket3.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket3.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "node_modules/ws/lib/subprotocol.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i63 = 0;
      for (i63; i63 < header.length; i63++) {
        const code = header.charCodeAt(i63);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i63;
        } else if (i63 !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i63;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i63}`);
          }
          if (end === -1)
            end = i63;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i63}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i63);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse };
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports, module2) {
    "use strict";
    var EventEmitter5 = require("events");
    var http = require("http");
    var https = require("https");
    var net2 = require("net");
    var tls = require("tls");
    var { createHash } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket3 = require_websocket();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer2 = class extends EventEmitter5 {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket3,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const version = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (req.headers.upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!key || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version !== 8 && version !== 13) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions2 = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions2[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions2,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions2, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions2, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions2[PerMessageDeflate.extensionName]) {
          const params = extensions2[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions2;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer2;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h3) => `${h3}: ${headers[h3]}`).join("\r\n") + "\r\n\r\n" + message
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message);
      }
    }
  }
});

// node_modules/anser/lib/index.js
var require_lib = __commonJS({
  "node_modules/anser/lib/index.js"(exports, module2) {
    "use strict";
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i63 = 0; i63 < props.length; i63++) {
          var descriptor = props[i63];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var ANSI_COLORS = [[{ color: "0, 0, 0", "class": "ansi-black" }, { color: "187, 0, 0", "class": "ansi-red" }, { color: "0, 187, 0", "class": "ansi-green" }, { color: "187, 187, 0", "class": "ansi-yellow" }, { color: "0, 0, 187", "class": "ansi-blue" }, { color: "187, 0, 187", "class": "ansi-magenta" }, { color: "0, 187, 187", "class": "ansi-cyan" }, { color: "255,255,255", "class": "ansi-white" }], [{ color: "85, 85, 85", "class": "ansi-bright-black" }, { color: "255, 85, 85", "class": "ansi-bright-red" }, { color: "0, 255, 0", "class": "ansi-bright-green" }, { color: "255, 255, 85", "class": "ansi-bright-yellow" }, { color: "85, 85, 255", "class": "ansi-bright-blue" }, { color: "255, 85, 255", "class": "ansi-bright-magenta" }, { color: "85, 255, 255", "class": "ansi-bright-cyan" }, { color: "255, 255, 255", "class": "ansi-bright-white" }]];
    var Anser2 = function() {
      _createClass(Anser3, null, [{
        key: "escapeForHtml",
        /**
         * Anser.escapeForHtml
         * Escape the input HTML.
         *
         * This does the minimum escaping of text to make it compliant with HTML.
         * In particular, the '&','<', and '>' characters are escaped. This should
         * be run prior to `ansiToHtml`.
         *
         * @name Anser.escapeForHtml
         * @function
         * @param {String} txt The input text (containing the ANSI snippets).
         * @returns {String} The escaped html.
         */
        value: function escapeForHtml(txt) {
          return new Anser3().escapeForHtml(txt);
        }
        /**
         * Anser.linkify
         * Adds the links in the HTML.
         *
         * This replaces any links in the text with anchor tags that display the
         * link. The links should have at least one whitespace character
         * surrounding it. Also, you should apply this after you have run
         * `ansiToHtml` on the text.
         *
         * @name Anser.linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML containing the <a> tags (unescaped).
         */
      }, {
        key: "linkify",
        value: function linkify(txt) {
          return new Anser3().linkify(txt);
        }
        /**
         * Anser.ansiToHtml
         * This replaces ANSI terminal escape codes with SPAN tags that wrap the
         * content.
         *
         * This function only interprets ANSI SGR (Select Graphic Rendition) codes
         * that can be represented in HTML.
         * For example, cursor movement codes are ignored and hidden from output.
         * The default style uses colors that are very close to the prescribed
         * standard. The standard assumes that the text will have a black
         * background. These colors are set as inline styles on the SPAN tags.
         *
         * Another option is to set `use_classes: true` in the options argument.
         * This will instead set classes on the spans so the colors can be set via
         * CSS. The class names used are of the format `ansi-*-fg/bg` and
         * `ansi-bright-*-fg/bg` where `*` is the color name,
         * i.e black/red/green/yellow/blue/magenta/cyan/white.
         *
         * @name Anser.ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */
      }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
          return new Anser3().ansiToHtml(txt, options);
        }
        /**
         * Anser.ansiToJson
         * Converts ANSI input into JSON output.
         *
         * @name Anser.ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */
      }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
          return new Anser3().ansiToJson(txt, options);
        }
        /**
         * Anser.ansiToText
         * Converts ANSI input into text output.
         *
         * @name Anser.ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */
      }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
          return new Anser3().ansiToText(txt);
        }
        /**
         * Anser
         * The `Anser` class.
         *
         * @name Anser
         * @function
         * @returns {Anser}
         */
      }]);
      function Anser3() {
        _classCallCheck(this, Anser3);
        this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null;
        this.bright = 0;
        this.decorations = [];
      }
      _createClass(Anser3, [{
        key: "setupPalette",
        value: function setupPalette() {
          this.PALETTE_COLORS = [];
          for (var i63 = 0; i63 < 2; ++i63) {
            for (var j = 0; j < 8; ++j) {
              this.PALETTE_COLORS.push(ANSI_COLORS[i63][j].color);
            }
          }
          var levels = [0, 95, 135, 175, 215, 255];
          var format = function format2(r2, g4, b4) {
            return levels[r2] + ", " + levels[g4] + ", " + levels[b4];
          };
          var r = void 0, g3 = void 0, b3 = void 0;
          for (var _r = 0; _r < 6; ++_r) {
            for (var _g = 0; _g < 6; ++_g) {
              for (var _b = 0; _b < 6; ++_b) {
                this.PALETTE_COLORS.push(format(_r, _g, _b));
              }
            }
          }
          var level = 8;
          for (var _i = 0; _i < 24; ++_i, level += 10) {
            this.PALETTE_COLORS.push(format(level, level, level));
          }
        }
        /**
         * escapeForHtml
         * Escapes the input text.
         *
         * @name escapeForHtml
         * @function
         * @param {String} txt The input text.
         * @returns {String} The escpaed HTML output.
         */
      }, {
        key: "escapeForHtml",
        value: function escapeForHtml(txt) {
          return txt.replace(/[&<>\"]/gm, function(str) {
            return str == "&" ? "&amp;" : str == '"' ? "&quot;" : str == "<" ? "&lt;" : str == ">" ? "&gt;" : "";
          });
        }
        /**
         * linkify
         * Adds HTML link elements.
         *
         * @name linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML output containing link elements.
         */
      }, {
        key: "linkify",
        value: function linkify(txt) {
          return txt.replace(/(https?:\/\/[^\s]+)/gm, function(str) {
            return '<a href="' + str + '">' + str + "</a>";
          });
        }
        /**
         * ansiToHtml
         * Converts ANSI input into HTML output.
         *
         * @name ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The HTML output.
         */
      }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
          return this.process(txt, options, true);
        }
        /**
         * ansiToJson
         * Converts ANSI input into HTML output.
         *
         * @name ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The JSON output.
         */
      }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
          options = options || {};
          options.json = true;
          options.clearLine = false;
          return this.process(txt, options, true);
        }
        /**
         * ansiToText
         * Converts ANSI input into HTML output.
         *
         * @name ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */
      }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
          return this.process(txt, {}, false);
        }
        /**
         * process
         * Processes the input.
         *
         * @name process
         * @function
         * @param {String} txt The input text.
         * @param {Object} options An object passed to `processChunk` method, extended with:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup
         */
      }, {
        key: "process",
        value: function process2(txt, options, markup) {
          var _this = this;
          var self = this;
          var raw_text_chunks = txt.split(/\033\[/);
          var first_chunk = raw_text_chunks.shift();
          if (options === void 0 || options === null) {
            options = {};
          }
          options.clearLine = /\r/.test(txt);
          var color_chunks = raw_text_chunks.map(function(chunk) {
            return _this.processChunk(chunk, options, markup);
          });
          if (options && options.json) {
            var first = self.processChunkJson("");
            first.content = first_chunk;
            first.clearLine = options.clearLine;
            color_chunks.unshift(first);
            if (options.remove_empty) {
              color_chunks = color_chunks.filter(function(c) {
                return !c.isEmpty();
              });
            }
            return color_chunks;
          } else {
            color_chunks.unshift(first_chunk);
          }
          return color_chunks.join("");
        }
        /**
         * processChunkJson
         * Processes the current chunk into json output.
         *
         * @name processChunkJson
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object} The result object:
         *
         *  - `content` (String): The text.
         *  - `fg` (String|null): The foreground color.
         *  - `bg` (String|null): The background color.
         *  - `fg_truecolor` (String|null): The foreground true color (if 16m color is enabled).
         *  - `bg_truecolor` (String|null): The background true color (if 16m color is enabled).
         *  - `clearLine` (Boolean): `true` if a carriageReturn \r was fount at end of line.
         *  - `was_processed` (Bolean): `true` if the colors were processed, `false` otherwise.
         *  - `isEmpty` (Function): A function returning `true` if the content is empty, or `false` otherwise.
         *
         */
      }, {
        key: "processChunkJson",
        value: function processChunkJson(text, options, markup) {
          options = typeof options == "undefined" ? {} : options;
          var use_classes = options.use_classes = typeof options.use_classes != "undefined" && options.use_classes;
          var key = options.key = use_classes ? "class" : "color";
          var result = {
            content: text,
            fg: null,
            bg: null,
            fg_truecolor: null,
            bg_truecolor: null,
            isInverted: false,
            clearLine: options.clearLine,
            decoration: null,
            decorations: [],
            was_processed: false,
            isEmpty: function isEmpty() {
              return !result.content;
            }
          };
          var matches = text.match(/^([!\x3c-\x3f]*)([\d;]*)([\x20-\x2c]*[\x40-\x7e])([\s\S]*)/m);
          if (!matches)
            return result;
          var orig_txt = result.content = matches[4];
          var nums = matches[2].split(";");
          if (matches[1] !== "" || matches[3] !== "m") {
            return result;
          }
          if (!markup) {
            return result;
          }
          var self = this;
          while (nums.length > 0) {
            var num_str = nums.shift();
            var num = parseInt(num_str);
            if (isNaN(num) || num === 0) {
              self.fg = self.bg = null;
              self.decorations = [];
            } else if (num === 1) {
              self.decorations.push("bold");
            } else if (num === 2) {
              self.decorations.push("dim");
            } else if (num === 3) {
              self.decorations.push("italic");
            } else if (num === 4) {
              self.decorations.push("underline");
            } else if (num === 5) {
              self.decorations.push("blink");
            } else if (num === 7) {
              self.decorations.push("reverse");
            } else if (num === 8) {
              self.decorations.push("hidden");
            } else if (num === 9) {
              self.decorations.push("strikethrough");
            } else if (num === 21) {
              self.removeDecoration("bold");
            } else if (num === 22) {
              self.removeDecoration("bold");
              self.removeDecoration("dim");
            } else if (num === 23) {
              self.removeDecoration("italic");
            } else if (num === 24) {
              self.removeDecoration("underline");
            } else if (num === 25) {
              self.removeDecoration("blink");
            } else if (num === 27) {
              self.removeDecoration("reverse");
            } else if (num === 28) {
              self.removeDecoration("hidden");
            } else if (num === 29) {
              self.removeDecoration("strikethrough");
            } else if (num === 39) {
              self.fg = null;
            } else if (num === 49) {
              self.bg = null;
            } else if (num >= 30 && num < 38) {
              self.fg = ANSI_COLORS[0][num % 10][key];
            } else if (num >= 90 && num < 98) {
              self.fg = ANSI_COLORS[1][num % 10][key];
            } else if (num >= 40 && num < 48) {
              self.bg = ANSI_COLORS[0][num % 10][key];
            } else if (num >= 100 && num < 108) {
              self.bg = ANSI_COLORS[1][num % 10][key];
            } else if (num === 38 || num === 48) {
              var is_foreground = num === 38;
              if (nums.length >= 1) {
                var mode = nums.shift();
                if (mode === "5" && nums.length >= 1) {
                  var palette_index = parseInt(nums.shift());
                  if (palette_index >= 0 && palette_index <= 255) {
                    if (!use_classes) {
                      if (!this.PALETTE_COLORS) {
                        self.setupPalette();
                      }
                      if (is_foreground) {
                        self.fg = this.PALETTE_COLORS[palette_index];
                      } else {
                        self.bg = this.PALETTE_COLORS[palette_index];
                      }
                    } else {
                      var klass = palette_index >= 16 ? "ansi-palette-" + palette_index : ANSI_COLORS[palette_index > 7 ? 1 : 0][palette_index % 8]["class"];
                      if (is_foreground) {
                        self.fg = klass;
                      } else {
                        self.bg = klass;
                      }
                    }
                  }
                } else if (mode === "2" && nums.length >= 3) {
                  var r = parseInt(nums.shift());
                  var g3 = parseInt(nums.shift());
                  var b3 = parseInt(nums.shift());
                  if (r >= 0 && r <= 255 && g3 >= 0 && g3 <= 255 && b3 >= 0 && b3 <= 255) {
                    var color = r + ", " + g3 + ", " + b3;
                    if (!use_classes) {
                      if (is_foreground) {
                        self.fg = color;
                      } else {
                        self.bg = color;
                      }
                    } else {
                      if (is_foreground) {
                        self.fg = "ansi-truecolor";
                        self.fg_truecolor = color;
                      } else {
                        self.bg = "ansi-truecolor";
                        self.bg_truecolor = color;
                      }
                    }
                  }
                }
              }
            }
          }
          if (self.fg === null && self.bg === null && self.decorations.length === 0) {
            return result;
          } else {
            var styles = [];
            var classes = [];
            var data = {};
            result.fg = self.fg;
            result.bg = self.bg;
            result.fg_truecolor = self.fg_truecolor;
            result.bg_truecolor = self.bg_truecolor;
            result.decorations = self.decorations;
            result.decoration = self.decorations.slice(-1).pop() || null;
            result.was_processed = true;
            return result;
          }
        }
        /**
         * processChunk
         * Processes the current chunk of text.
         *
         * @name processChunk
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object|String} The result (object if `json` is wanted back or string otherwise).
         */
      }, {
        key: "processChunk",
        value: function processChunk(text, options, markup) {
          var _this2 = this;
          options = options || {};
          var jsonChunk = this.processChunkJson(text, options, markup);
          var use_classes = options.use_classes;
          jsonChunk.decorations = jsonChunk.decorations.filter(function(decoration) {
            if (decoration === "reverse") {
              if (!jsonChunk.fg) {
                jsonChunk.fg = ANSI_COLORS[0][7][use_classes ? "class" : "color"];
              }
              if (!jsonChunk.bg) {
                jsonChunk.bg = ANSI_COLORS[0][0][use_classes ? "class" : "color"];
              }
              var tmpFg = jsonChunk.fg;
              jsonChunk.fg = jsonChunk.bg;
              jsonChunk.bg = tmpFg;
              var tmpFgTrue = jsonChunk.fg_truecolor;
              jsonChunk.fg_truecolor = jsonChunk.bg_truecolor;
              jsonChunk.bg_truecolor = tmpFgTrue;
              jsonChunk.isInverted = true;
              return false;
            }
            return true;
          });
          if (options.json) {
            return jsonChunk;
          }
          if (jsonChunk.isEmpty()) {
            return "";
          }
          if (!jsonChunk.was_processed) {
            return jsonChunk.content;
          }
          var colors = [];
          var decorations = [];
          var textDecorations = [];
          var data = {};
          var render_data = function render_data2(data2) {
            var fragments = [];
            var key = void 0;
            for (key in data2) {
              if (data2.hasOwnProperty(key)) {
                fragments.push("data-" + key + '="' + _this2.escapeForHtml(data2[key]) + '"');
              }
            }
            return fragments.length > 0 ? " " + fragments.join(" ") : "";
          };
          if (jsonChunk.isInverted) {
            data["ansi-is-inverted"] = "true";
          }
          if (jsonChunk.fg) {
            if (use_classes) {
              colors.push(jsonChunk.fg + "-fg");
              if (jsonChunk.fg_truecolor !== null) {
                data["ansi-truecolor-fg"] = jsonChunk.fg_truecolor;
                jsonChunk.fg_truecolor = null;
              }
            } else {
              colors.push("color:rgb(" + jsonChunk.fg + ")");
            }
          }
          if (jsonChunk.bg) {
            if (use_classes) {
              colors.push(jsonChunk.bg + "-bg");
              if (jsonChunk.bg_truecolor !== null) {
                data["ansi-truecolor-bg"] = jsonChunk.bg_truecolor;
                jsonChunk.bg_truecolor = null;
              }
            } else {
              colors.push("background-color:rgb(" + jsonChunk.bg + ")");
            }
          }
          jsonChunk.decorations.forEach(function(decoration) {
            if (use_classes) {
              decorations.push("ansi-" + decoration);
              return;
            }
            if (decoration === "bold") {
              decorations.push("font-weight:bold");
            } else if (decoration === "dim") {
              decorations.push("opacity:0.5");
            } else if (decoration === "italic") {
              decorations.push("font-style:italic");
            } else if (decoration === "hidden") {
              decorations.push("visibility:hidden");
            } else if (decoration === "strikethrough") {
              textDecorations.push("line-through");
            } else {
              textDecorations.push(decoration);
            }
          });
          if (textDecorations.length) {
            decorations.push("text-decoration:" + textDecorations.join(" "));
          }
          if (use_classes) {
            return '<span class="' + colors.concat(decorations).join(" ") + '"' + render_data(data) + ">" + jsonChunk.content + "</span>";
          } else {
            return '<span style="' + colors.concat(decorations).join(";") + '"' + render_data(data) + ">" + jsonChunk.content + "</span>";
          }
        }
      }, {
        key: "removeDecoration",
        value: function removeDecoration(decoration) {
          var index = this.decorations.indexOf(decoration);
          if (index >= 0) {
            this.decorations.splice(index, 1);
          }
        }
      }]);
      return Anser3;
    }();
    module2.exports = Anser2;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m3 = s * 60;
    var h3 = m3 * 60;
    var d3 = h3 * 24;
    var w3 = d3 * 7;
    var y3 = d3 * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y3;
        case "weeks":
        case "week":
        case "w":
          return n * w3;
        case "days":
        case "day":
        case "d":
          return n * d3;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h3;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m3;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d3) {
        return Math.round(ms / d3) + "d";
      }
      if (msAbs >= h3) {
        return Math.round(ms / h3) + "h";
      }
      if (msAbs >= m3) {
        return Math.round(ms / m3) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d3) {
        return plural(ms, msAbs, d3, "day");
      }
      if (msAbs >= h3) {
        return plural(ms, msAbs, h3, "hour");
      }
      if (msAbs >= m3) {
        return plural(ms, msAbs, m3, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module2) {
    function setup(env4) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env4).forEach((key) => {
        createDebug[key] = env4[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i63 = 0; i63 < namespace.length; i63++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i63);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v3) => {
            enableOverride = v3;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i63;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i63 = 0; i63 < len; i63++) {
          if (!split[i63]) {
            continue;
          }
          namespaces = split[i63].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i63;
        let len;
        for (i63 = 0, len = createDebug.skips.length; i63 < len; i63++) {
          if (createDebug.skips[i63].test(name)) {
            return false;
          }
        }
        for (i63 = 0, len = createDebug.names.length; i63 < len; i63++) {
          if (createDebug.names[i63].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v3) {
      try {
        return JSON.stringify(v3);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os3 = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env: env4 } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env4) {
      if (env4.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env4.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env4.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env4.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env4.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os3.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env4) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env4) || env4.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env4) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env4.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env4.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env4) {
        const version = parseInt((env4.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env4.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env4.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env4.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env4) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty");
    var util = require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_3, k3) => {
        return k3.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i63 = 0; i63 < keys.length; i63++) {
        debug.inspectOpts[keys[i63]] = exports.inspectOpts[keys[i63]];
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v3) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v3, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v3) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v3, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/regedit/errors.js
var require_errors = __commonJS({
  "node_modules/regedit/errors.js"(exports, module2) {
    var errors = {};
    errors[25121] = new Error("missing arguments");
    errors[25121].code = 25121;
    errors[25122] = new Error("unsupported hive");
    errors[25122].code = 25122;
    errors[25123] = new Error("expected to have groups of 4 arguments for each value that is written to the registry");
    errors[25123].code = 25123;
    errors[25124] = new Error('missing or invalid architecture from arguments, use "A" (agnostic), "S" (specific), "32" or "64"');
    errors[25124].code = 25124;
    errors[25125] = new Error("missing OSArchitecture global. Forgot to load util.vbs? submit an issue asap with steps to recreate");
    errors[25125].code = 25125;
    errors[25126] = new Error("invalid os architecture detected");
    errors[25126].code = 25126;
    errors[25127] = new Error("empty line written to vbscript stdin");
    errors[25127].code = 25127;
    errors[5] = new Error("access is denied");
    errors[5].code = 5;
    errors[2] = new Error("registry path does not exist");
    errors[2].code = 2;
    var e0 = new Error("wbemErrFailed");
    e0.description = "The call failed.";
    e0.code = 2147749889;
    errors[2147749889] = e0;
    var e1 = new Error("wbemErrNotFound");
    e1.description = "The object could not be found.";
    e1.code = 2147749890;
    errors[2147749890] = e1;
    var e2 = new Error("wbemErrAccessDenied");
    e2.description = "The current user does not have permission to perform the action.";
    e2.code = 2147749891;
    errors[2147749891] = e2;
    var e3 = new Error("wbemErrProviderFailure");
    e3.description = "The provider has failed at some time other than during initialization.";
    e3.code = 2147749892;
    errors[2147749892] = e3;
    var e4 = new Error("wbemErrTypeMismatch");
    e4.description = "A type mismatch occurred.";
    e4.code = 2147749893;
    errors[2147749893] = e4;
    var e5 = new Error("wbemErrOutOfMemory");
    e5.description = "There was not enough memory for the operation.";
    e5.code = 2147749894;
    errors[2147749894] = e5;
    var e6 = new Error("wbemErrInvalidContext");
    e6.description = "The SWbemNamedValue object is not valid.";
    e6.code = 2147749895;
    errors[2147749895] = e6;
    var e7 = new Error("wbemErrInvalidParameter");
    e7.description = "One of the parameters to the call is not correct.";
    e7.code = 2147749896;
    errors[2147749896] = e7;
    var e8 = new Error("wbemErrNotAvailable");
    e8.description = "The resource, typically a remote server, is not currently available.";
    e8.code = 2147749897;
    errors[2147749897] = e8;
    var e9 = new Error("wbemErrCriticalError");
    e9.description = "An internal, critical, and unexpected error occurred. Report this error to Microsoft Technical Support.";
    e9.code = 2147749898;
    errors[2147749898] = e9;
    var e10 = new Error("wbemErrInvalidStream");
    e10.description = "One or more network packets were corrupted during a remote session.";
    e10.code = 2147749899;
    errors[2147749899] = e10;
    var e11 = new Error("wbemErrNotSupported");
    e11.description = "The feature or operation is not supported.";
    e11.code = 2147749900;
    errors[2147749900] = e11;
    var e12 = new Error("wbemErrInvalidSuperclass");
    e12.description = "The parent class specified is not valid.";
    e12.code = 2147749901;
    errors[2147749901] = e12;
    var e13 = new Error("wbemErrInvalidNamespace");
    e13.description = "The namespace specified could not be found.";
    e13.code = 2147749902;
    errors[2147749902] = e13;
    var e14 = new Error("wbemErrInvalidObject");
    e14.description = "The specified instance is not valid.";
    e14.code = 2147749903;
    errors[2147749903] = e14;
    var e15 = new Error("wbemErrInvalidClass");
    e15.description = "The specified class is not valid.";
    e15.code = 2147749904;
    errors[2147749904] = e15;
    var e16 = new Error("wbemErrProviderNotFound");
    e16.description = "A provider referenced in the schema does not have a corresponding registration.";
    e16.code = 2147749905;
    errors[2147749905] = e16;
    var e17 = new Error("wbemErrInvalidProviderRegistration");
    e17.description = "A provider referenced in the schema has an incorrect or incomplete registration. This error may be caused by a missing pragma namespace command in the MOF file used to register the provider, resulting in the provider being registered in the wrong WMI namespace. This error may also be caused by a corrupt repository, which may be fixed by deleting it and recompiling the MOF files.";
    e17.code = 2147749906;
    errors[2147749906] = e17;
    var e18 = new Error("wbemErrProviderLoadFailure");
    e18.description = "COM cannot locate a provider referenced in the schema. This error may be caused by any of the following:";
    e18.code = 2147749907;
    errors[2147749907] = e18;
    var e19 = new Error("wbemErrInitializationFailure");
    e19.description = "A component, such as a provider, failed to initialize for internal reasons.";
    e19.code = 2147749908;
    errors[2147749908] = e19;
    var e20 = new Error("wbemErrTransportFailure");
    e20.description = "A networking error occurred, preventing normal operation.";
    e20.code = 2147749909;
    errors[2147749909] = e20;
    var e21 = new Error("wbemErrInvalidOperation");
    e21.description = "The requested operation is not valid. This error usually applies to invalid attempts to delete classes or properties.";
    e21.code = 2147749910;
    errors[2147749910] = e21;
    var e22 = new Error("wbemErrInvalidQuery");
    e22.description = "The requested operation is not valid. This error usually applies to invalid attempts to delete classes or properties.";
    e22.code = 2147749911;
    errors[2147749911] = e22;
    var e23 = new Error("wbemErrInvalidQueryType");
    e23.description = "The requested query language is not supported.";
    e23.code = 2147749912;
    errors[2147749912] = e23;
    var e24 = new Error("wbemErrAlreadyExists");
    e24.description = "In a put operation, the wbemChangeFlagCreateOnly flag was specified, but the instance already exists.";
    e24.code = 2147749913;
    errors[2147749913] = e24;
    var e25 = new Error("wbemErrOverrideNotAllowed");
    e25.description = "It is not possible to perform the add operation on this qualifier because the owning object does not permit overrides.";
    e25.code = 2147749914;
    errors[2147749914] = e25;
    var e26 = new Error("wbemErrPropagatedQualifier");
    e26.description = "The user attempted to delete a qualifier that was not owned. The qualifier was inherited from a parent class.";
    e26.code = 2147749915;
    errors[2147749915] = e26;
    var e27 = new Error("wbemErrPropagatedProperty");
    e27.description = "The user attempted to delete a property that was not owned. The property was inherited from a parent class.";
    e27.code = 2147749916;
    errors[2147749916] = e27;
    var e28 = new Error("wbemErrUnexpected");
    e28.description = "The client made an unexpected and illegal sequence of calls, such as calling EndEnumeration before calling BeginEnumeration.";
    e28.code = 2147749917;
    errors[2147749917] = e28;
    var e29 = new Error("wbemErrIllegalOperation");
    e29.description = "The user requested an illegal operation, such as spawning a class from an instance.";
    e29.code = 2147749918;
    errors[2147749918] = e29;
    var e30 = new Error("wbemErrCannotBeKey");
    e30.description = "There was an illegal attempt to specify a key qualifier on a property that cannot be a key. The keys are specified in the class definition for an object, and cannot be altered on a per-instance basis.";
    e30.code = 2147749919;
    errors[2147749919] = e30;
    var e31 = new Error("wbemErrIncompleteClass");
    e31.description = "The current object is not a valid class definition. Either it is incomplete, or it has not been registered with WMI using SWbemObject.Put_.";
    e31.code = 2147749920;
    errors[2147749920] = e31;
    var e32 = new Error("wbemErrInvalidSyntax");
    e32.description = "The syntax of an input parameter is incorrect for the applicable data structure. For example, when a CIM datetime structure does not have the correct format when passed to SWbemDateTime.SetFileTime.";
    e32.code = 2147749921;
    errors[2147749921] = e32;
    var e33 = new Error("wbemErrNondecoratedObject");
    e33.description = "Reserved for future use.";
    e33.code = 2147749922;
    errors[2147749922] = e33;
    var e34 = new Error("wbemErrReadOnly");
    e34.description = "The property that you are attempting to modify is read-only.";
    e34.code = 2147749923;
    errors[2147749923] = e34;
    var e35 = new Error("wbemErrProviderNotCapable");
    e35.description = "The provider cannot perform the requested operation. This would include a query that is too complex, retrieving an instance, creating or updating a class, deleting a class, or enumerating a class.";
    e35.code = 2147749924;
    errors[2147749924] = e35;
    var e36 = new Error("wbemErrClassHasChildren");
    e36.description = "An attempt was made to make a change that would invalidate a subclass.";
    e36.code = 2147749925;
    errors[2147749925] = e36;
    var e37 = new Error("wbemErrClassHasInstances");
    e37.description = "An attempt has been made to delete or modify a class that has instances.";
    e37.code = 2147749926;
    errors[2147749926] = e37;
    var e38 = new Error("wbemErrQueryNotImplemented");
    e38.description = "Reserved for future use.";
    e38.code = 2147749927;
    errors[2147749927] = e38;
    var e39 = new Error("wbemErrIllegalNull");
    e39.description = "A value of Nothing was specified for a property that may not be Nothing, such as one that is marked by a Key, Indexed, or Not_Null qualifier.";
    e39.code = 2147749928;
    errors[2147749928] = e39;
    var e40 = new Error("wbemErrInvalidQualifierType");
    e40.description = "The CIM type specified for a property is not valid.";
    e40.code = 2147749929;
    errors[2147749929] = e40;
    var e41 = new Error("wbemErrInvalidPropertyType");
    e41.description = "The CIM type specified for a property is not valid.";
    e41.code = 2147749930;
    errors[2147749930] = e41;
    var e42 = new Error("wbemErrValueOutOfRange");
    e42.description = "The request was made with an out-of-range value, or is incompatible with the type.";
    e42.code = 2147749931;
    errors[2147749931] = e42;
    var e43 = new Error("wbemErrCannotBeSingleton");
    e43.description = "An illegal attempt was made to make a class singleton, such as when the class is derived from a non-singleton class.";
    e43.code = 2147749932;
    errors[2147749932] = e43;
    var e44 = new Error("wbemErrInvalidCimType");
    e44.description = "The CIM type specified is not valid.";
    e44.code = 2147749933;
    errors[2147749933] = e44;
    var e45 = new Error("wbemErrInvalidMethod");
    e45.description = "The requested method is not available.";
    e45.code = 2147749934;
    errors[2147749934] = e45;
    var e46 = new Error("wbemErrInvalidMethodParameters");
    e46.description = "The parameters provided for the method are not valid.";
    e46.code = 2147749935;
    errors[2147749935] = e46;
    var e47 = new Error("wbemErrSystemProperty");
    e47.description = "There was an attempt to get qualifiers on a system property.";
    e47.code = 2147749936;
    errors[2147749936] = e47;
    var e48 = new Error("wbemErrInvalidProperty");
    e48.description = "The property type is not recognized.";
    e48.code = 2147749937;
    errors[2147749937] = e48;
    var e49 = new Error("wbemErrCallCancelled");
    e49.description = "An asynchronous process has been canceled internally or by the user. Note that due to the timing and nature of the asynchronous operation the operation may not have been truly canceled.";
    e49.code = 2147749938;
    errors[2147749938] = e49;
    var e50 = new Error("wbemErrShuttingDown");
    e50.description = "The user has requested an operation while WMI is in the process of shutting down.";
    e50.code = 2147749939;
    errors[2147749939] = e50;
    var e51 = new Error("wbemErrPropagatedMethod");
    e51.description = "An attempt was made to reuse an existing method name from a parent class, and the signatures did not match.";
    e51.code = 2147749940;
    errors[2147749940] = e51;
    var e52 = new Error("wbemErrUnsupportedParameter");
    e52.description = "One or more parameter values, such as a query text, is too complex or unsupported. WMI is therefore requested to retry the operation with simpler parameters.";
    e52.code = 2147749941;
    errors[2147749941] = e52;
    var e53 = new Error("wbemErrMissingParameter");
    e53.description = "A parameter was missing from the method call.";
    e53.code = 2147749942;
    errors[2147749942] = e53;
    var e54 = new Error("wbemErrInvalidParameterId");
    e54.description = "A method parameter has an ID qualifier that is not valid.";
    e54.code = 2147749943;
    errors[2147749943] = e54;
    var e55 = new Error("wbemErrNonConsecutiveParameterIds");
    e55.description = "One or more of the method parameters have ID qualifiers that are out of sequence.";
    e55.code = 2147749944;
    errors[2147749944] = e55;
    var e56 = new Error("wbemErrParameterIdOnRetval");
    e56.description = "The return value for a method has an ID qualifier.";
    e56.code = 2147749945;
    errors[2147749945] = e56;
    var e57 = new Error("wbemErrInvalidObjectPath");
    e57.description = "The specified object path was not valid.";
    e57.code = 2147749946;
    errors[2147749946] = e57;
    var e58 = new Error("wbemErrOutOfDiskSpace");
    e58.description = "Windows Server 2003:  Disk is out of space or the 4 GB limit on WMI repository (CIM repository) size is reached.";
    e58.code = 2147749947;
    errors[2147749947] = e58;
    var e59 = new Error("wbemErrBufferTooSmall");
    e59.description = "The supplied buffer was too small to hold all the objects in the enumerator or to read a string property.";
    e59.code = 2147749948;
    errors[2147749948] = e59;
    var e60 = new Error("wbemErrUnsupportedPutExtension");
    e60.description = "The provider does not support the requested put operation.";
    e60.code = 2147749949;
    errors[2147749949] = e60;
    var e61 = new Error("wbemErrUnknownObjectType");
    e61.description = "An object with an incorrect type or version was encountered during marshaling.";
    e61.code = 2147749950;
    errors[2147749950] = e61;
    var e62 = new Error("wbemErrUnknownPacketType");
    e62.description = "A packet with an incorrect type or version was encountered during marshaling.";
    e62.code = 2147749951;
    errors[2147749951] = e62;
    var e63 = new Error("wbemErrMarshalVersionMismatch");
    e63.description = "The packet has an unsupported version.";
    e63.code = 2147749952;
    errors[2147749952] = e63;
    var e64 = new Error("wbemErrMarshalInvalidSignature");
    e64.description = "The packet appears to be corrupted.";
    e64.code = 2147749953;
    errors[2147749953] = e64;
    var e65 = new Error("wbemErrInvalidQualifier");
    e65.description = "An attempt has been made to mismatch qualifiers, such as putting [key] on an object instead of a property.";
    e65.code = 2147749954;
    errors[2147749954] = e65;
    var e66 = new Error("wbemErrInvalidDuplicateParameter");
    e66.description = "A duplicate parameter has been declared in a CIM method.";
    e66.code = 2147749955;
    errors[2147749955] = e66;
    var e67 = new Error("wbemErrTooMuchData");
    e67.description = "Reserved for future use.";
    e67.code = 2147749956;
    errors[2147749956] = e67;
    var e68 = new Error("wbemErrServerTooBusy");
    e68.description = "A call to IWbemObjectSink::Indicate has failed. The provider may choose to refire the event.";
    e68.code = 2147749957;
    errors[2147749957] = e68;
    var e69 = new Error("wbemErrInvalidFlavor");
    e69.description = "The specified flavor was not valid.";
    e69.code = 2147749958;
    errors[2147749958] = e69;
    var e70 = new Error("wbemErrCircularReference");
    e70.description = "An attempt has been made to create a reference that is circular (for example, deriving a class from itself).";
    e70.code = 2147749959;
    errors[2147749959] = e70;
    var e71 = new Error("wbemErrUnsupportedClassUpdate");
    e71.description = "The specified class is not supported.";
    e71.code = 2147749960;
    errors[2147749960] = e71;
    var e72 = new Error("wbemErrCannotChangeKeyInheritance");
    e72.description = "An attempt was made to change a key when instances or subclasses are already using the key.";
    e72.code = 2147749961;
    errors[2147749961] = e72;
    var e73 = new Error("wbemErrCannotChangeIndexInheritance");
    e73.description = "An attempt was made to change an index when instances or subclasses are already using the index.";
    e73.code = 2147749968;
    errors[2147749968] = e73;
    var e74 = new Error("wbemErrTooManyProperties");
    e74.description = "An attempt was made to create more properties than the current version of the class supports.";
    e74.code = 2147749969;
    errors[2147749969] = e74;
    var e75 = new Error("wbemErrUpdateTypeMismatch");
    e75.description = "A property was redefined with a conflicting type in a derived class.";
    e75.code = 2147749970;
    errors[2147749970] = e75;
    var e76 = new Error("wbemErrUpdateOverrideNotAllowed");
    e76.description = "An attempt was made in a derived class to override a non-overrideable qualifier.";
    e76.code = 2147749971;
    errors[2147749971] = e76;
    var e77 = new Error("wbemErrUpdatePropagatedMethod");
    e77.description = "A method was redeclared with a conflicting signature in a derived class.";
    e77.code = 2147749972;
    errors[2147749972] = e77;
    var e78 = new Error("wbemErrMethodNotImplemented");
    e78.description = "An attempt was made to execute a method not marked with [implemented] in any relevant class.";
    e78.code = 2147749973;
    errors[2147749973] = e78;
    var e79 = new Error("wbemErrMethodDisabled");
    e79.description = "An attempt was made to execute a method marked with [disabled].";
    e79.code = 2147749974;
    errors[2147749974] = e79;
    var e80 = new Error("wbemErrRefresherBusy");
    e80.description = "The refresher is busy with another operation.";
    e80.code = 2147749975;
    errors[2147749975] = e80;
    var e81 = new Error("wbemErrUnparsableQuery");
    e81.description = "The filtering query is syntactically not valid.";
    e81.code = 2147749976;
    errors[2147749976] = e81;
    var e82 = new Error("wbemErrNotEventClass");
    e82.description = "The FROM clause of a filtering query references a class that is not an event class (not derived from __Event).";
    e82.code = 2147749977;
    errors[2147749977] = e82;
    var e83 = new Error("wbemErrMissingGroupWithin");
    e83.description = "A GROUP BY clause was used without the corresponding GROUP WITHIN clause.";
    e83.code = 2147749978;
    errors[2147749978] = e83;
    var e84 = new Error("wbemErrMissingAggregationList");
    e84.description = "A GROUP BY clause was used. Aggregation on all properties is not supported.";
    e84.code = 2147749979;
    errors[2147749979] = e84;
    var e85 = new Error("wbemErrPropertyNotAnObject");
    e85.description = "Dot notation was used on a property that is not an embedded object.";
    e85.code = 2147749980;
    errors[2147749980] = e85;
    var e86 = new Error("wbemErrAggregatingByObject");
    e86.description = "A GROUP BY clause references a property that is an embedded object without using dot notation.";
    e86.code = 2147749981;
    errors[2147749981] = e86;
    var e87 = new Error("wbemErrUninterpretableProviderQuery");
    e87.description = "An event provider registration query ( __EventProviderRegistration) did not specify the classes for which events were provided.";
    e87.code = 2147749983;
    errors[2147749983] = e87;
    var e88 = new Error("wbemErrBackupRestoreWinmgmtRunning");
    e88.description = "An request was made to back up or restore the repository while WMI was using it.";
    e88.code = 2147749984;
    errors[2147749984] = e88;
    var e89 = new Error("wbemErrQueueOverflow");
    e89.description = "The asynchronous delivery queue overflowed due to the event consumer being too slow.";
    e89.code = 2147749985;
    errors[2147749985] = e89;
    var e90 = new Error("wbemErrPrivilegeNotHeld");
    e90.description = "The operation failed because the client did not have the necessary security privilege.";
    e90.code = 2147749986;
    errors[2147749986] = e90;
    var e91 = new Error("wbemErrInvalidOperator");
    e91.description = "The operator is not valid for this property type.";
    e91.code = 2147749987;
    errors[2147749987] = e91;
    var e92 = new Error("wbemErrLocalCredentials");
    e92.description = "The user specified a username, password or authority for a local connection. The user must use a blank username/password and rely on default security.";
    e92.code = 2147749988;
    errors[2147749988] = e92;
    var e93 = new Error("wbemErrCannotBeAbstract");
    e93.description = "The class was made abstract when its parent class is not abstract.";
    e93.code = 2147749989;
    errors[2147749989] = e93;
    var e94 = new Error("wbemErrAmendedObject");
    e94.description = "An amended object was put without the wbemFlagUseAmendedQualifiers flag being specified.";
    e94.code = 2147749990;
    errors[2147749990] = e94;
    var e95 = new Error("wbemErrClientTooSlow");
    e95.description = "Windows Server 2003:  The client was not retrieving objects quickly enough from an enumeration. This constant is returned when a client creates an enumeration object but does not retrieve objects from the enumerator in a timely fashion, causing the enumerator's object caches to get backed up.";
    e95.code = 2147749991;
    errors[2147749991] = e95;
    var e96 = new Error("wbemErrNullSecurityDescriptor");
    e96.description = "Windows Server 2003:  A null security descriptor was used.";
    e96.code = 2147749992;
    errors[2147749992] = e96;
    var e97 = new Error("wbemErrTimeout");
    e97.description = "Windows Server 2003:  The operation timed out.";
    e97.code = 2147749993;
    errors[2147749993] = e97;
    var e98 = new Error("wbemErrInvalidAssociation");
    e98.description = "Windows Server 2003:  The association being used is not valid.";
    e98.code = 2147749994;
    errors[2147749994] = e98;
    var e99 = new Error("wbemErrAmbiguousOperation");
    e99.description = "Windows Server 2003:  The operation was ambiguous.";
    e99.code = 2147749995;
    errors[2147749995] = e99;
    var e100 = new Error("wbemErrQuotaViolation");
    e100.description = "Windows Server 2003:  WMI is taking up too much memory. This could be caused either by low memory availability or excessive memory consumption by WMI.";
    e100.code = 2147749996;
    errors[2147749996] = e100;
    var e101 = new Error("wbemErrTransactionConflict");
    e101.description = "Windows Server 2003:  The operation resulted in a transaction conflict.";
    e101.code = 2147749997;
    errors[2147749997] = e101;
    var e102 = new Error("wbemErrForcedRollback");
    e102.description = "Windows Server 2003:  The transaction forced a rollback.";
    e102.code = 2147749998;
    errors[2147749998] = e102;
    var e103 = new Error("wbemErrUnsupportedLocale");
    e103.description = "Windows Server 2003:  The locale used in the call is not supported.";
    e103.code = 2147749999;
    errors[2147749999] = e103;
    var e104 = new Error("wbemErrHandleOutOfDate");
    e104.description = "Windows Server 2003:  The object handle is out of date.";
    e104.code = 214775e4;
    errors[214775e4] = e104;
    var e105 = new Error("wbemErrConnectionFailed");
    e105.description = "Windows Server 2003:  Indicates that the connection to the SQL database failed.";
    e105.code = 2147750001;
    errors[2147750001] = e105;
    var e106 = new Error("wbemErrInvalidHandleRequest");
    e106.description = "Windows Server 2003:  The handle request was not valid.";
    e106.code = 2147750002;
    errors[2147750002] = e106;
    var e107 = new Error("wbemErrPropertyNameTooWide");
    e107.description = "Windows Server 2003:  The property name contains more than 255 characters.";
    e107.code = 2147750003;
    errors[2147750003] = e107;
    var e108 = new Error("wbemErrClassNameTooWide");
    e108.description = "Windows Server 2003:  The class name contains more than 255 characters.";
    e108.code = 2147750004;
    errors[2147750004] = e108;
    var e109 = new Error("wbemErrMethodNameTooWide");
    e109.description = "Windows Server 2003:  The method name contains more than 255 characters.";
    e109.code = 2147750005;
    errors[2147750005] = e109;
    var e110 = new Error("wbemErrQualifierNameTooWide");
    e110.description = "Windows Server 2003:  The qualifier name contains more than 255 characters.";
    e110.code = 2147750006;
    errors[2147750006] = e110;
    var e111 = new Error("wbemErrRerunCommand");
    e111.description = "Windows Server 2003:  Indicates that an SQL command should be rerun because there is a deadlock in SQL. This can be returned only when data is being stored in an SQL database.";
    e111.code = 2147750007;
    errors[2147750007] = e111;
    var e112 = new Error("wbemErrDatabaseVerMismatch");
    e112.description = "Windows Server 2003:  The database version does not match the version that the repository driver processes.";
    e112.code = 2147750008;
    errors[2147750008] = e112;
    var e113 = new Error("wbemErrVetoDelete");
    e113.description = "Windows Server 2003:  WMI cannot do the delete operation because the provider does not allow it.";
    e113.code = 2147750010;
    errors[2147750010] = e113;
    var e114 = new Error("wbemErrVetoPut");
    e114.description = "Windows Server 2003:  WMI cannot do the put operation because the provider does not allow it.";
    e114.code = 2147750010;
    errors[2147750010] = e114;
    var e115 = new Error("wbemErrInvalidLocale");
    e115.description = "Windows Server 2003:  The specified locale identifier was not valid for the operation.";
    e115.code = 2147750016;
    errors[2147750016] = e115;
    var e116 = new Error("wbemErrProviderSuspended");
    e116.description = "Windows Server 2003:  The provider is suspended.";
    e116.code = 2147750017;
    errors[2147750017] = e116;
    var e117 = new Error("wbemErrSynchronizationRequired");
    e117.description = "Windows Server 2003:  The object must be committed and retrieved again before the requested operation can succeed. This constant is returned when an object must be committed and re-retrieved to see the property value.";
    e117.code = 2147750018;
    errors[2147750018] = e117;
    var e118 = new Error("wbemErrNoSchema");
    e118.description = "Windows Server 2003:  The operation cannot be completed because no schema is available.";
    e118.code = 2147750019;
    errors[2147750019] = e118;
    var e119 = new Error("wbemErrProviderAlreadyRegistered");
    e119.description = "Windows Server 2003:  The provider registration cannot be done because the provider is already registered.";
    e119.code = 2147750020;
    errors[2147750020] = e119;
    var e120 = new Error("wbemErrProviderNotRegistered");
    e120.description = "Windows Server 2003:  The provider for the requested data is not registered.";
    e120.code = 2147750021;
    errors[2147750021] = e120;
    var e121 = new Error("wbemErrFatalTransportError");
    e121.description = "Windows Server 2003:  A fatal transport error occurred and other transport will not be attempted.";
    e121.code = 2147750022;
    errors[2147750022] = e121;
    var e122 = new Error("wbemErrEncryptedConnectionRequired");
    e122.description = "Windows Server 2003:  The client connection to WINMGMT must be encrypted for this operation. The IWbemServices proxy security settings should be adjusted and the operation retried.";
    e122.code = 2147750023;
    errors[2147750023] = e122;
    var e123 = new Error("wbemErrRegistrationTooBroad");
    e123.description = "Windows Server 2003:  The provider registration overlaps with the system event domain.";
    e123.code = 2147753985;
    errors[2147753985] = e123;
    var e124 = new Error("wbemErrRegistrationTooPrecise");
    e124.description = "Windows Server 2003:  A WITHIN clause was not used in this query.";
    e124.code = 2147753986;
    errors[2147753986] = e124;
    var e125 = new Error("wbemErrTimedout");
    e125.description = "Windows Server 2003:  Automation-specific error.";
    e125.code = 2147758081;
    errors[2147758081] = e125;
    var e126 = new Error("wbemErrResetToDefault");
    e126.description = "undefined";
    e126.code = 2147758082;
    errors[2147758082] = e126;
    module2.exports = errors;
  }
});

// node_modules/stream-slicer/index.js
var require_stream_slicer = __commonJS({
  "node_modules/stream-slicer/index.js"(exports, module2) {
    var Transform = require("stream").Transform;
    var $u = require("util");
    $u.inherits(StreamSlicer, Transform);
    function StreamSlicer(options) {
      if (!(this instanceof StreamSlicer))
        return new StreamSlicer(options);
      Transform.call(this, options);
      this._buffer = [];
      this._currentLength = 0;
      if (options && options.sliceBy)
        this._sliceBy = options.sliceBy;
      else
        this._sliceBy = "\n";
      if (options && options.replaceWith)
        this.replaceWith = new Buffer(options.replaceWith);
    }
    StreamSlicer.prototype._transform = function(chunk, encoding, callback) {
      chunk = String(chunk);
      var start = 0;
      var index = -1;
      while ((index = chunk.indexOf(this._sliceBy, start)) > -1) {
        var miniChunk = chunk.substring(start, index);
        this._append(miniChunk);
        this._separatorFlush();
        start = index + this._sliceBy.length;
      }
      var trailing = chunk.substring(start);
      if (trailing.length > 0)
        this._append(trailing);
      callback();
    };
    StreamSlicer.prototype._append = function(str) {
      var chunk = new Buffer(str);
      this._buffer.push(chunk);
      this._currentLength += chunk.length;
    };
    StreamSlicer.prototype._separatorFlush = function(transformFlush) {
      if (this.replaceWith && !transformFlush) {
        this._buffer.push(this.replaceWith);
        this._currentLength += this.replaceWith.length;
      }
      var data = Buffer.concat(this._buffer, this._currentLength);
      this._buffer = [];
      this._currentLength = 0;
      this.push(data);
      this.emit("slice", data);
    };
    StreamSlicer.prototype._flush = function(callback) {
      this._separatorFlush(true);
      if (callback)
        callback();
    };
    module2.exports = StreamSlicer;
  }
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re3) {
      return objectToString(re3) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d3) {
      return objectToString(d3) === "[object Date]";
    }
    exports.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = require("buffer").Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports, module2) {
    module2.exports = Array.isArray || function(arr) {
      return Object.prototype.toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/string_decoder/index.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/index.js"(exports) {
    var Buffer2 = require("buffer").Buffer;
    var isBufferEncoding = Buffer2.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error("Unknown encoding: " + encoding);
      }
    }
    var StringDecoder = exports.StringDecoder = function(encoding) {
      this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
      assertEncoding(encoding);
      switch (this.encoding) {
        case "utf8":
          this.surrogateSize = 3;
          break;
        case "ucs2":
        case "utf16le":
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case "base64":
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
      this.charBuffer = new Buffer2(6);
      this.charReceived = 0;
      this.charLength = 0;
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i63 = buffer.length >= 3 ? 3 : buffer.length;
      for (; i63 > 0; i63--) {
        var c = buffer[buffer.length - i63];
        if (i63 == 1 && c >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i63 <= 2 && c >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i63 <= 3 && c >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i63;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }
    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports, module2) {
    module2.exports = Readable;
    var isArray = require_isarray();
    var Buffer2 = require("buffer").Buffer;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    if (!EE.listenerCount)
      EE.listenerCount = function(emitter, type) {
        return emitter.listeners(type).length;
      };
    var Stream = require("stream");
    var util = require_util();
    util.inherits = require_inherits();
    var StringDecoder;
    util.inherits(Readable, Stream);
    function ReadableState(options, stream) {
      options = options || {};
      var hwm = options.highWaterMark;
      this.highWaterMark = hwm || hwm === 0 ? hwm : 16 * 1024;
      this.highWaterMark = ~~this.highWaterMark;
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = false;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.calledRead = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.objectMode = !!options.objectMode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.ranOut = false;
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      Stream.call(this);
    }
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (typeof chunk === "string" && !state.objectMode) {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer2(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (chunk === null || chunk === void 0) {
        state.reading = false;
        if (!state.ended)
          onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error("stream.push() after EOF");
          stream.emit("error", e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error("stream.unshift() after end event");
          stream.emit("error", e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) {
            state.buffer.unshift(chunk);
          } else {
            state.reading = false;
            state.buffer.push(chunk);
          }
          if (state.needReadable)
            emitReadable(stream);
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
      return needMoreData(state);
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
    };
    var MAX_HWM = 8388608;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        for (var p = 1; p < 32; p <<= 1)
          n |= n >> p;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return n === 0 ? 0 : 1;
      if (n === null || isNaN(n)) {
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
      if (n <= 0)
        return 0;
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else
          return state.length;
      }
      return n;
    }
    Readable.prototype.read = function(n) {
      var state = this._readableState;
      state.calledRead = true;
      var nOrig = n;
      var ret;
      if (typeof n !== "number" || n > 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        ret = null;
        if (state.length > 0 && state.decoder) {
          ret = fromList(n, state);
          state.length -= ret.length;
        }
        if (state.length === 0)
          endReadable(this);
        return ret;
      }
      var doRead = state.needReadable;
      if (state.length - n <= state.highWaterMark)
        doRead = true;
      if (state.ended || state.reading)
        doRead = false;
      if (doRead) {
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
      }
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      }
      state.length -= n;
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
      if (state.ended && !state.endEmitted && state.length === 0)
        endReadable(this);
      return ret;
    };
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!Buffer2.isBuffer(chunk) && "string" !== typeof chunk && chunk !== null && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function onEofChunk(stream, state) {
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.length > 0)
        emitReadable(stream);
      else
        endReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (state.emittedReadable)
        return;
      state.emittedReadable = true;
      if (state.sync)
        process.nextTick(function() {
          emitReadable_(stream);
        });
      else
        emitReadable_(stream);
    }
    function emitReadable_(stream) {
      stream.emit("readable");
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function() {
          maybeReadMore_(stream, state);
        });
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        if (readable !== src)
          return;
        cleanup();
      }
      function onend() {
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      function cleanup() {
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", cleanup);
        if (!dest._writableState || dest._writableState.needDrain)
          ondrain();
      }
      function onerror(er) {
        unpipe();
        dest.removeListener("error", onerror);
        if (EE.listenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      if (!dest._events || !dest._events.error)
        dest.on("error", onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        this.on("readable", pipeOnReadable);
        state.flowing = true;
        process.nextTick(function() {
          flow(src);
        });
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var dest = this;
        var state = src._readableState;
        state.awaitDrain--;
        if (state.awaitDrain === 0)
          flow(src);
      };
    }
    function flow(src) {
      var state = src._readableState;
      var chunk;
      state.awaitDrain = 0;
      function write(dest, i63, list) {
        var written = dest.write(chunk);
        if (false === written) {
          state.awaitDrain++;
        }
      }
      while (state.pipesCount && null !== (chunk = src.read())) {
        if (state.pipesCount === 1)
          write(state.pipes, 0, null);
        else
          forEach(state.pipes, write);
        src.emit("data", chunk);
        if (state.awaitDrain > 0)
          return;
      }
      if (state.pipesCount === 0) {
        state.flowing = false;
        if (EE.listenerCount(src, "data") > 0)
          emitDataEvents(src);
        return;
      }
      state.ranOut = true;
    }
    function pipeOnReadable() {
      if (this._readableState.ranOut) {
        this._readableState.ranOut = false;
        flow(this);
      }
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener("readable", pipeOnReadable);
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener("readable", pipeOnReadable);
        state.flowing = false;
        for (var i63 = 0; i63 < len; i63++)
          dests[i63].emit("unpipe", this);
        return this;
      }
      var i63 = indexOf(state.pipes, dest);
      if (i63 === -1)
        return this;
      state.pipes.splice(i63, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn3) {
      var res = Stream.prototype.on.call(this, ev, fn3);
      if (ev === "data" && !this._readableState.flowing)
        emitDataEvents(this);
      if (ev === "readable" && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            this.read(0);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      emitDataEvents(this);
      this.read(0);
      this.emit("resume");
    };
    Readable.prototype.pause = function() {
      emitDataEvents(this, true);
      this.emit("pause");
    };
    function emitDataEvents(stream, startPaused) {
      var state = stream._readableState;
      if (state.flowing) {
        throw new Error("Cannot switch to old mode now.");
      }
      var paused = startPaused || false;
      var readable = false;
      stream.readable = true;
      stream.pipe = Stream.prototype.pipe;
      stream.on = stream.addListener = Stream.prototype.on;
      stream.on("readable", function() {
        readable = true;
        var c;
        while (!paused && null !== (c = stream.read()))
          stream.emit("data", c);
        if (c === null) {
          readable = false;
          stream._readableState.needReadable = true;
        }
      });
      stream.pause = function() {
        paused = true;
        this.emit("pause");
      };
      stream.resume = function() {
        paused = false;
        if (readable)
          process.nextTick(function() {
            stream.emit("readable");
          });
        else
          this.read(0);
        this.emit("resume");
      };
      stream.emit("readable");
    }
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self = this;
      stream.on("end", function() {
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self.push(chunk);
        }
        self.push(null);
      });
      stream.on("data", function(chunk) {
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i63 in stream) {
        if (typeof stream[i63] === "function" && typeof this[i63] === "undefined") {
          this[i63] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i63);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });
      self._read = function(n) {
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self;
    };
    Readable._fromList = fromList;
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
      if (list.length === 0)
        return null;
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        if (stringMode)
          ret = list.join("");
        else
          ret = Buffer2.concat(list, length);
        list.length = 0;
      } else {
        if (n < list[0].length) {
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          ret = list.shift();
        } else {
          if (stringMode)
            ret = "";
          else
            ret = new Buffer2(n);
          var c = 0;
          for (var i63 = 0, l = list.length; i63 < l && c < n; i63++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
            c += cpy;
          }
        }
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error("endReadable called on non-empty stream");
      if (!state.endEmitted && state.calledRead) {
        state.ended = true;
        process.nextTick(function() {
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit("end");
          }
        });
      }
    }
    function forEach(xs, f) {
      for (var i63 = 0, l = xs.length; i63 < l; i63++) {
        f(xs[i63], i63);
      }
    }
    function indexOf(xs, x3) {
      for (var i63 = 0, l = xs.length; i63 < l; i63++) {
        if (xs[i63] === x3)
          return i63;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports, module2) {
    module2.exports = Writable;
    var Buffer2 = require("buffer").Buffer;
    Writable.WritableState = WritableState;
    var util = require_util();
    util.inherits = require_inherits();
    var Stream = require("stream");
    util.inherits(Writable, Stream);
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    function WritableState(options, stream) {
      options = options || {};
      var hwm = options.highWaterMark;
      this.highWaterMark = hwm || hwm === 0 ? hwm : 16 * 1024;
      this.objectMode = !!options.objectMode;
      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.buffer = [];
      this.errorEmitted = false;
    }
    function Writable(options) {
      var Duplex = require_stream_duplex();
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
      this._writableState = new WritableState(options, this);
      this.writable = true;
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe. Not readable."));
    };
    function writeAfterEnd(stream, state, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      process.nextTick(function() {
        cb(er);
      });
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!Buffer2.isBuffer(chunk) && "string" !== typeof chunk && chunk !== null && chunk !== void 0 && !state.objectMode) {
        var er = new TypeError("Invalid non-string/buffer chunk");
        stream.emit("error", er);
        process.nextTick(function() {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = function() {
        };
      if (state.ended)
        writeAfterEnd(this, state, cb);
      else if (validChunk(this, state, chunk, cb))
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      return ret;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = new Buffer2(chunk, encoding);
      }
      return chunk;
    }
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing)
        state.buffer.push(new WriteReq(chunk, encoding, cb));
      else
        doWrite(stream, state, len, chunk, encoding, cb);
      return ret;
    }
    function doWrite(stream, state, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      if (sync)
        process.nextTick(function() {
          cb(er);
        });
      else
        cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(stream, state);
        if (!finished && !state.bufferProcessing && state.buffer.length)
          clearBuffer(stream, state);
        if (sync) {
          process.nextTick(function() {
            afterWrite(stream, state, finished, cb);
          });
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      cb();
      if (finished)
        finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      for (var c = 0; c < state.buffer.length; c++) {
        var entry = state.buffer[c];
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, len, chunk, encoding, cb);
        if (state.writing) {
          c++;
          break;
        }
      }
      state.bufferProcessing = false;
      if (c < state.buffer.length)
        state.buffer = state.buffer.slice(c);
      else
        state.buffer.length = 0;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (typeof chunk !== "undefined" && chunk !== null)
        this.write(chunk, encoding);
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(stream, state) {
      return state.ending && state.length === 0 && !state.finished && !state.writing;
    }
    function finishMaybe(stream, state) {
      var need = needFinish(stream, state);
      if (need) {
        state.finished = true;
        stream.emit("finish");
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
    }
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module2) {
    module2.exports = Duplex;
    var objectKeys = Object.keys || function(obj) {
      var keys = [];
      for (var key in obj)
        keys.push(key);
      return keys;
    };
    var util = require_util();
    util.inherits = require_inherits();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable);
    forEach(objectKeys(Writable.prototype), function(method) {
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    });
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      process.nextTick(this.end.bind(this));
    }
    function forEach(xs, f) {
      for (var i63 = 0, l = xs.length; i63 < l; i63++) {
        f(xs[i63], i63);
      }
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports, module2) {
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = require_util();
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function TransformState(options, stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb)
        return stream.emit("error", new Error("no writecb in Transform class"));
      ts.writechunk = null;
      ts.writecb = null;
      if (data !== null && data !== void 0)
        stream.push(data);
      if (cb)
        cb(er);
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      var ts = this._transformState = new TransformState(options, this);
      var stream = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      this.once("finish", function() {
        if ("function" === typeof this._flush)
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    function done(stream, er) {
      if (er)
        return stream.emit("error", er);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var ts = stream._transformState;
      if (ws.length)
        throw new Error("calling transform done when ws.length != 0");
      if (ts.transforming)
        throw new Error("calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/transform.js
var require_transform = __commonJS({
  "node_modules/readable-stream/transform.js"(exports, module2) {
    module2.exports = require_stream_transform();
  }
});

// node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "node_modules/xtend/immutable.js"(exports, module2) {
    module2.exports = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i63 = 0; i63 < arguments.length; i63++) {
        var source = arguments[i63];
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/through2/through2.js
var require_through2 = __commonJS({
  "node_modules/through2/through2.js"(exports, module2) {
    var Transform = require_transform();
    var inherits = require("util").inherits;
    var xtend = require_immutable();
    function DestroyableTransform(opts) {
      Transform.call(this, opts);
      this._destroyed = false;
    }
    inherits(DestroyableTransform, Transform);
    DestroyableTransform.prototype.destroy = function(err) {
      if (this._destroyed)
        return;
      this._destroyed = true;
      var self = this;
      process.nextTick(function() {
        if (err)
          self.emit("error", err);
        self.emit("close");
      });
    };
    function noop(chunk, enc, callback) {
      callback(null, chunk);
    }
    function through2(construct) {
      return function(options, transform, flush) {
        if (typeof options == "function") {
          flush = transform;
          transform = options;
          options = {};
        }
        if (typeof transform != "function")
          transform = noop;
        if (typeof flush != "function")
          flush = null;
        return construct(options, transform, flush);
      };
    }
    module2.exports = through2(function(options, transform, flush) {
      var t2 = new DestroyableTransform(options);
      t2._transform = transform;
      if (flush)
        t2._flush = flush;
      return t2;
    });
    module2.exports.ctor = through2(function(options, transform, flush) {
      function Through2(override) {
        if (!(this instanceof Through2))
          return new Through2(override);
        this.options = xtend(options, override);
        DestroyableTransform.call(this, this.options);
      }
      inherits(Through2, DestroyableTransform);
      Through2.prototype._transform = transform;
      if (flush)
        Through2.prototype._flush = flush;
      return Through2;
    });
    module2.exports.obj = through2(function(options, transform, flush) {
      var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options));
      t2._transform = transform;
      if (flush)
        t2._flush = flush;
      return t2;
    });
  }
});

// node_modules/regedit/lib/helper.js
var require_helper = __commonJS({
  "node_modules/regedit/lib/helper.js"(exports, module2) {
    var debug = require_src()("regedit");
    var WIN_EOL = module2.exports.WIN_EOL = "\r\n";
    module2.exports.encode = function(str) {
      return escape(str) + WIN_EOL;
    };
    module2.exports.writeArrayToStream = function(arr, stream, optionalCallback) {
      var member = arr.pop();
      function write(m3) {
        var b3 = module2.exports.encode(m3);
        debug(b3);
        return stream.write(b3);
        return false;
      }
      while (write(member)) {
        member = arr.pop();
      }
      if (arr.length === 0) {
        stream.write(WIN_EOL, optionalCallback);
        return;
      }
      stream.once("drain", function() {
        module2.exports.writeArrayToStream(arr, stream, optionalCallback);
      });
    };
    module2.exports.vbsOutputTransform = function(chunk, enc, callback) {
      try {
        if (enc === "buffer") {
          chunk = chunk.toString();
        } else {
          chunk = chunk.toString(enc);
        }
        this.push(JSON.parse(chunk));
      } catch (e) {
        return callback(e);
      }
      return callback();
    };
  }
});

// node_modules/regedit/lib/execFile.js
var require_execFile = __commonJS({
  "node_modules/regedit/lib/execFile.js"(exports, module2) {
    var childProcess = require("child_process");
    module2.exports = function(options) {
      options = options || {};
      return function execFile() {
        var child = childProcess.execFile.apply(childProcess, arguments);
        if (!options.bufferStdout) {
          child.stdout.removeAllListeners("data");
        }
        if (!options.bufferStderr) {
          child.stderr.removeAllListeners("data");
        }
        return child;
      };
    };
  }
});

// node_modules/if-async/index.js
var require_if_async = __commonJS({
  "node_modules/if-async/index.js"(exports, module2) {
    var util = require("util");
    module2.exports = ifAsync;
    var OK = 0;
    var EXPECT_THEN = 1;
    function ifAsync() {
      var clauses = toArray(arguments);
      var elseClause = elseNoop;
      var fluentState = OK;
      if (clauses.length === 0) {
        throw new Error("at least one predicate and one consequent are required");
      }
      if (clauses.length === 1) {
        fluentState = EXPECT_THEN;
      } else if (clauses.length % 2 === 1) {
        elseClause = clauses.pop();
      }
      var functor = function() {
        if (fluentState !== OK) {
          throw new Error("missing at least one consequent, you forgot to call then() ?");
        }
        var args = arguments;
        var callback = args[args.length - 1];
        if (typeof callback !== "function") {
          throw new Error("missing callback argument");
        }
        var predicate = clauses.shift();
        if (!predicate) {
          return elseClause.apply(null, args);
        }
        var consequent = clauses.shift();
        var replacedCallbackArgs = toArray(args);
        replacedCallbackArgs.pop();
        replacedCallbackArgs.push(predicateCallback);
        predicate.apply(null, replacedCallbackArgs);
        function predicateCallback(err, result) {
          if (err)
            return callback(err);
          if (result) {
            return consequent.apply(null, args);
          } else {
            functor.apply(null, args);
          }
        }
      };
      functor.then = function(fn3) {
        if (fluentState !== EXPECT_THEN) {
          throw new Error("not expecting a then() call now");
        }
        fluentState = OK;
        clauses.push(fn3);
        return functor;
      };
      functor.and = function(fn3) {
        var predicate = clauses.pop();
        clauses.push(
          ifAsync(predicate).then(fn3).else(callbackFalse)
        );
        return functor;
      };
      functor.and.not = function(predicate) {
        return functor.and(not(predicate));
      };
      functor.or = function(fn3) {
        var predicate = clauses.pop();
        clauses.push(
          ifAsync(predicate).then(callbackTrue).elseIf(fn3).then(callbackTrue).else(callbackFalse)
        );
        return functor;
      };
      functor.or.not = function(predicate) {
        return functor.or(not(predicate));
      };
      functor.else = function(predicate) {
        if (fluentState === EXPECT_THEN) {
          throw new Error("only then() may be called after elseIf()");
        }
        elseClause = predicate;
        return functor;
      };
      functor.elseif = functor.elseIf = function(predicate) {
        if (fluentState === EXPECT_THEN) {
          throw new Error("only then() may be called after elseIf()");
        }
        clauses.push(predicate);
        fluentState = EXPECT_THEN;
        return functor;
      };
      functor.elseif.not = function(predicate) {
        return functor.elseIf(not(predicate));
      };
      return functor;
    }
    ifAsync.not = function(predicate) {
      if (typeof predicate !== "function") {
        throw new Error("argument must be a predicate function");
      }
      return ifAsync(not(predicate));
    };
    function not(predicate) {
      return function() {
        var args = toArray(arguments);
        var callback = args.pop();
        if (typeof callback !== "function") {
          throw new Error("expected a callback but instead got " + typeof callback);
        }
        args.push(function(err, result) {
          callback(err, !result);
        });
        predicate.apply(null, args);
      };
    }
    function elseNoop() {
      var args = toArray(arguments);
      var callback = args.pop();
      args.unshift(null);
      if (typeof callback !== "function") {
        throw new Error("expected a callback function");
      }
      setImmediate(function() {
        callback.apply(null, args);
      });
    }
    function callbackTrue() {
      var callback = arguments[arguments.length - 1];
      if (typeof callback !== "function") {
        throw new Error("expected a callback function");
      }
      callback(null, true);
    }
    function callbackFalse() {
      var callback = arguments[arguments.length - 1];
      if (typeof callback !== "function") {
        throw new Error("expected a callback function");
      }
      callback(null, false);
    }
    function toArray(args) {
      return Array.prototype.slice.call(args, 0);
    }
  }
});

// node_modules/regedit/lib/cscript.js
var require_cscript = __commonJS({
  "node_modules/regedit/lib/cscript.js"(exports, module2) {
    var ifAsync;
    var fs5;
    var execFile;
    var debug;
    var init;
    function resetDependencies() {
      init = false;
      ifAsync = require_if_async();
      fs5 = require("fs");
      execFile = require_execFile()({ bufferStdout: true, bufferStderr: true });
      debug = require_src()("regedit:cscript");
    }
    resetDependencies();
    var CSCRIPT_NOT_FOUND = module2.exports.CSCRIPT_NOT_FOUND = "INFO: Could not find files for the given pattern(s).";
    var CSCRIPT_EXPECTED_OUTPUT = module2.exports.CSCRIPT_EXPECTED_OUTPUT = "Microsoft (R) Windows Script Host Version";
    var cscript = "cscript.exe";
    function spawnCScriptSucceeded(callback) {
      debug("spawnCScriptSucceeded()");
      execFile("cscript.exe", function(err, stdout) {
        if (err) {
          if (err.code === "ENOENT") {
            return callback(null, false);
          }
          return callback(err);
        }
        cscript = "cscript.exe";
        callback(null, stdout.indexOf(CSCRIPT_EXPECTED_OUTPUT) > -1);
      });
    }
    function whereCScriptSucceeded(callback) {
      debug("whereCScriptSucceeded()");
      execFile("where cscript.exe", function(err, stdout) {
        if (err) {
          if (err.code === "ENOENT") {
            return callback(null, false);
          }
          return callback(err);
        }
        if (typeof stdout !== "string") {
          return callback(null, false);
        }
        if (stdout.indexOf(CSCRIPT_NOT_FOUND) > -1) {
          return callback(null, false);
        }
        cscript = stdout.trim();
        callback(null, true);
      });
    }
    function fsStatCScriptSucceeded(callback) {
      debug("fsStatCScriptSucceeded()");
      fs5.stat("c:\\windows\\system32\\cscript.exe", function(err) {
        if (err) {
          if (err.code === "ENOENT") {
            return callback(null, false);
          }
          return callback(err);
        }
        cscript = "c:\\windows\\system32\\cscript.exe";
        callback(null, true);
      });
    }
    function callbackWithError(cb) {
      cb(new Error("cscript not found"));
    }
    module2.exports.path = function() {
      if (init === false) {
        throw new Error("must initialize first");
      }
      debug(cscript);
      return cscript;
    };
    module2.exports.init = function(callback) {
      debug("init()");
      if (init) {
        debug("already initialized");
        return setImmediate(callback);
      }
      var functor = ifAsync(spawnCScriptSucceeded).or(whereCScriptSucceeded).or(fsStatCScriptSucceeded).then(function(cb) {
        init = true;
        cb();
      }).else(callbackWithError);
      functor(function(err) {
        if (err) {
          return callback(err);
        }
        callback();
      });
    };
    module2.exports._mock = function(_fs, _execFile, _init) {
      fs5 = _fs;
      execFile = _execFile;
      init = _init;
    };
    module2.exports._mockReset = resetDependencies;
  }
});

// node_modules/regedit/index.js
var require_regedit = __commonJS({
  "node_modules/regedit/index.js"(exports, module2) {
    var fs5 = require("fs");
    var util = require("util");
    var childProcess = require("child_process");
    var path25 = require("path");
    var debug = require_src()("regedit");
    var errors = require_errors();
    var StreamSlicer = require_stream_slicer();
    var through2 = require_through2();
    var helper = require_helper();
    var execFile = require_execFile()();
    var cscript = require_cscript();
    var OS_ARCH_AGNOSTIC = "A";
    var OS_ARCH_SPECIFIC = "S";
    var OS_ARCH_32BIT = "32";
    var OS_ARCH_64BIT = "64";
    var externalVBSFolderLocation;
    function handleErrorsAndClose(child, callback) {
      let error;
      child.once("error", function(e) {
        debug("process error %s", e);
        error = e;
      });
      child.once("close", function(code) {
        debug("process exit with code %d", code);
        if (error) {
          if (error.code in errors) {
            return callback(errors[error.code]);
          }
          return callback(error);
        }
        if (code !== 0) {
          if (code in errors) {
            return callback(errors[code]);
          }
          return callback(new Error("vbscript process reported unknown error code " + code));
        }
        callback();
      });
    }
    function execute(args, callback) {
      if (typeof callback !== "function") {
        throw new Error("missing callback");
      }
      debug(args);
      cscript.init(function(err) {
        if (err) {
          return callback(err);
        }
        childProcess.execFile(cscript.path(), args, function(err2, stdout, stderr) {
          if (err2) {
            if (stdout) {
              console.log(stdout);
            }
            if (stderr) {
              console.error(stderr);
            }
            if (err2.code in errors) {
              return callback(errors[err2.code]);
            }
            return callback(err2);
          }
          if (stderr) {
            return callback(new Error(stderr));
          }
          if (!stdout) {
            return callback();
          }
          debug(stdout);
          let result;
          err2 = null;
          try {
            result = JSON.parse(stdout);
          } catch (e) {
            e.stdout = stdout;
            err2 = e;
          }
          callback(err2, result);
        });
      });
    }
    function spawnEx(args, keys, callback) {
      cscript.init(function(err) {
        if (err) {
          return callback(err);
        }
        debug(args);
        const child = execFile(cscript.path(), args, { encoding: "utf8" });
        handleErrorsAndClose(child, callback);
        helper.writeArrayToStream(keys, child.stdin);
      });
    }
    function renderValueByType(value, type) {
      type = type.toUpperCase();
      switch (type) {
        case "REG_NONE":
          if (value === "") {
            return "\0";
          }
          return value;
        case "REG_BINARY":
          if (!util.isArray(value)) {
            throw new Error("invalid value type " + typeof value + " for registry type REG_BINARY, please use an array of numbers");
          }
          return value.join(",");
        case "REG_MULTI_SZ":
          if (!util.isArray(value)) {
            throw new Error("invalid value type " + typeof value + " for registry type REG_BINARY, please use an array of strings");
          }
          return value.join(",");
        case "REG_SZ":
          if (value === "") {
            return "\0";
          }
          return value;
        default:
          return value;
      }
    }
    function baseCommand(cmd, arch2) {
      let scriptPath;
      if (externalVBSFolderLocation && typeof externalVBSFolderLocation === "string") {
        scriptPath = externalVBSFolderLocation;
      } else {
        scriptPath = path25.join(__dirname, "vbs");
      }
      return ["//Nologo", path25.join(scriptPath, cmd), arch2];
    }
    function toCommandArgs(cmd, arch2, keys) {
      let result = baseCommand(cmd, arch2);
      if (typeof keys === "string") {
        result.push(keys);
      } else if (util.isArray(keys)) {
        result = result.concat(keys);
      } else {
        debug("creating command without using keys %s", keys ? keys : "");
      }
      return result;
    }
    module2.exports.setExternalVBSLocation = function(newLocation) {
      if (fs5.existsSync(newLocation)) {
        externalVBSFolderLocation = newLocation;
        return "Folder found and set";
      }
      return "Folder not found";
    };
    module2.exports.list = function(keys, architecture, callback) {
      if (architecture === void 0) {
        callback = void 0;
        architecture = OS_ARCH_AGNOSTIC;
      } else if (typeof architecture === "function") {
        callback = architecture;
        architecture = OS_ARCH_AGNOSTIC;
      }
      if (typeof keys === "string") {
        keys = [keys];
      }
      if (typeof callback === "function") {
        execute(toCommandArgs("regList.wsf", architecture, keys), callback);
        return;
      }
      const outputStream = through2.obj(helper.vbsOutputTransform);
      cscript.init(function(err) {
        if (err) {
          return outputStream.emit("error", err);
        }
        const args = baseCommand("regListStream.wsf", architecture);
        const child = execFile(cscript.path(), args, { encoding: "utf8" }, function(err2) {
          if (err2) {
            outputStream.emit("error", err2);
          }
        });
        child.stderr.pipe(process.stderr);
        const slicer = new StreamSlicer({ sliceBy: helper.WIN_EOL });
        child.stdout.pipe(slicer).pipe(outputStream);
        helper.writeArrayToStream(keys, child.stdin);
      });
      return outputStream;
    };
    module2.exports.createKey = function(keys, architecture, callback) {
      if (typeof architecture === "function") {
        callback = architecture;
        architecture = OS_ARCH_AGNOSTIC;
      }
      if (typeof keys === "string") {
        keys = [keys];
      }
      const args = baseCommand("regCreateKey.wsf", architecture);
      spawnEx(args, keys, callback);
    };
    module2.exports.deleteKey = function(keys, architecture, callback) {
      if (typeof architecture === "function") {
        callback = architecture;
        architecture = OS_ARCH_AGNOSTIC;
      }
      if (typeof keys === "string") {
        keys = [keys];
      }
      const args = baseCommand("regDeleteKey.wsf", architecture);
      spawnEx(args, keys, callback);
    };
    module2.exports.deleteValue = function(keys, architecture, callback) {
      if (typeof architecture === "function") {
        callback = architecture;
        architecture = OS_ARCH_AGNOSTIC;
      }
      if (typeof keys === "string") {
        keys = [keys];
      }
      var args = baseCommand("regDeleteValue.wsf", architecture);
      spawnEx(args, keys, callback);
    };
    module2.exports.putValue = function(map, architecture, callback) {
      if (typeof architecture === "function") {
        callback = architecture;
        architecture = OS_ARCH_AGNOSTIC;
      }
      const args = baseCommand("regPutValue.wsf", architecture);
      let values = [];
      for (const key in map) {
        if (map.hasOwnProperty(key)) {
          const keyValues = map[key];
          for (const valueName in keyValues) {
            if (keyValues.hasOwnProperty(valueName)) {
              const entry = keyValues[valueName];
              values.push(entry.type);
              values.push(renderValueByType(entry.value, entry.type));
              values.push(valueName);
              values.push(key);
            }
          }
        }
      }
      spawnEx(args, values, callback);
    };
    module2.exports.listUnexpandedValues = function(valuePaths, architecture, callback) {
      if (architecture === void 0) {
        callback = void 0;
        architecture = OS_ARCH_AGNOSTIC;
      } else if (typeof architecture === "function") {
        callback = architecture;
        architecture = OS_ARCH_AGNOSTIC;
      }
      if (typeof valuePaths === "string") {
        valuePaths = [valuePaths];
      }
      if (typeof callback === "function") {
        execute(toCommandArgs("wsRegReadList.wsf", architecture, valuePaths), callback);
        return;
      }
      const outputStream = through2.obj(helper.vbsOutputTransform);
      cscript.init(function(err) {
        if (err) {
          return outputStream.emit("error", err);
        }
        const args = baseCommand("wsRegReadListStream.wsf", architecture);
        const child = execFile(cscript.path(), args, { encoding: "utf8" }, function(err2) {
          if (err2) {
            outputStream.emit("error", err2);
          }
        });
        child.stderr.pipe(process.stderr);
        const slicer = new StreamSlicer({ sliceBy: helper.WIN_EOL });
        child.stdout.pipe(slicer).pipe(outputStream);
        helper.writeArrayToStream(valuePaths, child.stdin);
      });
      return outputStream;
    };
    module2.exports.promisified = {
      list: function(keys, architecture = OS_ARCH_AGNOSTIC) {
        return new Promise(function(resolve, reject) {
          module2.exports.list(keys, architecture, function(err, res) {
            if (err) {
              return reject(err);
            }
            return resolve(res);
          });
        });
      },
      listUnexpandedValues: function(valuePaths, architecture = OS_ARCH_AGNOSTIC) {
        return new Promise(function(resolve, reject) {
          module2.exports.listUnexpandedValues(valuePaths, architecture, function(err, res) {
            if (err) {
              return reject(err);
            }
            return resolve(res);
          });
        });
      },
      createKey: function(keys, architecture = OS_ARCH_AGNOSTIC) {
        return new Promise(function(resolve, reject) {
          module2.exports.createKey(keys, architecture, function(err) {
            if (err) {
              return reject(err);
            }
            return resolve();
          });
        });
      },
      deleteKey: function(keys, architecture = OS_ARCH_AGNOSTIC) {
        return new Promise(function(resolve, reject) {
          module2.exports.deleteKey(keys, architecture, function(err) {
            if (err) {
              return reject(err);
            }
            return resolve();
          });
        });
      },
      deleteValue: function(keys, architecture = OS_ARCH_AGNOSTIC) {
        return new Promise(function(resolve, reject) {
          module2.exports.deleteValue(keys, architecture, function(err) {
            if (err) {
              return reject(err);
            }
            return resolve();
          });
        });
      },
      putValue: function(map, architecture = OS_ARCH_AGNOSTIC) {
        return new Promise(function(resolve, reject) {
          module2.exports.putValue(map, architecture, function(err) {
            if (err) {
              return reject(err);
            }
            return resolve();
          });
        });
      }
    };
    module2.exports.arch = {};
    module2.exports.arch.list = function(keys, callback) {
      return module2.exports.list(keys, OS_ARCH_SPECIFIC, callback);
    };
    module2.exports.arch.list32 = function(keys, callback) {
      return module2.exports.list(keys, OS_ARCH_32BIT, callback);
    };
    module2.exports.arch.list64 = function(keys, callback) {
      return module2.exports.list(keys, OS_ARCH_64BIT, callback);
    };
    module2.exports.arch.listUnexpandedValues = function(valuePaths, callback) {
      return module2.exports.listUnexpandedValues(valuePaths, OS_ARCH_SPECIFIC, callback);
    };
    module2.exports.arch.listUnexpandedValues32 = function(valuePaths, callback) {
      return module2.exports.listUnexpandedValues(valuePaths, OS_ARCH_32BIT, callback);
    };
    module2.exports.arch.listUnexpandedValues64 = function(valuePaths, callback) {
      return module2.exports.listUnexpandedValues(valuePaths, OS_ARCH_64BIT, callback);
    };
    module2.exports.arch.createKey = function(keys, callback) {
      return module2.exports.createKey(keys, OS_ARCH_SPECIFIC, callback);
    };
    module2.exports.arch.createKey32 = function(keys, callback) {
      return module2.exports.createKey(keys, OS_ARCH_32BIT, callback);
    };
    module2.exports.arch.createKey64 = function(keys, callback) {
      return module2.exports.createKey(keys, OS_ARCH_64BIT, callback);
    };
    module2.exports.arch.deleteKey = function(keys, callback) {
      return module2.exports.deleteKey(keys, OS_ARCH_SPECIFIC, callback);
    };
    module2.exports.arch.deleteKey32 = function(keys, callback) {
      return module2.exports.deleteKey(keys, OS_ARCH_32BIT, callback);
    };
    module2.exports.arch.deleteKey64 = function(keys, callback) {
      return module2.exports.deleteKey(keys, OS_ARCH_64BIT, callback);
    };
    module2.exports.arch.deleteValue = function(keys, callback) {
      return module2.exports.deleteValue(keys, OS_ARCH_SPECIFIC, callback);
    };
    module2.exports.arch.deleteValue32 = function(keys, callback) {
      return module2.exports.deleteValue(keys, OS_ARCH_32BIT, callback);
    };
    module2.exports.arch.deleteValue64 = function(keys, callback) {
      return module2.exports.deleteValue(keys, OS_ARCH_64BIT, callback);
    };
    module2.exports.arch.putValue = function(keys, callback) {
      return module2.exports.putValue(keys, OS_ARCH_SPECIFIC, callback);
    };
    module2.exports.arch.putValue32 = function(keys, callback) {
      return module2.exports.putValue(keys, OS_ARCH_32BIT, callback);
    };
    module2.exports.arch.putValue64 = function(keys, callback) {
      return module2.exports.putValue(keys, OS_ARCH_64BIT, callback);
    };
    module2.exports.arch.promisified = {
      list: function(keys) {
        return module2.exports.promisified.list(keys, OS_ARCH_SPECIFIC);
      },
      list32: function(keys) {
        return module2.exports.promisified.list(keys, OS_ARCH_32BIT);
      },
      list64: function(keys) {
        return module2.exports.promisified.list(keys, OS_ARCH_64BIT);
      },
      listUnexpandedValues: function(valuePaths) {
        return module2.exports.promisified.listUnexpandedValues(valuePaths, OS_ARCH_SPECIFIC);
      },
      listUnexpandedValues32: function(valuePaths) {
        return module2.exports.promisified.listUnexpandedValues(valuePaths, OS_ARCH_32BIT);
      },
      listUnexpandedValues64: function(valuePaths) {
        return module2.exports.promisified.listUnexpandedValues(valuePaths, OS_ARCH_64BIT);
      },
      createKey: function(keys) {
        return module2.exports.promisified.createKey(keys, OS_ARCH_SPECIFIC);
      },
      createKey32: function(keys) {
        return module2.exports.promisified.createKey(keys, OS_ARCH_32BIT);
      },
      createKey64: function(keys) {
        return module2.exports.promisified.createKey(keys, OS_ARCH_64BIT);
      },
      deleteKey: function(keys) {
        return module2.exports.promisified.deleteKey(keys, OS_ARCH_SPECIFIC);
      },
      deleteKey32: function(keys) {
        return module2.exports.promisified.deleteKey(keys, OS_ARCH_32BIT);
      },
      deleteKey64: function(keys) {
        return module2.exports.promisified.deleteKey(keys, OS_ARCH_64BIT);
      },
      deleteValue: function(keys) {
        return module2.exports.promisified.deleteValue(keys, OS_ARCH_SPECIFIC);
      },
      deleteValue32: function(keys) {
        return module2.exports.promisified.deleteValue(keys, OS_ARCH_32BIT);
      },
      deleteValue64: function(keys) {
        return module2.exports.promisified.deleteValue(keys, OS_ARCH_64BIT);
      },
      putValue: function(keys) {
        return module2.exports.promisified.putValue(keys, OS_ARCH_SPECIFIC);
      },
      putValue32: function(keys) {
        return module2.exports.promisified.putValue(keys, OS_ARCH_32BIT);
      },
      putValue64: function(keys) {
        return module2.exports.promisified.putValue(keys, OS_ARCH_64BIT);
      }
    };
  }
});

// src/extension.ts
var extension_exports = {};
__export(extension_exports, {
  activate: () => activate,
  deactivate: () => deactivate,
  printChannelOutput: () => printChannelOutput,
  showStatusText: () => showStatusText,
  statusBarItem: () => statusBarItem,
  taskOutputChannel: () => taskOutputChannel
});
module.exports = __toCommonJS(extension_exports);
var import_vscode36 = require("vscode");
var child_process2 = __toESM(require("child_process"), 1);
var import_fs7 = require("fs");
var import_path8 = require("path");
var import_os5 = require("os");

// ../frontend/src/supplement/RequisitionPipeline.ts
var RequisitionPipeline = class _RequisitionPipeline {
  constructor(hub) {
    this.hub = hub;
    hub.register("job", this.addJob);
  }
  // The time in seconds how long a pending request is kept alive for execution.
  // If the job was not handled in this time frame, it will be removed and ignored.
  static offeringTime = 30;
  // Determines the rate at which pending requests are announced (milliseconds between announces).
  static announceInterval = 100;
  // A FIFO list with open requests.
  pendingRequests = [];
  // A timer to announce pending requests to the application in a regular interval.
  announceTimer;
  // A timer to clean up requests that aren't handled in a certain amount of time.
  watchDog;
  announcePromise;
  nextJobId = 0;
  /**
   * Adds a job (consisting of a number of requests) to the internal list for execution.
   *
   * @param job The job to add to the pipeline.
   *
   * @returns A promise which is immediately resolved to true.
   */
  addJob = (job) => {
    this.pendingRequests.push(...job.map((request) => {
      return {
        ...request,
        jobId: this.nextJobId
      };
    }));
    ++this.nextJobId;
    if (!this.announceTimer) {
      this.announceTimer = setInterval(this.announceRequest, _RequisitionPipeline.announceInterval);
    }
    return Promise.resolve(true);
  };
  /**
   * Triggers the execution for the top request in the list, if there's one.
   */
  announceRequest = () => {
    if (this.announcePromise) {
      return;
    }
    if (this.pendingRequests.length > 0) {
      const request = this.pendingRequests[0];
      this.announcePromise = this.hub.execute(request.requestType, request.parameter);
      this.announcePromise.then((value) => {
        if (value) {
          this.removeTopRequest();
        } else {
          this.announcePromise = void 0;
        }
      }).catch((e) => {
        console.error(e);
        this.removeTopRequest();
      });
      if (!this.watchDog) {
        this.watchDog = setTimeout(() => {
          this.cancelCurrentJob();
        }, _RequisitionPipeline.offeringTime * 1e3);
      }
    }
  };
  /**
   * Removes the top entry in the pending list, if there's any, and stops the watchdog.
   */
  removeTopRequest = () => {
    if (this.watchDog) {
      clearTimeout(this.watchDog);
      this.watchDog = void 0;
    }
    this.announcePromise = void 0;
    this.pendingRequests.shift();
    if (this.pendingRequests.length === 0 && this.announceTimer) {
      clearInterval(this.announceTimer);
      this.announceTimer = void 0;
    }
  };
  /**
   * Not only removes the top entry in the pending list, but all requests that belong to the same job as that
   * top entry.
   *
   * If any part of a job fails to execute then all following parts cannot be executed either.
   */
  cancelCurrentJob = () => {
    if (this.watchDog) {
      clearTimeout(this.watchDog);
      this.watchDog = void 0;
    } else {
      return;
    }
    this.announcePromise = void 0;
    const current = this.pendingRequests.shift();
    if (current) {
      while (this.pendingRequests.length > 0 && this.pendingRequests[0].jobId === current.jobId) {
        this.pendingRequests.shift();
      }
    }
    if (this.pendingRequests.length === 0 && this.announceTimer) {
      clearInterval(this.announceTimer);
      this.announceTimer = void 0;
    }
  };
};

// ../frontend/src/supplement/Requisitions.ts
var appParameters = /* @__PURE__ */ new Map();
var parseAppParameters = () => {
  if (typeof window !== "undefined") {
    const queryParts = window.location.search.substring(1).split("&");
    queryParts.forEach((part) => {
      const elements = part.split("=");
      if (elements.length > 1) {
        appParameters.set(elements[0], elements[1]);
        if (elements[0] === "app") {
          appParameters.embedded = true;
        } else if (elements[0] === "fontSize") {
          const fontSize = parseInt(elements[1], 10);
          if (!isNaN(fontSize)) {
            appParameters.fontSize = fontSize;
          }
        } else if (elements[0] === "editorFontSize") {
          const fontSize = parseInt(elements[1], 10);
          if (!isNaN(fontSize)) {
            appParameters.editorFontSize = fontSize;
          }
        }
      }
    });
  }
  if (process.env.NODE_ENV === "test") {
    appParameters.testsRunning = true;
  } else if (process.env.NODE_ENV === "development") {
    appParameters.inDevelopment = true;
  }
  if (process.env.VSCODE_PID !== void 0 && process.env.JEST_WORKER_ID === void 0) {
    appParameters.inExtension = true;
  }
};
var RequisitionHub = class _RequisitionHub {
  // A list of callbacks associated with a specific request.
  registry = /* @__PURE__ */ new Map();
  remoteTarget;
  source;
  // Created and held here to keep it alive. It works via job subscriptions, not direct calls.
  requestPipeline;
  constructor(source = "app") {
    this.source = source;
    this.requestPipeline = new RequisitionPipeline(this);
    this.setRemoteTarget();
  }
  /**
   * Creates a new instance of the requisition hub with default parameters.
   *
   * @returns A new instance of the requisition hub.
   */
  static get instance() {
    return new _RequisitionHub();
  }
  /**
   * Injects the remote end for sending messages to the host.
   *
   * @param target The remote target to use for sending/broadcasting messages. If undefined, the environment
   *               is examined to find a suitable target, which is usually a message handler in the host.
   */
  setRemoteTarget(target) {
    if (target) {
      this.remoteTarget = target;
    } else if (typeof window !== "undefined") {
      if (window.webkit) {
        this.remoteTarget = window.webkit.messageHandlers.hostChannel;
      } else {
        const chrome = window.chrome;
        if (chrome && chrome.webview) {
          this.remoteTarget = chrome.webview;
        }
      }
      if (this.remoteTarget) {
        window.onNativeMessage = (message) => {
          this.handleRemoteMessage(message);
        };
      } else {
        this.remoteTarget = window.parent;
        window.addEventListener("message", (message) => {
          if (message.data.source !== "app") {
            this.handleRemoteMessage(message.data);
          }
        });
        if (appParameters.embedded) {
          document.addEventListener("keydown", (e) => {
            const obj = {
              source: this.source,
              command: "keydown",
              altKey: e.altKey,
              code: e.code,
              ctrlKey: e.ctrlKey,
              isComposing: e.isComposing,
              key: e.key,
              location: e.location,
              metaKey: e.metaKey,
              repeat: e.repeat,
              shiftKey: e.shiftKey
            };
            window.parent.postMessage(obj, "*");
            if (e.metaKey && (e.key === "c" || e.key === "x")) {
              const selection = window.getSelection();
              if (selection) {
                this.writeToClipboard(selection.toString());
                const element = document.activeElement;
                if (e.key === "x" && (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement)) {
                  if (element.selectionStart !== null) {
                    const oldValue = element.value;
                    const caret = Math.min(element.selectionStart, element.selectionEnd ?? 1e3);
                    element.value = oldValue.substring(0, element.selectionStart) + oldValue.substring(element.selectionEnd ?? element.selectionStart);
                    element.selectionStart = caret;
                    element.selectionEnd = caret;
                  }
                }
              }
            }
          });
          document.addEventListener("keyup", (e) => {
            const obj = {
              type: "keyup",
              altKey: e.altKey,
              code: e.code,
              ctrlKey: e.ctrlKey,
              isComposing: e.isComposing,
              key: e.key,
              location: e.location,
              metaKey: e.metaKey,
              repeat: e.repeat,
              shiftKey: e.shiftKey
            };
            window.parent.postMessage(obj, "*");
          });
        }
      }
    }
  }
  /**
   * Stores a callback with a given request type for later execution.
   *
   * @param requestType The request type for which to call the given callback. Must not be empty.
   * @param callback The callback to trigger when request with the given id is to be executed.
   */
  register = (requestType, callback) => {
    if (!this.registry.has(requestType)) {
      this.registry.set(requestType, [callback]);
    } else {
      const list = this.registry.get(requestType);
      const index = list.findIndex((entry) => {
        return entry === callback;
      });
      if (index === -1) {
        list.unshift(callback);
      }
    }
  };
  /**
   * Removes one or more callbacks from the request registry.
   *
   * - With no request type and no callback the entire registry is cleared.
   * - If no callback is given, remove all callbacks for the given request type.
   * - Otherwise remove all occurrences of the callback for the given request type.
   *
   * @param requestType If specified then remove only callbacks for that specific id.
   * @param callback If specified remove all registered entries with the specific callback (filtered by requestType).
   */
  unregister = (requestType, callback) => {
    if (!requestType) {
      this.registry.clear();
      return;
    }
    const list = this.registry.get(requestType);
    if (list) {
      const newList = list.filter((candidate) => {
        return candidate !== callback;
      });
      if (newList.length > 0) {
        this.registry.set(requestType, newList);
      } else {
        this.registry.delete(requestType);
      }
    }
  };
  /**
   * Returns the number of registrations for a given requisition. Useful mostly for tests.
   *
   * @param requestType The type for which to return the count.
   *
   * @returns The number registered callbacks.
   */
  registrations = (requestType) => {
    const list = this.registry.get(requestType);
    return list?.length ?? 0;
  };
  /**
   * Execute a list of registered callbacks for a request.
   *
   * @param requestType The request type for which to execute the registered callbacks.
   * @param parameter The value required for the callbacks.
   *
   * @returns A promise which is resolved when all callbacks are resolved.
   */
  execute = async (requestType, parameter) => {
    const list = this.registry.get(requestType);
    if (list) {
      const promises = [];
      list.forEach((callback) => {
        promises.push(callback(parameter));
      });
      const results = await Promise.all(promises);
      return Promise.resolve(results.some((value) => {
        return value;
      }));
    }
    return Promise.resolve(false);
  };
  /**
   * A specialized execution function for remote calls. It will use messaging to communicate to a possible host or
   * embedded site.
   *
   * @param requestType The request type for which to execute the registered callbacks.
   * @param parameter The value required for the callbacks.
   *
   * @returns True if a remote target exists, otherwise false.
   */
  executeRemote = (requestType, parameter) => {
    if (this.remoteTarget) {
      if (this.remoteTarget.postMessage) {
        const message = {
          source: this.source,
          command: requestType,
          data: parameter
        };
        this.remoteTarget.postMessage(message, "*");
      } else if (this.remoteTarget.broadcastRequest) {
        void this.remoteTarget.broadcastRequest(void 0, requestType, parameter);
      }
      return true;
    }
    return false;
  };
  /**
   * A combination of local and remote execution. The actual execution depends on the provider parameter.
   * If it is undefined, the request is executed locally and remotely. Otherwise it is executed only remotely.
   *
   * @param provider If assigned specifies the source of the request. This is used to avoid sending the request
   *                 back to the same provider.
   * @param requestType The request type for which to execute the registered callbacks.
   * @param parameter The value required for the callbacks.
   *
   * @returns True if any of the callbacks returned true, otherwise false.
   */
  broadcastRequest = async (provider, requestType, parameter) => {
    let result = false;
    if (!provider) {
      result ||= await this.execute(requestType, parameter);
    }
    if (this.remoteTarget?.broadcastRequest) {
      await this.remoteTarget.broadcastRequest(provider, requestType, parameter);
      result = true;
    } else {
      result ||= this.executeRemote(requestType, parameter);
    }
    return result;
  };
  /**
   * Schedules a remote message to all subscribed callbacks.
   *
   * @param message The message to distribute.
   */
  handleRemoteMessage(message) {
    if (message.command === "paste" && message.data) {
      const element = document.activeElement;
      const text = message.data.text;
      if (element && (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement)) {
        const dataTransfer = new DataTransfer();
        dataTransfer.setData("text/plain", text);
        const pasteEvent = new ClipboardEvent("paste", { clipboardData: dataTransfer });
        element.dispatchEvent(pasteEvent);
      }
      return;
    }
    const requestType = message.command;
    const parameter = message.data;
    const list = this.registry.get(requestType);
    if (list) {
      list.forEach((callback) => {
        void callback(parameter);
      });
    }
  }
  /**
   * Clipboard access is limited and must be handled differently, depending on whether running in embedded mode
   * or standalone.
   *
   * @param text The text to write to the clipboard.
   */
  writeToClipboard(text) {
    if (appParameters.embedded) {
      const message = {
        source: this.source,
        command: "writeClipboard",
        text
      };
      this.remoteTarget?.postMessage?.(message, "*");
    } else {
      void navigator.clipboard.writeText(text);
    }
  }
};
parseAppParameters();
var requisitions = RequisitionHub.instance;

// ../frontend/src/utilities/MySQLShellLauncher.ts
var import_child_process = __toESM(require("child_process"), 1);
var import_fs2 = __toESM(require("fs"), 1);
var import_path2 = __toESM(require("path"), 1);
var net = __toESM(require("net"), 1);
var import_os = __toESM(require("os"), 1);

// ../frontend/src/utilities/string-helpers.ts
var formatBytes = (value) => {
  if (value < 1024) {
    return `${value.toFixed(2)} B`;
  }
  value /= 1024;
  if (value < 1014) {
    return `${value.toFixed(2)} KB`;
  }
  value /= 1024;
  if (value < 1024) {
    return `${value.toFixed(2)} MB`;
  }
  value /= 1024;
  return `${value.toFixed(2)} GB`;
};
var filterInt = (value) => {
  if (/^[-+]?(\d+|Infinity)$/.test(value)) {
    return Number(value);
  } else {
    return NaN;
  }
};
var snakeToCamelCase = (str) => {
  if (str.includes("_") || str.includes("-")) {
    return str.toLowerCase().replace(/([-_][a-z])/g, (group) => {
      return group.toUpperCase().replace("-", "").replace("_", "");
    });
  } else {
    return str;
  }
};
var convertCamelToTitleCase = (s) => {
  if (s.length < 1) {
    return "";
  }
  return s.charAt(0).toUpperCase() + s.slice(1);
};
var convertToPascalCase = (str) => {
  str = str.replace(/[^\d\w,]/g, "");
  if (str.includes("_")) {
    str = snakeToCamelCase(str);
  }
  return convertCamelToTitleCase(str);
};
var pathToCamelCase = (str) => {
  if (str.startsWith("/")) {
    str = str.slice(1);
  }
  str.replaceAll("/", "_");
  return str.replace(/([-_][a-z])/g, (group) => {
    return group.toUpperCase().replace("-", "").replace("_", "");
  });
};
var convertCamelToSnakeCase = (o, options) => {
  return deepMapKeys(o, options?.ignore ?? [], (value, key) => {
    const snakeCased = key.replace(/([a-z])([A-Z])/g, (full, match1, match2) => {
      return `${match1}_${match2.toLowerCase()}`;
    });
    return snakeCased;
  });
};
var convertSnakeToCamelCase = (o, options) => {
  return deepMapKeys(o, options?.ignore ?? [], (value, key) => {
    return key.replace(/_([a-z0-9])/gi, (full, match) => {
      return match.toUpperCase();
    });
  });
};
var compareVersionStrings = (baseVersion, compareToVersion) => {
  const v1 = baseVersion.split(".");
  const v22 = compareToVersion.split(".");
  const k3 = Math.min(v1.length, v22.length);
  for (let i63 = 0; i63 < k3; ++i63) {
    const v1Num = parseInt(v1[i63], 10);
    const v2Num = parseInt(v22[i63], 10);
    if (v1Num > v2Num) {
      return 1;
    }
    if (v1Num < v2Num) {
      return -1;
    }
  }
  return v1.length === v22.length ? 0 : v1.length < v22.length ? -1 : 1;
};

// ../frontend/src/utilities/helpers.ts
var uuid = () => {
  let d3 = (/* @__PURE__ */ new Date()).getTime();
  let d22 = performance && performance.now && performance.now() * 1e3 || 0;
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    let r = Math.random() * 16;
    if (d3 > 0) {
      r = (d3 + r) % 16 | 0;
      d3 = Math.floor(d3 / 16);
    } else {
      r = (d22 + r) % 16 | 0;
      d22 = Math.floor(d22 / 16);
    }
    return (c === "x" ? r : r & 7 | 8).toString(16);
  });
};
var sleep = (ms) => {
  return new Promise((resolve) => {
    return setTimeout(resolve, ms);
  });
};
var waitFor = async (timeout, condition) => {
  while (!condition() && timeout > 0) {
    timeout -= 100;
    await sleep(100);
  }
  return timeout > 0 ? true : false;
};
var deepMapKeys = (o, ignoreList, fn3) => {
  const result = {};
  for (const [k3, v3] of Object.entries(o)) {
    let actualValue = v3;
    if (!ignoreList.includes(k3)) {
      if (Array.isArray(v3)) {
        actualValue = deepMapArray(v3, ignoreList, fn3);
      } else if (v3 !== null && typeof v3 === "object") {
        actualValue = deepMapKeys(v3, ignoreList, fn3);
      }
    }
    result[fn3(v3, k3)] = actualValue;
  }
  return result;
};
var deepMapArray = (a, ignoreList, fn3) => {
  return a.map((v3) => {
    if (Array.isArray(v3)) {
      return deepMapArray(v3, ignoreList, fn3);
    } else if (v3 !== null && typeof v3 === "object") {
      return deepMapKeys(v3, ignoreList, fn3);
    }
    return v3;
  });
};

// ../frontend/src/communication/ProtocolGui.ts
var multiResultAPIs = [
  "gui.core.list_files" /* GuiCoreListFiles */,
  "gui.db.get_schema_object_names" /* GuiDbGetSchemaObjectNames */,
  "gui.dbconnections.list_db_connections" /* GuiDbconnectionsListDbConnections */,
  "gui.modules.get_profile_data_tree" /* GuiModulesGetProfileDataTree */,
  "gui.shell.complete" /* GuiShellComplete */,
  "gui.sqleditor.execute" /* GuiSqleditorExecute */,
  "gui.db.get_catalog_object_names" /* GuiDbGetCatalogObjectNames */,
  "gui.db.get_table_object_names" /* GuiDbGetTableObjectNames */
];

// ../frontend/src/supplement/ShellInterface/ShellInterfaceCore.ts
var ShellInterfaceCore = class {
  /**
   * Returns information about the backend, e.g. for showing in the about box.
   *
   * @returns A promise with backend information.
   */
  get backendInformation() {
    return (async () => {
      const response = await MessageScheduler.get.sendRequest({
        requestType: "gui.core.get_backend_information" /* GuiCoreGetBackendInformation */,
        parameters: {}
      });
      return {
        architecture: response.result.architecture,
        major: filterInt(response.result.major),
        minor: filterInt(response.result.minor),
        patch: filterInt(response.result.patch),
        platform: response.result.platform,
        serverDistribution: response.result.serverDistribution,
        serverMajor: filterInt(response.result.serverMajor),
        serverMinor: filterInt(response.result.serverMinor),
        serverPatch: filterInt(response.result.serverPatch)
      };
    })();
  }
  async getLogLevel() {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.core.get_log_level" /* GuiCoreGetLogLevel */,
      parameters: {}
    });
    return response.result;
  }
  async setLogLevel(logLevel) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.core.set_log_level" /* GuiCoreSetLogLevel */,
      parameters: { args: { logLevel } }
    });
  }
  /**
   * @returns Returns a promise resolving to a list of DB type names.
   */
  async getDbTypes() {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.dbconnections.get_db_types" /* GuiDbconnectionsGetDbTypes */,
      parameters: {}
    });
    return response.result;
  }
  /**
   * Checks if the given path is valid and points to an existing file.
   *
   * @param path The path to check.
   *
   * @returns A promise which resolves to true if the path is valid, otherwise to false.
   */
  async validatePath(path25) {
    try {
      await MessageScheduler.get.sendRequest({
        requestType: "gui.core.validate_path" /* GuiCoreValidatePath */,
        parameters: { args: { path: path25 } }
      });
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Creates the database file for an sqlite3 connection. The file must not exist yet.
   *
   * @param path The path to the file to create.
   *
   * @returns A promise which resolves when the operation was concluded.
   */
  async createDatabaseFile(path25) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.core.create_file" /* GuiCoreCreateFile */,
      parameters: { args: { path: path25 } }
    });
  }
  /**
   * @returns A promise resolving to a list of scripts from the backend used to unit testing and for help in the
   *          frontend communication debugger.
   */
  async getDebuggerScriptNames() {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.debugger.get_scripts" /* GuiDebuggerGetScripts */,
      parameters: {}
    });
    return response.result;
  }
  /**
   * @param path The name/path of the script.
   *
   * @returns The content of the script give by its name.
   */
  async getDebuggerScriptContent(path25) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.debugger.get_script_content" /* GuiDebuggerGetScriptContent */,
      parameters: { args: { path: path25 } }
    });
    return response.result;
  }
};

// ../frontend/src/supplement/ShellInterface/ShellInterfaceDbConnection.ts
var ShellInterfaceDbConnection = class {
  id = "dbConnection";
  /**
   * Adds a new database connection to a profile.
   *
   * @param profileId The id of the profile.
   * @param connection An object holding all data of the connection.
   * @param folderPath The folder path used for grouping and nesting connections, optional
   *
   * @returns A promise resolving to the id of the new connection.
   */
  async addDbConnection(profileId, connection, folderPath = "") {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.dbconnections.add_db_connection" /* GuiDbconnectionsAddDbConnection */,
      parameters: {
        args: {
          profileId,
          connection: {
            dbType: connection.dbType,
            caption: connection.caption,
            description: connection.description,
            options: connection.options
          },
          folderPath
        }
      }
    });
    return response.result;
  }
  /**
   * Updates the connection data in the backend.
   *
   * @param profileId The id of the profile.
   * @param connection An object holding all data of the connection.
   * @param folderPath The folder path used for grouping and nesting connections.
   *
   * @returns A promise which resolves when the request was concluded.
   */
  async updateDbConnection(profileId, connection, folderPath = "") {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.dbconnections.update_db_connection" /* GuiDbconnectionsUpdateDbConnection */,
      parameters: {
        args: {
          profileId,
          connectionId: connection.id,
          connection: {
            dbType: connection.dbType,
            caption: connection.caption,
            description: connection.description,
            options: connection.options
          },
          folderPath
        }
      }
    });
  }
  /**
   * Removes a database connection from a profile.
   *
   * @param profileId The id of the profile.
   * @param connectionId The connection to remove.
   *
   * @returns A promise which resolves when the request was concluded.
   */
  async removeDbConnection(profileId, connectionId) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.dbconnections.remove_db_connection" /* GuiDbconnectionsRemoveDbConnection */,
      parameters: { args: { profileId, connectionId } }
    });
  }
  /**
   * Returns all database connections of a given profile and in a given folder path.
   *
   * @param profileId The id of the profile.
   * @param folderPath The folder path used for grouping and nesting connections.
   *
   * @returns A promise which resolves to the list of existing connections.
   */
  async listDbConnections(profileId, folderPath = "") {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.dbconnections.list_db_connections" /* GuiDbconnectionsListDbConnections */,
      parameters: { args: { profileId, folderPath } }
    });
    const result = [];
    response.forEach((entry) => {
      result.push(...entry.result);
    });
    return result;
  }
  /**
   * @param connectionId The id of the connection.
   *
   * @returns A promise resolving to the details of the requested connection or undefined, if no connection with the
   *          given identifier exists.
   */
  async getDbConnection(connectionId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.dbconnections.get_db_connection" /* GuiDbconnectionsGetDbConnection */,
      parameters: { args: { dbConnectionId: connectionId } }
    });
    return response.result;
  }
};

// ../frontend/src/supplement/ShellInterface/ShellInterfaceModule.ts
var ShellInterfaceModule = class {
  // Mappings between script category ids and editor languages.
  scriptCategoryToLanguage = /* @__PURE__ */ new Map([
    [4 /* MySQLScript */, "mysql"],
    [5 /* PythonScript */, "python"],
    [6 /* JavaScriptScript */, "javascript"],
    [7 /* TypeScriptScript */, "typescript"],
    [8 /* SQLiteScript */, "sql"],
    [3 /* JSON */, "json"]
  ]);
  languageToScriptCategory = /* @__PURE__ */ new Map([
    ["mysql", 4 /* MySQLScript */],
    ["python", 5 /* PythonScript */],
    ["javascript", 6 /* JavaScriptScript */],
    ["typescript", 7 /* TypeScriptScript */],
    ["sql", 8 /* SQLiteScript */],
    ["json", 3 /* JSON */]
  ]);
  /**
   * Creates a new data record in the data tree given by the tree identifier.
   *
   * @param caption The data caption.
   * @param content The content of data module.
   * @param dataCategoryId The id of data category.
   * @param treeIdentifier The identifier of the tree.
   * @param folderPath The folder path f.e. "/scripts/server1"
   * @param profileId The id of profile
   *
   * @returns A promise resolving to the id of the added data entry.
   */
  async addData(caption, content, dataCategoryId, treeIdentifier, folderPath, profileId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.modules.add_data" /* GuiModulesAddData */,
      parameters: {
        args: {
          caption,
          content,
          dataCategoryId,
          treeIdentifier,
          folderPath,
          profileId
        }
      }
    });
    return response.result;
  }
  /**
   * Returns a list of data entries from a given folder and the specified data category.
   *
   * @param folderId The id of the folder.
   * @param dataCategoryId The id of the data category.
   *
   * @returns A promise resolving to the list of data entries.
   */
  async listData(folderId, dataCategoryId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.modules.list_data" /* GuiModulesListData */,
      parameters: {
        args: {
          folderId,
          dataCategoryId
        }
      }
    });
    return response.result;
  }
  /**
   * Retrieves the content of a specific data item.
   *
   * @param dataId An id which identifies a data item (returned from list or add data).
   *
   * @returns A promise resolving to the data content.
   */
  async getDataContent(dataId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.modules.get_data_content" /* GuiModulesGetDataContent */,
      parameters: {
        args: {
          id: dataId
        }
      }
    });
    return response.result;
  }
  /**
   * Creates a new data tree in the given profile.
   *
   * @param treeIdentifier The identifier of the tree.
   * @param profileId The id of profile
   *
   * @returns A promise which resolves when the request is finished.
   */
  async createProfileDataTree(treeIdentifier, profileId) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.modules.create_profile_data_tree" /* GuiModulesCreateProfileDataTree */,
      parameters: {
        args: {
          treeIdentifier,
          profileId
        }
      }
    });
  }
  /**
   * Gets the complete data tree specified by the tree tree identifier, for the given profile.
   *
   * @param treeIdentifier The identifier of the tree.
   * @param profileId The id of profile
   *
   * @returns A promise resolving to the list of tree entries.
   */
  async getProfileDataTree(treeIdentifier, profileId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.modules.get_profile_data_tree" /* GuiModulesGetProfileDataTree */,
      parameters: {
        args: {
          treeIdentifier,
          profileId
        }
      }
    });
    const result = [];
    response.forEach((list) => {
      result.push(...list.result);
    });
    return result;
  }
  /**
   * Creates the user group data tree for the given tree identifier and user group id.
   *
   * @param treeIdentifier The identifier of the tree.
   * @param userGroupId The id of user group
   *
   * @returns A promise which resolves when the request is finished.
   */
  async createUserGroupDataTree(treeIdentifier, userGroupId) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.modules.create_user_group_data_tree" /* GuiModulesCreateUserGroupDataTree */,
      parameters: {
        args: {
          treeIdentifier,
          userGroupId
        }
      }
    });
  }
  /**
   * Gets the user group data tree for the given tree identifier and user group id.
   *
   * @param treeIdentifier The identifier of the tree.
   * @param userGroupId The id of user group
   *
   * @returns A promise which resolves when the request is finished.
   */
  async getUserGroupDataTree(treeIdentifier, userGroupId) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.modules.get_user_group_data_tree" /* GuiModulesGetUserGroupDataTree */,
      parameters: {
        args: {
          treeIdentifier,
          userGroupId
        }
      }
    });
  }
  /**
   * Returns a list with identifiers of available data trees for a given profile.
   *
   * @param profileId The id of profile.
   *
   * @returns A promise which resolves when the request is finished.
   */
  async getProfileDataTreeIdentifiers(profileId) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.modules.get_profile_tree_identifiers" /* GuiModulesGetProfileTreeIdentifiers */,
      parameters: {
        args: {
          profileId
        }
      }
    });
  }
  /**
   * Shares data to user group
   *
   * @param id The id of the data
   * @param userGroupId The id of user group
   * @param readOnly The flag that specifies whether the data is read only
   * @param treeIdentifier The identifier of the tree.
   * @param folderPath The folder path f.e. "/scripts/server1"
   *
   * @returns A promise which resolves when the request is finished.
   */
  async shareDataToUserGroup(id, userGroupId, readOnly, treeIdentifier, folderPath) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.modules.share_data_to_user_group" /* GuiModulesShareDataToUserGroup */,
      parameters: {
        args: {
          id,
          userGroupId,
          readOnly,
          treeIdentifier,
          folderPath
        }
      }
    });
  }
  /**
   * Shares data to user group
   *
   * @param id The id of the data
   * @param profileId The id of profile
   * @param readOnly The flag that specifies whether the data is read only
   * @param treeIdentifier The identifier of the tree.
   * @param folderPath The folder path f.e. "/scripts/server1"
   *
   * @returns A promise which resolves when the request is finished.
   */
  async addDataToProfile(id, profileId, readOnly, treeIdentifier, folderPath) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.modules.add_data_to_profile" /* GuiModulesAddDataToProfile */,
      parameters: {
        args: {
          id,
          profileId,
          readOnly,
          treeIdentifier,
          folderPath
        }
      }
    });
  }
  /**
   * Update data at the given module
   *
   * @param id The id of the data
   * @param caption Caption
   * @param content The content data
   *
   * @returns A promise which resolves when the request is finished.
   */
  async updateData(id, caption, content) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.modules.update_data" /* GuiModulesUpdateData */,
      parameters: {
        args: {
          id,
          caption,
          content
        }
      }
    });
  }
  /**
   * Deletes data
   *
   * @param id The id of the data
   * @param folderId The id of the folder
   *
   * @returns A promise which resolves when the request is finished.
   */
  async deleteData(id, folderId) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.modules.delete_data" /* GuiModulesDeleteData */,
      parameters: {
        args: {
          id,
          folderId
        }
      }
    });
  }
  /**
   * Gets the list of available data categories.
   *
   * @param parentID The ID of the parent data category. If not given, the root entries are returned.
   *
   * @returns A promise resolving to the list of category entries.
   */
  async listDataCategories(parentID) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.modules.list_data_categories" /* GuiModulesListDataCategories */,
      parameters: {
        args: {
          categoryId: parentID
        }
      }
    });
    return response.result;
  }
  /**
   * Adds a new data category for data entries.
   *
   * @param category A human readable string identifying the data category.
   * @param parent Specifies the parent category to which the new category belongs. Root categories have no parent.
   *
   * @returns A promise which resolves when the request is finished.
   */
  async addDataCategory(category, parent) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.modules.add_data_category" /* GuiModulesAddDataCategory */,
      parameters: {
        args: {
          name: category,
          parentCategoryId: parent
        }
      }
    });
  }
  /**
   * Remove a data category from the list of available data categories.
   *
   * @param categoryId The id of the data category
   *
   * @returns A promise which resolves when the request is finished.
   */
  async removeDataCategory(categoryId) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.modules.remove_data_category" /* GuiModulesRemoveDataCategory */,
      parameters: {
        args: {
          categoryId
        }
      }
    });
  }
  /**
   * Returns the resource id of one of the script types, depending on the given language.
   *
   * @param language The language for which to return the script type.
   *
   * @returns A value which identifies a module data script resource or undefined if no such type exists.
   */
  scriptTypeFromLanguage(language) {
    return this.languageToScriptCategory.get(language);
  }
  /**
   * Collects a list of script data entries.
   *
   * @param profileId The profile for which to load the scripts (default profile, if undefined).
   *
   * @returns A promise which resolves with the script details.
   */
  async loadScriptsTree(profileId) {
    return this.loadScriptTreeEntries(2 /* Script */, profileId);
  }
  /**
   * Loads all entries from the "scripts" subtree.
   *
   * @param categoryId The ID of the module data category for the "Script" type.
   * @param profileId The ID of the profile for which to load the tree.
   *
   * @returns A promise resolving to a list of script state entries, comprising the tree.
   */
  async loadScriptTreeEntries(categoryId, profileId) {
    const dataTree = await this.getProfileDataTree("scripts", profileId);
    const createTree = async (parentId, target) => {
      const result2 = dataTree.filter((entry, index, arr) => {
        if (entry.parentFolderId === parentId) {
          arr.splice(index, 1);
          return true;
        }
        return false;
      });
      for await (const entry of result2) {
        const entries = await this.loadScriptStates(entry.id, categoryId);
        await createTree(entry.id, entries);
        target.push({
          id: "",
          folderId: parentId,
          dbDataId: entry.id,
          caption: entry.caption,
          children: entries,
          type: 2 /* Folder */
        });
      }
    };
    const result = [];
    if (dataTree.length > 0 && dataTree[0].caption === "scripts") {
      const root = dataTree.shift();
      if (root) {
        const states = await this.loadScriptStates(root.id, categoryId);
        result.push(...states);
        await createTree(root.id, result);
      }
    }
    return result;
  }
  /**
   * Constructs script state entries from script data entries.
   *
   * @param folderId The ID of the folder from which to load the items.
   * @param dataCategoryId The ID of the data category, which determines the data items to load.
   *
   * @returns A list of state entries for all found data entries.
   */
  loadScriptStates = async (folderId, dataCategoryId) => {
    const listData = [];
    const dataEntries = await this.listData(folderId, dataCategoryId);
    listData.push(...dataEntries.map((entry) => {
      const language = this.scriptCategoryToLanguage.get(entry.dataCategoryId) ?? "mysql";
      return {
        id: uuid(),
        folderId,
        type: 1 /* Script */,
        caption: entry.caption,
        language,
        dbDataId: entry.id
      };
    }));
    return listData;
  };
};

// ../frontend/src/supplement/ShellInterface/ShellInterfaceUser.ts
var ShellInterfaceUser = class {
  /**
   * Authenticate a user.
   *
   * @param username The name of the user.
   * @param password The user's password.
   *
   * @returns A promise resolving to the user's active profile.
   */
  async authenticate(username, password) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "authenticate" /* UserAuthenticate */,
      parameters: { username, password }
    }, false);
    webSession.userName = username;
    webSession.userId = response.activeProfile.userId;
    webSession.loadProfile(response.activeProfile);
    return response.activeProfile;
  }
  /**
   * Creates a new MySQL Shell GUI user account.
   *
   * @param username The name of the user.
   * @param password The user's password.
   * @param role The role that should be assigned to the user.
   * @param allowedHosts Allowed hosts that user can connect from.
   *
   * @returns A promise which resolves when the request was finished.
   */
  async createUser(username, password, role, allowedHosts) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.users.create_user" /* GuiUsersCreateUser */,
      parameters: { args: { username, password, role, allowedHosts } }
    });
  }
  /**
   * Returns the default profile of the given user.
   *
   * @param userId The id of the user.
   *
   * @returns A promise which resolves with the profile data when the request was finished.
   */
  async getDefaultProfile(userId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.users.get_default_profile" /* GuiUsersGetDefaultProfile */,
      parameters: { args: { userId } }
    });
    if (!Array.isArray(response)) {
      return response.result;
    }
  }
  /**
   * Returns the default profile of the given user.
   *
   * @param userId The id of the user.
   * @param profileId The profile_id that should be come the new default.
   *
   * @returns A promise which resolves when the request was finished.
   */
  async setDefaultProfile(userId, profileId) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.users.set_default_profile" /* GuiUsersSetDefaultProfile */,
      parameters: { args: { userId, profileId } }
    });
  }
  /**
   * Returns the list of modules for the given user.
   *
   * @param userId The id of the user.
   *
   * @returns A promise resolving to the list of known modules.
   */
  async getGuiModuleList(userId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.users.get_gui_module_list" /* GuiUsersGetGuiModuleList */,
      parameters: { args: { userId } }
    });
    if (!Array.isArray(response)) {
      return Promise.resolve(response.result);
    }
    return Promise.resolve([]);
  }
  /**
   * Returns the specified profile.
   *
   * @param profileId The id of the profile.
   *
   * @returns A promise resolving to the profile details.
   */
  async getProfile(profileId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.users.get_profile" /* GuiUsersGetProfile */,
      parameters: { args: { profileId } }
    });
    if (!Array.isArray(response)) {
      return Promise.resolve(response.result);
    }
  }
  /**
   * Adds a new user profile.
   *
   * @param profile The profile.
   *
   * @returns A promise resolving to the data of the just added profile.
   */
  async addProfile(profile) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.users.add_profile" /* GuiUsersAddProfile */,
      parameters: { args: { userId: profile.userId, profile } }
    });
    return response.result;
  }
  /**
   * Updates the user profile.
   *
   * @param profile The profile to update.
   *
   * @returns A promise resolving to the updated profile data.
   */
  async updateProfile(profile) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.users.update_profile" /* GuiUsersUpdateProfile */,
      parameters: { args: { profile } }
    });
    if (!Array.isArray(response)) {
      return Promise.resolve(response.result);
    }
  }
  /**
   * Deletes a user profile.
   *
   * @param profile The profile to remove.
   *
   * @returns A promise which resolve when the request was finished.
   */
  async deleteProfile(profile) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.users.delete_profile" /* GuiUsersDeleteProfile */,
      parameters: { args: { userId: profile.userId, profileId: profile.id } }
    });
  }
  /**
   * Grant the given roles to the user.
   *
   * @param username The name of the user.
   * @param role The list of roles that should be assigned to the user. Use listRoles() to list all available roles.
   *
   * @returns A promise which resolve when the request was finished.
   */
  async grantRole(username, role) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.users.grant_role" /* GuiUsersGrantRole */,
      parameters: { args: { username, role } }
    });
  }
  /**
   * Returns the list of profile for the given user
   *
   * @param userId The id of the user.
   *
   * @returns A promise resolving to the list of profiles.
   */
  async listProfiles(userId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.users.list_profiles" /* GuiUsersListProfiles */,
      parameters: { args: { userId } }
    });
    return response.result;
  }
  /**
   * Lists all privileges of a role.
   *
   * @param role The name of the role.
   *
   * @returns A promise which resolve when the request was finished.
   */
  async listRolePrivileges(role) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.users.list_role_privileges" /* GuiUsersListRolePrivileges */,
      parameters: { args: { role } }
    });
  }
  /**
   * Lists all roles that can be assigned to users.
   *
   * @returns A promise which resolve when the request was finished.
   */
  async listRoles() {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.users.list_roles" /* GuiUsersListRoles */,
      parameters: {}
    });
  }
  /**
   * Lists all privileges assigned to a user.
   *
   * @param username The name of the user.
   *
   * @returns A promise which resolve when the request was finished.
   */
  async listUserPrivileges(username) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.users.list_user_privileges" /* GuiUsersListUserPrivileges */,
      parameters: { args: { username } }
    });
  }
  /**
   * List the granted roles for a given user.
   *
   * @param username The name of the user.
   *
   * @returns A promise which resolve when the request was finished.
   */
  async listUserRoles(username) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.users.list_user_roles" /* GuiUsersListUserRoles */,
      parameters: { args: { username } }
    });
  }
  /**
   * Lists all user accounts.
   *
   * @returns A promise which resolve when the request was finished.
   */
  async listUsers() {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.users.list_users" /* GuiUsersListUsers */,
      parameters: {}
    });
  }
  /**
   * Sets the profile of the user's current web session.
   *
   * @param profileId The id of the profile.
   *
   * @returns A promise which resolve when the request was finished.
   */
  async setCurrentProfile(profileId) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.users.set_current_profile" /* GuiUsersSetCurrentProfile */,
      parameters: { args: { profileId } }
    });
  }
  /**
   * set the password of a db_connection url
   *
   * @param url The URL needs to be in the following form user@(host[:port]|socket).
   * @param password The password
   *
   * @returns A promise which resolve when the request was finished.
   */
  async storePassword(url, password) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.dbconnections.set_credential" /* GuiDbconnectionsSetCredential */,
      parameters: { args: { url, password } }
    });
  }
  /**
   * deletes the password of a db_connection url
   *
   * @param url The URL needs to be in the following form user@(host[:port]|socket).
   *
   * @returns A promise which resolve when the request was finished.
   */
  async clearPassword(url) {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.dbconnections.delete_credential" /* GuiDbconnectionsDeleteCredential */,
      parameters: { args: { url } }
    });
  }
  /**
   * lists the db_connection urls that have a password stored
   *
   * @returns A promise which resolve when the request was finished.
   */
  async listCredentials() {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.dbconnections.list_credentials" /* GuiDbconnectionsListCredentials */,
      parameters: {}
    });
  }
};

// ../frontend/src/supplement/ShellInterface/ShellInterface.ts
var ShellInterface = class _ShellInterface {
  static interfaces = {};
  static get core() {
    if (!_ShellInterface.interfaces.core) {
      _ShellInterface.interfaces.core = new ShellInterfaceCore();
    }
    return _ShellInterface.interfaces.core;
  }
  static get users() {
    if (!_ShellInterface.interfaces.users) {
      _ShellInterface.interfaces.users = new ShellInterfaceUser();
    }
    return _ShellInterface.interfaces.users;
  }
  static get modules() {
    if (!_ShellInterface.interfaces.modules) {
      _ShellInterface.interfaces.modules = new ShellInterfaceModule();
    }
    return _ShellInterface.interfaces.modules;
  }
  static get dbConnections() {
    if (!_ShellInterface.interfaces.dbConnections) {
      _ShellInterface.interfaces.dbConnections = new ShellInterfaceDbConnection();
    }
    return _ShellInterface.interfaces.dbConnections;
  }
};

// ../frontend/src/supplement/Storage/Cookies.ts
var Cookies = class {
  set(name, value) {
    let cookie = "";
    cookie = `${name}=${value ?? ""}`;
    if (typeof document !== "undefined") {
      document.cookie = cookie;
    }
  }
  get(name) {
    if (typeof document === "undefined" || !document.cookie) {
      return null;
    }
    const cookie = document.cookie.split(";").find((item) => {
      return item.split("=")[0].trim() === name;
    });
    if (cookie) {
      const parts = cookie.split("=");
      if (parts.length === 1) {
        return parts[0];
      }
      return parts[1].trim();
    }
    return null;
  }
  remove(name) {
    if (typeof document !== "undefined") {
      document.cookie = name + "=; Max-Age=0;";
    }
  }
  clear() {
    if (typeof document !== "undefined") {
      for (const cookie of document.cookie.split(";")) {
        this.remove(cookie.split("=")[0].trim());
      }
    }
  }
};

// ../frontend/src/supplement/WebSession.ts
var WebSession = class _WebSession {
  localUserMode = false;
  cookies = new Cookies();
  shellProfile = {
    description: "",
    id: -1,
    name: "",
    userId: -1,
    options: {}
  };
  sessionData;
  constructor() {
    this.clearSessionData();
  }
  static get instance() {
    return new _WebSession();
  }
  get userId() {
    return this.sessionData.userId;
  }
  set userId(userId) {
    this.sessionData.userId = userId;
    this.writeSessionData();
  }
  get userName() {
    return this.sessionData.userName;
  }
  set userName(name) {
    this.sessionData.userName = name;
    this.writeSessionData();
  }
  /**
   * @returns The profile data for the current session/user.
   */
  get profile() {
    return this.shellProfile;
  }
  /**
   * Stores new profile data for the current session/user. This will also
   * store the profile in the shell.
   *
   * @param newProfile The new profile data.
   */
  set profile(newProfile) {
    this.loadProfile(newProfile);
    this.saveProfile();
  }
  get currentProfileId() {
    return this.shellProfile.id;
  }
  /**
   * @returns The ID of the current application session.
   */
  get sessionId() {
    return this.sessionData.sessionId;
  }
  /**
   * Stores the given id as current application session ID. Will also be stored in a cookie for the BE.
   */
  set sessionId(id) {
    this.cookies.clear();
    this.sessionData.sessionId = id;
    if (id) {
      this.cookies.set("SessionId", id);
    }
    this.cookies.set("SameSite", "None");
    this.cookies.set("Secure");
  }
  clearSessionData() {
    this.sessionData = {
      sessionId: "",
      userName: "",
      profileId: -1,
      userId: -1,
      moduleSessionId: {}
    };
  }
  /**
   * Returns the session ID for a specific module.
   *
   * @param moduleName The module name for which to query the session ID.
   *
   * @returns The found ID or nothing if no module session exists.
   */
  moduleSessionId(moduleName) {
    return this.sessionData.moduleSessionId[moduleName];
  }
  /**
   * Sets the session ID for a specific module.
   *
   * @param moduleName The name of the module for which to set the session ID.
   * @param sessionId The session ID for that module. Will also be stored in the browser's session storage.
   */
  setModuleSessionId(moduleName, sessionId) {
    if (sessionId) {
      this.sessionData.moduleSessionId[moduleName] = sessionId;
    } else {
      delete this.sessionData.moduleSessionId[moduleName];
    }
  }
  /**
   * Load a profile from the shell. Calling this function won't update the shell
   * as seen in Session.currentSession.profile = profile.
   *
   * @param newProfile the profile object to be loaded
   */
  loadProfile(newProfile) {
    this.shellProfile = newProfile;
    this.sessionData.profileId = newProfile.id;
    this.sessionData.userId = newProfile.userId;
    this.writeSessionData();
    void requisitions.execute("profileLoaded", void 0);
  }
  /**
   * Sends the current profile data to the backend.
   */
  saveProfile() {
    ShellInterface.users.updateProfile(this.shellProfile).then(() => {
    }).catch((reason) => {
      void requisitions.execute("showError", ["Profile Update Error", String(reason)]);
    });
  }
  writeSessionData() {
    if (!process.env.VSCODE_PID) {
    }
  }
};
var webSession = WebSession.instance;

// ../frontend/src/communication/ResponseError.ts
var ResponseError = class extends Error {
  constructor(info) {
    super(info.requestState.msg);
    this.info = info;
  }
};

// ../frontend/src/communication/MessageScheduler.ts
var MessageScheduler = class _MessageScheduler {
  static instance;
  static multiResultList = multiResultAPIs;
  socket;
  debugging = false;
  disconnecting = false;
  reconnectTimer;
  reconnectTimeout = 1e3;
  // In milliseconds.
  ongoingRequests = /* @__PURE__ */ new Map();
  #traceEnabled = false;
  static get get() {
    if (!_MessageScheduler.instance) {
      _MessageScheduler.instance = this.createInstance();
    }
    return _MessageScheduler.instance;
  }
  constructor() {
  }
  static createInstance() {
    return new _MessageScheduler();
  }
  /**
   * @returns True if the connection is established.
   */
  get isConnected() {
    if (this.socket) {
      return this.socket.readyState === this.socket.OPEN;
    }
    return false;
  }
  set inDebugCall(value) {
    this.debugging = value;
  }
  set traceEnabled(value) {
    this.#traceEnabled = value;
  }
  get traceEnabled() {
    return this.#traceEnabled;
  }
  /**
   * Opens a web socket connection.
   *
   * @param options Details for the connection.
   *
   * @returns A promise which indicates success or failure.
   */
  connect(options) {
    this.disconnecting = false;
    if (this.socket && (this.socket.readyState === this.socket.OPEN || this.socket.readyState === this.socket.CONNECTING)) {
      return Promise.resolve();
    } else {
      const target = new URL(options.url);
      target.protocol = options.url.protocol.replace("http", "ws");
      target.pathname = "ws1.ws";
      if (appParameters.inDevelopment) {
        target.port = "8000";
      }
      return new Promise((resolve, reject) => {
        const socket = this.createWebSocket(target, options);
        socket.addEventListener("close", this.onClose.bind(this, options));
        socket.addEventListener("message", this.onMessage);
        socket.addEventListener("open", this.onOpen.bind(this, resolve));
        socket.addEventListener("error", this.onError.bind(this, options, reject));
        this.socket = socket;
      });
    }
  }
  /**
   * Disconnect the socket
   */
  disconnect() {
    if (this.socket) {
      try {
        this.disconnecting = true;
        this.socket.close();
        delete this.socket;
        this.socket = void 0;
      } catch (e) {
        console.error("Internal error while closing websocket: " + String(e));
      }
    }
  }
  /**
   * Sends a request to the backend and returns a promise for the expected responses.
   *
   * @param details The type and parameters for the request.
   * @param useExecute A flag to indicate this is actually an execute request, but in the simple form.
   * @param caseConversionIgnores Ignore case conversions for items in this list
   *
   * @returns A promise resolving with a list of responses or a single response received from the backend.
   */
  sendRequest(details, useExecute = true, caseConversionIgnores = []) {
    return this.constructAndSendRequest(useExecute, caseConversionIgnores, {
      ...details
    });
  }
  /**
   * Sends a request to the backend which is not processed in any way (camel case conversion etc.).
   * This is mostly useful for communication debugging.
   *
   * @param details The raw request structure.
   * @param callback A callback for intermediate results.
   *
   * @returns A promise resolving with a single response received from the backend.
   */
  sendRawRequest(details, callback) {
    details.request_id = details.request_id ?? uuid();
    return new Promise((resolve, reject) => {
      if (this.traceEnabled) {
        void requisitions.execute("debugger", { request: details });
      }
      const ongoingRequest = {
        protocolType: "native",
        result: [],
        resolve,
        reject,
        onData: callback
      };
      this.ongoingRequests.set(details.request_id, ongoingRequest);
      this.socket?.send(JSON.stringify(details));
    });
  }
  /**
   * Creates a web socket for the given options.
   *
   * @param target The endpoint to connect the socket to.
   * @param options Details for the connection.
   *
   * @returns A new websocket instance.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createWebSocket(target, options) {
    return new WebSocket(target);
  }
  /**
   * First entry point for messages sent from the backend. The message is parsed and converted to camel case keys.
   * Depending on the response event type the result of this conversion is then returned in the associated promise
   * or scheduled via the given callback.
   *
   * @param event The event containing the data sent by the backend.
   */
  onMessage = (event) => {
    const response = this.convertDataToResponse(event.data);
    if (response) {
      if (this.isWebSessionData(response) && !this.debugging) {
        void requisitions.execute("webSessionStarted", response);
      } else if (response.requestId) {
        const record = this.ongoingRequests.get(response.requestId);
        if (record) {
          const ongoing = record;
          const data = response;
          switch (response.eventType) {
            case 2 /* DataResponse */: {
              if (this.isErrorInfo(response)) {
                const index = response.result.info.indexOf("ERROR:");
                if (index > -1) {
                  const error = response.result.info.substring(index);
                  this.ongoingRequests.delete(response.requestId);
                  ongoing.reject(error);
                  break;
                }
              }
              if (ongoing.onData) {
                ongoing.onData(data, response.requestId);
              } else {
                ongoing.result.push(data);
              }
              break;
            }
            case 3 /* FinalResponse */: {
              this.ongoingRequests.delete(response.requestId);
              if (_MessageScheduler.multiResultList.includes(record.protocolType)) {
                ongoing.result.push(data);
                ongoing.resolve(ongoing.result);
              } else {
                ongoing.resolve(data);
              }
              break;
            }
            case 4 /* DoneResponse */: {
              this.ongoingRequests.delete(response.requestId);
              if (_MessageScheduler.multiResultList.includes(record.protocolType) || ongoing.result.length === 0) {
                ongoing.resolve(ongoing.result);
              } else {
                ongoing.resolve(ongoing.result[0]);
              }
              break;
            }
            case -2 /* ErrorResponse */: {
              this.ongoingRequests.delete(response.requestId);
              const result = data.result;
              if (result && "requestState" in result) {
                ongoing.reject(new ResponseError(result));
              } else {
                ongoing.reject(new ResponseError(data));
              }
              break;
            }
            default:
          }
        }
      }
    }
  };
  /**
   * This is the core method to send a request to the backend.
   *
   * @param isExecuteRequest True if the request must be sent as execution request.
   * @param caseConversionIgnores Ignore case conversions for items in this list
   * @param details The type and parameters for the request.
   *
   * @returns A promise resolving with a list of responses received from the backend.
   */
  constructAndSendRequest(isExecuteRequest, caseConversionIgnores, details) {
    const requestId = details.requestId ?? uuid();
    return new Promise((resolve, reject) => {
      const record = {
        requestId,
        request: isExecuteRequest ? "execute" : details.requestType,
        command: isExecuteRequest ? details.requestType : void 0,
        ...details.parameters
      };
      caseConversionIgnores = caseConversionIgnores.concat(["rows"]);
      const data = convertCamelToSnakeCase(record, { ignore: caseConversionIgnores });
      if (this.traceEnabled) {
        void requisitions.execute("debugger", { request: data });
      }
      const ongoingRequest = {
        protocolType: details.requestType,
        result: [],
        resolve,
        reject,
        onData: details.onData
      };
      this.ongoingRequests.set(requestId, ongoingRequest);
      this.socket?.send(JSON.stringify(data));
    });
  }
  /**
   * Called when the socket is opened.
   *
   * @param resolve The resolver function to signal when the socket connection is available.
   */
  onOpen = (resolve) => {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
    this.reconnectTimeout = 1e3;
    void requisitions.execute("socketStateChanged", true).then(() => {
      resolve();
    });
  };
  /**
   * Called when the socket is closed or failed to open. Unfortunately, the given close code is always the same
   * (1006) and the close reason is always empty.
   *
   * @param options The options used to open the websocket. Needed for automatic reconnect.
   */
  onClose = (options) => {
    webSession.clearSessionData();
    void requisitions.execute("socketStateChanged", false);
    if (!this.disconnecting && !this.debugging) {
      if (this.reconnectTimer) {
        clearTimeout(this.reconnectTimer);
      }
      this.reconnectTimer = setTimeout(() => {
        void this.connect(options);
      }, this.reconnectTimeout);
    }
  };
  /**
   * Called when an error occurred in the socket connection.
   *
   * @param options The options used to open the websocket. Needed for automatic reconnect.
   * @param reject The reject function to call to signal that the connection had a failure to open.
   * @param event Event that gives more info about the error.
   */
  onError = (options, reject, event) => {
    reject(JSON.stringify(event, void 0, 4));
    this.reconnectTimeout *= 2;
    if (this.reconnectTimer) {
      this.reconnectTimer = setTimeout(() => {
        void this.connect(options);
      }, this.reconnectTimeout);
    }
    void requisitions.execute("showError", [
      "Communication Error",
      `Could not establish a connection to the backend. Make sure you use valid user credentials and the MySQL Shell is running. Trying to reconnect in ${this.reconnectTimeout / 1e3} seconds.`
    ]);
  };
  /**
   * Processes the raw backend data record and converts it to a response usable in the application.
   * This involves convert snake casing to camel case and determining the type of the response.
   *
   * @param data The data received by the web socket.
   *
   * @returns The generated response object. Can be undefined if the incoming data does not conform to the expected
   *          format.
   */
  convertDataToResponse = (data) => {
    if (!data || !(typeof data === "string")) {
      return void 0;
    }
    const responseObject = JSON.parse(data);
    if (this.traceEnabled) {
      void requisitions.execute("debugger", { response: responseObject });
    }
    const response = convertSnakeToCamelCase(responseObject, { ignore: ["rows"] });
    switch (response.requestState.type) {
      case "ERROR": {
        response.eventType = -2 /* ErrorResponse */;
        break;
      }
      case "PENDING": {
        if (response.requestState.msg === "Execution started...") {
          response.eventType = 1 /* StartResponse */;
        } else {
          response.eventType = 2 /* DataResponse */;
        }
        break;
      }
      case "OK": {
        if (response.done) {
          response.eventType = 4 /* DoneResponse */;
        } else {
          response.eventType = 3 /* FinalResponse */;
        }
        break;
      }
      default: {
        response.eventType = 0 /* Unknown */;
        break;
      }
    }
    return response;
  };
  isErrorInfo(response) {
    return response.result && response.result.info !== void 0;
  }
  isWebSessionData(response) {
    return response.sessionUuid !== void 0;
  }
};

// ../frontend/src/utilities/file-utilities.ts
var import_path = __toESM(require("path"), 1);
var import_fs = __toESM(require("fs"), 1);
var findExecutable = (program) => {
  if (import_path.default.isAbsolute(program) || program.includes("/") || program.includes("\\")) {
    return program;
  }
  const envPath = process.env.PATH ?? "";
  const envExt = process.env.PATHEXT ?? "";
  const pathDirs = envPath.replace(/["]+/g, "").split(import_path.default.delimiter).filter(Boolean);
  const extensions2 = envExt.split(";");
  const candidates = pathDirs.flatMap((d3) => {
    return extensions2.map((ext) => {
      return import_path.default.join(d3, program + ext);
    });
  });
  for (const filePath of candidates) {
    if (import_fs.default.existsSync(filePath)) {
      return filePath;
    }
  }
  return "";
};

// ../frontend/src/utilities/MySQLShellLauncher.ts
var MySQLShellLauncher = class _MySQLShellLauncher {
  constructor(onOutput, onError, onExit) {
    this.onOutput = onOutput;
    this.onError = onError;
    this.onExit = onExit;
  }
  /**
   * When the extension is deployed with an embedded MySQL Shell, a custom shell user config dir is used, as
   * defined in the extensionShellUserConfigFolderBaseName constant. If this constant should be changed at some point
   * in the future, it is important to note that the corresponding constant
   * EXTENSION_SHELL_USER_CONFIG_FOLDER_BASENAME in the ShellModuleSession.py file of the gui_plugin needs to be
   * adjusted as well.
   */
  static extensionShellUserConfigFolderBaseName = "mysqlsh-gui";
  shellProcess;
  launchDetails = { port: 0, singleUserToken: "" };
  /**
   * Returns the MySQL Shell configuration directory that should be used for this shell session. That can either be
   * a special extension path or the standard path in the user's home dir.
   *
   * @param inDevelopment True if we are running in development mode.
   *
   * @returns The MySQL Shell user config dir as string.
   */
  static getShellUserConfigDir = (inDevelopment) => {
    let shellUserConfigDir;
    shellUserConfigDir = process.env.MYSQLSH_GUI_CUSTOM_CONFIG_DIR ?? "";
    if (shellUserConfigDir.length === 0) {
      shellUserConfigDir = appParameters.get("shellUserConfigDir") ?? "";
    }
    if (shellUserConfigDir.length === 0 || !import_fs2.default.existsSync(shellUserConfigDir)) {
      if (inDevelopment) {
        if (import_os.default.platform() === "win32") {
          shellUserConfigDir = import_path2.default.join(import_os.default.homedir(), "AppData", "Roaming", "MySQL", "mysqlsh");
        } else {
          shellUserConfigDir = import_path2.default.join(import_os.default.homedir(), ".mysqlsh");
        }
      } else {
        if (import_os.default.platform() === "win32") {
          shellUserConfigDir = import_path2.default.join(
            import_os.default.homedir(),
            "AppData",
            "Roaming",
            "MySQL",
            _MySQLShellLauncher.extensionShellUserConfigFolderBaseName
          );
        } else {
          shellUserConfigDir = import_path2.default.join(
            import_os.default.homedir(),
            `.${_MySQLShellLauncher.extensionShellUserConfigFolderBaseName}`
          );
        }
      }
    }
    return shellUserConfigDir;
  };
  /**
   * Starts an instance of the MySQL Shell using the given context. The caller has to take care to manage
   * the return process.
   *
   * @param config Contains the details to set up the shell process.
   *
   * @returns the created process.
   */
  static runMysqlShell = (config) => {
    const shellPath = _MySQLShellLauncher.getShellPath(config.rootPath);
    const shellUserConfigDir = _MySQLShellLauncher.getShellUserConfigDir(config.inDevelopment);
    const embedded = shellPath.startsWith(config.rootPath) ? "embedded " : "";
    config.onStdOutData(`Starting ${embedded}MySQL Shell, using config dir '${shellUserConfigDir}' ...`);
    if (!import_fs2.default.existsSync(shellUserConfigDir)) {
      import_fs2.default.mkdirSync(shellUserConfigDir, { recursive: true });
    }
    const shellProcess = import_child_process.default.spawn(shellPath, config.parameters, {
      /* eslint-disable @typescript-eslint/naming-convention */
      env: {
        ...process.env,
        LOG_LEVEL: config.logLevel,
        MYSQLSH_USER_CONFIG_HOME: shellUserConfigDir,
        MYSQLSH_TERM_COLOR_MODE: "nocolor"
      }
      /* eslint-enable @typescript-eslint/naming-convention */
    });
    if (shellProcess.stdin && config.processInput) {
      shellProcess.stdin.setDefaultEncoding("utf-8");
      shellProcess.stdin.write(`${config.processInput}
`);
      shellProcess.stdin.end();
    }
    const stdDataOut = (data) => {
      config.onStdOutData(data.toString());
    };
    shellProcess.stdout?.on("data", stdDataOut);
    const onError = (error) => {
      config.onError?.(new Error(`Error while starting MySQL Shell: ${error.message}`));
    };
    shellProcess.on("error", onError);
    if (config.onStdErrData) {
      const stdErrorDataOut = (data) => {
        config.onStdErrData?.(data.toString());
      };
      shellProcess.stderr.on("data", stdErrorDataOut);
    } else {
      shellProcess.stderr?.on("data", stdDataOut);
    }
    if (config.onExit) {
      shellProcess.on("exit", config.onExit);
    }
    return shellProcess;
  };
  /**
   * Determines an unused TCP/IP port that can be used for a shell process.
   *
   * @returns A promise which resolves to the found port.
   */
  static findFreePort = () => {
    return new Promise((resolve, reject) => {
      const server = net.createServer();
      let errorEncountered = false;
      server.on("error", (err) => {
        server.close();
        if (!errorEncountered) {
          errorEncountered = true;
          reject(err);
        }
      });
      server.listen(0, () => {
        const address = server.address();
        if (!address || typeof address === "string" || address.port === 0) {
          reject(new Error("Unable to get a port for the backend"));
        } else {
          server.close();
          if (!errorEncountered) {
            errorEncountered = true;
            resolve(address.port);
          }
        }
      });
    });
  };
  /**
   * Returns the path to the MySQL Shell binary that should be used.
   *
   * The function checks if a MySQL Shell exists under the given root path. If so, the path to that binary is
   * returned. Otherwise it returns just the name of the mysqlsh executable, assuming that the MySQL Shell is
   * installed and that it is in the PATH.
   *
   * @param rootPath The file system path where to look for a shell binary.
   *
   * @returns The path to the MySQL Shell as string.
   */
  static getShellPath = (rootPath) => {
    let shellPath = import_path2.default.join(rootPath, "shell", "bin", "mysqlsh");
    if (import_os.default.platform() === "win32") {
      shellPath += ".exe";
    }
    if (!import_fs2.default.existsSync(shellPath)) {
      if (import_os.default.platform() === "win32") {
        shellPath = findExecutable("mysqlsh");
      } else {
        shellPath = "mysqlsh";
      }
    }
    return shellPath;
  };
  /**
   * Checks the given port to see if that is currently in use by opening a socket to it.
   *
   * @param port The port to test.
   *
   * @returns True if the given port is already in use, otherwise false.
   */
  static checkPort = (port) => {
    return new Promise((resolve, reject) => {
      const socket = new net.Socket();
      socket.on("timeout", () => {
        socket.destroy();
        resolve(false);
      });
      socket.on("connect", () => {
        socket.destroy();
        resolve(true);
      });
      socket.on("error", (error) => {
        if (error.code !== "ECONNREFUSED") {
          reject(error);
        } else {
          resolve(false);
        }
      });
      socket.connect(port, "0.0.0.0");
    });
  };
  /**
   * Ends the shell process without disposing of the launcher class. A new process can be started at any time.
   *
   * @returns a promise that resolves when the process signalled its end.
   */
  exitProcess() {
    return new Promise((resolve) => {
      const done = () => {
        this.shellProcess = void 0;
        this.launchDetails = { port: 0, singleUserToken: "" };
        resolve();
      };
      if (this.shellProcess?.pid) {
        this.shellProcess.on("close", done);
        this.shellProcess.kill();
      } else {
        done();
      }
    });
  }
  /**
   * Starts the MySQL Shell gui_plugin webserver in single user mode and connects to the websocket.
   *
   * @param rootPath The path of the extension
   * @param inDevelopment True if we are running in development mode.
   * @param secure If true a secure connection is established (which requires proper SSL certificates).
   * @param logLevel The log level to use initially.
   * @param target If a target URL is specified, the extension connects to that remote shell instead.
   * @param forwardPort A callback function that forwards the connection through the ssh tunnel
   */
  startShellAndConnect = (rootPath, inDevelopment, secure, logLevel = "INFO", target, forwardPort) => {
    if (target) {
      const url = new URL(target);
      try {
        MessageScheduler.get.connect({ url: new URL(target) }).then(() => {
          this.launchDetails.port = Number(url.port ?? 8e3);
          this.launchDetails.singleUserToken = url.searchParams.get("token") ?? "";
          void requisitions.execute("connectedToUrl", url);
        }).catch((reason) => {
          this.onOutput(`Could not establish websocket connection: ${String(reason)}`);
          void requisitions.execute("connectedToUrl", void 0);
        });
      } catch (e) {
        this.onOutput("Error while parsing the external URL string: " + String(e));
        void requisitions.execute("connectedToUrl", void 0);
      }
    } else {
      const launchShellUsingPort = (port) => {
        this.launchDetails.singleUserToken = uuid();
        this.launchDetails.port = port;
        const secureString = secure ? "secure={}, " : "";
        const parameters = [
          "--no-defaults",
          "--py",
          "-e",
          `gui.start.web_server(port=${this.launchDetails.port}, ${secureString}read_token_on_stdin=True)`
        ];
        const onOutput = (output) => {
          if (output.includes("Mode: Single user")) {
            const protocol = secure ? "https" : "http";
            let host2 = "localhost";
            if (appParameters.testsRunning && !appParameters.inExtension) {
              host2 = "127.0.0.1";
            }
            const url = new URL(`${protocol}://${host2}:${port}/?token=${this.launchDetails.singleUserToken}`);
            const options = {
              url,
              shellConfigDir: _MySQLShellLauncher.getShellUserConfigDir(inDevelopment)
            };
            if (forwardPort) {
              this.onOutput("Establishing the port forwarding session to remote ssh server...");
              forwardPort(url).then((redirectUrl) => {
                MessageScheduler.get.connect(options).then(() => {
                  void requisitions.execute("connectedToUrl", redirectUrl);
                }).catch(
                  /* istanbul ignore next */
                  (reason) => {
                    this.onError(
                      new Error(`Could not establish websocket connection: ${String(reason)}`)
                    );
                    void requisitions.execute("connectedToUrl", void 0);
                  }
                );
              }).catch((reason) => {
                this.onError(
                  new Error(`Could not establish the port forwarding: ${String(reason)}`)
                );
              });
            } else {
              MessageScheduler.get.connect(options).then(() => {
                void requisitions.execute("connectedToUrl", url);
              }).catch(
                /* istanbul ignore next */
                (reason) => {
                  this.onError(
                    new Error(`Could not establish websocket connection: ${String(reason)}`)
                  );
                  void requisitions.execute("connectedToUrl", void 0);
                  setTimeout(() => {
                    void this.exitProcess();
                  }, 0);
                }
              );
            }
          }
          this.onOutput(output);
        };
        this.shellProcess = _MySQLShellLauncher.runMysqlShell({
          rootPath,
          inDevelopment,
          logLevel,
          parameters,
          onStdOutData: onOutput,
          onError: this.onError,
          onExit: this.onExit,
          processInput: this.launchDetails.singleUserToken
        });
      };
      if (appParameters.testsRunning) {
        launchShellUsingPort(Math.floor(Math.random() * 2e4) + 2e4);
      } else {
        let port = 33336;
        if (process.env.MYSQLSH_GUI_CUSTOM_PORT !== void 0) {
          const customPort = parseInt(process.env.MYSQLSH_GUI_CUSTOM_PORT, 10);
          if (!isNaN(customPort)) {
            port = customPort;
          } else {
            console.log(`MYSQLSH_GUI_CUSTOM_PORT is not a number, using 33336.`);
          }
        }
        void _MySQLShellLauncher.checkPort(port).then((inUse) => {
          if (!inUse) {
            launchShellUsingPort(port);
          } else {
            this.onOutput("Finding free port...");
            _MySQLShellLauncher.findFreePort().then((port2) => {
              launchShellUsingPort(port2);
            }).catch(
              /* istanbul ignore next */
              (error) => {
                if (error instanceof Error) {
                  this.onError(error);
                } else {
                  this.onError(new Error(String(error)));
                }
              }
            );
          }
        });
      }
    }
  };
};

// src/ExtensionHost.ts
var import_vscode34 = require("vscode");

// ../frontend/src/supplement/ShellInterface/ShellInterfaceMds.ts
var ShellInterfaceMds = class {
  async getMdsConfigProfiles(configFilePath) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mds.list.config_profiles" /* MdsListConfigProfiles */,
      parameters: { kwargs: { configFilePath } }
    });
    return response.result;
  }
  async setDefaultConfigProfile(profile) {
    await MessageScheduler.get.sendRequest({
      requestType: "mds.set.default_config_profile" /* MdsSetDefaultConfigProfile */,
      parameters: { args: { profileName: profile } }
    });
  }
  async getMdsCompartments(configProfile, compartmentId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mds.list.compartments" /* MdsListCompartments */,
      parameters: { kwargs: { configProfile, compartmentId } }
    });
    return response.result;
  }
  async getMdsMySQLDbSystems(configProfile, compartmentId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mds.list.db_systems" /* MdsListDbSystems */,
      parameters: { kwargs: { configProfile, compartmentId } }
    });
    return response.result;
  }
  async getMdsMySQLDbSystem(configProfile, dbSystemId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mds.get.db_system" /* MdsGetDbSystem */,
      parameters: { kwargs: { configProfile, dbSystemId } }
    });
    return response.result;
  }
  async getMdsComputeInstances(configProfile, compartmentId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mds.list.compute_instances" /* MdsListComputeInstances */,
      parameters: { kwargs: { configProfile, compartmentId } }
    });
    return response.result;
  }
  async getMdsBastions(configProfile, compartmentId, validForDbSystemId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mds.list.bastions" /* MdsListBastions */,
      parameters: { kwargs: { configProfile, compartmentId, validForDbSystemId } }
    });
    return response.result;
  }
  async getMdsBastion(configProfile, bastionId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mds.get.bastion" /* MdsGetBastion */,
      parameters: { kwargs: { configProfile, bastionId } }
    });
    return response.result;
  }
  async createBastion(configProfile, dbSystemId, awaitActiveState) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mds.create.bastion" /* MdsCreateBastion */,
      parameters: { kwargs: { configProfile, dbSystemId, awaitActiveState } }
    });
    return response.result;
  }
  async createBastionSession(configProfile, targetId, sessionType, compartmentId, awaitCreation, callback) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mds.create.bastion_session" /* MdsCreateBastionSession */,
      parameters: { kwargs: { configProfile, targetId, sessionType, compartmentId, awaitCreation } },
      onData: callback
    });
    return response.result;
  }
  async listLoadBalancers(configProfile, compartmentId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mds.list.load_balancers" /* MdsListLoadBalancers */,
      parameters: { kwargs: { configProfile, compartmentId } }
    });
    return response.result;
  }
  async setCurrentCompartment(parameters) {
    await MessageScheduler.get.sendRequest({
      requestType: "mds.set.current_compartment" /* MdsSetCurrentCompartment */,
      parameters: { kwargs: parameters }
    });
  }
  async setCurrentBastion(parameters) {
    await MessageScheduler.get.sendRequest({
      requestType: "mds.set.current_bastion" /* MdsSetCurrentBastion */,
      parameters: { kwargs: parameters }
    });
  }
  async listDbSystemShapes(isSupportedFor, configProfile, compartmentId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mds.list.db_system_shapes" /* MdsListDbSystemShapes */,
      parameters: { kwargs: { configProfile, isSupportedFor, compartmentId } }
    });
    return response.result;
  }
  async listComputeShapes(configProfile, compartmentId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mds.list.compute_shapes" /* MdsListComputeShapes */,
      parameters: { kwargs: { configProfile, compartmentId } }
    });
    return response.result;
  }
};

// ../frontend/src/supplement/ShellInterface/ShellInterfaceShellSession.ts
var ShellInterfaceShellSession = class {
  mds = new ShellInterfaceMds();
  moduleSessionLookupId = "";
  /**
   * Creates a new instance of the shell interface.
   *
   * @param sessionId If given this specifies an existing shell session, so we don't get a startShellSession
   *                  call later.
   */
  constructor(sessionId) {
    if (sessionId) {
      this.moduleSessionLookupId = "shellSession.temporary";
      webSession.setModuleSessionId(this.moduleSessionLookupId, sessionId);
    }
  }
  /**
   * @returns A flag indicating whether a session was already opened or not.
   */
  get hasSession() {
    return this.moduleSessionId !== void 0;
  }
  /**
   * Starts a new shell session
   *
   * @param id The id of the shell session tab.
   * @param dbConnectionId The id of the connection the shell tab should open.
   * @param shellArgs Additional arguments for the backend.
   * @param requestId An explicit request ID (instead of using the implicitly created one), to allow the caller
   *                  to associate the execution request and the various results.
   * @param callback The callback for intermediate results.
   *
   * @returns A promise resolving to an optional set of results which might require additional handling,
   *          like a shell prompt.
   */
  async startShellSession(id, dbConnectionId, shellArgs, requestId, callback) {
    this.moduleSessionLookupId = `shellSession.${id}`;
    if (this.hasSession) {
      return void 0;
    }
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.shell.start_session" /* GuiShellStartSession */,
      requestId,
      parameters: {
        args: {
          dbConnectionId,
          shellArgs
        }
      },
      onData: callback
    });
    if (response.result?.moduleSessionId) {
      webSession.setModuleSessionId(this.moduleSessionLookupId, response.result.moduleSessionId);
    }
    return response.result;
  }
  /**
   * Closes the current session.
   *
   * @returns A promise which resolves when the request is finished.
   */
  async closeShellSession() {
    const moduleSessionId = this.moduleSessionId;
    if (moduleSessionId) {
      await MessageScheduler.get.sendRequest({
        requestType: "gui.shell.close_session" /* GuiShellCloseSession */,
        parameters: {
          args: {
            moduleSessionId
          }
        }
      });
      webSession.setModuleSessionId(this.moduleSessionLookupId);
    }
  }
  /**
   * Sends the shell command to the backend for execution.
   *
   * @param command The shell command to execute.
   * @param requestId An explicit request ID (instead of using the implicitly created one), to allow the caller
   *                  to associate the execution request and the various results.
   * @param callback The callback for intermediate results.
   *
   * @returns A listener for the response.
   */
  async execute(command, requestId, callback) {
    const moduleSessionId = this.moduleSessionId;
    if (moduleSessionId) {
      const response = await MessageScheduler.get.sendRequest({
        requestType: "gui.shell.execute" /* GuiShellExecute */,
        requestId,
        parameters: {
          args: {
            command,
            moduleSessionId
          }
        },
        onData: callback
      });
      return response.result;
    }
  }
  /**
   * Sends a reply from the user back to the backend (e.g. passwords, choices etc.).
   *
   * @param requestId The same request ID that was used to request input from the user.
   * @param type Indicates if the user accepted the request or cancelled it.
   * @param reply The reply from the user.
   * @param moduleSessionId Use this to override the module session ID.
   *
   * @returns A listener for the response.
   */
  async sendReply(requestId, type, reply, moduleSessionId) {
    moduleSessionId = moduleSessionId ?? this.moduleSessionId;
    if (moduleSessionId) {
      await MessageScheduler.get.sendRequest({
        requestType: "prompt_reply" /* PromptReply */,
        parameters: { moduleSessionId, requestId, type, reply }
      }, false);
    }
  }
  /**
   * Retrieves possible completion items for the given position in the text.
   *
   * @param text The editor content.
   * @param offset The offset within that content.
   *
   * @returns A listener for the response.
   */
  async getCompletionItems(text, offset) {
    const moduleSessionId = this.moduleSessionId;
    if (moduleSessionId) {
      const response = await MessageScheduler.get.sendRequest({
        requestType: "gui.shell.complete" /* GuiShellComplete */,
        parameters: {
          args: {
            data: text,
            offset,
            moduleSessionId
          }
        }
      });
      const result = [];
      response.forEach((list) => {
        if (list.result) {
          result.push(list.result);
        }
      });
      return result;
    }
    return [];
  }
  get moduleSessionId() {
    return webSession.moduleSessionId(this.moduleSessionLookupId);
  }
};

// ../frontend/src/shell-tasks/ShellTask.ts
var ShellTask = class _ShellTask {
  constructor(caption, promptCallback, messageCallback) {
    this.caption = caption;
    this.promptCallback = promptCallback;
    this.messageCallback = messageCallback;
    this.currentStatus = "pending";
  }
  currentStatus;
  statusCallback;
  currentProgress;
  get status() {
    return this.currentStatus;
  }
  get percentageDone() {
    return this.currentProgress;
  }
  static getCurrentTimeStamp() {
    return (/* @__PURE__ */ new Date()).toISOString().replace("T", " ").slice(0, -1);
  }
  setStatusCallback(callback) {
    this.statusCallback = callback;
  }
  async runTask(shellArgs, dbConnectionId, responses) {
    this.setStatus("running");
    this.sendMessage(`[${_ShellTask.getCurrentTimeStamp()}] [INFO] Starting Task: ${this.caption}

`);
    const requestId = uuid();
    let shellSession;
    let responseIndex = 0;
    const handleData = (data, final) => {
      if (data.moduleSessionId) {
        shellSession = new ShellInterfaceShellSession(data.moduleSessionId);
      }
      if (this.isShellFeedbackRequest(data) && shellSession) {
        if (responses && responseIndex < responses.length) {
          void shellSession.sendReply(requestId, "OK" /* Ok */, responses[responseIndex++]);
        } else {
          void this.promptCallback(data.prompt, data.type === "password").then((value) => {
            if (shellSession) {
              if (value) {
                void shellSession.sendReply(requestId, "OK" /* Ok */, value);
              } else {
                void shellSession.sendReply(requestId, "CANCEL" /* Cancel */, "");
              }
            }
          });
        }
      } else if (this.isShellSimpleResult(data)) {
        if (data.info && this.statusCallback !== void 0) {
          const group = Array.from(data.info.matchAll(/(\d+)%\scompleted/gm), (m3) => {
            return m3[1];
          });
          if (group.length > 0) {
            const percentage = parseInt(group[0], 10);
            if (!isNaN(percentage) && this.currentProgress !== percentage) {
              this.currentProgress = percentage;
              this.statusCallback(this.currentStatus);
            }
          }
        }
        this.sendMessage(data.info ?? data.status);
      }
      if (final) {
        this.setStatus("done");
        this.sendMessage(`
[${_ShellTask.getCurrentTimeStamp()}] [INFO] Task '${this.caption}' completed successfully.

`);
        if (shellSession) {
          void shellSession.closeShellSession();
        }
      }
    };
    try {
      const response = await MessageScheduler.get.sendRequest({
        requestType: "gui.shell.start_session" /* GuiShellStartSession */,
        requestId,
        parameters: {
          args: {
            dbConnectionId,
            shellArgs
          }
        },
        onData: (data) => {
          if (data.result) {
            handleData(data.result, false);
          }
        }
      });
      if (response.result) {
        handleData(response.result, true);
      }
    } catch (reason) {
      this.currentStatus = "error";
      this.sendMessage(`[${_ShellTask.getCurrentTimeStamp()}] [ERROR]: ${String(reason)}

`);
      if (shellSession) {
        void shellSession.closeShellSession();
      }
    }
  }
  setStatus(status) {
    this.currentStatus = status;
    this.statusCallback?.(status);
  }
  sendMessage(message) {
    if (message) {
      this.messageCallback(message);
    }
  }
  isShellFeedbackRequest(response) {
    return response.type !== void 0;
  }
  isShellSimpleResult(response) {
    const candidate = response;
    return candidate.info !== void 0 || candidate.error !== void 0 || candidate.note !== void 0 || candidate.promptDescriptor !== void 0 || candidate.status !== void 0 || candidate.warning !== void 0;
  }
};

// ../frontend/src/supplement/Settings/SettingsRegistry.ts
var settingCategories = {
  key: "<root>",
  id: "",
  title: "<root>",
  description: "<root>",
  values: [],
  children: []
};
var categoryFromPath = (path25) => {
  const parts = path25.split(".");
  const key = parts.pop();
  if (!key) {
    throw new Error(`The setting category path "${path25}" is invalid.`);
  }
  let category = settingCategories;
  do {
    const part = parts.shift();
    if (!part) {
      break;
    }
    if (!category.children) {
      throw new Error(`The setting category path "${path25}" is invalid.`);
    }
    const entry = category.children.find((child) => {
      return child.key === part;
    });
    if (!entry) {
      throw new Error(`The setting category path "${path25}" is invalid.`);
    }
    category = entry;
  } while (true);
  return [key, category];
};
var registerSettingCategory = (path25, title, description) => {
  const [key, category] = categoryFromPath(path25);
  if (category.children && category.children.find((child) => {
    return child.key === key;
  })) {
    throw new Error(`Attempt to register an existing setting category (${path25}).`);
  }
  if (!category.children) {
    category.children = [];
  }
  category.children.push({
    title,
    key,
    id: path25,
    description,
    values: []
  });
};
var registerSetting = (path25, title, description, valueType, defaultValue, advanced, parameters = {}) => {
  const [key, category] = categoryFromPath(path25);
  if (category.values.find((child) => {
    return child.key === key;
  })) {
    throw new Error(`Attempt to register an existing setting value (${path25}).`);
  }
  category.values.push({
    key,
    title,
    id: path25,
    description,
    valueType,
    defaultValue,
    advanced,
    parameters
  });
};
var registerSettings = () => {
  registerSettingCategory("workers", "Background Workers", "Settings related to background workers");
  registerSetting(
    "workers.minWorkerCount",
    "Minimum Background Worker Count",
    "The number of workers that are always available.",
    "number",
    3,
    true
  );
  registerSetting(
    "workers.maxWorkerCount",
    "Maximum Background Worker Count",
    "The maximum number of workers that are active at the same time.",
    "number",
    3,
    true
  );
  registerSetting(
    "workers.maxPendingTaskCount",
    "Maximum Number of Waiting Tasks",
    "Describes the highest number of waiting tasks for a free background worker. If this number is exceeded an error is thrown, indicating that the worker pool is overloaded and can no longer cope with incoming work.",
    "number",
    100,
    true
  );
  registerSetting(
    "workers.removeIdleTime",
    "Delay to Remove Inactive Workers",
    "Specifies the number of seconds that pass until the oldest inactive worker is removed. Has no effect if the current number of active workers fall below the minimal worker count.",
    "number",
    5,
    true
  );
  registerSettingCategory(
    "theming",
    "Theme Settings",
    "Values used to theme the application. There is a dedicated editor to change these values."
  );
  registerSetting(
    "theming.currentTheme",
    "Current Theme",
    "Select the active theme for the current profile.",
    "choice",
    "auto",
    false
  );
  registerSetting(
    "theming.themes",
    "Registered Themes",
    "Themes can be edited in the Theme Editor.",
    "action",
    "Click to Open the Theme Editor",
    false,
    { action: "showThemeEditor" }
  );
  registerSetting(
    "theming.colorPadColors",
    "Color Pad Colors",
    "",
    "list",
    [],
    false
  );
  registerSettingCategory("editor", "Code Editor", "Settings related to all code editors.");
  registerSettingCategory("editor.theming", "Theming", "Settings related to theming.");
  registerSetting(
    "editor.theming.decorationSet",
    "Decoration Set for Code Editor Gutters",
    "Select one of the sets for code-block decoration that results in mixed language code editors.",
    "choice",
    "standard",
    false,
    {
      choices: [
        ["Standard Set", "standard", "Includes only a solid marker for editor rows"],
        [
          "Alternative Set",
          "alternative",
          "Uses a hatch pattern with different colors to separate editor content and result areas"
        ]
      ]
    }
  );
  registerSetting(
    "editor.wordWrap",
    "Word Wrapping",
    "Determines how long lines should be wrapped automatically by the editor.",
    "choice",
    "off",
    false,
    {
      choices: [
        ["Off", "off", "Lines never wrap"],
        ["On", "on", "Lines wrap at the viewport width"],
        ["Word Wrap Column", "wordWrapColumn", 'Lines wrap at "Code Editor: Word Wrap Column"'],
        [
          "Bounded",
          "bounded",
          'Lines wrap at the minimum of viewport width or "Code Editor: Word Wrap Column"'
        ]
      ]
    }
  );
  registerSetting(
    "editor.wordWrapColumn",
    "Word Wrap Column",
    "Controls the column of the editor to wrap long lines when Code Editor: Word Wrap is `wordWrapColumn` or `bounded`.",
    "number",
    120,
    false
  );
  registerSetting(
    "editor.showHidden",
    "Invisible Characters",
    "When set to true, normally invisible characters (like space or tabulator) are displayed too.",
    "boolean",
    false,
    false
  );
  registerSetting(
    "editor.dbVersion",
    "MySQL DB Version",
    "The default version to be used for MySQL language support, if no version is available.",
    "string",
    "8.0.25",
    false
  );
  registerSetting(
    "editor.sqlMode",
    "MySQL SQL Mode",
    "The default SQL mode to be used for MySQL language support, if mode information is not available.",
    "string",
    "",
    false
  );
  registerSetting(
    "editor.stopOnErrors",
    "Stop on Errors",
    "If this option is set, execution of scripts will be stopped if an error occurs. Otherwise, the script execution continues with the next statement.",
    "boolean",
    false,
    false
  );
  registerSetting(
    "editor.showMinimap",
    "Show the Minimap",
    "Determines if code editors should show a minimap, instead of the plain scrollbar, for better navigation.",
    "boolean",
    true,
    false
  );
  registerSettingCategory("dbEditor", "DB Editor", "Settings related to a DB editor");
  registerSetting(
    "dbEditor.startLanguage",
    "Start Language",
    "Select the initial language for new DB editors.",
    "choice",
    "sql",
    false,
    {
      choices: [
        ["JavaScript", "javascript", "Supported in all code editors"],
        ["TypeScript", "typescript", "Supported only in DB editors"],
        ["Python", "python", "Supported only in shell session editors"],
        ["SQL", "sql", "Supported in all code editors"]
      ]
    }
  );
  registerSetting(
    "dbEditor.defaultEditor",
    "Default Editor",
    "Select the type of the first editor when opening a DB connection.",
    "choice",
    "notebook",
    false,
    {
      choices: [
        ["DB Notebook", "notebook", "A multi-language editor with embedded results"],
        ["MySQL Script", "script", "A single-language script editor (MySQL)"]
      ]
    }
  );
  registerSetting(
    "dbEditor.useMinimap",
    "Use the minimap if globally enabled",
    "Determines if notebooks in the DB editor show a minimap. Only has an effect when mini maps are globally enabled",
    "boolean",
    false,
    false
  );
  registerSetting(
    "dbEditor.upperCaseKeywords",
    "Use UPPER case keywords in code completion",
    "When set, keywords shown in code-completion popups appear in all uppercase letters and are inserted as such in the SQL code editors.",
    "boolean",
    true,
    false
  );
  registerSettingCategory("dbEditor.connectionBrowser", "Connection Browser", "Settings related to the connection overview page in the DB Editor Module");
  registerSetting(
    "dbEditor.connectionBrowser.showGreeting",
    "Show Greeting",
    "If set, a message section is shown with some useful links.",
    "boolean",
    true,
    false
  );
  registerSettingCategory("sql", "SQL Execution", "Settings related to how SQL queries are handled");
  registerSetting(
    "sql.limitRowCount",
    "Result Set Page Size",
    "Determines the size of one page in a result set, but has no effect if a top-level LIMIT clause is specified in the query. Set to 0 to disable auto adding a LIMIT clause and return all records as a single page. However, be cautious with large row counts (> 50000).",
    "number",
    1e3,
    false,
    { range: [0, 1e4] }
  );
  registerSetting(
    "sql.rowPacketSize",
    "Row Packet Size",
    "Determines the number of result records that are sent in a single response from the backend.",
    "number",
    1e3,
    true
  );
  registerSettingCategory("shellSession", "Shell Session", "Settings related to a shell session");
  registerSettingCategory(
    "shellSession.sessionBrowser",
    "Shell Session Browser",
    "Settings related to the shell session overview page in the Shell Session Module"
  );
  registerSetting(
    "shellSession.sessionBrowser.showGreeting",
    "Show Greeting",
    "If set, a message section is shown with some useful links.",
    "boolean",
    true,
    false
  );
  registerSetting(
    "shellSession.startLanguage",
    "Start Language",
    "Select the initial language for a new shell session.",
    "choice",
    "javascript",
    false,
    {
      choices: [
        ["JavaScript", "javascript", "Supported in all code editors"],
        ["Python", "python", "Supported only in shell session editors"],
        ["SQL", "sql", "Supported in all code editors"]
      ]
    }
  );
};

// ../frontend/src/supplement/Settings/Settings.ts
var Settings = class _Settings {
  static dirty = false;
  static values = {
    theming: {
      themes: [],
      currentTheme: "Auto"
    }
  };
  static saveTimer;
  constructor() {
  }
  /**
   * Stores the settings in the user's profile.
   *
   * @param force If true then save even if the current set has not changed since last load/save.
   */
  static saveSettings(force = false) {
    if (!this.dirty && !force) {
      return;
    }
    this.dirty = false;
    const profile = webSession.profile;
    profile.options = this.values;
    webSession.saveProfile();
    this.restartAutoSaveTimeout();
  }
  static get(key, defaultValue) {
    const { target, subKey } = this.objectForKey(key, false);
    if (!target || !subKey) {
      return defaultValue;
    }
    return target[subKey] ?? defaultValue;
  }
  static set(key, value) {
    this.dirty = true;
    const { target, subKey } = this.objectForKey(key, true);
    if (target && subKey) {
      target[subKey] = value;
    }
    void requisitions.execute("settingsChanged", { key, value });
    void requisitions.executeRemote("settingsChanged", { key, value });
  }
  /**
   * Splits the given key at dots and uses the parts (sans the last one) to navigate the settings to a specific
   * target object, which is then returned.
   *
   * @param key The access key.
   * @param canCreate Indicates if missing sub objects can be created if not found.
   *
   * @returns An object with the object at the given path (not counting the last part, which is returned as subKey).
   */
  static objectForKey(key, canCreate) {
    let run = this.values;
    const parts = key.split(".");
    this.validatePath(key);
    while (parts.length > 1) {
      if (run[parts[0]]) {
        run = run[parts[0]];
      } else if (canCreate) {
        run[parts[0]] = {};
        run = run[parts[0]];
      } else {
        return { target: void 0 };
      }
      parts.splice(0, 1);
    }
    return { target: run, subKey: parts[0] };
  }
  /**
   * Takes the list of path values and checks if there's an entry in the settings registry for each of them.
   * If one could not be found an error is thrown.
   *
   * @param path The path to check.
   */
  static validatePath(path25) {
    const [key, category] = categoryFromPath(path25);
    if (!category.values.find((value) => {
      return value.key === key;
    })) {
      throw new Error(`The settings path ${path25} addresses an unregistered setting.`);
    }
  }
  static mergeProfileValues = () => {
    this.values = Object.assign(this.values, webSession.profile.options);
    this.restartAutoSaveTimeout();
    return requisitions.execute("settingsChanged", void 0);
  };
  static applicationWillFinish = () => {
    if (this.saveTimer) {
      clearTimeout(this.saveTimer);
    }
    requisitions.unregister(void 0, this.mergeProfileValues);
    requisitions.unregister(void 0, this.applicationWillFinish);
    this.saveSettings();
    return Promise.resolve(true);
  };
  static restartAutoSaveTimeout() {
    if (this.saveTimer) {
      clearInterval(this.saveTimer);
      this.saveTimer = null;
    }
    this.saveTimer = setTimeout(() => {
      return this.saveSettings();
    }, 3e3);
  }
  static {
    registerSettings();
    setTimeout(() => {
      requisitions.register("profileLoaded", _Settings.mergeProfileValues);
      requisitions.register("applicationWillFinish", _Settings.applicationWillFinish);
    }, 0);
  }
};

// src/tree-providers/ShellTreeProvider/ShellTasksTreeProvider.ts
var import_vscode2 = require("vscode");

// src/tree-providers/ShellTreeProvider/ShellTaskTreeItem.ts
var path3 = __toESM(require("path"), 1);
var import_vscode = require("vscode");
var ShellTaskTreeItem = class _ShellTaskTreeItem extends import_vscode.TreeItem {
  constructor(task, command) {
    super(`${task.caption} (${task.status}${_ShellTaskTreeItem.percentage(task)})`, import_vscode.TreeItemCollapsibleState.None);
    this.task = task;
    let taskIcon;
    switch (task.status) {
      case "running": {
        taskIcon = "shellTaskRunning.svg";
        break;
      }
      case "done": {
        taskIcon = "shellTaskOk.svg";
        break;
      }
      case "error": {
        taskIcon = "shellTaskError.svg";
        break;
      }
      default: {
        taskIcon = "shellTask.svg";
      }
    }
    this.iconPath = {
      light: path3.join(__dirname, "..", "images", "light", taskIcon),
      dark: path3.join(__dirname, "..", "images", "dark", taskIcon)
    };
    this.command = command;
  }
  contextValue = "shellTask";
  static percentage(task) {
    return task.percentageDone && task.status === "running" ? ` ${String(task.percentageDone)}%` : "";
  }
};

// src/tree-providers/ShellTreeProvider/ShellTasksTreeProvider.ts
var ShellTasksTreeDataProvider = class {
  constructor(tasks) {
    this.tasks = tasks;
  }
  changeEvent = new import_vscode2.EventEmitter();
  get onDidChangeTreeData() {
    return this.changeEvent.event;
  }
  dispose() {
  }
  refresh(item) {
    this.changeEvent.fire(item);
  }
  getTreeItem(element) {
    return element;
  }
  getChildren(element) {
    if (!element) {
      return this.tasks.map((task) => {
        const item = new ShellTaskTreeItem(task, { title: "Show Task Output", command: "msg.showTaskOutput" });
        task.setStatusCallback(this.statusCallback.bind(item));
        return item;
      });
    }
    return Promise.resolve([]);
  }
  statusCallback = (status, item) => {
    if (status) {
      this.refresh(item);
    }
  };
};

// src/communication/NodeMessageScheduler.ts
var import_fs3 = require("fs");
var import_path3 = require("path");

// node_modules/ws/wrapper.mjs
var import_stream = __toESM(require_stream(), 1);
var import_receiver = __toESM(require_receiver(), 1);
var import_sender = __toESM(require_sender(), 1);
var import_websocket = __toESM(require_websocket(), 1);
var import_websocket_server = __toESM(require_websocket_server(), 1);
var wrapper_default = import_websocket.default;

// src/communication/NodeMessageScheduler.ts
var NodeMessageScheduler = class _NodeMessageScheduler extends MessageScheduler {
  static createInstance() {
    return new _NodeMessageScheduler();
  }
  createWebSocket(target, options) {
    let ca;
    if (options.shellConfigDir) {
      const caFile = (0, import_path3.join)(options.shellConfigDir, "plugin_data/gui_plugin/web_certs/rootCA.crt");
      if ((0, import_fs3.existsSync)(caFile)) {
        ca = (0, import_fs3.readFileSync)(caFile);
      }
    }
    return new wrapper_default(target, { ca });
  }
};

// src/DBEditorCommandHandler.ts
var import_fs4 = __toESM(require("fs"), 1);
var import_path5 = require("path");
var import_vscode15 = require("vscode");

// src/WebviewProviders/DBConnectionViewProvider.ts
var import_promises = require("fs/promises");
var import_vscode6 = require("vscode");

// ../frontend/src/modules/ModuleInfo.ts
var DBEditorModuleId = "gui.sqleditor";
var ShellModuleId = "gui.shell";

// src/utilities.ts
var import_vscode3 = require("vscode");
var switchVsCodeContext = (key, enable) => {
  return import_vscode3.commands.executeCommand("setContext", key, enable);
};
var showMessageWithTimeout = (message, timeout = 3e3) => {
  void import_vscode3.window.withProgress(
    {
      location: import_vscode3.ProgressLocation.Notification,
      title: message,
      cancellable: false
    },
    async (progress) => {
      await waitFor(timeout, () => {
        return false;
      });
      progress.report({ increment: 100 });
    }
  );
};
var showModalDialog = (message, okText = "OK", detail) => {
  return new Promise((resolve) => {
    switchVsCodeContext("showsModalDialog", true);
    const options = { detail, modal: true };
    void import_vscode3.window.showInformationMessage(message, options, okText).then((answer) => {
      switchVsCodeContext("showsModalDialog", false);
      resolve(answer === okText);
    });
  });
};

// src/WebviewProviders/WebviewProvider.ts
var path4 = __toESM(require("path"), 1);
var import_vscode5 = require("vscode");

// src/WebviewProviders/webview-helpers.ts
var import_vscode4 = require("vscode");
var prepareWebviewContent = (panel, url) => {
  url.searchParams.set("app", "vscode");
  const vsCodeFontSize = import_vscode4.workspace.getConfiguration(`editor`).get("fontSize", 14);
  url.searchParams.set("editorFontSize", vsCodeFontSize.toString());
  const testImgUrl = new URL(url.toString());
  testImgUrl.pathname = "/images/no-image.svg";
  const showUnsecuredConnectionWarning = import_vscode4.workspace.getConfiguration(`msg.shell`).get("showUnsecuredConnectionWarning", true);
  panel.webview.html = `
<!doctype html><html lang="en">
<head>
<meta http-equiv="Content-Security-Policy" content="default-src *; img-src http: https:;
    script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'unsafe-inline' http: https: data: *;">
<style>
    .warning {
        width: 210px;
        height: 50px;
        color: black;
        background: red;
        -webkit-border-radius: 5px;
        -moz-border-radius: 5px;
        position:absolute;
        bottom: 10px;
        right: 10px;
        opacity: 0.5;
        text-align: center;
    }
    .clickThrough {
        pointer-events: none;
    }
    .warning h1 {
        line-height: 20px;
        font-size: 12px;
        font-weight: 500;
        margin: 0px;
    }
    .warning p {
        line-height: 8px;
        font-size: 8px;
        font-weight: 300;
        margin: 0px;
    }
    .warning p a {
        color: white;
    }
    #waitForContent {
        display: none;
        justify-content: center;
        align-items: center;
        text-align: center;
        min-height: 100vh;
    }
    .pingEffect {
        display: inline-block;
        position: relative;
        width: 80px;
        height: 80px;
    }
    .pingEffect div {
        position: absolute;
        border: 4px solid var(--vscode-foreground);
        opacity: 1;
        border-radius: 50%;
        animation: pingEffect 1s cubic-bezier(0, 0.2, 0.8, 1) infinite;
    }
    .pingEffect div:nth-child(2) {
    animation-delay: -0.5s;
    }
    @keyframes pingEffect {
        0% {
            top: 36px;
            left: 36px;
            width: 0;
            height: 0;
            opacity: 1;
        }
        100% {
            top: 0px;
            left: 0px;
            width: 72px;
            height: 72px;
            opacity: 0;
        }
    }
  </style>
  <script>
    // Keep track of whether the waitForContentDiv should still be shown
    let showWaitForContentDiv = true;

    // Hides the waitForContentDiv in case the content was loaded or there was and error
    function hideWaitForContentDiv() {
        showWaitForContentDiv = false;
        document.getElementById("waitForContent").style.display = "none";
    }

    // Displays a floating div panel at the bottom right
    function showFloatingLabel(title, info, clickThrough) {
        var div = document.createElement("div");
        div.classList.add("warning");
        if (clickThrough) {
            div.classList.add("clickThrough");
        }
        var h1 = document.createElement("h1");
        h1.innerHTML = title;
        div.appendChild(h1);
        var p = document.createElement("p");
        p.innerHTML = info;
        div.appendChild(p);
        document.body.appendChild(div);
    }

    // Called when an error occurred while loading the content
    function showLoadingError() {
        hideWaitForContentDiv();

        if ("${url.protocol}" === "https:") {
            showFloatingLabel("Failed to Connect",
                "Please check if you have the<br>" +
                "MySQL Shell rootCA.crt certificate<br>" +
                "<a href='https://dev.mysql.com/doc/mysql-shell-for-vs-code/en/certificate-handling.html'>" +
                "installed</a> on your local system.", false);
        } else {
            showFloatingLabel("Failed to Connect",
                "Unable to connect to MySQL Shell.<br>" +
                "Please check if the MySQL Shell<br>" +
                "process is running.", false);
        }
    }

    // Only display the waitForContentDiv after 1 second to avoid flickering
    setTimeout(() => {
        // If the waitForContentDiv should still be show (content has not loaded yet, or there was an error)
        if (showWaitForContentDiv) {
            document.getElementById("waitForContent").style.display = "flex";
        }
    }, 1000);
  </script>
</head>
<body style="margin:0px;padding:0px;overflow:hidden;">
<!-- Everything is larger in our iframe. Not sure who is to blame for this, but we need to scale it down. -->
<iframe id="frame-msg" onload="hideWaitForContentDiv()"
    src="${url.toString()}"
    frameborder="0" style="overflow: hidden; overflow-x: hidden; overflow-y: hidden; height:100%;
    width: 100%; position: absolute; top: 0px; left: 0px; right: 0px; bottom: 0px; user-select: none;">
</iframe>
<div id="waitForContent"><div class="pingEffect"><div></div><div></div></div></div>
<img src="${testImgUrl.toString()}" onerror="showLoadingError()"
    width="0" height="0">
<script>
    let frame;
    let vscode;

    document.addEventListener("paste", (event) => {
        frame.contentWindow.postMessage({
            source: "host",
            command: "paste",
            data: { text: event.clipboardData.getData("text") }
        }, "*");
    });

    window.addEventListener('message', (event) => {
        if (!frame) {
            vscode = acquireVsCodeApi();
            frame = document.getElementById("frame-msg");

            // Listen to style changes on the outer iframe.
            const sendThemeMessage = () => {
                frame.contentWindow.postMessage({
                    source: "host",
                    command: "hostThemeChange",
                    data: { css: document.documentElement.style.cssText, themeClass: document.body.className }
                }, "*");
            };

            const observer = new MutationObserver(sendThemeMessage);
            observer.observe(document.documentElement, { attributes: true, attributeFilter: ["style"] });

            // Send initial theme change message.
            sendThemeMessage();
        }

        if (event.data.source === "host") {
            // Forward message from the extension to the iframe.
            frame.contentWindow.postMessage(event.data, "*");
        } else if (event.data.source === "app") {
            // Forward app events either directly or after a conversion to vscode.
            switch (event.data.command) {
                case "keydown": {
                    window.dispatchEvent(new KeyboardEvent("keydown", event.data));
                    break;
                }
                case "keyup": {
                    window.dispatchEvent(new KeyboardEvent("keyup", event.data));
                    break;
                }
                case "writeClipboard": {
                    // This is a special message and can be handled here.
                    window.navigator.clipboard.writeText(event.data.text);
                    break;
                }
                default: {
                    vscode.postMessage(event.data);
                    break;
                }
            }
        }
    });

    if ("${url.protocol}" !== "https:" && ${String(showUnsecuredConnectionWarning)} === true) {
        showFloatingLabel("Warning: Unsecured Connection",
            "MySQL Shell is currently using HTTP.<br>" +
            "Open the VS Code Settings and enable <br>" +
            "Msg &gt; Shell: Enforce Https.",
            true);
    }
</script>

</body></html>`;
};

// src/WebviewProviders/WebviewProvider.ts
var WebviewProvider = class {
  constructor(url, onDispose, onStateChange) {
    this.url = url;
    this.onDispose = onDispose;
    this.onStateChange = onStateChange;
  }
  panel;
  requisitions;
  #notifyOnDispose = true;
  #caption;
  /** @returns the current caption of the web view panel (if it exists). */
  get caption() {
    return this.#caption ?? "MySQL Shell";
  }
  /** Sets a new caption for the webview panel. */
  set caption(value) {
    this.#caption = value;
    if (this.panel) {
      this.panel.title = value;
    }
  }
  close() {
    if (this.panel) {
      this.#notifyOnDispose = false;
      this.panel.dispose();
      this.panel = void 0;
    }
  }
  /**
   * Runs a remote command in the webview.
   *
   * @param requestType The type of the request to be sent.
   * @param parameter The data for the request.
   * @param settingName For positioning in VS Code, if a new webview must be opened.
   *
   * @returns A promise that resolves when the panel is up and running.
   */
  runCommand(requestType, parameter, settingName = "") {
    return this.runInPanel(() => {
      this.requisitions?.executeRemote(requestType, parameter);
      return Promise.resolve(true);
    }, settingName);
  }
  /**
   * Runs a block of code in this web view. If the web view panel doesn't exist, it will be created first.
   *
   * @param block The block to execute.
   * @param settingName The name of the setting which determines where to place the tab in case it must be created
   *                    by this method.
   * @returns A promise which resolves after the block was executed.
   */
  runInPanel(block, settingName) {
    const placement = settingName ? import_vscode5.workspace.getConfiguration("msg.tabPosition").get(settingName) : void 0;
    return new Promise((resolve, reject) => {
      if (!this.panel) {
        if (this.caption) {
          this.createPanel(placement).then(() => {
            block().then(() => {
              resolve(true);
            }).catch((reason) => {
              reject(reason);
            });
          }).catch((reason) => {
            reject(reason);
          });
        } else {
          resolve(false);
        }
      } else {
        this.panel.reveal();
        block().then(() => {
          resolve(true);
        }).catch((reason) => {
          reject(reason);
        });
      }
    });
  }
  createPanel(placement) {
    return new Promise((resolve) => {
      void this.prepareEditorGroup(placement).then((viewColumn) => {
        this.panel = import_vscode5.window.createWebviewPanel(
          "msg-webview",
          this.#caption,
          { viewColumn, preserveFocus: true },
          {
            enableScripts: true,
            retainContextWhenHidden: true
          }
        );
        this.panel.onDidDispose(() => {
          this.handleDispose();
        });
        this.panel.iconPath = {
          dark: import_vscode5.Uri.file(path4.join(__dirname, "..", "images", "dark", "mysql.svg")),
          light: import_vscode5.Uri.file(path4.join(__dirname, "..", "images", "light", "mysql.svg"))
        };
        this.requisitions = new RequisitionHub("host");
        this.requisitions.setRemoteTarget(this.panel.webview);
        this.requisitions.register("applicationDidStart", () => {
          resolve(true);
          printChannelOutput("State: application did start");
          return Promise.resolve(true);
        });
        this.requisitionsCreated();
        this.panel.webview.onDidReceiveMessage((message) => {
          if (message.source === "app") {
            this.requisitions?.handleRemoteMessage(message);
          }
        });
        if (this.onStateChange) {
          this.panel.onDidChangeViewState((event) => {
            this.onStateChange?.(this, event.webviewPanel.active);
          });
        }
        prepareWebviewContent(this.panel, this.url);
      });
    });
  }
  handleDispose() {
    this.panel = void 0;
    if (this.#notifyOnDispose) {
      this.onDispose(this);
    }
  }
  requisitionsCreated() {
    if (this.requisitions) {
      this.requisitions.register("settingsChanged", this.updateVscodeSettings);
      this.requisitions.register("selectConnectionTab", this.selectConnectionTab);
      this.requisitions.register("dialogResponse", this.dialogResponse);
      this.requisitions.register("updateStatusbar", this.updateStatusbar);
      this.requisitions.register(
        "closeInstance",
        this.forwardSimple.bind(this, "closeInstance")
      );
    }
  }
  selectConnectionTab = (details) => {
    if (this.panel) {
      return requisitions.execute("proxyRequest", {
        provider: this,
        original: { requestType: "selectConnectionTab", parameter: details }
      });
    }
    return Promise.resolve(false);
  };
  dialogResponse = (response) => {
    return requisitions.execute("proxyRequest", {
      provider: this,
      original: { requestType: "dialogResponse", parameter: response }
    });
  };
  updateStatusbar = (items) => {
    return requisitions.execute("proxyRequest", {
      provider: this,
      original: { requestType: "updateStatusbar", parameter: items }
    });
  };
  /**
   * Used to forward all requests to the global requisitions, which have no parameters.
   *
   * @param requestType The request type to forward.
   *
   * @returns A promise that resolves when the request was forwarded.
   */
  forwardSimple = (requestType) => {
    return requisitions.execute("proxyRequest", {
      provider: this,
      original: { requestType, parameter: void 0 }
    });
  };
  updateVscodeSettings = (entry) => {
    return new Promise((resolve) => {
      if (entry) {
        const parts = entry.key.split(".");
        if (parts.length === 3) {
          const configuration = import_vscode5.workspace.getConfiguration(`msg.${parts[0]}`);
          void configuration.update(
            `${parts[1]}.${parts[2]}`,
            entry.value,
            import_vscode5.ConfigurationTarget.Global
          ).then(() => {
            resolve(true);
          });
        }
      }
      resolve(false);
    });
  };
  prepareEditorGroup = async (placement) => {
    let viewColumn = !placement || placement === "Active" ? import_vscode5.ViewColumn.Active : import_vscode5.ViewColumn.Beside;
    if (placement === "Beside Bottom") {
      viewColumn = import_vscode5.ViewColumn.Active;
      await import_vscode5.commands.executeCommand("workbench.action.editorLayoutTwoRows");
      await import_vscode5.commands.executeCommand("workbench.action.focusSecondEditorGroup");
    }
    return viewColumn;
  };
};

// src/WebviewProviders/DBConnectionViewProvider.ts
var DBConnectionViewProvider = class extends WebviewProvider {
  /**
   * Tracks the current schema of all open connections in this provider.
   * This is needed to update the UI when the user changes the current provider.
   */
  currentSchemas = /* @__PURE__ */ new Map();
  #lastNotebookUri;
  /**
   * Shows the given module page.
   *
   * @param page The page to show.
   *
   * @returns A promise which resolves after the command was executed.
   */
  show(page) {
    return this.runCommand("job", [
      { requestType: "showModule", parameter: DBEditorModuleId },
      { requestType: "showPage", parameter: { module: DBEditorModuleId, page } }
    ], "newConnection");
  }
  /**
   * Shows a sub part of a page.
   *
   * @param pageId The page to open in the webview tab (if not already done). Can either be the name of a page
   *               or a connection id.
   * @param type The type of the section.
   * @param id The id of the item to be selected.
   *
   * @returns A promise which resolves after the command was executed.
   */
  showPageSection(pageId, type, id) {
    return this.runCommand("job", [
      { requestType: "showModule", parameter: DBEditorModuleId },
      { requestType: "showPage", parameter: { module: DBEditorModuleId, page: pageId } },
      { requestType: "showPageSection", parameter: { id, type } }
    ], "newConnection");
  }
  /**
   * Executes a single statement in a webview tab.
   *
   * @param page The page to open in the webview tab (if not already done).
   * @param details Required information about the query that must be executed.
   *
   * @returns A promise which resolves after the command was executed.
   */
  runQuery(page, details) {
    return this.runCommand("job", [
      { requestType: "showModule", parameter: DBEditorModuleId },
      { requestType: "showPage", parameter: { module: DBEditorModuleId, page, suppressAbout: true } },
      { requestType: "editorRunQuery", parameter: details }
    ], details.linkId === -1 ? "newConnection" : "newConnectionWithEmbeddedSql");
  }
  /**
   * Executes a full script in a webview tab.
   *
   * @param page The page to open in the webview tab (if not already done).
   * @param details The content of the script to run and other related information.
   *
   * @returns A promise which resolves after the command was executed.
   */
  runScript(page, details) {
    return this.runCommand("job", [
      { requestType: "showModule", parameter: DBEditorModuleId },
      {
        requestType: "showPage",
        parameter: { module: DBEditorModuleId, page, suppressAbout: true, noEditor: true }
      },
      { requestType: "editorRunScript", parameter: details }
    ], "newConnection");
  }
  /**
   * Opens a new script editor in the webview tab and loads the given content into it.
   *
   * @param page The page to open in the webview tab (if not already done).
   * @param details The content of the script to run and other related information.
   *
   * @returns A promise which resolves after the command was executed.
   */
  editScript(page, details) {
    return this.runCommand("job", [
      { requestType: "showModule", parameter: DBEditorModuleId },
      { requestType: "showPage", parameter: { module: DBEditorModuleId, page, suppressAbout: true } },
      { requestType: "editorEditScript", parameter: details }
    ], "newConnection");
  }
  /**
   * Loads the content given in the request into the current script editor.
   *
   * @param page The page to open in the webview tab (if not already done).
   * @param details The content of the script and other related information.
   *
   * @returns A promise which resolves after the command was executed.
   */
  loadScript(page, details) {
    return this.runCommand("job", [
      { requestType: "showModule", parameter: DBEditorModuleId },
      { requestType: "showPage", parameter: { module: DBEditorModuleId, page, suppressAbout: true } },
      { requestType: "editorLoadScript", parameter: details }
    ], "newConnection");
  }
  /**
   * Opens a new script editor in the webview tab and loads the given content into it.
   *
   * @param details The content of the script to run and other related information.
   *
   * @returns A promise which resolves after the command was executed.
   */
  createNewEditor(details) {
    return this.runCommand("job", [
      { requestType: "showModule", parameter: DBEditorModuleId },
      {
        requestType: "showPage",
        parameter: { module: DBEditorModuleId, page: details.page, suppressAbout: true }
      },
      { requestType: "createNewEditor", parameter: details }
    ], "newConnection");
  }
  /**
   * Inserts data from a script (given by a module data id) into this connection editor.
   * The editor must already exist.
   *
   * @param state The script information.
   *
   * @returns A promise which resolves after the command was executed.
   */
  insertScriptData(state) {
    if (state.dbDataId) {
      return this.runCommand(
        "editorInsertUserScript",
        { language: state.language, resourceId: state.dbDataId },
        "newConnection"
      );
    }
    return Promise.resolve(false);
  }
  /**
   * Opens the dialog for adding a new connection on the app.
   *
   * @param mdsData Additional data for MDS connections.
   * @param profileName The config profile name for MDS connections.
   *
   * @returns A promise which resolves after the command was executed.
   */
  addConnection(mdsData, profileName) {
    return this.runCommand("job", [
      { requestType: "showModule", parameter: DBEditorModuleId },
      { requestType: "showPage", parameter: { module: DBEditorModuleId, page: "connections" } },
      { requestType: "addNewConnection", parameter: { mdsData, profileName } }
    ], "connections");
  }
  /**
   * Removes the connection from the stored connection list.
   *
   * @param connectionId The connection id.
   *
   * @returns A promise which resolves after the command was executed.
   */
  removeConnection(connectionId) {
    return this.runCommand("job", [
      { requestType: "showModule", parameter: DBEditorModuleId },
      { requestType: "showPage", parameter: { module: DBEditorModuleId, page: "connections" } },
      { requestType: "removeConnection", parameter: connectionId }
    ], "connections");
  }
  /**
   * Shows the connection editor on the connections page for the given connection id.
   *
   * @param connectionId The connection id.
   *
   * @returns A promise which resolves after the command was executed.
   */
  editConnection(connectionId) {
    return this.runCommand("job", [
      { requestType: "showModule", parameter: DBEditorModuleId },
      { requestType: "showPage", parameter: { module: DBEditorModuleId, page: "connections" } },
      { requestType: "editConnection", parameter: connectionId }
    ], "connections");
  }
  /**
   * Shows the connection editor on the connections page with a duplicate of the given connection.
   *
   * @param connectionId The connection id.
   *
   * @returns A promise which resolves after the command was executed.
   */
  duplicateConnection(connectionId) {
    return this.runCommand("job", [
      { requestType: "showModule", parameter: DBEditorModuleId },
      { requestType: "showPage", parameter: { module: DBEditorModuleId, page: "connections" } },
      { requestType: "duplicateConnection", parameter: connectionId }
    ], "connections");
  }
  renameFile(request) {
    return this.runCommand("job", [
      { requestType: "editorRenameScript", parameter: request }
    ], "connections");
  }
  /**
   * Closes the editor with the given id in the webview tab.
   *
   * @param connectionId The id of the webview tab.
   * @param editorId The id of the editor to close.
   *
   * @returns A promise which resolves after the command was executed.
   */
  closeEditor(connectionId, editorId) {
    return this.runCommand("job", [
      // No need to send a showModule request here. The module must exist or the editor wouldn't be open.
      { requestType: "editorClose", parameter: { connectionId, editorId } }
    ], "");
  }
  reselectLastItem() {
    void requisitions.execute("proxyRequest", {
      provider: this,
      original: {
        requestType: "editorSelect",
        parameter: { connectionId: -1, editorId: "" }
      }
    });
  }
  /**
   * We have 2 entry points to create new scripts. One is from the web app via a remote request. The other is from the
   * extension via a local request. This method handles the local request.
   *
   * @param language The language of the script to create.
   */
  createScript(language) {
    void requisitions.execute("proxyRequest", {
      provider: this,
      original: {
        requestType: "createNewEditor",
        parameter: language
      }
    });
  }
  /**
   * Shows the MRS DB object editor dialog.
   *
   * @param page The page to show.
   * @param data Details of the object to edit.
   *
   * @returns A promise which resolves after the command was executed.
   */
  editMrsDbObject(page, data) {
    return this.runCommand("job", [
      { requestType: "showModule", parameter: DBEditorModuleId },
      { requestType: "showPage", parameter: { module: DBEditorModuleId, page } },
      { requestType: "showMrsDbObjectDialog", parameter: data }
    ], "newConnection");
  }
  /**
   * Tell the web app to switch the current schema to the given one.
   *
   * @param connectionId The ID of the connection to switch the schema for.
   * @param schema The new current schema.
   *
   * @returns Returns a promise which resolves after the command was executed.
   */
  makeCurrentSchema(connectionId, schema) {
    this.currentSchemas.set(connectionId, schema);
    if (this.panel) {
      return this.runCommand("job", [
        { requestType: "sqlSetCurrentSchema", parameter: { id: "", connectionId, schema } }
      ], "connections");
    }
    return Promise.resolve(false);
  }
  requisitionsCreated() {
    super.requisitionsCreated();
    if (this.requisitions) {
      [
        "refreshConnections",
        "connectionAdded",
        "connectionUpdated",
        "connectionRemoved",
        "refreshOciTree",
        "codeBlocksUpdate",
        "editorLoadScript",
        "editorSaveScript",
        "createNewEditor",
        "editorsChanged",
        "editorSelect"
      ].forEach((requestType) => {
        this.requisitions.register(requestType, this.forwardRequest.bind(this, requestType));
      });
      this.requisitions.register("newSession", this.createNewSession);
      this.requisitions.register("closeInstance", this.closeInstance);
      this.requisitions.register("showInfo", this.showInfo);
      this.requisitions.register("editorSaveNotebook", this.editorSaveNotebook);
      this.requisitions.register("editorSaveNotebookInPlace", this.editorSaveNotebookInPlace);
      this.requisitions.register("editorLoadNotebook", this.editorLoadNotebook);
      this.requisitions.register("showOpenDialog", this.showOpenDialog);
      this.requisitions.register("sqlSetCurrentSchema", this.setCurrentSchema);
    }
  }
  /**
   * Takes a request and forwards it to the global extension requisitions, as a proxy request.
   *
   * @param requestType The type of request to forward.
   * @param parameter The request parameter.
   *
   * @returns The promise returned by the global extension requisitions.
   */
  forwardRequest = async (requestType, parameter) => {
    return requisitions.execute("proxyRequest", {
      provider: this,
      original: { requestType, parameter }
    });
  };
  createNewSession = async (_details) => {
    await import_vscode6.commands.executeCommand("msg.newSession");
    return true;
  };
  setCurrentSchema = (data) => {
    this.currentSchemas.set(data.connectionId, data.schema);
    return requisitions.execute("proxyRequest", {
      provider: this,
      original: { requestType: "sqlSetCurrentSchema", parameter: data }
    });
  };
  showInfo = (values) => {
    showMessageWithTimeout(values.join("\n"), 5e3);
    return Promise.resolve(true);
  };
  /**
   * Sent when a notebook shall be saved. This comes in two flavours: either with no content, which means the content
   * must be created first (which is only handled by the frontend), or with content, which means the user has to
   * select a file to save to.
   *
   * This is used for notebook content in a DB editor tab. There's a separate implementation for a standalone
   * notebook file here NotebookEditorProvider.triggerSave.
   *
   * @param content The content to save.
   *
   * @returns A promise which resolves to true if the save was successful.
   */
  editorSaveNotebook = (content) => {
    return new Promise((resolve) => {
      if (content) {
        const dialogOptions = {
          title: "",
          filters: {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            "MySQL Notebook": ["mysql-notebook"]
          },
          saveLabel: "Save Notebook"
        };
        void import_vscode6.window.showSaveDialog(dialogOptions).then((uri) => {
          if (uri !== void 0) {
            this.#lastNotebookUri = uri;
            const path25 = uri.fsPath;
            (0, import_promises.writeFile)(path25, content).then(() => {
              import_vscode6.window.setStatusBarMessage(`DB Notebook saved to ${path25}`, 5e3);
              return resolve(true);
            }).catch(() => {
              void import_vscode6.window.showErrorMessage(`Could not save notebook to ${path25}.`);
              return resolve(false);
            });
          } else {
            return resolve(false);
          }
        });
      } else {
        return resolve(false);
      }
    });
  };
  editorSaveNotebookInPlace = (content) => {
    return new Promise((resolve) => {
      if (content) {
        if (this.#lastNotebookUri === void 0) {
          void this.editorSaveNotebook(content);
        } else {
          const path25 = this.#lastNotebookUri.fsPath;
          (0, import_promises.writeFile)(path25, content).then(() => {
            import_vscode6.window.setStatusBarMessage(`DB Notebook saved to ${path25}`, 5e3);
            return resolve(true);
          }).catch(() => {
            void import_vscode6.window.showErrorMessage(`Could not save notebook to ${path25}.`);
            return resolve(false);
          });
        }
      } else {
        return resolve(false);
      }
    });
  };
  /**
   * Sent when a notebook shall be loaded. The user has to select a file to load from. The content of the file is
   * then sent back to the frontend and used there to replace the current notebook.
   *
   * This is used for notebook content in a DB editor tab. There's a separate implementation for a standalone
   * notebook file here NotebookEditorProvider.triggerLoad.
   *
   * @returns A promise which resolves to true if the save was successful.
   */
  editorLoadNotebook = () => {
    return new Promise((resolve) => {
      const dialogOptions = {
        title: "",
        canSelectFiles: true,
        canSelectFolders: false,
        canSelectMany: false,
        filters: {
          // eslint-disable-next-line @typescript-eslint/naming-convention
          "MySQL Notebook": ["mysql-notebook"]
        },
        openLabel: "Open Notebook"
      };
      void import_vscode6.window.showOpenDialog(dialogOptions).then((paths) => {
        if (paths && paths.length > 0) {
          this.#lastNotebookUri = paths[0];
          const path25 = paths[0].fsPath;
          (0, import_promises.readFile)(path25, { encoding: "utf-8" }).then((content) => {
            this.requisitions?.executeRemote("editorLoadNotebook", { content, standalone: false });
          }).catch(() => {
            void import_vscode6.window.showErrorMessage(`Could not load notebook from ${path25}.`);
          });
        }
        resolve(true);
      });
    });
  };
  showOpenDialog = (options) => {
    return new Promise((resolve) => {
      const dialogOptions = {
        id: options.id,
        defaultUri: import_vscode6.Uri.file(options.default ?? ""),
        openLabel: options.openLabel,
        canSelectFiles: options.canSelectFiles,
        canSelectFolders: options.canSelectFolders,
        canSelectMany: options.canSelectMany,
        filters: options.filters,
        title: options.title
      };
      void import_vscode6.window.showOpenDialog(dialogOptions).then((paths) => {
        if (paths) {
          const result = {
            resourceId: dialogOptions.id ?? "",
            path: paths.map((path25) => {
              return path25.fsPath;
            })
          };
          void this.requisitions?.executeRemote("selectFile", result);
        }
        resolve(true);
      });
    });
  };
  closeInstance = () => {
    this.close();
    return Promise.resolve(true);
  };
};

// src/CodeBlocks.ts
var import_path4 = __toESM(require("path"), 1);
var import_vscode7 = require("vscode");

// node_modules/antlr4ng/dist/antlr4.mjs
var h = class {
  constructor() {
    this.source = null, this.type = null, this.channel = null, this.start = null, this.stop = null, this.tokenIndex = null, this.line = null, this.column = null, this._text = null;
  }
  getTokenSource() {
    return this.source[0];
  }
  getInputStream() {
    return this.source[1];
  }
  get text() {
    return this._text;
  }
  set text(t) {
    this._text = t;
  }
};
h.INVALID_TYPE = 0;
h.EPSILON = -2;
h.MIN_USER_TOKEN_TYPE = 1;
h.EOF = -1;
h.DEFAULT_CHANNEL = 0;
h.HIDDEN_CHANNEL = 1;
var Ft = class {
  create(t, e, n, s, r, o, l, a) {
  }
};
var ft = class i extends h {
  constructor(t, e, n, s, r) {
    super(), this.source = t !== void 0 ? t : i.EMPTY_SOURCE, this.type = e !== void 0 ? e : null, this.channel = n !== void 0 ? n : h.DEFAULT_CHANNEL, this.start = s !== void 0 ? s : -1, this.stop = r !== void 0 ? r : -1, this.tokenIndex = -1, this.source[0] !== null ? (this.line = t[0].line, this.column = t[0].column) : this.column = -1;
  }
  clone() {
    let t = new i(this.source, this.type, this.channel, this.start, this.stop);
    return t.tokenIndex = this.tokenIndex, t.line = this.line, t.column = this.column, t.text = this.text, t;
  }
  cloneWithType(t) {
    let e = new i(this.source, t, this.channel, this.start, this.stop);
    return e.tokenIndex = this.tokenIndex, e.line = this.line, e.column = this.column, t === h.EOF && (e.text = ""), e;
  }
  toString(t) {
    let e = "";
    this._channel > 0 && (e = ",channel=" + this.channel);
    let n = this.text;
    n ? (n = n.replace(/\n/g, "\\n"), n = n.replace(/\r/g, "\\r"), n = n.replace(/\t/g, "\\t")) : n = "<no text>";
    let s = String(this.type);
    return t && (s = t.vocabulary.getDisplayName(this.type)), "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + n + "',<" + s + ">" + e + "," + this.line + ":" + this.column + "]";
  }
  get text() {
    if (this._text !== null)
      return this._text;
    let t = this.getInputStream();
    if (t === null)
      return null;
    let e = t.size;
    return this.start < e && this.stop < e ? t.getText(this.start, this.stop) : "<EOF>";
  }
  set text(t) {
    this._text = t;
  }
};
ft.EMPTY_SOURCE = [null, null];
var g = class i2 {
  constructor(t, e) {
    this.start = t, this.stop = e;
  }
  static of(t, e) {
    return t != e || t < 0 || t > i2.INTERVAL_POOL_MAX_VALUE ? new i2(t, e) : (i2.cache[t] === null && (i2.cache[t] = new i2(t, t)), i2.cache[t]);
  }
  equals(t) {
    return t instanceof i2 ? this.start === t.start && this.stop === t.stop : false;
  }
  hashCode() {
    let t = 23;
    return t = t * 31 + this.start, t = t * 31 + this.stop, t;
  }
  startsBeforeDisjoint(t) {
    return this.start < t.start && this.stop < t.start;
  }
  startsBeforeNonDisjoint(t) {
    return this.start <= t.start && this.stop >= t.start;
  }
  startsAfter(t) {
    return this.start > t.start;
  }
  startsAfterDisjoint(t) {
    return this.start > t.stop;
  }
  startsAfterNonDisjoint(t) {
    return this.start > t.start && this.start <= t.stop;
  }
  disjoint(t) {
    return this.startsBeforeDisjoint(t) || this.startsAfterDisjoint(t);
  }
  adjacent(t) {
    return this.start === t.stop + 1 || this.stop === t.start - 1;
  }
  properlyContains(t) {
    return t.start >= this.start && t.stop <= this.stop;
  }
  union(t) {
    return i2.of(Math.min(this.start, t.start), Math.max(this.stop, t.stop));
  }
  intersection(t) {
    return i2.of(Math.max(this.start, t.start), Math.min(this.stop, t.stop));
  }
  differenceNotProperlyContained(t) {
    let e = null;
    return t.startsBeforeNonDisjoint(this) ? e = i2.of(Math.max(this.start, t.stop + 1), this.stop) : t.startsAfterNonDisjoint(this) && (e = i2.of(this.start, t.start - 1)), e;
  }
  toString() {
    return this.start === this.stop ? this.start.toString() : this.start.toString() + ".." + this.stop.toString();
  }
  get length() {
    return this.stop < this.start ? 0 : this.stop - this.start + 1;
  }
};
g.INVALID_INTERVAL = new g(-1, -2);
g.INTERVAL_POOL_MAX_VALUE = 1e3;
g.cache = new Array(g.INTERVAL_POOL_MAX_VALUE + 1);
g.cache.fill(null);
var fe = class {
  EOF = -1;
  UNKNOWN_SOURCE_NAME = "<unknown>";
};
var st = class {
  constructor(t, e) {
    if (this.name = "", this.stringData = t, this.decodeToUnicodeCodePoints = e ?? false, this._index = 0, this.data = [], this.decodeToUnicodeCodePoints)
      for (let n = 0; n < this.stringData.length; ) {
        let s = this.stringData.codePointAt(n);
        this.data.push(s), n += s <= 65535 ? 1 : 2;
      }
    else {
      this.data = new Array(this.stringData.length);
      for (let n = 0; n < this.stringData.length; n++)
        this.data[n] = this.stringData.charCodeAt(n);
    }
    this._size = this.data.length;
  }
  reset() {
    this._index = 0;
  }
  consume() {
    if (this._index >= this._size)
      throw "cannot consume EOF";
    this._index += 1;
  }
  LA(t) {
    if (t === 0)
      return 0;
    t < 0 && (t += 1);
    let e = this._index + t - 1;
    return e < 0 || e >= this._size ? h.EOF : this.data[e];
  }
  mark() {
    return -1;
  }
  release(t) {
  }
  seek(t) {
    if (t <= this._index) {
      this._index = t;
      return;
    }
    this._index = Math.min(t, this._size);
  }
  getText(t, e) {
    let n;
    if (t instanceof g ? (n = t.start, e = t.stop) : n = t, e >= this._size && (e = this._size - 1), n >= this._size)
      return "";
    if (this.decodeToUnicodeCodePoints) {
      let s = "";
      for (let r = n; r <= e; r++)
        s += String.fromCodePoint(this.data[r]);
      return s;
    } else
      return this.stringData.slice(n, e + 1);
  }
  toString() {
    return this.stringData;
  }
  get index() {
    return this._index;
  }
  get size() {
    return this._size;
  }
  getSourceName() {
    return this.name ? this.name : fe.UNKNOWN_SOURCE_NAME;
  }
};
var pe = { fromString: function(i63) {
  return new st(i63, true);
}, fromBlob: function(i63, t, e, n) {
  let s = new window.FileReader();
  s.onload = function(r) {
    let o = new st(r.target.result, true);
    e(o);
  }, s.onerror = n, s.readAsText(i63, t);
}, fromBuffer: function(i63, t) {
  return new st(i63.toString(t), true);
} };
var $ = class {
  syntaxError(t, e, n, s, r, o) {
  }
  reportAmbiguity(t, e, n, s, r, o, l) {
  }
  reportAttemptingFullContext(t, e, n, s, r, o) {
  }
  reportContextSensitivity(t, e, n, s, r, o) {
  }
};
var vt = class extends $ {
  constructor() {
    super();
  }
  syntaxError(t, e, n, s, r, o) {
    console.error("line " + n + ":" + s + " " + r);
  }
};
vt.INSTANCE = new vt();
var me = class extends $ {
  constructor(t) {
    if (super(), t === null)
      throw "delegates";
    return this.delegates = t, this;
  }
  syntaxError(t, e, n, s, r, o) {
    this.delegates.map((l) => l.syntaxError(t, e, n, s, r, o));
  }
  reportAmbiguity(t, e, n, s, r, o, l) {
    this.delegates.map((a) => a.reportAmbiguity(t, e, n, s, r, o, l));
  }
  reportAttemptingFullContext(t, e, n, s, r, o) {
    this.delegates.map((l) => l.reportAttemptingFullContext(t, e, n, s, r, o));
  }
  reportContextSensitivity(t, e, n, s, r, o) {
    this.delegates.map((l) => l.reportContextSensitivity(t, e, n, s, r, o));
  }
};
var bt = class i3 {
  static EOF = -1;
  static tokenTypeMapCache = /* @__PURE__ */ new Map();
  static ruleIndexMapCache = /* @__PURE__ */ new Map();
  constructor() {
    this._listeners = [vt.INSTANCE], this.interpreter = null, this._stateNumber = -1;
  }
  checkVersion(t) {
    let e = "4.13.1";
    e !== t && console.log("ANTLR runtime and generated code versions disagree: " + e + "!=" + t);
  }
  addErrorListener(t) {
    this._listeners.push(t);
  }
  removeErrorListeners() {
    this._listeners = [];
  }
  getTokenTypeMap() {
    let t = this.vocabulary, e = i3.tokenTypeMapCache.get(t);
    if (!e) {
      e = /* @__PURE__ */ new Map();
      for (let n = 0; n <= this.atn.maxTokenType; n++) {
        let s = t.getLiteralName(n);
        s && e.set(s, n);
        let r = t.getSymbolicName(n);
        r && e.set(r, n);
      }
      e.set("EOF", h.EOF), i3.tokenTypeMapCache.set(t, e);
    }
    return e;
  }
  getRuleIndexMap() {
    let t = this.ruleNames, e = i3.ruleIndexMapCache.get(t);
    return e || (e = /* @__PURE__ */ new Map(), t.forEach((n, s) => e.set(n, s)), i3.ruleIndexMapCache.set(t, e)), e;
  }
  getTokenType(t) {
    let e = this.getTokenTypeMap().get(t);
    return e || h.INVALID_TYPE;
  }
  getErrorHeader(t) {
    let e = t.offendingToken.line, n = t.offendingToken.column;
    return "line " + e + ":" + n;
  }
  getTokenErrorDisplay(t) {
    if (t === null)
      return "<no token>";
    let e = t.text;
    return e === null && (t.type === h.EOF ? e = "<EOF>" : e = "<" + t.type + ">"), e = e.replace(`
`, "\\n").replace("\r", "\\r").replace("	", "\\t"), "'" + e + "'";
  }
  getErrorListenerDispatch() {
    return new me(this._listeners);
  }
  sempred(t, e, n) {
    return true;
  }
  precpred(t, e) {
    return true;
  }
  get atn() {
    return this.interpreter.atn;
  }
  get state() {
    return this._stateNumber;
  }
  set state(t) {
    this._stateNumber = t;
  }
};
var Mt = class extends Ft {
  constructor(t) {
    super(), this.copyText = t === void 0 ? false : t;
  }
  create(t, e, n, s, r, o, l, a) {
    let u = new ft(t, e, s, r, o);
    return u.line = l, u.column = a, n !== null ? u.text = n : this.copyText && t[1] !== null && (u.text = t[1].getText(r, o)), u;
  }
  createThin(t, e) {
    let n = new ft(null, t);
    return n.text = e, n;
  }
};
Mt.DEFAULT = new Mt();
var M = class i4 extends Error {
  constructor(t) {
    super(t.message), Error.captureStackTrace && Error.captureStackTrace(this, i4), this.message = t.message, this.recognizer = t.recognizer, this.input = t.input, this.ctx = t.ctx, this.offendingToken = null, this.offendingState = -1, this.recognizer !== null && (this.offendingState = this.recognizer.state);
  }
  getExpectedTokens() {
    return this.recognizer !== null ? this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx) : null;
  }
  toString() {
    return this.message;
  }
};
var rt = class extends M {
  constructor(t, e, n, s) {
    super({ message: "", recognizer: t, input: e, ctx: null }), this.startIndex = n, this.deadEndConfigs = s;
  }
  toString() {
    let t = "";
    return this.startIndex >= 0 && this.startIndex < this.input.size && (t = this.input.getText(new g(this.startIndex, this.startIndex))), "LexerNoViableAltException" + t;
  }
};
var N = class i5 extends bt {
  constructor(t) {
    super(), this._input = t, this._factory = Mt.DEFAULT, this._tokenFactorySourcePair = [this, t], this.interpreter = null, this._token = null, this._tokenStartCharIndex = -1, this._tokenStartLine = -1, this._tokenStartColumn = -1, this._hitEOF = false, this._channel = h.DEFAULT_CHANNEL, this._type = h.INVALID_TYPE, this._modeStack = [], this._mode = i5.DEFAULT_MODE, this._text = null;
  }
  reset() {
    this._input !== null && this._input.seek(0), this._token = null, this._type = h.INVALID_TYPE, this._channel = h.DEFAULT_CHANNEL, this._tokenStartCharIndex = -1, this._tokenStartColumn = -1, this._tokenStartLine = -1, this._text = null, this._hitEOF = false, this._mode = i5.DEFAULT_MODE, this._modeStack = [], this.interpreter.reset();
  }
  nextToken() {
    if (this._input === null)
      throw "nextToken requires a non-null input stream.";
    let t = this._input.mark();
    try {
      for (; ; ) {
        if (this._hitEOF)
          return this.emitEOF(), this._token;
        this._token = null, this._channel = h.DEFAULT_CHANNEL, this._tokenStartCharIndex = this._input.index, this._tokenStartColumn = this.interpreter.column, this._tokenStartLine = this.interpreter.line, this._text = null;
        let e = false;
        for (; ; ) {
          this._type = h.INVALID_TYPE;
          let n = i5.SKIP;
          try {
            n = this.interpreter.match(this._input, this._mode);
          } catch (s) {
            if (s instanceof M)
              this.notifyListeners(s), this.recover(s);
            else
              throw console.log(s.stack), s;
          }
          if (this._input.LA(1) === h.EOF && (this._hitEOF = true), this._type === h.INVALID_TYPE && (this._type = n), this._type === i5.SKIP) {
            e = true;
            break;
          }
          if (this._type !== i5.MORE)
            break;
        }
        if (!e)
          return this._token === null && this.emit(), this._token;
      }
    } finally {
      this._input.release(t);
    }
  }
  skip() {
    this._type = i5.SKIP;
  }
  more() {
    this._type = i5.MORE;
  }
  mode(t) {
    this._mode = t;
  }
  pushMode(t) {
    this.interpreter.debug && console.log("pushMode " + t), this._modeStack.push(this._mode), this.mode(t);
  }
  popMode() {
    if (this._modeStack.length === 0)
      throw "Empty Stack";
    return this.interpreter.debug && console.log("popMode back to " + this._modeStack.slice(0, -1)), this.mode(this._modeStack.pop()), this._mode;
  }
  emitToken(t) {
    this._token = t;
  }
  emit() {
    let t = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.getCharIndex() - 1, this._tokenStartLine, this._tokenStartColumn);
    return this.emitToken(t), t;
  }
  emitEOF() {
    let t = this.column, e = this.line, n = this._factory.create(this._tokenFactorySourcePair, h.EOF, null, h.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, e, t);
    return this.emitToken(n), n;
  }
  getCharIndex() {
    return this._input.index;
  }
  getAllTokens() {
    let t = [], e = this.nextToken();
    for (; e.type !== h.EOF; )
      t.push(e), e = this.nextToken();
    return t;
  }
  notifyListeners(t) {
    let e = this._tokenStartCharIndex, n = this._input.index, s = this._input.getText(e, n), r = "token recognition error at: '" + this.getErrorDisplay(s) + "'";
    this.getErrorListenerDispatch().syntaxError(this, null, this._tokenStartLine, this._tokenStartColumn, r, t);
  }
  getErrorDisplay(t) {
    let e = [];
    for (let n = 0; n < t.length; n++)
      e.push(t[n]);
    return e.join("");
  }
  getErrorDisplayForChar(t) {
    return t.charCodeAt(0) === h.EOF ? "<EOF>" : t === `
` ? "\\n" : t === "	" ? "\\t" : t === "\r" ? "\\r" : t;
  }
  getCharErrorDisplay(t) {
    return "'" + this.getErrorDisplayForChar(t) + "'";
  }
  recover(t) {
    this._input.LA(1) !== h.EOF && (t instanceof rt ? this.interpreter.consume(this._input) : this._input.consume());
  }
  get inputStream() {
    return this._input;
  }
  set inputStream(t) {
    this._input = null, this._tokenFactorySourcePair = [this, null], this.reset(), this._input = t, this._tokenFactorySourcePair = [this, t];
  }
  get sourceName() {
    return this._input.sourceName;
  }
  get type() {
    return this._type;
  }
  set type(t) {
    this._type = t;
  }
  get line() {
    return this.interpreter.line;
  }
  set line(t) {
    this.interpreter.line = t;
  }
  get column() {
    return this.interpreter.column;
  }
  set column(t) {
    this.interpreter.column = t;
  }
  get text() {
    return this._text !== null ? this._text : this.interpreter.getText(this._input);
  }
  set text(t) {
    this._text = t;
  }
};
N.DEFAULT_MODE = 0;
N.MORE = -2;
N.SKIP = -3;
N.DEFAULT_TOKEN_CHANNEL = h.DEFAULT_CHANNEL;
N.HIDDEN = h.HIDDEN_CHANNEL;
N.MIN_CHAR_VALUE = 0;
N.MAX_CHAR_VALUE = 1114111;
var Ut = class {
};
var xe = class extends Ut {
  constructor(t) {
    super(), this.tokenSource = t, this.tokens = [], this._index = -1, this.fetchedEOF = false;
  }
  mark() {
    return 0;
  }
  release(t) {
  }
  reset() {
    this.seek(0);
  }
  seek(t) {
    this.lazyInit(), this._index = this.adjustSeekIndex(t);
  }
  get size() {
    return this.tokens.length;
  }
  get index() {
    return this._index;
  }
  get(t) {
    return this.lazyInit(), this.tokens[t];
  }
  consume() {
    let t = false;
    if (this._index >= 0 ? this.fetchedEOF ? t = this._index < this.tokens.length - 1 : t = this._index < this.tokens.length : t = false, !t && this.LA(1) === h.EOF)
      throw "cannot consume EOF";
    this.sync(this._index + 1) && (this._index = this.adjustSeekIndex(this._index + 1));
  }
  sync(t) {
    let e = t - this.tokens.length + 1;
    return e > 0 ? this.fetch(e) >= e : true;
  }
  fetch(t) {
    if (this.fetchedEOF)
      return 0;
    for (let e = 0; e < t; e++) {
      let n = this.tokenSource.nextToken();
      if (n.tokenIndex = this.tokens.length, this.tokens.push(n), n.type === h.EOF)
        return this.fetchedEOF = true, e + 1;
    }
    return t;
  }
  getTokens(t, e, n) {
    if (this.lazyInit(), t === void 0 && e === void 0)
      return this.tokens;
    if (e === void 0 && (e = this.tokens.length - 1), t < 0 || e >= this.tokens.length || e < 0 || t >= this.tokens.length)
      throw new RangeError("start " + t + " or stop " + e + " not in 0.." + (this.tokens.length - 1));
    if (t > e)
      return [];
    if (n === void 0)
      return this.tokens.slice(t, e + 1);
    let s = [];
    e >= this.tokens.length && (e = this.tokens.length - 1);
    for (let r = t; r < e; r++) {
      let o = this.tokens[r];
      if (o.type === h.EOF) {
        s.push(o);
        break;
      }
      n.contains(o.type) && s.push(o);
    }
    return s;
  }
  LA(t) {
    return this.LT(t).type;
  }
  LB(t) {
    return this._index - t < 0 ? null : this.tokens[this._index - t];
  }
  LT(t) {
    if (this.lazyInit(), t === 0)
      return null;
    if (t < 0)
      return this.LB(-t);
    let e = this._index + t - 1;
    return this.sync(e), e >= this.tokens.length ? this.tokens[this.tokens.length - 1] : this.tokens[e];
  }
  adjustSeekIndex(t) {
    return t;
  }
  lazyInit() {
    this._index === -1 && this.setup();
  }
  setup() {
    this.sync(0), this._index = this.adjustSeekIndex(0);
  }
  setTokenSource(t) {
    this.tokenSource = t, this.tokens = [], this._index = -1, this.fetchedEOF = false;
  }
  getTokenSource() {
    return this.tokenSource;
  }
  nextTokenOnChannel(t, e) {
    if (this.sync(t), t >= this.tokens.length)
      return -1;
    let n = this.tokens[t];
    for (; n.channel !== this.channel; ) {
      if (n.type === h.EOF)
        return -1;
      t += 1, this.sync(t), n = this.tokens[t];
    }
    return t;
  }
  previousTokenOnChannel(t, e) {
    for (; t >= 0 && this.tokens[t].channel !== e; )
      t -= 1;
    return t;
  }
  getHiddenTokensToRight(t, e) {
    if (e === void 0 && (e = -1), this.lazyInit(), t < 0 || t >= this.tokens.length)
      throw "" + t + " not in 0.." + this.tokens.length - 1;
    let n = this.nextTokenOnChannel(t + 1, N.DEFAULT_TOKEN_CHANNEL), s = t + 1, r = n === -1 ? this.tokens.length - 1 : n;
    return this.filterForChannel(s, r, e);
  }
  getHiddenTokensToLeft(t, e) {
    if (e === void 0 && (e = -1), this.lazyInit(), t < 0 || t >= this.tokens.length)
      throw "" + t + " not in 0.." + this.tokens.length - 1;
    let n = this.previousTokenOnChannel(t - 1, N.DEFAULT_TOKEN_CHANNEL);
    if (n === t - 1)
      return null;
    let s = n + 1, r = t - 1;
    return this.filterForChannel(s, r, e);
  }
  filterForChannel(t, e, n) {
    let s = [];
    for (let r = t; r < e + 1; r++) {
      let o = this.tokens[r];
      n === -1 ? o.channel !== N.DEFAULT_TOKEN_CHANNEL && s.push(o) : o.channel === n && s.push(o);
    }
    return s.length === 0 ? null : s;
  }
  getSourceName() {
    return this.tokenSource.sourceName;
  }
  getText(t) {
    this.lazyInit(), this.fill(), t || (t = new g(0, this.tokens.length - 1));
    let e = t.start;
    e instanceof h && (e = e.tokenIndex);
    let n = t.stop;
    if (n instanceof h && (n = n.tokenIndex), e === null || n === null || e < 0 || n < 0)
      return "";
    n >= this.tokens.length && (n = this.tokens.length - 1);
    let s = "";
    for (let r = e; r < n + 1; r++) {
      let o = this.tokens[r];
      if (o.type === h.EOF)
        break;
      s = s + o.text;
    }
    return s;
  }
  fill() {
    for (this.lazyInit(); this.fetch(1e3) === 1e3; )
      ;
  }
};
var Ht = class extends xe {
  constructor(t, e) {
    super(t), this.channel = e === void 0 ? h.DEFAULT_CHANNEL : e;
  }
  adjustSeekIndex(t) {
    return this.nextTokenOnChannel(t, this.channel);
  }
  LB(t) {
    if (t === 0 || this.index - t < 0)
      return null;
    let e = this.index, n = 1;
    for (; n <= t; )
      e = this.previousTokenOnChannel(e - 1, this.channel), n += 1;
    return e < 0 ? null : this.tokens[e];
  }
  LT(t) {
    if (this.lazyInit(), t === 0)
      return null;
    if (t < 0)
      return this.LB(-t);
    let e = this.index, n = 1;
    for (; n < t; )
      this.sync(e + 1) && (e = this.nextTokenOnChannel(e + 1, this.channel)), n += 1;
    return this.tokens[e];
  }
  getNumberOfOnChannelTokens() {
    let t = 0;
    this.fill();
    for (let e = 0; e < this.tokens.length; e++) {
      let n = this.tokens[e];
      if (n.channel === this.channel && (t += 1), n.type === h.EOF)
        break;
    }
    return t;
  }
};
var Bt = class {
};
var w = class extends Bt {
};
var it = class extends w {
};
var dt = class extends w {
  constructor(t) {
    super(), this._parent = null, this.symbol = t;
  }
  getChild(t) {
    return null;
  }
  getSymbol() {
    return this.symbol;
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    this._parent = t;
  }
  getPayload() {
    return this.symbol;
  }
  getSourceInterval() {
    if (this.symbol === null)
      return g.INVALID_INTERVAL;
    let t = this.symbol.tokenIndex;
    return new g(t, t);
  }
  getChildCount() {
    return 0;
  }
  accept(t) {
    return t.visitTerminal(this);
  }
  getText() {
    return this.symbol.text;
  }
  toString() {
    return this.symbol.type === h.EOF ? "<EOF>" : this.symbol.text;
  }
  toStringTree() {
    return this.toString();
  }
};
var Lt = class extends dt {
  constructor(t) {
    super(t);
  }
  isErrorNode() {
    return true;
  }
  accept(t) {
    return t.visitErrorNode(this);
  }
};
function pt(i63, t) {
  if (!Array.isArray(i63) || !Array.isArray(t))
    return false;
  if (i63 === t)
    return true;
  if (i63.length !== t.length)
    return false;
  for (let e = 0; e < i63.length; e++)
    if (i63[e] !== t[e] && (!i63[e].equals || !i63[e].equals(t[e])))
      return false;
  return true;
}
var ln = Math.round(Math.random() * Math.pow(2, 32));
function ge(i63) {
  if (!i63)
    return 0;
  let t = typeof i63, e = t === "string" ? i63 : t === "object" && i63.toString ? i63.toString() : false;
  if (!e)
    return 0;
  let n, s, r = e.length & 3, o = e.length - r, l = ln, a = 3432918353, u = 461845907, c = 0;
  for (; c < o; )
    s = e.charCodeAt(c) & 255 | (e.charCodeAt(++c) & 255) << 8 | (e.charCodeAt(++c) & 255) << 16 | (e.charCodeAt(++c) & 255) << 24, ++c, s = (s & 65535) * a + (((s >>> 16) * a & 65535) << 16) & 4294967295, s = s << 15 | s >>> 17, s = (s & 65535) * u + (((s >>> 16) * u & 65535) << 16) & 4294967295, l ^= s, l = l << 13 | l >>> 19, n = (l & 65535) * 5 + (((l >>> 16) * 5 & 65535) << 16) & 4294967295, l = (n & 65535) + 27492 + (((n >>> 16) + 58964 & 65535) << 16);
  switch (s = 0, r) {
    case 3:
      s ^= (e.charCodeAt(c + 2) & 255) << 16;
    case 2:
      s ^= (e.charCodeAt(c + 1) & 255) << 8;
    case 1:
      s ^= e.charCodeAt(c) & 255, s = (s & 65535) * a + (((s >>> 16) * a & 65535) << 16) & 4294967295, s = s << 15 | s >>> 17, s = (s & 65535) * u + (((s >>> 16) * u & 65535) << 16) & 4294967295, l ^= s;
  }
  return l ^= e.length, l ^= l >>> 16, l = (l & 65535) * 2246822507 + (((l >>> 16) * 2246822507 & 65535) << 16) & 4294967295, l ^= l >>> 13, l = (l & 65535) * 3266489909 + (((l >>> 16) * 3266489909 & 65535) << 16) & 4294967295, l ^= l >>> 16, l >>> 0;
}
var R = class i6 {
  constructor() {
    this.count = 0, this.hash = 0;
  }
  update() {
    for (let t = 0; t < arguments.length; t++) {
      let e = arguments[t];
      if (e != null)
        if (Array.isArray(e))
          this.update.apply(this, e);
        else {
          let n = 0;
          switch (typeof e) {
            case "undefined":
            case "function":
              continue;
            case "number":
            case "boolean":
              n = e;
              break;
            case "string":
              n = ge(e);
              break;
            default:
              e.updateHashCode ? e.updateHashCode(this) : console.log("No updateHashCode for " + e.toString());
              continue;
          }
          n = n * 3432918353, n = n << 15 | n >>> 32 - 15, n = n * 461845907, this.count = this.count + 1;
          let s = this.hash ^ n;
          s = s << 13 | s >>> 32 - 13, s = s * 5 + 3864292196, this.hash = s;
        }
    }
  }
  finish() {
    let t = this.hash ^ this.count * 4;
    return t = t ^ t >>> 16, t = t * 2246822507, t = t ^ t >>> 13, t = t * 3266489909, t = t ^ t >>> 16, t;
  }
  static hashStuff() {
    let t = new i6();
    return t.update.apply(t, arguments), t.finish();
  }
};
function Te(i63) {
  return i63 ? typeof i63 == "string" ? ge(i63) : i63.hashCode() : -1;
}
function Se(i63, t) {
  return i63 ? i63.equals(t) : i63 === t;
}
function en(i63) {
  return i63 === null ? "null" : i63;
}
function G(i63) {
  return Array.isArray(i63) ? "[" + i63.map(en).join(", ") + "]" : "null";
}
var Ee = "h-";
var k = class {
  constructor(t, e) {
    this.data = {}, this.hashFunction = t || Te, this.equalsFunction = e || Se;
  }
  add(t) {
    let e = Ee + this.hashFunction(t);
    if (e in this.data) {
      let n = this.data[e];
      for (let s = 0; s < n.length; s++)
        if (this.equalsFunction(t, n[s]))
          return n[s];
      return n.push(t), t;
    } else
      return this.data[e] = [t], t;
  }
  has(t) {
    return this.get(t) != null;
  }
  get(t) {
    let e = Ee + this.hashFunction(t);
    if (e in this.data) {
      let n = this.data[e];
      for (let s = 0; s < n.length; s++)
        if (this.equalsFunction(t, n[s]))
          return n[s];
    }
    return null;
  }
  values() {
    return Object.keys(this.data).filter((t) => t.startsWith(Ee)).flatMap((t) => this.data[t], this);
  }
  toString() {
    return G(this.values());
  }
  get length() {
    return Object.keys(this.data).filter((t) => t.startsWith(Ee)).map((t) => this.data[t].length, this).reduce((t, e) => t + e, 0);
  }
};
var T = class i7 {
  hashCode() {
    let t = new R();
    return this.updateHashCode(t), t.finish();
  }
  evaluate(t, e) {
  }
  evalPrecedence(t, e) {
    return this;
  }
  static andContext(t, e) {
    if (t === null || t === i7.NONE)
      return e;
    if (e === null || e === i7.NONE)
      return t;
    let n = new $e(t, e);
    return n.opnds.length === 1 ? n.opnds[0] : n;
  }
  static orContext(t, e) {
    if (t === null)
      return e;
    if (e === null)
      return t;
    if (t === i7.NONE || e === i7.NONE)
      return i7.NONE;
    let n = new Je(t, e);
    return n.opnds.length === 1 ? n.opnds[0] : n;
  }
};
var $e = class i8 extends T {
  constructor(t, e) {
    super();
    let n = new k();
    t instanceof i8 ? t.opnds.map(function(r) {
      n.add(r);
    }) : n.add(t), e instanceof i8 ? e.opnds.map(function(r) {
      n.add(r);
    }) : n.add(e);
    let s = nn(n);
    if (s.length > 0) {
      let r = null;
      s.map(function(o) {
        (r === null || o.precedence < r.precedence) && (r = o);
      }), n.add(r);
    }
    this.opnds = Array.from(n.values());
  }
  equals(t) {
    return this === t ? true : t instanceof i8 ? pt(this.opnds, t.opnds) : false;
  }
  updateHashCode(t) {
    t.update(this.opnds, "AND");
  }
  evaluate(t, e) {
    for (let n = 0; n < this.opnds.length; n++)
      if (!this.opnds[n].evaluate(t, e))
        return false;
    return true;
  }
  evalPrecedence(t, e) {
    let n = false, s = [];
    for (let o = 0; o < this.opnds.length; o++) {
      let l = this.opnds[o], a = l.evalPrecedence(t, e);
      if (n |= a !== l, a === null)
        return null;
      a !== T.NONE && s.push(a);
    }
    if (!n)
      return this;
    if (s.length === 0)
      return T.NONE;
    let r = null;
    return s.map(function(o) {
      r = r === null ? o : T.andContext(r, o);
    }), r;
  }
  toString() {
    let t = this.opnds.map((e) => e.toString());
    return (t.length > 3 ? t.slice(3) : t).join("&&");
  }
};
var Je = class i9 extends T {
  constructor(t, e) {
    super();
    let n = new k();
    t instanceof i9 ? t.opnds.map(function(r) {
      n.add(r);
    }) : n.add(t), e instanceof i9 ? e.opnds.map(function(r) {
      n.add(r);
    }) : n.add(e);
    let s = nn(n);
    if (s.length > 0) {
      let r = s.sort(function(l, a) {
        return l.compareTo(a);
      }), o = r[r.length - 1];
      n.add(o);
    }
    this.opnds = Array.from(n.values());
  }
  equals(t) {
    return this === t ? true : t instanceof i9 ? pt(this.opnds, t.opnds) : false;
  }
  updateHashCode(t) {
    t.update(this.opnds, "OR");
  }
  evaluate(t, e) {
    for (let n = 0; n < this.opnds.length; n++)
      if (this.opnds[n].evaluate(t, e))
        return true;
    return false;
  }
  evalPrecedence(t, e) {
    let n = false, s = [];
    for (let o = 0; o < this.opnds.length; o++) {
      let l = this.opnds[o], a = l.evalPrecedence(t, e);
      if (n |= a !== l, a === T.NONE)
        return T.NONE;
      a !== null && s.push(a);
    }
    if (!n)
      return this;
    if (s.length === 0)
      return null;
    let r = null;
    return s.map(function(o) {
      return r === null ? o : T.orContext(r, o);
    }), r;
  }
  toString() {
    let t = this.opnds.map((e) => e.toString());
    return (t.length > 3 ? t.slice(3) : t).join("||");
  }
};
function nn(i63) {
  let t = [];
  return i63.values().map(function(e) {
    e instanceof T.PrecedencePredicate && t.push(e);
  }), t;
}
var re = class i10 extends T {
  constructor(t, e, n) {
    super(), this.ruleIndex = t === void 0 ? -1 : t, this.predIndex = e === void 0 ? -1 : e, this.isCtxDependent = n === void 0 ? false : n;
  }
  evaluate(t, e) {
    let n = this.isCtxDependent ? e : null;
    return t.sempred(n, this.ruleIndex, this.predIndex);
  }
  updateHashCode(t) {
    t.update(this.ruleIndex, this.predIndex, this.isCtxDependent);
  }
  equals(t) {
    return this === t ? true : t instanceof i10 ? this.ruleIndex === t.ruleIndex && this.predIndex === t.predIndex && this.isCtxDependent === t.isCtxDependent : false;
  }
  toString() {
    return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
  }
};
T.NONE = new re();
var O = class {
  constructor(t) {
    if (t == null)
      throw "target cannot be null.";
    this.target = t, this.isEpsilon = false, this.label = null;
  }
};
var mt = class extends O {
  constructor(t) {
    super(t);
  }
};
var d = { EPSILON: 1, RANGE: 2, RULE: 3, PREDICATE: 4, ATOM: 5, ACTION: 6, SET: 7, NOT_SET: 8, WILDCARD: 9, PRECEDENCE: 10 };
var Vt = class extends mt {
  constructor(t, e, n, s) {
    super(t), this.serializationType = d.PREDICATE, this.ruleIndex = e, this.predIndex = n, this.isCtxDependent = s, this.isEpsilon = true;
  }
  matches(t, e, n) {
    return false;
  }
  getPredicate() {
    return new re(this.ruleIndex, this.predIndex, this.isCtxDependent);
  }
  toString() {
    return "pred_" + this.ruleIndex + ":" + this.predIndex;
  }
};
var ut = class extends M {
  constructor(t, e, n) {
    super({ message: an(e, n || null), recognizer: t, input: t.inputStream, ctx: t._ctx });
    let r = t.interpreter.atn.states[t.state].transitions[0];
    r instanceof Vt ? (this.ruleIndex = r.ruleIndex, this.predicateIndex = r.predIndex) : (this.ruleIndex = 0, this.predicateIndex = 0), this.predicate = e, this.offendingToken = t.getCurrentToken();
  }
};
function an(i63, t) {
  return t !== null ? t : "failed predicate: {" + i63 + "}?";
}
var J = class extends M {
  constructor(t) {
    super({ message: "", recognizer: t, input: t.inputStream, ctx: t._ctx }), this.offendingToken = t.getCurrentToken();
  }
};
var xt = class extends M {
  constructor(t, e, n, s, r, o) {
    o = o ?? t._ctx, s = s ?? t.getCurrentToken(), n = n ?? t.getCurrentToken(), e = e ?? t.inputStream, super({ message: "", recognizer: t, input: e, ctx: o }), this.deadEndConfigs = r, this.startToken = n, this.offendingToken = s;
  }
};
var _ = class i11 {
  constructor() {
    this.atn = null, this.ruleIndex = 0, this.epsilonOnlyTransitions = false, this.transitions = [], this.nextTokenWithinRule = null;
  }
  get stateType() {
    return i11.INVALID_STATE_NUMBER;
  }
  toString() {
    return `${this.stateNumber}`;
  }
  equals(t) {
    return t instanceof i11 ? this.stateNumber === t.stateNumber : false;
  }
  isNonGreedyExitState() {
    return false;
  }
  addTransition(t, e) {
    e === void 0 && (e = -1), this.transitions.length === 0 ? this.epsilonOnlyTransitions = t.isEpsilon : this.epsilonOnlyTransitions !== t.isEpsilon && (this.epsilonOnlyTransitions = false), e === -1 ? this.transitions.push(t) : this.transitions.splice(e, 1, t);
  }
};
_.INVALID_STATE_NUMBER = -1;
var b = class i12 {
  constructor(t, e, n) {
    this.literalNames = t ?? i12.EMPTY_NAMES, this.symbolicNames = e ?? i12.EMPTY_NAMES, this.displayNames = n ?? i12.EMPTY_NAMES, this.maxTokenType = Math.max(this.displayNames.length, Math.max(this.literalNames.length, this.symbolicNames.length)) - 1;
  }
  static fromTokenNames(t) {
    if (t == null || t.length === 0)
      return i12.EMPTY_VOCABULARY;
    let e = [...t], n = [...t];
    for (let s = 0; s < t.length; s++) {
      let r = t[s];
      if (r != null) {
        if (!r.isEmpty()) {
          let o = r.charAt(0);
          if (o === "'") {
            n[s] = null;
            continue;
          } else if (o.toUpperCase() === o) {
            e[s] = null;
            continue;
          }
        }
        e[s] = null, n[s] = null;
      }
    }
    return new i12(e, n, t);
  }
  getMaxTokenType() {
    return this.maxTokenType;
  }
  getLiteralName(t) {
    return t >= 0 && t < this.literalNames.length ? this.literalNames[t] : null;
  }
  getSymbolicName(t) {
    return t >= 0 && t < this.symbolicNames.length ? this.symbolicNames[t] : t === h.EOF ? "EOF" : null;
  }
  getDisplayName(t) {
    if (t >= 0 && t < this.displayNames.length) {
      let s = this.displayNames[t];
      if (s != null)
        return s;
    }
    let e = this.getLiteralName(t);
    if (e != null)
      return e;
    let n = this.getSymbolicName(t);
    return n ?? `${t}`;
  }
  getLiteralNames() {
    return this.literalNames;
  }
  getSymbolicNames() {
    return this.symbolicNames;
  }
  getDisplayNames() {
    return this.displayNames;
  }
};
b.EMPTY_NAMES = [];
b.EMPTY_VOCABULARY = new b(b.EMPTY_NAMES, b.EMPTY_NAMES, b.EMPTY_NAMES);
var D = class i13 {
  static COMPLETE_CHAR_SET = i13.of(N.MIN_CHAR_VALUE, N.MAX_CHAR_VALUE);
  static EMPTY_SET = new i13();
  static {
    i13.COMPLETE_CHAR_SET.readonly = true, i13.EMPTY_SET.readonly = true;
  }
  constructor(t) {
    this.intervals = [], this.readOnly = false, t && this.addSet(t);
  }
  static of(t, e) {
    let n = new i13();
    return n.addRange(t, e), n;
  }
  get minElement() {
    return this.intervals.length === 0 ? h.INVALID_TYPE : this.intervals[0].start;
  }
  get maxElement() {
    return this.intervals.length === 0 ? h.INVALID_TYPE : this.intervals[this.intervals.length - 1].stop;
  }
  get isNil() {
    return this.intervals.length === 0;
  }
  clear() {
    if (this.readOnly)
      throw new IllegalStateException("can't alter readonly IntervalSet");
    this.intervals = [];
  }
  addOne(t) {
    this.addInterval(new g(t, t));
  }
  addRange(t, e) {
    this.addInterval(new g(t, e));
  }
  addInterval(t) {
    if (this.readOnly)
      throw new IllegalStateException("can't alter readonly IntervalSet");
    if (this.intervals.length === 0)
      this.intervals.push(t);
    else {
      for (let e = 0; e < this.intervals.length; e++) {
        let n = this.intervals[e];
        if (t.equals(n))
          return;
        if (t.adjacent(n) || !t.disjoint(n)) {
          let s = t.union(n);
          this.intervals[e] = s;
          for (let r = e + 1; r < this.intervals.length; ) {
            let o = this.intervals[r];
            if (!s.adjacent(o) && s.disjoint(o))
              break;
            this.intervals.splice(r, 1), this.intervals[e] = s.union(o);
          }
          return;
        }
        if (t.startsBeforeDisjoint(n)) {
          this.intervals.splice(e, 0, t);
          return;
        }
      }
      this.intervals.push(t);
    }
  }
  addSet(t) {
    return t.intervals.forEach((e) => this.addInterval(e), this), this;
  }
  complement(t, e) {
    if (!t)
      return new i13();
    let n = new i13();
    if (t instanceof i13) {
      if (t.isNil)
        return new i13();
      n.addSet(t);
    } else
      n.addInterval(new g(t, e));
    return n.subtract(this);
  }
  or(t) {
    let e = new i13();
    return e.addSet(this), t.forEach((n) => e.addSet(n), this), e;
  }
  and(t) {
    if (t.isNil)
      return new i13();
    let e = this.intervals, n = t.intervals, s, r = e.length, o = n.length, l = 0, a = 0;
    for (; l < r && a < o; ) {
      let u = e[l], c = n[a];
      u.startsBeforeDisjoint(c) ? l++ : c.startsBeforeDisjoint(u) ? a++ : u.properlyContains(c) ? (s || (s = new i13()), s.addInterval(u.intersection(c)), a++) : c.properlyContains(u) ? (s || (s = new i13()), s.addInterval(u.intersection(c)), l++) : u.disjoint(c) || (s || (s = new i13()), s.addInterval(u.intersection(c)), u.startsAfterNonDisjoint(c) ? a++ : c.startsAfterNonDisjoint(u) && l++);
    }
    return s || new i13();
  }
  subtract(t) {
    if (this.isNil)
      return new i13();
    let e = new i13(this);
    if (t.isNil)
      return e;
    let n = 0, s = 0;
    for (; n < e.intervals.length && s < t.intervals.length; ) {
      let r = e.intervals[n], o = t.intervals[s];
      if (o.stop < r.start) {
        s++;
        continue;
      }
      if (o.start > r.stop) {
        n++;
        continue;
      }
      let l = null, a = null;
      if (o.start > r.start && (l = new g(r.start, o.start - 1)), o.stop < r.stop && (a = new g(o.stop + 1, r.stop)), l != null)
        if (a != null) {
          e.intervals[n] = l, e.intervals.splice(n + 1, 0, a), n++, s++;
          continue;
        } else {
          e.intervals[n] = l, n++;
          continue;
        }
      else if (a != null) {
        e.intervals[n] = a, s++;
        continue;
      } else {
        e.intervals.splice(n, 1);
        continue;
      }
    }
    return e;
  }
  contains(t) {
    if (this.intervals === null)
      return false;
    {
      let e = this.intervals.length, n = 0, s = e - 1;
      for (; n <= s; ) {
        let r = Math.floor((n + s) / 2), o = this.intervals[r];
        if (o.stop < t)
          n = r + 1;
        else if (o.start > t)
          s = r - 1;
        else
          return true;
      }
      return false;
    }
  }
  removeRange(t) {
    if (this.readOnly)
      throw new IllegalStateException("can't alter readonly IntervalSet");
    if (t.start === t.stop)
      this.removeOne(t.start);
    else if (this.intervals !== null) {
      let e = 0;
      for (let n = 0; n < this.intervals.length; n++) {
        let s = this.intervals[e];
        if (t.stop <= s.start)
          return;
        if (t.start > s.start && t.stop < s.stop) {
          this.intervals[e] = new g(s.start, t.start);
          let r = new g(t.stop, s.stop);
          this.intervals.splice(e, 0, r);
          return;
        } else
          t.start <= s.start && t.stop >= s.stop ? (this.intervals.splice(e, 1), e = e - 1) : t.start < s.stop ? this.intervals[e] = new g(s.start, t.start) : t.stop < s.stop && (this.intervals[e] = new g(t.stop, s.stop));
        e += 1;
      }
    }
  }
  removeOne(t) {
    if (this.readOnly)
      throw new IllegalStateException("can't alter readonly IntervalSet");
    if (this.intervals !== null)
      for (let e = 0; e < this.intervals.length; e++) {
        let n = this.intervals[e];
        if (t < n.start)
          return;
        if (t === n.start && t === n.stop) {
          this.intervals.splice(e, 1);
          return;
        } else if (t === n.start) {
          this.intervals[e] = new g(n.start + 1, n.stop);
          return;
        } else if (t === n.stop) {
          this.intervals[e] = new g(n.start, n.stop);
          return;
        } else if (t < n.stop) {
          let s = new g(n.start, t);
          n.start = t + 1, this.intervals.splice(e, 0, s);
          return;
        }
      }
  }
  toString(t) {
    if (this.intervals.length === 0)
      return "{}";
    let e = "";
    this.length > 1 && (e += "{");
    let n, s;
    t instanceof b ? (s = t, n = false) : n = t ?? false;
    for (let r = 0; r < this.intervals.length; ++r) {
      let o = this.intervals[r], l = o.start, a = o.stop;
      if (l === a)
        l == h.EOF ? e += "<EOF>" : n ? e += "'" + String.fromCodePoint(l) + "'" : s ? e += this.elementName(s, l) : e += l;
      else if (n)
        e += "'" + String.fromCodePoint(l) + "'..'" + String.fromCodePoint(a) + "'";
      else if (s)
        for (let u = l; u <= a; ++u)
          u > l && (e += ", "), e += this.elementName(s, u);
      else
        e += l + ".." + a;
      r < this.intervals.length - 1 && (e += ", ");
    }
    return this.length > 1 && (e += "}"), e;
  }
  elementName(t, e) {
    return e === h.EOF ? "<EOF>" : e === h.EPSILON ? "<EPSILON>" : t.getDisplayName(e);
  }
  toArray() {
    let t = [];
    if (this.intervals !== null)
      for (let e = 0; e < this.intervals.length; e++) {
        let n = this.intervals[e];
        for (let s = n.start; s <= n.stop; s++)
          t.push(s);
      }
    return t;
  }
  get length() {
    let t = 0;
    if (this.intervals.length == 1) {
      let n = this.intervals[0];
      return n.stop - n.start + 1;
    }
    for (let n of this.intervals)
      t += n.length;
    return t;
  }
  isReadonly() {
    return this.readOnly;
  }
  setReadonly(t) {
    if (this.readOnly && !t)
      throw new IllegalStateException("can't alter readonly IntervalSet");
    this.readOnly = t;
  }
  [Symbol.iterator]() {
    return this.intervals[Symbol.iterator]();
  }
};
var m = { INVALID_TYPE: 0, BASIC: 1, RULE_START: 2, BLOCK_START: 3, PLUS_BLOCK_START: 4, STAR_BLOCK_START: 5, TOKEN_START: 6, RULE_STOP: 7, BLOCK_END: 8, STAR_LOOP_BACK: 9, STAR_LOOP_ENTRY: 10, PLUS_LOOP_BACK: 11, LOOP_END: 12 };
var gt = class {
  constructor() {
    this.errorRecoveryMode = false, this.lastErrorIndex = -1, this.lastErrorStates = null, this.nextTokensContext = null, this.nextTokenState = 0;
  }
  reset(t) {
    this.endErrorCondition(t);
  }
  beginErrorCondition(t) {
    this.errorRecoveryMode = true;
  }
  inErrorRecoveryMode(t) {
    return this.errorRecoveryMode;
  }
  endErrorCondition(t) {
    this.errorRecoveryMode = false, this.lastErrorStates = null, this.lastErrorIndex = -1;
  }
  reportMatch(t) {
    this.endErrorCondition(t);
  }
  reportError(t, e) {
    this.inErrorRecoveryMode(t) || (this.beginErrorCondition(t), e instanceof xt ? this.reportNoViableAlternative(t, e) : e instanceof J ? this.reportInputMismatch(t, e) : e instanceof ut ? this.reportFailedPredicate(t, e) : (console.log("unknown recognition error type: " + e.constructor.name), console.log(e.stack), t.notifyErrorListeners(e.offendingToken, e.getMessage(), e)));
  }
  recover(t, e) {
    this.lastErrorIndex === t.inputStream.index && this.lastErrorStates !== null && this.lastErrorStates.indexOf(t.state) >= 0 && t.consume(), this.lastErrorIndex = t._input.index, this.lastErrorStates === null && (this.lastErrorStates = []), this.lastErrorStates.push(t.state);
    let n = this.getErrorRecoverySet(t);
    this.consumeUntil(t, n);
  }
  sync(t) {
    if (this.inErrorRecoveryMode(t))
      return;
    let e = t.interpreter.atn.states[t.state], n = t.tokenStream.LA(1), s = t.atn.nextTokens(e);
    if (s.contains(n)) {
      this.nextTokensContext = null, this.nextTokenState = _.INVALID_STATE_NUMBER;
      return;
    } else if (s.contains(h.EPSILON)) {
      this.nextTokensContext === null && (this.nextTokensContext = t._ctx, this.nextTokensState = t._stateNumber);
      return;
    }
    switch (e.stateType) {
      case m.BLOCK_START:
      case m.STAR_BLOCK_START:
      case m.PLUS_BLOCK_START:
      case m.STAR_LOOP_ENTRY:
        if (this.singleTokenDeletion(t) !== null)
          return;
        throw new J(t);
      case m.PLUS_LOOP_BACK:
      case m.STAR_LOOP_BACK:
        {
          this.reportUnwantedToken(t);
          let r = new D();
          r.addSet(t.getExpectedTokens());
          let o = r.addSet(this.getErrorRecoverySet(t));
          this.consumeUntil(t, o);
        }
        break;
      default:
    }
  }
  reportNoViableAlternative(t, e) {
    let n = t.tokenStream, s;
    n !== null ? e.startToken.type === h.EOF ? s = "<EOF>" : s = n.getText(new g(e.startToken.tokenIndex, e.offendingToken.tokenIndex)) : s = "<unknown input>";
    let r = "no viable alternative at input " + this.escapeWSAndQuote(s);
    t.notifyErrorListeners(r, e.offendingToken, e);
  }
  reportInputMismatch(t, e) {
    let n = "mismatched input " + this.getTokenErrorDisplay(e.offendingToken) + " expecting " + e.getExpectedTokens().toString(t.vocabulary);
    t.notifyErrorListeners(n, e.offendingToken, e);
  }
  reportFailedPredicate(t, e) {
    let s = "rule " + t.ruleNames[t._ctx.ruleIndex] + " " + e.message;
    t.notifyErrorListeners(s, e.offendingToken, e);
  }
  reportUnwantedToken(t) {
    if (this.inErrorRecoveryMode(t))
      return;
    this.beginErrorCondition(t);
    let e = t.getCurrentToken(), n = this.getTokenErrorDisplay(e), s = this.getExpectedTokens(t), r = "extraneous input " + n + " expecting " + s.toString(t.vocabulary);
    t.notifyErrorListeners(r, e, null);
  }
  reportMissingToken(t) {
    if (this.inErrorRecoveryMode(t))
      return;
    this.beginErrorCondition(t);
    let e = t.getCurrentToken(), s = "missing " + this.getExpectedTokens(t).toString(t.vocabulary) + " at " + this.getTokenErrorDisplay(e);
    t.notifyErrorListeners(s, e, null);
  }
  recoverInline(t) {
    let e = this.singleTokenDeletion(t);
    if (e !== null)
      return t.consume(), e;
    if (this.singleTokenInsertion(t))
      return this.getMissingSymbol(t);
    throw new J(t);
  }
  singleTokenInsertion(t) {
    let e = t.tokenStream.LA(1), n = t.interpreter.atn, r = n.states[t.state].transitions[0].target;
    return n.nextTokens(r, t._ctx).contains(e) ? (this.reportMissingToken(t), true) : false;
  }
  singleTokenDeletion(t) {
    let e = t.tokenStream.LA(2);
    if (this.getExpectedTokens(t).contains(e)) {
      this.reportUnwantedToken(t), t.consume();
      let s = t.getCurrentToken();
      return this.reportMatch(t), s;
    } else
      return null;
  }
  getMissingSymbol(t) {
    let e = t.getCurrentToken(), n = this.getExpectedTokens(t), s = h.INVALID_TYPE;
    n.isNil || (s = n.minElement);
    let r;
    s === h.EOF ? r = "<missing EOF>" : r = "<missing " + t.vocabulary.getDisplayName(s) + ">";
    let o = e, l = t.tokenStream.LT(-1);
    return o.type === h.EOF && l !== null && (o = l), t.getTokenFactory().create(o.source, s, r, h.DEFAULT_CHANNEL, -1, -1, o.line, o.column);
  }
  getExpectedTokens(t) {
    return t.getExpectedTokens();
  }
  getTokenErrorDisplay(t) {
    if (t === null)
      return "<no token>";
    let e = t.text;
    return e === null && (t.type === h.EOF ? e = "<EOF>" : e = "<" + t.type + ">"), this.escapeWSAndQuote(e);
  }
  escapeWSAndQuote(t) {
    return t = t.replace(/\n/g, "\\n"), t = t.replace(/\r/g, "\\r"), t = t.replace(/\t/g, "\\t"), "'" + t + "'";
  }
  getErrorRecoverySet(t) {
    let e = t.interpreter.atn, n = t._ctx, s = new D();
    for (; n !== null && n.invokingState >= 0; ) {
      let o = e.states[n.invokingState].transitions[0], l = e.nextTokens(o.followState);
      s.addSet(l), n = n.parent;
    }
    return s.removeOne(h.EPSILON), s;
  }
  consumeUntil(t, e) {
    let n = t.tokenStream.LA(1);
    for (; n !== h.EOF && !e.contains(n); )
      t.consume(), n = t.tokenStream.LA(1);
  }
};
function sn(i63, t) {
  if (i63 === null) {
    let e = { state: null, alt: null, context: null, semanticContext: null };
    return t && (e.reachesIntoOuterContext = 0), e;
  } else {
    let e = {};
    return e.state = i63.state || null, e.alt = i63.alt === void 0 ? null : i63.alt, e.context = i63.context || null, e.semanticContext = i63.semanticContext || null, t && (e.reachesIntoOuterContext = i63.reachesIntoOuterContext || 0, e.precedenceFilterSuppressed = i63.precedenceFilterSuppressed || false), e;
  }
}
var C = class i14 {
  constructor(t, e) {
    this.checkContext(t, e), t = sn(t), e = sn(e, true), this.state = t.state !== null ? t.state : e.state, this.alt = t.alt !== null ? t.alt : e.alt, this.context = t.context !== null ? t.context : e.context, this.semanticContext = t.semanticContext !== null ? t.semanticContext : e.semanticContext !== null ? e.semanticContext : T.NONE, this.reachesIntoOuterContext = e.reachesIntoOuterContext, this.precedenceFilterSuppressed = e.precedenceFilterSuppressed;
  }
  checkContext(t, e) {
    (t.context === null || t.context === void 0) && (e === null || e.context === null || e.context === void 0) && (this.context = null);
  }
  hashCode() {
    let t = new R();
    return this.updateHashCode(t), t.finish();
  }
  updateHashCode(t) {
    t.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);
  }
  equals(t) {
    return this === t ? true : t instanceof i14 ? this.state.stateNumber === t.state.stateNumber && this.alt === t.alt && (this.context === null ? t.context === null : this.context.equals(t.context)) && this.semanticContext.equals(t.semanticContext) && this.precedenceFilterSuppressed === t.precedenceFilterSuppressed : false;
  }
  hashCodeForConfigSet() {
    let t = new R();
    return t.update(this.state.stateNumber, this.alt, this.semanticContext), t.finish();
  }
  equalsForConfigSet(t) {
    return this === t ? true : t instanceof i14 ? this.state.stateNumber === t.state.stateNumber && this.alt === t.alt && this.semanticContext.equals(t.semanticContext) : false;
  }
  toString() {
    return "(" + this.state + "," + this.alt + (this.context !== null ? ",[" + this.context.toString() + "]" : "") + (this.semanticContext !== T.NONE ? "," + this.semanticContext.toString() : "") + (this.reachesIntoOuterContext > 0 ? ",up=" + this.reachesIntoOuterContext : "") + ")";
  }
};
var L = class extends _ {
  get stateType() {
    return m.RULE_STOP;
  }
};
var ht = class extends O {
  constructor(t, e, n, s) {
    super(t), this.ruleIndex = e, this.precedence = n, this.followState = s, this.serializationType = d.RULE, this.isEpsilon = true;
  }
  matches(t, e, n) {
    return false;
  }
};
var Tt = class extends O {
  constructor(t, e) {
    super(t), this.serializationType = d.SET, e != null ? this.label = e : (this.label = new D(), this.label.addOne(h.INVALID_TYPE));
  }
  matches(t, e, n) {
    return this.label.contains(t);
  }
  toString() {
    return this.label.toString();
  }
};
var ot = class extends Tt {
  constructor(t, e) {
    super(t, e), this.serializationType = d.NOT_SET;
  }
  matches(t, e, n) {
    return t >= e && t <= n && !super.matches(t, e, n);
  }
  toString() {
    return "~" + super.toString();
  }
};
var Yt = class extends O {
  constructor(t) {
    super(t), this.serializationType = d.WILDCARD;
  }
  matches(t, e, n) {
    return t >= e && t <= n;
  }
  toString() {
    return ".";
  }
};
function rn(i63, t) {
  return i63 = i63.replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r"), t && (i63 = i63.replace(/ /g, "\xB7")), i63;
}
var P = { toStringTree: function(i63, t, e) {
  t = t || null, e = e || null, e !== null && (t = e.ruleNames);
  let n = P.getNodeText(i63, t);
  n = rn(n, false);
  let s = i63.getChildCount();
  if (s === 0)
    return n;
  let r = "(" + n + " ";
  s > 0 && (n = P.toStringTree(i63.getChild(0), t), r = r.concat(n));
  for (let o = 1; o < s; o++)
    n = P.toStringTree(i63.getChild(o), t), r = r.concat(" " + n);
  return r = r.concat(")"), r;
}, getNodeText: function(i63, t, e) {
  if (t = t || null, e = e || null, e !== null && (t = e.ruleNames), t !== null)
    if (i63 instanceof U) {
      let r = i63.ruleContext.getAltNumber();
      return r != 0 ? t[i63.ruleIndex] + ":" + r : t[i63.ruleIndex];
    } else {
      if (i63 instanceof it)
        return i63.toString();
      if (i63 instanceof w && i63.symbol !== null)
        return i63.symbol.text;
    }
  let n = i63.getPayload();
  return n instanceof h ? n.text : i63.getPayload().toString();
}, getChildren: function(i63) {
  let t = [];
  for (let e = 0; e < i63.getChildCount(); e++)
    t.push(i63.getChild(e));
  return t;
}, getAncestors: function(i63) {
  let t = [];
  for (i63 = i63.getParent(); i63 !== null; )
    t = [i63].concat(t), i63 = i63.getParent();
  return t;
}, findAllTokenNodes: function(i63, t) {
  return P.findAllNodes(i63, t, true);
}, findAllRuleNodes: function(i63, t) {
  return P.findAllNodes(i63, t, false);
}, findAllNodes: function(i63, t, e) {
  let n = [];
  return P._findAllNodes(i63, t, e, n), n;
}, _findAllNodes: function(i63, t, e, n) {
  e && i63 instanceof w ? i63.symbol.type === t && n.push(i63) : !e && i63 instanceof U && i63.ruleIndex === t && n.push(i63);
  for (let s = 0; s < i63.getChildCount(); s++)
    P._findAllNodes(i63.getChild(s), t, e, n);
}, descendants: function(i63) {
  let t = [i63];
  for (let e = 0; e < i63.getChildCount(); e++)
    t = t.concat(P.descendants(i63.getChild(e)));
  return t;
} };
var U = class extends Bt {
  constructor(t, e) {
    super(), this._parent = t ?? null, this.children = null, this.invokingState = e ?? -1;
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    this._parent = t;
  }
  depth() {
    let t = 0, e = this;
    for (; e !== null; )
      e = e.parent, t += 1;
    return t;
  }
  isEmpty() {
    return this.invokingState === -1;
  }
  getSourceInterval() {
    return g.INVALID_INTERVAL;
  }
  get ruleContext() {
    return this;
  }
  get ruleIndex() {
    return -1;
  }
  getPayload() {
    return this;
  }
  getText() {
    return this.getChildCount() === 0 ? "" : this.children.map(function(t) {
      return t.getText();
    }).join("");
  }
  getAltNumber() {
    return 0;
  }
  setAltNumber(t) {
  }
  setParent(t) {
    this.parent = t;
  }
  getChild(t) {
    return null;
  }
  getChildCount() {
    return 0;
  }
  accept(t) {
    return t.visitChildren(this);
  }
  toStringTree(t, e) {
    return P.toStringTree(this, t, e);
  }
  toString(t, e) {
    t = t || null, e = e || null;
    let n = this, s = "[";
    for (; n !== null && n !== e; ) {
      if (t === null)
        n.isEmpty() || (s += n.invokingState);
      else {
        let r = n.ruleIndex, o = r >= 0 && r < t.length ? t[r] : "" + r;
        s += o;
      }
      n.parent !== null && (t !== null || !n.parent.isEmpty()) && (s += " "), n = n.parent;
    }
    return s += "]", s;
  }
};
var x = class i15 {
  constructor(t) {
    this.cachedHashCode = t;
  }
  isEmpty() {
    return this === i15.EMPTY;
  }
  hasEmptyPath() {
    return this.getReturnState(this.length - 1) === i15.EMPTY_RETURN_STATE;
  }
  hashCode() {
    return this.cachedHashCode;
  }
  updateHashCode(t) {
    t.update(this.cachedHashCode);
  }
};
x.EMPTY = null;
x.EMPTY_RETURN_STATE = 2147483647;
x.globalNodeCount = 1;
x.id = x.globalNodeCount;
x.trace_atn_sim = false;
var et = class i16 extends x {
  constructor(t, e) {
    let n = new R();
    n.update(t, e);
    let s = n.finish();
    return super(s), this.parents = t, this.returnStates = e, this;
  }
  isEmpty() {
    return this.returnStates[0] === x.EMPTY_RETURN_STATE;
  }
  getParent(t) {
    return this.parents[t];
  }
  getReturnState(t) {
    return this.returnStates[t];
  }
  equals(t) {
    return this === t ? true : t instanceof i16 ? this.hashCode() !== t.hashCode() ? false : pt(this.returnStates, t.returnStates) && pt(this.parents, t.parents) : false;
  }
  toString() {
    if (this.isEmpty())
      return "[]";
    {
      let t = "[";
      for (let e = 0; e < this.returnStates.length; e++) {
        if (e > 0 && (t = t + ", "), this.returnStates[e] === x.EMPTY_RETURN_STATE) {
          t = t + "$";
          continue;
        }
        t = t + this.returnStates[e], this.parents[e] !== null ? t = t + " " + this.parents[e] : t = t + "null";
      }
      return t + "]";
    }
  }
  get length() {
    return this.returnStates.length;
  }
};
var v = class i17 extends x {
  constructor(t, e) {
    let n = 0, s = new R();
    t !== null ? s.update(t, e) : s.update(1), n = s.finish(), super(n), this.parent = t, this.returnState = e;
  }
  getParent(t) {
    return this.parent;
  }
  getReturnState(t) {
    return this.returnState;
  }
  equals(t) {
    return this === t ? true : t instanceof i17 ? this.hashCode() !== t.hashCode() || this.returnState !== t.returnState ? false : this.parent == null ? t.parent == null : this.parent.equals(t.parent) : false;
  }
  toString() {
    let t = this.parent === null ? "" : this.parent.toString();
    return t.length === 0 ? this.returnState === x.EMPTY_RETURN_STATE ? "$" : "" + this.returnState : "" + this.returnState + " " + t;
  }
  get length() {
    return 1;
  }
  static create(t, e) {
    return e === x.EMPTY_RETURN_STATE && t === null ? x.EMPTY : new i17(t, e);
  }
};
var qt = class extends v {
  constructor() {
    super(null, x.EMPTY_RETURN_STATE);
  }
  isEmpty() {
    return true;
  }
  getParent(t) {
    return null;
  }
  getReturnState(t) {
    return this.returnState;
  }
  equals(t) {
    return this === t;
  }
  toString() {
    return "$";
  }
};
x.EMPTY = new qt();
var ie = "h-";
var Q = class {
  constructor(t, e) {
    this.data = {}, this.hashFunction = t || Te, this.equalsFunction = e || Se;
  }
  set(t, e) {
    let n = ie + this.hashFunction(t);
    if (n in this.data) {
      let s = this.data[n];
      for (let r = 0; r < s.length; r++) {
        let o = s[r];
        if (this.equalsFunction(t, o.key)) {
          let l = o.value;
          return o.value = e, l;
        }
      }
      return s.push({ key: t, value: e }), e;
    } else
      return this.data[n] = [{ key: t, value: e }], e;
  }
  containsKey(t) {
    let e = ie + this.hashFunction(t);
    if (e in this.data) {
      let n = this.data[e];
      for (let s = 0; s < n.length; s++) {
        let r = n[s];
        if (this.equalsFunction(t, r.key))
          return true;
      }
    }
    return false;
  }
  get(t) {
    let e = ie + this.hashFunction(t);
    if (e in this.data) {
      let n = this.data[e];
      for (let s = 0; s < n.length; s++) {
        let r = n[s];
        if (this.equalsFunction(t, r.key))
          return r.value;
      }
    }
    return null;
  }
  entries() {
    return Object.keys(this.data).filter((t) => t.startsWith(ie)).flatMap((t) => this.data[t], this);
  }
  getKeys() {
    return this.entries().map((t) => t.key);
  }
  getValues() {
    return this.entries().map((t) => t.value);
  }
  toString() {
    return "[" + this.entries().map((e) => "{" + e.key + ":" + e.value + "}").join(", ") + "]";
  }
  get length() {
    return Object.keys(this.data).filter((t) => t.startsWith(ie)).map((t) => this.data[t].length, this).reduce((t, e) => t + e, 0);
  }
};
function oe(i63, t) {
  if (t == null && (t = U.EMPTY), t.parent === null || t === U.EMPTY)
    return x.EMPTY;
  let e = oe(i63, t.parent), s = i63.states[t.invokingState].transitions[0];
  return v.create(e, s.followState.stateNumber);
}
function Qe(i63, t, e) {
  if (i63.isEmpty())
    return i63;
  let n = e.get(i63) || null;
  if (n !== null)
    return n;
  if (n = t.get(i63), n !== null)
    return e.set(i63, n), n;
  let s = false, r = [];
  for (let l = 0; l < r.length; l++) {
    let a = Qe(i63.getParent(l), t, e);
    if (s || a !== i63.getParent(l)) {
      if (!s) {
        r = [];
        for (let u = 0; u < i63.length; u++)
          r[u] = i63.getParent(u);
        s = true;
      }
      r[l] = a;
    }
  }
  if (!s)
    return t.add(i63), e.set(i63, i63), i63;
  let o = null;
  return r.length === 0 ? o = x.EMPTY : r.length === 1 ? o = v.create(r[0], i63.getReturnState(0)) : o = new et(r, i63.returnStates), t.add(o), e.set(o, o), e.set(i63, o), o;
}
function Ae(i63, t, e, n) {
  if (i63 === t)
    return i63;
  if (i63 instanceof v && t instanceof v)
    return cn(i63, t, e, n);
  if (e) {
    if (i63 instanceof qt)
      return i63;
    if (t instanceof qt)
      return t;
  }
  return i63 instanceof v && (i63 = new et([i63.getParent()], [i63.returnState])), t instanceof v && (t = new et([t.getParent()], [t.returnState])), un(i63, t, e, n);
}
function un(i63, t, e, n) {
  if (n !== null) {
    let c = n.get(i63, t);
    if (c !== null)
      return x.trace_atn_sim && console.log("mergeArrays a=" + i63 + ",b=" + t + " -> previous"), c;
    if (c = n.get(t, i63), c !== null)
      return x.trace_atn_sim && console.log("mergeArrays a=" + i63 + ",b=" + t + " -> previous"), c;
  }
  let s = 0, r = 0, o = 0, l = new Array(i63.returnStates.length + t.returnStates.length).fill(0), a = new Array(i63.returnStates.length + t.returnStates.length).fill(null);
  for (; s < i63.returnStates.length && r < t.returnStates.length; ) {
    let c = i63.parents[s], f = t.parents[r];
    if (i63.returnStates[s] === t.returnStates[r]) {
      let p = i63.returnStates[s];
      p === x.EMPTY_RETURN_STATE && c === null && f === null || c !== null && f !== null && c === f ? (a[o] = c, l[o] = p) : (a[o] = Ae(c, f, e, n), l[o] = p), s += 1, r += 1;
    } else
      i63.returnStates[s] < t.returnStates[r] ? (a[o] = c, l[o] = i63.returnStates[s], s += 1) : (a[o] = f, l[o] = t.returnStates[r], r += 1);
    o += 1;
  }
  if (s < i63.returnStates.length)
    for (let c = s; c < i63.returnStates.length; c++)
      a[o] = i63.parents[c], l[o] = i63.returnStates[c], o += 1;
  else
    for (let c = r; c < t.returnStates.length; c++)
      a[o] = t.parents[c], l[o] = t.returnStates[c], o += 1;
  if (o < a.length) {
    if (o === 1) {
      let c = v.create(a[0], l[0]);
      return n !== null && n.set(i63, t, c), c;
    }
    a = a.slice(0, o), l = l.slice(0, o);
  }
  let u = new et(a, l);
  return u.equals(i63) ? (n !== null && n.set(i63, t, i63), x.trace_atn_sim && console.log("mergeArrays a=" + i63 + ",b=" + t + " -> a"), i63) : u.equals(t) ? (n !== null && n.set(i63, t, t), x.trace_atn_sim && console.log("mergeArrays a=" + i63 + ",b=" + t + " -> b"), t) : (hn(a), n !== null && n.set(i63, t, u), x.trace_atn_sim && console.log("mergeArrays a=" + i63 + ",b=" + t + " -> " + u), u);
}
function hn(i63) {
  let t = new Q();
  for (let e = 0; e < i63.length; e++) {
    let n = i63[e];
    t.containsKey(n) || t.set(n, n);
  }
  for (let e = 0; e < i63.length; e++)
    i63[e] = t.get(i63[e]);
}
function cn(i63, t, e, n) {
  if (n !== null) {
    let r = n.get(i63, t);
    if (r !== null || (r = n.get(t, i63), r !== null))
      return r;
  }
  let s = fn(i63, t, e);
  if (s !== null)
    return n !== null && n.set(i63, t, s), s;
  if (i63.returnState === t.returnState) {
    let r = Ae(i63.parent, t.parent, e, n);
    if (r === i63.parent)
      return i63;
    if (r === t.parent)
      return t;
    let o = v.create(r, i63.returnState);
    return n !== null && n.set(i63, t, o), o;
  } else {
    let r = null;
    if ((i63 === t || i63.parent !== null && i63.parent === t.parent) && (r = i63.parent), r !== null) {
      let u = [i63.returnState, t.returnState];
      i63.returnState > t.returnState && (u[0] = t.returnState, u[1] = i63.returnState);
      let c = [r, r], f = new et(c, u);
      return n !== null && n.set(i63, t, f), f;
    }
    let o = [i63.returnState, t.returnState], l = [i63.parent, t.parent];
    i63.returnState > t.returnState && (o[0] = t.returnState, o[1] = i63.returnState, l = [t.parent, i63.parent]);
    let a = new et(l, o);
    return n !== null && n.set(i63, t, a), a;
  }
}
function fn(i63, t, e) {
  if (e) {
    if (i63 === x.EMPTY)
      return x.EMPTY;
    if (t === x.EMPTY)
      return x.EMPTY;
  } else {
    if (i63 === x.EMPTY && t === x.EMPTY)
      return x.EMPTY;
    if (i63 === x.EMPTY) {
      let n = [t.returnState, x.EMPTY_RETURN_STATE], s = [t.parent, null];
      return new et(s, n);
    } else if (t === x.EMPTY) {
      let n = [i63.returnState, x.EMPTY_RETURN_STATE], s = [i63.parent, null];
      return new et(s, n);
    }
  }
  return null;
}
var H = class {
  constructor() {
    this.data = [];
  }
  clear(t) {
    t === void 0 ? this.data = [] : (this.resize(t), this.data[t >>> 5] &= ~(1 << t));
  }
  or(t) {
    let e = Math.min(this.data.length, t.data.length), n = 0;
    for (; n + 7 < e; n += 8)
      this.data[n] |= t.data[n], this.data[n + 1] |= t.data[n + 1], this.data[n + 2] |= t.data[n + 2], this.data[n + 3] |= t.data[n + 3], this.data[n + 4] |= t.data[n + 4], this.data[n + 5] |= t.data[n + 5], this.data[n + 6] |= t.data[n + 6], this.data[n + 7] |= t.data[n + 7];
    for (; n < e; ++n)
      this.data[n] |= t.data[n];
    if (this.data.length < t.data.length) {
      this.resize((t.data.length << 5) - 1);
      let s = t.data.length;
      for (let r = e; r < s; ++r)
        this.data[r] = t.data[r];
    }
  }
  get(t) {
    return (this.data[t >>> 5] & 1 << t) !== 0;
  }
  get length() {
    let t = 0, e = this.data.length, n = this.data;
    for (let s = 0; s < e; s++)
      t += this.bitCount(n[s]);
    return t;
  }
  values() {
    let t = new Array(this.length()), e = 0, n = this.data.length;
    for (let s = 0; s < n; ++s) {
      let r = this.data[s];
      for (; r != 0; ) {
        let o = r & -r;
        t[e++] = (s << 5) + this.bitCount(o - 1 | 0), r ^= o;
      }
    }
    return t;
  }
  nextSetBit(t) {
    for (let e of this)
      if (e > t)
        return e;
  }
  set(t) {
    this.resize(t), this.data[t >>> 5] |= 1 << t;
  }
  toString() {
    return "{" + this.values().join(", ") + "}";
  }
  resize(t) {
    let e = t + 32 >>> 5;
    for (let n = this.data.length; n < e; n++)
      this.data[n] = 0;
  }
  bitCount(t) {
    return t -= t >>> 1 & 1431655765, t = (t & 858993459) + (t >>> 2 & 858993459), (t + (t >>> 4) & 252645135) * 16843009 >>> 24;
  }
  [Symbol.iterator]() {
    let t = this.data.length, e = 0, n = this.data[e], s = this.bitCount, r = this.data;
    return { [Symbol.iterator]() {
      return this;
    }, next() {
      for (; e < t; )
        if (n !== 0) {
          let o = n & -n, l = (e << 5) + s(o - 1 | 0);
          return n ^= o, { done: false, value: l };
        } else
          e++, e < t && (n = r[e]);
      return { done: true, value: void 0 };
    } };
  }
};
var Rt = class i18 {
  constructor(t) {
    this.atn = t;
  }
  getDecisionLookahead(t) {
    if (t === null)
      return null;
    let e = t.transitions.length, n = [];
    for (let s = 0; s < e; s++) {
      n[s] = new D();
      let r = new k(), o = false;
      this._LOOK(t.transition(s).target, null, x.EMPTY, n[s], r, new H(), o, false), (n[s].length === 0 || n[s].contains(i18.HIT_PRED)) && (n[s] = null);
    }
    return n;
  }
  LOOK(t, e, n) {
    let s = new D(), r = true;
    n = n || null;
    let o = n !== null ? oe(t.atn, n) : null;
    return this._LOOK(t, e, o, s, new k(), new H(), r, true), s;
  }
  _LOOK(t, e, n, s, r, o, l, a) {
    let u = new C({ state: t, alt: 0, context: n }, null);
    if (!r.has(u)) {
      if (r.add(u), t === e) {
        if (n === null) {
          s.addOne(h.EPSILON);
          return;
        } else if (n.isEmpty() && a) {
          s.addOne(h.EOF);
          return;
        }
      }
      if (t instanceof L) {
        if (n === null) {
          s.addOne(h.EPSILON);
          return;
        } else if (n.isEmpty() && a) {
          s.addOne(h.EOF);
          return;
        }
        if (n !== x.EMPTY) {
          let c = o.get(t.ruleIndex);
          try {
            o.clear(t.ruleIndex);
            for (let f = 0; f < n.length; f++) {
              let p = this.atn.states[n.getReturnState(f)];
              this._LOOK(p, e, n.getParent(f), s, r, o, l, a);
            }
          } finally {
            c && o.set(t.ruleIndex);
          }
          return;
        }
      }
      for (let c = 0; c < t.transitions.length; c++) {
        let f = t.transitions[c];
        if (f.constructor === ht) {
          if (o.get(f.target.ruleIndex))
            continue;
          let p = v.create(n, f.followState.stateNumber);
          try {
            o.set(f.target.ruleIndex), this._LOOK(f.target, e, p, s, r, o, l, a);
          } finally {
            o.clear(f.target.ruleIndex);
          }
        } else if (f instanceof mt)
          l ? this._LOOK(f.target, e, n, s, r, o, l, a) : s.addOne(i18.HIT_PRED);
        else if (f.isEpsilon)
          this._LOOK(f.target, e, n, s, r, o, l, a);
        else if (f.constructor === Yt)
          s.addRange(h.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
        else {
          let p = f.label;
          p !== null && (f instanceof ot && (p = p.complement(h.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType)), s.addSet(p));
        }
      }
    }
  }
};
Rt.HIT_PRED = h.INVALID_TYPE;
var S = class {
  constructor(t, e) {
    this.grammarType = t, this.maxTokenType = e, this.states = [], this.decisionToState = [], this.ruleToStartState = [], this.ruleToStopState = [], this.modeNameToStartState = {}, this.ruleToTokenType = [], this.lexerActions = [], this.modeToStartState = [];
  }
  nextTokensInContext(t, e) {
    return new Rt(this).LOOK(t, null, e);
  }
  nextTokensNoContext(t) {
    return t.nextTokenWithinRule !== null || (t.nextTokenWithinRule = this.nextTokensInContext(t, null), t.nextTokenWithinRule.readOnly = true), t.nextTokenWithinRule;
  }
  nextTokens(t, e) {
    return e === void 0 ? this.nextTokensNoContext(t) : this.nextTokensInContext(t, e);
  }
  addState(t) {
    t !== null && (t.atn = this, t.stateNumber = this.states.length), this.states.push(t);
  }
  removeState(t) {
    this.states[t.stateNumber] = null;
  }
  defineDecisionState(t) {
    return this.decisionToState.push(t), t.decision = this.decisionToState.length - 1, t.decision;
  }
  getDecisionState(t) {
    return this.decisionToState.length === 0 ? null : this.decisionToState[t];
  }
  getExpectedTokens(t, e) {
    if (t < 0 || t >= this.states.length)
      throw "Invalid state number.";
    let n = this.states[t], s = this.nextTokens(n);
    if (!s.contains(h.EPSILON))
      return s;
    let r = new D();
    for (r.addSet(s), r.removeOne(h.EPSILON); e !== null && e.invokingState >= 0 && s.contains(h.EPSILON); ) {
      let l = this.states[e.invokingState].transitions[0];
      s = this.nextTokens(l.followState), r.addSet(s), r.removeOne(h.EPSILON), e = e.parent;
    }
    return s.contains(h.EPSILON) && r.addOne(h.EOF), r;
  }
};
S.INVALID_ALT_NUMBER = 0;
var wt = { LEXER: 0, PARSER: 1 };
var Ot = class extends _ {
  get stateType() {
    return m.BASIC;
  }
};
var B = class extends _ {
  constructor() {
    return super(), this.decision = -1, this.nonGreedy = false, this;
  }
};
var q = class extends B {
  constructor() {
    return super(), this.endState = null, this;
  }
};
var Kt = class extends _ {
  get stateType() {
    return m.BLOCK_END;
  }
};
var W = class extends _ {
  get stateType() {
    return m.LOOP_END;
  }
};
var le = class extends _ {
  constructor() {
    super(), this.isPrecedenceRule = false;
  }
  get stateType() {
    return m.RULE_START;
  }
};
var jt = class extends B {
  get stateType() {
    return m.TOKEN_START;
  }
};
var Dt = class extends B {
  get stateType() {
    return m.PLUS_LOOP_BACK;
  }
};
var St = class extends _ {
  get stateType() {
    return m.STAR_LOOP_BACK;
  }
};
var Y = class extends B {
  constructor() {
    super(), this.precedenceRuleDecision = false;
  }
  get stateType() {
    return m.STAR_LOOP_ENTRY;
  }
};
var Et = class extends q {
  get stateType() {
    return m.PLUS_BLOCK_START;
  }
};
var At = class extends q {
  get stateType() {
    return m.STAR_BLOCK_START;
  }
};
var ae = class extends q {
  get stateType() {
    return m.BLOCK_START;
  }
};
var Nt = class extends O {
  constructor(t, e) {
    super(t), this.label_ = e, this.label = this.makeLabel(), this.serializationType = d.ATOM;
  }
  makeLabel() {
    let t = new D();
    return t.addOne(this.label_), t;
  }
  matches(t, e, n) {
    return this.label_ === t;
  }
  toString() {
    return this.label_;
  }
};
var ue = class extends O {
  constructor(t, e, n) {
    super(t), this.serializationType = d.RANGE, this.start = e, this.stop = n, this.label = this.makeLabel();
  }
  makeLabel() {
    let t = new D();
    return t.addRange(this.start, this.stop), t;
  }
  matches(t, e, n) {
    return t >= this.start && t <= this.stop;
  }
  toString() {
    return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
  }
};
var Gt = class extends O {
  constructor(t, e, n, s) {
    super(t), this.serializationType = d.ACTION, this.ruleIndex = e, this.actionIndex = n === void 0 ? -1 : n, this.isCtxDependent = s === void 0 ? false : s, this.isEpsilon = true;
  }
  matches(t, e, n) {
    return false;
  }
  toString() {
    return "action_" + this.ruleIndex + ":" + this.actionIndex;
  }
};
var Ct = class extends O {
  constructor(t, e) {
    super(t), this.serializationType = d.EPSILON, this.isEpsilon = true, this.outermostPrecedenceReturn = e;
  }
  matches(t, e, n) {
    return false;
  }
  toString() {
    return "epsilon";
  }
};
var he = class i19 extends T {
  constructor(t) {
    super(), this.precedence = t === void 0 ? 0 : t;
  }
  evaluate(t, e) {
    return t.precpred(e, this.precedence);
  }
  evalPrecedence(t, e) {
    return t.precpred(e, this.precedence) ? T.NONE : null;
  }
  compareTo(t) {
    return this.precedence - t.precedence;
  }
  updateHashCode(t) {
    t.update(this.precedence);
  }
  equals(t) {
    return this === t ? true : t instanceof i19 ? this.precedence === t.precedence : false;
  }
  toString() {
    return "{" + this.precedence + ">=prec}?";
  }
};
T.PrecedencePredicate = he;
var Ne = class extends mt {
  constructor(t, e) {
    super(t), this.serializationType = d.PRECEDENCE, this.precedence = e, this.isEpsilon = true;
  }
  matches(t, e, n) {
    return false;
  }
  getPredicate() {
    return new he(this.precedence);
  }
  toString() {
    return this.precedence + " >= _p";
  }
};
var ct = class {
  constructor(t) {
    t === void 0 && (t = null), this.readOnly = false, this.verifyATN = t === null ? true : t.verifyATN, this.generateRuleBypassTransitions = t === null ? false : t.generateRuleBypassTransitions;
  }
};
ct.defaultOptions = new ct();
ct.defaultOptions.readOnly = true;
var y = { CHANNEL: 0, CUSTOM: 1, MODE: 2, MORE: 3, POP_MODE: 4, PUSH_MODE: 5, SKIP: 6, TYPE: 7 };
var F = class {
  constructor(t) {
    this.actionType = t, this.isPositionDependent = false;
  }
  hashCode() {
    let t = new R();
    return this.updateHashCode(t), t.finish();
  }
  updateHashCode(t) {
    t.update(this.actionType);
  }
  equals(t) {
    return this === t;
  }
};
var Wt = class extends F {
  constructor() {
    super(y.SKIP);
  }
  execute(t) {
    t.skip();
  }
  toString() {
    return "skip";
  }
};
Wt.INSTANCE = new Wt();
var Ce = class i20 extends F {
  constructor(t) {
    super(y.CHANNEL), this.channel = t;
  }
  execute(t) {
    t._channel = this.channel;
  }
  updateHashCode(t) {
    t.update(this.actionType, this.channel);
  }
  equals(t) {
    return this === t ? true : t instanceof i20 ? this.channel === t.channel : false;
  }
  toString() {
    return "channel(" + this.channel + ")";
  }
};
var ye = class i21 extends F {
  constructor(t, e) {
    super(y.CUSTOM), this.ruleIndex = t, this.actionIndex = e, this.isPositionDependent = true;
  }
  execute(t) {
    t.action(null, this.ruleIndex, this.actionIndex);
  }
  updateHashCode(t) {
    t.update(this.actionType, this.ruleIndex, this.actionIndex);
  }
  equals(t) {
    return this === t ? true : t instanceof i21 ? this.ruleIndex === t.ruleIndex && this.actionIndex === t.actionIndex : false;
  }
};
var Xt = class extends F {
  constructor() {
    super(y.MORE);
  }
  execute(t) {
    t.more();
  }
  toString() {
    return "more";
  }
};
Xt.INSTANCE = new Xt();
var _e = class i22 extends F {
  constructor(t) {
    super(y.TYPE), this.type = t;
  }
  execute(t) {
    t.type = this.type;
  }
  updateHashCode(t) {
    t.update(this.actionType, this.type);
  }
  equals(t) {
    return this === t ? true : t instanceof i22 ? this.type === t.type : false;
  }
  toString() {
    return "type(" + this.type + ")";
  }
};
var Ie = class i23 extends F {
  constructor(t) {
    super(y.PUSH_MODE), this.mode = t;
  }
  execute(t) {
    t.pushMode(this.mode);
  }
  updateHashCode(t) {
    t.update(this.actionType, this.mode);
  }
  equals(t) {
    return this === t ? true : t instanceof i23 ? this.mode === t.mode : false;
  }
  toString() {
    return "pushMode(" + this.mode + ")";
  }
};
var zt = class extends F {
  constructor() {
    super(y.POP_MODE);
  }
  execute(t) {
    t.popMode();
  }
  toString() {
    return "popMode";
  }
};
zt.INSTANCE = new zt();
var ke = class i24 extends F {
  constructor(t) {
    super(y.MODE), this.mode = t;
  }
  execute(t) {
    t.mode(this.mode);
  }
  updateHashCode(t) {
    t.update(this.actionType, this.mode);
  }
  equals(t) {
    return this === t ? true : t instanceof i24 ? this.mode === t.mode : false;
  }
  toString() {
    return "mode(" + this.mode + ")";
  }
};
var Ze = 4;
function Le(i63, t) {
  let e = [];
  return e[i63 - 1] = t, e.map(function(n) {
    return t;
  });
}
var yt = class {
  constructor(t) {
    t == null && (t = ct.defaultOptions), this.deserializationOptions = t, this.stateFactories = null, this.actionFactories = null;
  }
  deserialize(t) {
    let e = this.reset(t);
    this.checkVersion(e), e && this.skipUUID();
    let n = this.readATN();
    this.readStates(n, e), this.readRules(n, e), this.readModes(n);
    let s = [];
    return this.readSets(n, s, this.readInt.bind(this)), e && this.readSets(n, s, this.readInt32.bind(this)), this.readEdges(n, s), this.readDecisions(n), this.readLexerActions(n, e), this.markPrecedenceDecisions(n), this.verifyATN(n), this.deserializationOptions.generateRuleBypassTransitions && n.grammarType === wt.PARSER && (this.generateRuleBypassTransitions(n), this.verifyATN(n)), n;
  }
  reset(t) {
    if ((t.charCodeAt ? t.charCodeAt(0) : t[0]) === Ze - 1) {
      let n = function(r) {
        let o = r.charCodeAt(0);
        return o > 1 ? o - 2 : o + 65534;
      }, s = t.split("").map(n);
      return s[0] = t.charCodeAt(0), this.data = s, this.pos = 0, true;
    } else
      return this.data = t, this.pos = 0, false;
  }
  skipUUID() {
    let t = 0;
    for (; t++ < 8; )
      this.readInt();
  }
  checkVersion(t) {
    let e = this.readInt();
    if (!t && e !== Ze)
      throw "Could not deserialize ATN with version " + e + " (expected " + Ze + ").";
  }
  readATN() {
    let t = this.readInt(), e = this.readInt();
    return new S(t, e);
  }
  readStates(t, e) {
    let n, s, r, o = [], l = [], a = this.readInt();
    for (let f = 0; f < a; f++) {
      let p = this.readInt();
      if (p === m.INVALID_TYPE) {
        t.addState(null);
        continue;
      }
      let E = this.readInt();
      e && E === 65535 && (E = -1);
      let tt = this.stateFactory(p, E);
      if (p === m.LOOP_END) {
        let kt = this.readInt();
        o.push([tt, kt]);
      } else if (tt instanceof q) {
        let kt = this.readInt();
        l.push([tt, kt]);
      }
      t.addState(tt);
    }
    for (n = 0; n < o.length; n++)
      s = o[n], s[0].loopBackState = t.states[s[1]];
    for (n = 0; n < l.length; n++)
      s = l[n], s[0].endState = t.states[s[1]];
    let u = this.readInt();
    for (n = 0; n < u; n++)
      r = this.readInt(), t.states[r].nonGreedy = true;
    let c = this.readInt();
    for (n = 0; n < c; n++)
      r = this.readInt(), t.states[r].isPrecedenceRule = true;
  }
  readRules(t, e) {
    let n, s = this.readInt();
    for (t.grammarType === wt.LEXER && (t.ruleToTokenType = Le(s, 0)), t.ruleToStartState = Le(s, 0), n = 0; n < s; n++) {
      let r = this.readInt();
      if (t.ruleToStartState[n] = t.states[r], t.grammarType === wt.LEXER) {
        let o = this.readInt();
        e && o === 65535 && (o = h.EOF), t.ruleToTokenType[n] = o;
      }
    }
    for (t.ruleToStopState = Le(s, 0), n = 0; n < t.states.length; n++) {
      let r = t.states[n];
      r instanceof L && (t.ruleToStopState[r.ruleIndex] = r, t.ruleToStartState[r.ruleIndex].stopState = r);
    }
  }
  readModes(t) {
    let e = this.readInt();
    for (let n = 0; n < e; n++) {
      let s = this.readInt();
      t.modeToStartState.push(t.states[s]);
    }
  }
  readSets(t, e, n) {
    let s = this.readInt();
    for (let r = 0; r < s; r++) {
      let o = new D();
      e.push(o);
      let l = this.readInt();
      this.readInt() !== 0 && o.addOne(-1);
      for (let u = 0; u < l; u++) {
        let c = n(), f = n();
        o.addRange(c, f);
      }
    }
  }
  readEdges(t, e) {
    let n, s, r, o, l, a = this.readInt();
    for (n = 0; n < a; n++) {
      let u = this.readInt(), c = this.readInt(), f = this.readInt(), p = this.readInt(), E = this.readInt(), tt = this.readInt();
      o = this.edgeFactory(t, f, u, c, p, E, tt, e), t.states[u].addTransition(o);
    }
    for (n = 0; n < t.states.length; n++)
      for (r = t.states[n], s = 0; s < r.transitions.length; s++) {
        let u = r.transitions[s];
        if (!(u instanceof ht))
          continue;
        let c = -1;
        t.ruleToStartState[u.target.ruleIndex].isPrecedenceRule && u.precedence === 0 && (c = u.target.ruleIndex), o = new Ct(u.followState, c), t.ruleToStopState[u.target.ruleIndex].addTransition(o);
      }
    for (n = 0; n < t.states.length; n++) {
      if (r = t.states[n], r instanceof q) {
        if (r.endState === null || r.endState.startState)
          throw "IllegalState";
        r.endState.startState = r;
      }
      if (r instanceof Dt)
        for (s = 0; s < r.transitions.length; s++)
          l = r.transitions[s].target, l instanceof Et && (l.loopBackState = r);
      else if (r instanceof St)
        for (s = 0; s < r.transitions.length; s++)
          l = r.transitions[s].target, l instanceof Y && (l.loopBackState = r);
    }
  }
  readDecisions(t) {
    let e = this.readInt();
    for (let n = 0; n < e; n++) {
      let s = this.readInt(), r = t.states[s];
      t.decisionToState.push(r), r.decision = n;
    }
  }
  readLexerActions(t, e) {
    if (t.grammarType === wt.LEXER) {
      let n = this.readInt();
      t.lexerActions = Le(n, null);
      for (let s = 0; s < n; s++) {
        let r = this.readInt(), o = this.readInt();
        e && o === 65535 && (o = -1);
        let l = this.readInt();
        e && l === 65535 && (l = -1), t.lexerActions[s] = this.lexerActionFactory(r, o, l);
      }
    }
  }
  generateRuleBypassTransitions(t) {
    let e, n = t.ruleToStartState.length;
    for (e = 0; e < n; e++)
      t.ruleToTokenType[e] = t.maxTokenType + e + 1;
    for (e = 0; e < n; e++)
      this.generateRuleBypassTransition(t, e);
  }
  generateRuleBypassTransition(t, e) {
    let n, s, r = new ae();
    r.ruleIndex = e, t.addState(r);
    let o = new Kt();
    o.ruleIndex = e, t.addState(o), r.endState = o, t.defineDecisionState(r), o.startState = r;
    let l = null, a = null;
    if (t.ruleToStartState[e].isPrecedenceRule) {
      for (a = null, n = 0; n < t.states.length; n++)
        if (s = t.states[n], this.stateIsEndStateFor(s, e)) {
          a = s, l = s.loopBackState.transitions[0];
          break;
        }
      if (l === null)
        throw "Couldn't identify final state of the precedence rule prefix section.";
    } else
      a = t.ruleToStopState[e];
    for (n = 0; n < t.states.length; n++) {
      s = t.states[n];
      for (let p = 0; p < s.transitions.length; p++) {
        let E = s.transitions[p];
        E !== l && E.target === a && (E.target = o);
      }
    }
    let u = t.ruleToStartState[e], c = u.transitions.length;
    for (; c > 0; )
      r.addTransition(u.transitions[c - 1]), u.transitions = u.transitions.slice(-1);
    t.ruleToStartState[e].addTransition(new Ct(r)), o.addTransition(new Ct(a));
    let f = new Ot();
    t.addState(f), f.addTransition(new Nt(o, t.ruleToTokenType[e])), r.addTransition(new Ct(f));
  }
  stateIsEndStateFor(t, e) {
    if (t.ruleIndex !== e || !(t instanceof Y))
      return null;
    let n = t.transitions[t.transitions.length - 1].target;
    return n instanceof W && n.epsilonOnlyTransitions && n.transitions[0].target instanceof L ? t : null;
  }
  markPrecedenceDecisions(t) {
    for (let e = 0; e < t.states.length; e++) {
      let n = t.states[e];
      if (n instanceof Y && t.ruleToStartState[n.ruleIndex].isPrecedenceRule) {
        let s = n.transitions[n.transitions.length - 1].target;
        s instanceof W && s.epsilonOnlyTransitions && s.transitions[0].target instanceof L && (n.precedenceRuleDecision = true);
      }
    }
  }
  verifyATN(t) {
    if (this.deserializationOptions.verifyATN)
      for (let e = 0; e < t.states.length; e++) {
        let n = t.states[e];
        if (n !== null)
          if (this.checkCondition(n.epsilonOnlyTransitions || n.transitions.length <= 1), n instanceof Et)
            this.checkCondition(n.loopBackState !== null);
          else if (n instanceof Y)
            if (this.checkCondition(n.loopBackState !== null), this.checkCondition(n.transitions.length === 2), n.transitions[0].target instanceof At)
              this.checkCondition(n.transitions[1].target instanceof W), this.checkCondition(!n.nonGreedy);
            else if (n.transitions[0].target instanceof W)
              this.checkCondition(n.transitions[1].target instanceof At), this.checkCondition(n.nonGreedy);
            else
              throw "IllegalState";
          else
            n instanceof St ? (this.checkCondition(n.transitions.length === 1), this.checkCondition(n.transitions[0].target instanceof Y)) : n instanceof W ? this.checkCondition(n.loopBackState !== null) : n instanceof le ? this.checkCondition(n.stopState !== null) : n instanceof q ? this.checkCondition(n.endState !== null) : n instanceof Kt ? this.checkCondition(n.startState !== null) : n instanceof B ? this.checkCondition(n.transitions.length <= 1 || n.decision >= 0) : this.checkCondition(n.transitions.length <= 1 || n instanceof L);
      }
  }
  checkCondition(t, e) {
    if (!t)
      throw e == null && (e = "IllegalState"), e;
  }
  readInt() {
    return this.data[this.pos++];
  }
  readInt32() {
    let t = this.readInt(), e = this.readInt();
    return t | e << 16;
  }
  edgeFactory(t, e, n, s, r, o, l, a) {
    let u = t.states[s];
    switch (e) {
      case d.EPSILON:
        return new Ct(u);
      case d.RANGE:
        return l !== 0 ? new ue(u, h.EOF, o) : new ue(u, r, o);
      case d.RULE:
        return new ht(t.states[r], o, l, u);
      case d.PREDICATE:
        return new Vt(u, r, o, l !== 0);
      case d.PRECEDENCE:
        return new Ne(u, r);
      case d.ATOM:
        return l !== 0 ? new Nt(u, h.EOF) : new Nt(u, r);
      case d.ACTION:
        return new Gt(u, r, o, l !== 0);
      case d.SET:
        return new Tt(u, a[r]);
      case d.NOT_SET:
        return new ot(u, a[r]);
      case d.WILDCARD:
        return new Yt(u);
      default:
        throw "The specified transition type: " + e + " is not valid.";
    }
  }
  stateFactory(t, e) {
    if (this.stateFactories === null) {
      let n = [];
      n[m.INVALID_TYPE] = null, n[m.BASIC] = () => new Ot(), n[m.RULE_START] = () => new le(), n[m.BLOCK_START] = () => new ae(), n[m.PLUS_BLOCK_START] = () => new Et(), n[m.STAR_BLOCK_START] = () => new At(), n[m.TOKEN_START] = () => new jt(), n[m.RULE_STOP] = () => new L(), n[m.BLOCK_END] = () => new Kt(), n[m.STAR_LOOP_BACK] = () => new St(), n[m.STAR_LOOP_ENTRY] = () => new Y(), n[m.PLUS_LOOP_BACK] = () => new Dt(), n[m.LOOP_END] = () => new W(), this.stateFactories = n;
    }
    if (t > this.stateFactories.length || this.stateFactories[t] === null)
      throw "The specified state type " + t + " is not valid.";
    {
      let n = this.stateFactories[t]();
      if (n !== null)
        return n.ruleIndex = e, n;
    }
  }
  lexerActionFactory(t, e, n) {
    if (this.actionFactories === null) {
      let s = [];
      s[y.CHANNEL] = (r, o) => new Ce(r), s[y.CUSTOM] = (r, o) => new ye(r, o), s[y.MODE] = (r, o) => new ke(r), s[y.MORE] = (r, o) => Xt.INSTANCE, s[y.POP_MODE] = (r, o) => zt.INSTANCE, s[y.PUSH_MODE] = (r, o) => new Ie(r), s[y.SKIP] = (r, o) => Wt.INSTANCE, s[y.TYPE] = (r, o) => new _e(r), this.actionFactories = s;
    }
    if (t > this.actionFactories.length || this.actionFactories[t] === null)
      throw "The specified lexer action type " + t + " is not valid.";
    return this.actionFactories[t](e, n);
  }
};
var $t = class {
  visitTerminal(t) {
  }
  visitErrorNode(t) {
  }
  enterEveryRule(t) {
  }
  exitEveryRule(t) {
  }
};
var Re = class extends $t {
  constructor(t) {
    super(), this.parser = t;
  }
  enterEveryRule(t) {
    console.log("enter   " + this.parser.ruleNames[t.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
  }
  visitTerminal(t) {
    console.log("consume " + t.symbol + " rule " + this.parser.ruleNames[this.parser._ctx.ruleIndex]);
  }
  exitEveryRule(t) {
    console.log("exit    " + this.parser.ruleNames[t.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
  }
};
var Pt = class extends bt {
  constructor(t) {
    super(), this._input = null, this.errorHandler = new gt(), this._precedenceStack = [], this._precedenceStack.push(0), this._ctx = null, this.buildParseTrees = true, this._tracer = null, this._parseListeners = null, this._syntaxErrors = 0, this.tokenStream = t;
  }
  get context() {
    return this._ctx;
  }
  reset() {
    this._input !== null && this._input.seek(0), this.errorHandler.reset(this), this._ctx = null, this._syntaxErrors = 0, this.setTrace(false), this._precedenceStack = [], this._precedenceStack.push(0), this.interpreter !== null && this.interpreter.reset();
  }
  match(t) {
    let e = this.getCurrentToken();
    return e.type === t ? (this.errorHandler.reportMatch(this), this.consume()) : (e = this.errorHandler.recoverInline(this), this.buildParseTrees && e.tokenIndex === -1 && this._ctx.addErrorNode(e)), e;
  }
  matchWildcard() {
    let t = this.getCurrentToken();
    return t.type > 0 ? (this.errorHandler.reportMatch(this), this.consume()) : (t = this.errorHandler.recoverInline(this), this.buildParseTrees && t.tokenIndex === -1 && this._ctx.addErrorNode(t)), t;
  }
  getParseListeners() {
    return this._parseListeners || [];
  }
  addParseListener(t) {
    if (t === null)
      throw "listener";
    this._parseListeners === null && (this._parseListeners = []), this._parseListeners.push(t);
  }
  removeParseListener(t) {
    if (this._parseListeners !== null) {
      let e = this._parseListeners.indexOf(t);
      e >= 0 && this._parseListeners.splice(e, 1), this._parseListeners.length === 0 && (this._parseListeners = null);
    }
  }
  removeParseListeners() {
    this._parseListeners = null;
  }
  triggerEnterRuleEvent() {
    if (this._parseListeners !== null) {
      let t = this._ctx;
      this._parseListeners.forEach(function(e) {
        e.enterEveryRule(t), t.enterRule(e);
      });
    }
  }
  triggerExitRuleEvent() {
    if (this._parseListeners !== null) {
      let t = this._ctx;
      this._parseListeners.slice(0).reverse().forEach(function(e) {
        t.exitRule(e), e.exitEveryRule(t);
      });
    }
  }
  getTokenFactory() {
    return this._input.tokenSource._factory;
  }
  setTokenFactory(t) {
    this._input.tokenSource._factory = t;
  }
  getATNWithBypassAlts() {
    let t = this.getSerializedATN();
    if (t === null)
      throw "The current parser does not support an ATN with bypass alternatives.";
    let e = this.bypassAltsAtnCache[t];
    if (e === null) {
      let n = new ct();
      n.generateRuleBypassTransitions = true, e = new yt(n).deserialize(t), this.bypassAltsAtnCache[t] = e;
    }
    return e;
  }
  get tokenStream() {
    return this._input;
  }
  set tokenStream(t) {
    this._input = null, this.reset(), this._input = t;
  }
  get inputStream() {
    return this._input;
  }
  set inputStream(t) {
    this.tokenStream = t;
  }
  get syntaxErrorsCount() {
    return this._syntaxErrors;
  }
  getCurrentToken() {
    return this._input.LT(1);
  }
  notifyErrorListeners(t, e, n) {
    e = e || null, n = n || null, e === null && (e = this.getCurrentToken()), this._syntaxErrors += 1;
    let s = e.line, r = e.column;
    this.getErrorListenerDispatch().syntaxError(this, e, s, r, t, n);
  }
  consume() {
    let t = this.getCurrentToken();
    t.type !== h.EOF && this.tokenStream.consume();
    let e = this._parseListeners !== null && this._parseListeners.length > 0;
    if (this.buildParseTrees || e) {
      let n;
      this.errorHandler.inErrorRecoveryMode(this) ? n = this._ctx.addErrorNode(t) : n = this._ctx.addTokenNode(t), n.invokingState = this.state, e && this._parseListeners.forEach(function(s) {
        n instanceof it || n.isErrorNode !== void 0 && n.isErrorNode() ? s.visitErrorNode(n) : n instanceof w && s.visitTerminal(n);
      });
    }
    return t;
  }
  addContextToParseTree() {
    this._ctx.parent !== null && this._ctx.parent.addChild(this._ctx);
  }
  enterRule(t, e, n) {
    this.state = e, this._ctx = t, this._ctx.start = this._input.LT(1), this.buildParseTrees && this.addContextToParseTree(), this.triggerEnterRuleEvent();
  }
  exitRule() {
    this._ctx.stop = this._input.LT(-1), this.triggerExitRuleEvent(), this.state = this._ctx.invokingState, this._ctx = this._ctx.parent;
  }
  enterOuterAlt(t, e) {
    t.setAltNumber(e), this.buildParseTrees && this._ctx !== t && this._ctx.parent !== null && (this._ctx.parent.removeLastChild(), this._ctx.parent.addChild(t)), this._ctx = t;
  }
  getPrecedence() {
    return this._precedenceStack.length === 0 ? -1 : this._precedenceStack[this._precedenceStack.length - 1];
  }
  enterRecursionRule(t, e, n, s) {
    this.state = e, this._precedenceStack.push(s), this._ctx = t, this._ctx.start = this._input.LT(1), this.triggerEnterRuleEvent();
  }
  pushNewRecursionContext(t, e, n) {
    let s = this._ctx;
    s._parent = t, s.invokingState = e, s.stop = this._input.LT(-1), this._ctx = t, this._ctx.start = s.start, this.buildParseTrees && this._ctx.addChild(s), this.triggerEnterRuleEvent();
  }
  unrollRecursionContexts(t) {
    this._precedenceStack.pop(), this._ctx.stop = this._input.LT(-1);
    let e = this._ctx, n = this.getParseListeners();
    if (n !== null && n.length > 0)
      for (; this._ctx !== t; )
        this.triggerExitRuleEvent(), this._ctx = this._ctx.parent;
    else
      this._ctx = t;
    e._parent = t, this.buildParseTrees && t !== null && t.addChild(e);
  }
  getInvokingContext(t) {
    let e = this._ctx;
    for (; e !== null; ) {
      if (e.ruleIndex === t)
        return e;
      e = e.parent;
    }
    return null;
  }
  precpred(t, e) {
    return e >= this._precedenceStack[this._precedenceStack.length - 1];
  }
  inContext(t) {
    return false;
  }
  isExpectedToken(t) {
    let e = this.interpreter.atn, n = this._ctx, s = e.states[this.state], r = e.nextTokens(s);
    if (r.contains(t))
      return true;
    if (!r.contains(h.EPSILON))
      return false;
    for (; n !== null && n.invokingState >= 0 && r.contains(h.EPSILON); ) {
      let l = e.states[n.invokingState].transitions[0];
      if (r = e.nextTokens(l.followState), r.contains(t))
        return true;
      n = n.parent;
    }
    return !!(r.contains(h.EPSILON) && t === h.EOF);
  }
  getExpectedTokens() {
    return this.interpreter.atn.getExpectedTokens(this.state, this._ctx);
  }
  getExpectedTokensWithinCurrentRule() {
    let t = this.interpreter.atn, e = t.states[this.state];
    return t.nextTokens(e);
  }
  getRuleIndex(t) {
    let e = this.getRuleIndexMap().get(t);
    return e !== null ? e : -1;
  }
  getRuleInvocationStack(t) {
    t = t || null, t === null && (t = this._ctx);
    let e = [];
    for (; t !== null; ) {
      let n = t.ruleIndex;
      n < 0 ? e.push("n/a") : e.push(this.ruleNames[n]), t = t.parent;
    }
    return e;
  }
  getDFAStrings() {
    return this.interpreter.decisionToDFA.toString();
  }
  dumpDFA() {
    let t = false;
    for (let e = 0; e < this.interpreter.decisionToDFA.length; e++) {
      let n = this.interpreter.decisionToDFA[e];
      n.states.length > 0 && (t && console.log(), console.log("Decision " + n.decision + ":"), console.log(n.toString(this.vocabulary)), t = true);
    }
  }
  getSourceName() {
    return this._input.sourceName;
  }
  setTrace(t) {
    t ? (this._tracer !== null && this.removeParseListener(this._tracer), this._tracer = new Re(this), this.addParseListener(this._tracer)) : (this.removeParseListener(this._tracer), this._tracer = null);
  }
  createTerminalNode(t, e) {
    return new dt(e);
  }
  createErrorNode(t, e) {
    return new Lt(e);
  }
};
Pt.bypassAltsAtnCache = {};
function dn(i63) {
  return i63.hashCodeForConfigSet();
}
function pn(i63, t) {
  return i63 === t ? true : i63 === null || t === null ? false : i63.equalsForConfigSet(t);
}
var I = class i25 {
  constructor(t) {
    this.configLookup = new k(dn, pn), this.fullCtx = t === void 0 ? true : t, this.readOnly = false, this.configs = [], this.uniqueAlt = 0, this.conflictingAlts = null, this.hasSemanticContext = false, this.dipsIntoOuterContext = false, this.cachedHashCode = -1;
  }
  add(t, e) {
    if (e === void 0 && (e = null), this.readOnly)
      throw "This set is readonly";
    t.semanticContext !== T.NONE && (this.hasSemanticContext = true), t.reachesIntoOuterContext > 0 && (this.dipsIntoOuterContext = true);
    let n = this.configLookup.add(t);
    if (n === t)
      return this.cachedHashCode = -1, this.configs.push(t), true;
    let s = !this.fullCtx, r = Ae(n.context, t.context, s, e);
    return n.reachesIntoOuterContext = Math.max(n.reachesIntoOuterContext, t.reachesIntoOuterContext), t.precedenceFilterSuppressed && (n.precedenceFilterSuppressed = true), n.context = r, true;
  }
  getStates() {
    let t = new k();
    for (let e = 0; e < this.configs.length; e++)
      t.add(this.configs[e].state);
    return t;
  }
  getPredicates() {
    let t = [];
    for (let e = 0; e < this.configs.length; e++) {
      let n = this.configs[e].semanticContext;
      n !== T.NONE && t.push(n.semanticContext);
    }
    return t;
  }
  optimizeConfigs(t) {
    if (this.readOnly)
      throw "This set is readonly";
    if (this.configLookup.length !== 0)
      for (let e = 0; e < this.configs.length; e++) {
        let n = this.configs[e];
        n.context = t.getCachedContext(n.context);
      }
  }
  addAll(t) {
    for (let e = 0; e < t.length; e++)
      this.add(t[e]);
    return false;
  }
  equals(t) {
    return this === t || t instanceof i25 && pt(this.configs, t.configs) && this.fullCtx === t.fullCtx && this.uniqueAlt === t.uniqueAlt && this.conflictingAlts === t.conflictingAlts && this.hasSemanticContext === t.hasSemanticContext && this.dipsIntoOuterContext === t.dipsIntoOuterContext;
  }
  hashCode() {
    let t = new R();
    return t.update(this.configs), t.finish();
  }
  updateHashCode(t) {
    this.readOnly ? (this.cachedHashCode === -1 && (this.cachedHashCode = this.hashCode()), t.update(this.cachedHashCode)) : t.update(this.hashCode());
  }
  isEmpty() {
    return this.configs.length === 0;
  }
  contains(t) {
    if (this.configLookup === null)
      throw "This method is not implemented for readonly sets.";
    return this.configLookup.contains(t);
  }
  containsFast(t) {
    if (this.configLookup === null)
      throw "This method is not implemented for readonly sets.";
    return this.configLookup.containsFast(t);
  }
  clear() {
    if (this.readOnly)
      throw "This set is readonly";
    this.configs = [], this.cachedHashCode = -1, this.configLookup = new k();
  }
  setReadonly(t) {
    this.readOnly = t, t && (this.configLookup = null);
  }
  toString() {
    return G(this.configs) + (this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") + (this.uniqueAlt !== S.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") + (this.conflictingAlts !== null ? ",conflictingAlts=" + this.conflictingAlts : "") + (this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
  }
  get items() {
    return this.configs;
  }
  get length() {
    return this.configs.length;
  }
};
var X = class i26 {
  constructor(t, e) {
    return t === null && (t = -1), e === null && (e = new I()), this.stateNumber = t, this.configs = e, this.edges = null, this.isAcceptState = false, this.prediction = 0, this.lexerActionExecutor = null, this.requiresFullContext = false, this.predicates = null, this;
  }
  getAltSet() {
    let t = new k();
    if (this.configs !== null)
      for (let e = 0; e < this.configs.length; e++) {
        let n = this.configs[e];
        t.add(n.alt);
      }
    return t.length === 0 ? null : t;
  }
  equals(t) {
    return this === t || t instanceof i26 && this.configs.equals(t.configs);
  }
  toString() {
    let t = "" + this.stateNumber + ":" + this.configs;
    return this.isAcceptState && (t = t + "=>", this.predicates !== null ? t = t + this.predicates : t = t + this.prediction), t;
  }
  hashCode() {
    let t = new R();
    return t.update(this.configs), t.finish();
  }
};
var V = class {
  constructor(t, e) {
    return this.atn = t, this.sharedContextCache = e, this;
  }
  getCachedContext(t) {
    if (this.sharedContextCache === null)
      return t;
    let e = new Q();
    return Qe(t, this.sharedContextCache, e);
  }
};
V.ERROR = new X(2147483647, new I());
var ce = class extends I {
  constructor() {
    super(), this.configLookup = new k();
  }
};
var z = class i27 extends C {
  constructor(t, e) {
    super(t, e);
    let n = t.lexerActionExecutor || null;
    return this.lexerActionExecutor = n || (e !== null ? e.lexerActionExecutor : null), this.passedThroughNonGreedyDecision = e !== null ? this.checkNonGreedyDecision(e, this.state) : false, this.hashCodeForConfigSet = i27.prototype.hashCode, this.equalsForConfigSet = i27.prototype.equals, this;
  }
  updateHashCode(t) {
    t.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);
  }
  equals(t) {
    return this === t || t instanceof i27 && this.passedThroughNonGreedyDecision === t.passedThroughNonGreedyDecision && (this.lexerActionExecutor ? this.lexerActionExecutor.equals(t.lexerActionExecutor) : !t.lexerActionExecutor) && super.equals(t);
  }
  checkNonGreedyDecision(t, e) {
    return t.passedThroughNonGreedyDecision || e instanceof B && e.nonGreedy;
  }
};
var Qt = class i28 extends F {
  constructor(t, e) {
    super(e.actionType), this.offset = t, this.action = e, this.isPositionDependent = true;
  }
  execute(t) {
    this.action.execute(t);
  }
  updateHashCode(t) {
    t.update(this.actionType, this.offset, this.action);
  }
  equals(t) {
    return this === t ? true : t instanceof i28 ? this.offset === t.offset && this.action === t.action : false;
  }
};
var Pe = class i29 {
  constructor(t) {
    return this.lexerActions = t === null ? [] : t, this.cachedHashCode = R.hashStuff(t), this;
  }
  fixOffsetBeforeMatch(t) {
    let e = null;
    for (let n = 0; n < this.lexerActions.length; n++)
      this.lexerActions[n].isPositionDependent && !(this.lexerActions[n] instanceof Qt) && (e === null && (e = this.lexerActions.concat([])), e[n] = new Qt(t, this.lexerActions[n]));
    return e === null ? this : new i29(e);
  }
  execute(t, e, n) {
    let s = false, r = e.index;
    try {
      for (let o = 0; o < this.lexerActions.length; o++) {
        let l = this.lexerActions[o];
        if (l instanceof Qt) {
          let a = l.offset;
          e.seek(n + a), l = l.action, s = n + a !== r;
        } else
          l.isPositionDependent && (e.seek(r), s = false);
        l.execute(t);
      }
    } finally {
      s && e.seek(r);
    }
  }
  hashCode() {
    return this.cachedHashCode;
  }
  updateHashCode(t) {
    t.update(this.cachedHashCode);
  }
  equals(t) {
    if (this === t)
      return true;
    if (t instanceof i29) {
      if (this.cachedHashCode != t.cachedHashCode)
        return false;
      if (this.lexerActions.length != t.lexerActions.length)
        return false;
      {
        let e = this.lexerActions.length;
        for (let n = 0; n < e; ++n)
          if (!this.lexerActions[n].equals(t.lexerActions[n]))
            return false;
        return true;
      }
    } else
      return false;
  }
  static append(t, e) {
    if (t === null)
      return new i29([e]);
    let n = t.lexerActions.concat([e]);
    return new i29(n);
  }
};
function on(i63) {
  i63.index = -1, i63.line = 0, i63.column = -1, i63.dfaState = null;
}
var tn = class {
  constructor() {
    on(this);
  }
  reset() {
    on(this);
  }
};
var Z = class i30 extends V {
  constructor(t, e, n, s) {
    super(e, s), this.decisionToDFA = n, this.recog = t, this.startIndex = -1, this.line = 1, this.column = 0, this.mode = N.DEFAULT_MODE, this.prevAccept = new tn();
  }
  copyState(t) {
    this.column = t.column, this.line = t.line, this.mode = t.mode, this.startIndex = t.startIndex;
  }
  match(t, e) {
    this.mode = e;
    let n = t.mark();
    try {
      this.startIndex = t.index, this.prevAccept.reset();
      let s = this.decisionToDFA[e];
      return s.s0 === null ? this.matchATN(t) : this.execATN(t, s.s0);
    } finally {
      t.release(n);
    }
  }
  reset() {
    this.prevAccept.reset(), this.startIndex = -1, this.line = 1, this.column = 0, this.mode = N.DEFAULT_MODE;
  }
  matchATN(t) {
    let e = this.atn.modeToStartState[this.mode];
    i30.debug && console.log("matchATN mode " + this.mode + " start: " + e);
    let n = this.mode, s = this.computeStartState(t, e), r = s.hasSemanticContext;
    s.hasSemanticContext = false;
    let o = this.addDFAState(s);
    r || (this.decisionToDFA[this.mode].s0 = o);
    let l = this.execATN(t, o);
    return i30.debug && console.log("DFA after matchATN: " + this.decisionToDFA[n].toLexerString()), l;
  }
  execATN(t, e) {
    i30.debug && console.log("start state closure=" + e.configs), e.isAcceptState && this.captureSimState(this.prevAccept, t, e);
    let n = t.LA(1), s = e;
    for (; ; ) {
      i30.debug && console.log("execATN loop starting closure: " + s.configs);
      let r = this.getExistingTargetState(s, n);
      if (r === null && (r = this.computeTargetState(t, s, n)), r === V.ERROR || (n !== h.EOF && this.consume(t), r.isAcceptState && (this.captureSimState(this.prevAccept, t, r), n === h.EOF)))
        break;
      n = t.LA(1), s = r;
    }
    return this.failOrAccept(this.prevAccept, t, s.configs, n);
  }
  getExistingTargetState(t, e) {
    if (t.edges === null || e < i30.MIN_DFA_EDGE || e > i30.MAX_DFA_EDGE)
      return null;
    let n = t.edges[e - i30.MIN_DFA_EDGE];
    return n === void 0 && (n = null), i30.debug && n !== null && console.log("reuse state " + t.stateNumber + " edge to " + n.stateNumber), n;
  }
  computeTargetState(t, e, n) {
    let s = new ce();
    return this.getReachableConfigSet(t, e.configs, s, n), s.items.length === 0 ? (s.hasSemanticContext || this.addDFAEdge(e, n, V.ERROR), V.ERROR) : this.addDFAEdge(e, n, null, s);
  }
  failOrAccept(t, e, n, s) {
    if (this.prevAccept.dfaState !== null) {
      let r = t.dfaState.lexerActionExecutor;
      return this.accept(e, r, this.startIndex, t.index, t.line, t.column), t.dfaState.prediction;
    } else {
      if (s === h.EOF && e.index === this.startIndex)
        return h.EOF;
      throw new rt(this.recog, e, this.startIndex, n);
    }
  }
  getReachableConfigSet(t, e, n, s) {
    let r = S.INVALID_ALT_NUMBER;
    for (let o = 0; o < e.items.length; o++) {
      let l = e.items[o], a = l.alt === r;
      if (!(a && l.passedThroughNonGreedyDecision)) {
        i30.debug && console.log(`testing %s at %s
`, this.getTokenName(s), l.toString(this.recog, true));
        for (let u = 0; u < l.state.transitions.length; u++) {
          let c = l.state.transitions[u], f = this.getReachableTarget(c, s);
          if (f !== null) {
            let p = l.lexerActionExecutor;
            p !== null && (p = p.fixOffsetBeforeMatch(t.index - this.startIndex));
            let E = s === h.EOF, tt = new z({ state: f, lexerActionExecutor: p }, l);
            this.closure(t, tt, n, a, true, E) && (r = l.alt);
          }
        }
      }
    }
  }
  accept(t, e, n, s, r, o) {
    i30.debug && console.log(`ACTION %s
`, e), t.seek(s), this.line = r, this.column = o, e !== null && this.recog !== null && e.execute(this.recog, t, n);
  }
  getReachableTarget(t, e) {
    return t.matches(e, 0, N.MAX_CHAR_VALUE) ? t.target : null;
  }
  computeStartState(t, e) {
    let n = x.EMPTY, s = new ce();
    for (let r = 0; r < e.transitions.length; r++) {
      let o = e.transitions[r].target, l = new z({ state: o, alt: r + 1, context: n }, null);
      this.closure(t, l, s, false, false, false);
    }
    return s;
  }
  closure(t, e, n, s, r, o) {
    let l = null;
    if (i30.debug && console.log("closure(" + e.toString(this.recog, true) + ")"), e.state instanceof L) {
      if (i30.debug && (this.recog !== null ? console.log(`closure at %s rule stop %s
`, this.recog.ruleNames[e.state.ruleIndex], e) : console.log(`closure at rule stop %s
`, e)), e.context === null || e.context.hasEmptyPath()) {
        if (e.context === null || e.context.isEmpty())
          return n.add(e), true;
        n.add(new z({ state: e.state, context: x.EMPTY }, e)), s = true;
      }
      if (e.context !== null && !e.context.isEmpty()) {
        for (let a = 0; a < e.context.length; a++)
          if (e.context.getReturnState(a) !== x.EMPTY_RETURN_STATE) {
            let u = e.context.getParent(a), c = this.atn.states[e.context.getReturnState(a)];
            l = new z({ state: c, context: u }, e), s = this.closure(t, l, n, s, r, o);
          }
      }
      return s;
    }
    e.state.epsilonOnlyTransitions || (!s || !e.passedThroughNonGreedyDecision) && n.add(e);
    for (let a = 0; a < e.state.transitions.length; a++) {
      let u = e.state.transitions[a];
      l = this.getEpsilonTarget(t, e, u, n, r, o), l !== null && (s = this.closure(t, l, n, s, r, o));
    }
    return s;
  }
  getEpsilonTarget(t, e, n, s, r, o) {
    let l = null;
    if (n.serializationType === d.RULE) {
      let a = v.create(e.context, n.followState.stateNumber);
      l = new z({ state: n.target, context: a }, e);
    } else {
      if (n.serializationType === d.PRECEDENCE)
        throw "Precedence predicates are not supported in lexers.";
      if (n.serializationType === d.PREDICATE)
        i30.debug && console.log("EVAL rule " + n.ruleIndex + ":" + n.predIndex), s.hasSemanticContext = true, this.evaluatePredicate(t, n.ruleIndex, n.predIndex, r) && (l = new z({ state: n.target }, e));
      else if (n.serializationType === d.ACTION)
        if (e.context === null || e.context.hasEmptyPath()) {
          let a = Pe.append(e.lexerActionExecutor, this.atn.lexerActions[n.actionIndex]);
          l = new z({ state: n.target, lexerActionExecutor: a }, e);
        } else
          l = new z({ state: n.target }, e);
      else
        n.serializationType === d.EPSILON ? l = new z({ state: n.target }, e) : (n.serializationType === d.ATOM || n.serializationType === d.RANGE || n.serializationType === d.SET) && o && n.matches(h.EOF, 0, N.MAX_CHAR_VALUE) && (l = new z({ state: n.target }, e));
    }
    return l;
  }
  evaluatePredicate(t, e, n, s) {
    if (this.recog === null)
      return true;
    if (!s)
      return this.recog.sempred(null, e, n);
    let r = this.column, o = this.line, l = t.index, a = t.mark();
    try {
      return this.consume(t), this.recog.sempred(null, e, n);
    } finally {
      this.column = r, this.line = o, t.seek(l), t.release(a);
    }
  }
  captureSimState(t, e, n) {
    t.index = e.index, t.line = this.line, t.column = this.column, t.dfaState = n;
  }
  addDFAEdge(t, e, n, s) {
    if (n === void 0 && (n = null), s === void 0 && (s = null), n === null && s !== null) {
      let r = s.hasSemanticContext;
      if (s.hasSemanticContext = false, n = this.addDFAState(s), r)
        return n;
    }
    return e < i30.MIN_DFA_EDGE || e > i30.MAX_DFA_EDGE || (i30.debug && console.log("EDGE " + t + " -> " + n + " upon " + e), t.edges === null && (t.edges = []), t.edges[e - i30.MIN_DFA_EDGE] = n), n;
  }
  addDFAState(t) {
    let e = new X(null, t), n = null;
    for (let l = 0; l < t.items.length; l++) {
      let a = t.items[l];
      if (a.state instanceof L) {
        n = a;
        break;
      }
    }
    n !== null && (e.isAcceptState = true, e.lexerActionExecutor = n.lexerActionExecutor, e.prediction = this.atn.ruleToTokenType[n.state.ruleIndex]);
    let s = this.decisionToDFA[this.mode], r = s.states.get(e);
    if (r !== null)
      return r;
    let o = e;
    return o.stateNumber = s.states.length, t.setReadonly(true), o.configs = t, s.states.add(o), o;
  }
  getDFA(t) {
    return this.decisionToDFA[t];
  }
  getText(t) {
    return t.getText(this.startIndex, t.index - 1);
  }
  consume(t) {
    t.LA(1) === `
`.charCodeAt(0) ? (this.line += 1, this.column = 0) : this.column += 1, t.consume();
  }
  getTokenName(t) {
    return t === -1 ? "EOF" : "'" + String.fromCharCode(t) + "'";
  }
};
Z.debug = false;
Z.dfa_debug = false;
Z.MIN_DFA_EDGE = 0;
Z.MAX_DFA_EDGE = 127;
var lt = class {
  constructor() {
    this.cache = new Q();
  }
  add(t) {
    if (t === x.EMPTY)
      return x.EMPTY;
    let e = this.cache.get(t) || null;
    return e !== null ? e : (this.cache.set(t, t), t);
  }
  get(t) {
    return this.cache.get(t) || null;
  }
  get length() {
    return this.cache.length;
  }
};
var Zt = class {
  constructor(t, e, n) {
    this.dfa = t, this.literalNames = e || [], this.symbolicNames = n || [];
  }
  toString() {
    if (this.dfa.s0 === null)
      return null;
    let t = "", e = this.dfa.sortedStates();
    for (let n = 0; n < e.length; n++) {
      let s = e[n];
      if (s.edges !== null) {
        let r = s.edges.length;
        for (let o = 0; o < r; o++) {
          let l = s.edges[o] || null;
          l !== null && l.stateNumber !== 2147483647 && (t = t.concat(this.getStateString(s)), t = t.concat("-"), t = t.concat(this.getEdgeLabel(o)), t = t.concat("->"), t = t.concat(this.getStateString(l)), t = t.concat(`
`));
        }
      }
    }
    return t.length === 0 ? null : t;
  }
  getEdgeLabel(t) {
    return t === 0 ? "EOF" : this.literalNames !== null || this.symbolicNames !== null ? this.literalNames[t - 1] || this.symbolicNames[t - 1] : String.fromCharCode(t - 1);
  }
  getStateString(t) {
    let e = (t.isAcceptState ? ":" : "") + "s" + t.stateNumber + (t.requiresFullContext ? "^" : "");
    return t.isAcceptState ? t.predicates !== null ? e + "=>" + G(t.predicates) : e + "=>" + t.prediction.toString() : e;
  }
};
var Fe = class extends Zt {
  constructor(t) {
    super(t, null);
  }
  getEdgeLabel(t) {
    return "'" + String.fromCharCode(t) + "'";
  }
};
var at = class {
  constructor(t, e) {
    if (e === void 0 && (e = 0), this.atnStartState = t, this.decision = e, this._states = new k(), this.s0 = null, this.precedenceDfa = false, t instanceof Y && t.precedenceRuleDecision) {
      this.precedenceDfa = true;
      let n = new X(null, new I());
      n.edges = [], n.isAcceptState = false, n.requiresFullContext = false, this.s0 = n;
    }
  }
  getPrecedenceStartState(t) {
    if (!this.precedenceDfa)
      throw "Only precedence DFAs may contain a precedence start state.";
    return t < 0 || t >= this.s0.edges.length ? null : this.s0.edges[t] || null;
  }
  setPrecedenceStartState(t, e) {
    if (!this.precedenceDfa)
      throw "Only precedence DFAs may contain a precedence start state.";
    t < 0 || (this.s0.edges[t] = e);
  }
  setPrecedenceDfa(t) {
    if (this.precedenceDfa !== t) {
      if (this._states = new k(), t) {
        let e = new X(null, new I());
        e.edges = [], e.isAcceptState = false, e.requiresFullContext = false, this.s0 = e;
      } else
        this.s0 = null;
      this.precedenceDfa = t;
    }
  }
  sortedStates() {
    return this._states.values().sort(function(e, n) {
      return e.stateNumber - n.stateNumber;
    });
  }
  toString(t, e) {
    return t = t || null, e = e || null, this.s0 === null ? "" : new Zt(this, t, e).toString();
  }
  toLexerString() {
    return this.s0 === null ? "" : new Fe(this).toString();
  }
  get states() {
    return this._states;
  }
};
var nt = class extends U {
  constructor(t, e) {
    super(t, e), this.children = null, this.start = null, this.stop = null, this.exception = null;
  }
  copyFrom(t) {
    this._parent = t._parent, this.invokingState = t.invokingState, this.children = null, this.start = t.start, this.stop = t.stop, t.children && (this.children = [], t.children.map(function(e) {
      e instanceof Lt && (this.children.push(e), e.parent = this);
    }, this));
  }
  enterRule(t) {
  }
  exitRule(t) {
  }
  addChild(t) {
    return this.children === null && (this.children = []), this.children.push(t), t;
  }
  removeLastChild() {
    this.children !== null && this.children.pop();
  }
  addTokenNode(t) {
    let e = new dt(t);
    return this.addChild(e), e.parent = this, e;
  }
  addErrorNode(t) {
    let e = new Lt(t);
    return this.addChild(e), e.parent = this, e;
  }
  getChild(t, e) {
    if (e = e ?? null, this.children === null || t < 0 || t >= this.children.length)
      return null;
    if (e === null)
      return this.children[t];
    for (let n = 0; n < this.children.length; n++) {
      let s = this.children[n];
      if (s instanceof e) {
        if (t === 0)
          return s;
        t -= 1;
      }
    }
    return null;
  }
  getToken(t, e) {
    if (this.children === null || e < 0 || e >= this.children.length)
      return null;
    for (let n = 0; n < this.children.length; n++) {
      let s = this.children[n];
      if (s instanceof w && s.symbol.type === t) {
        if (e === 0)
          return s;
        e -= 1;
      }
    }
    return null;
  }
  getTokens(t) {
    if (this.children === null)
      return [];
    {
      let e = [];
      for (let n = 0; n < this.children.length; n++) {
        let s = this.children[n];
        s instanceof w && s.symbol.type === t && e.push(s);
      }
      return e;
    }
  }
  getRuleContext(t, e) {
    return this.getChild(t, e);
  }
  getRuleContexts(t) {
    if (this.children === null)
      return [];
    {
      let e = [];
      for (let n = 0; n < this.children.length; n++) {
        let s = this.children[n];
        s instanceof t && e.push(s);
      }
      return e;
    }
  }
  getChildCount() {
    return this.children === null ? 0 : this.children.length;
  }
  getSourceInterval() {
    return this.start === null || this.stop === null ? g.INVALID_INTERVAL : new g(this.start.tokenIndex, this.stop.tokenIndex);
  }
};
U.EMPTY = new nt();
var se = class {
  walk(t, e) {
    if (e instanceof it || e.isErrorNode !== void 0 && e.isErrorNode())
      t.visitErrorNode(e);
    else if (e instanceof w)
      t.visitTerminal(e);
    else {
      this.enterRule(t, e);
      for (let s = 0; s < e.getChildCount(); s++) {
        let r = e.getChild(s);
        this.walk(t, r);
      }
      this.exitRule(t, e);
    }
  }
  enterRule(t, e) {
    let n = e.ruleContext;
    t.enterEveryRule(n), n.enterRule(t);
  }
  exitRule(t, e) {
    let n = e.ruleContext;
    n.exitRule(t), t.exitEveryRule(n);
  }
};
se.DEFAULT = new se();
var K = class i31 extends N {
  static TOKEN_REF = 1;
  static RULE_REF = 2;
  static ANYWHERE = 3;
  static ROOT = 4;
  static WILDCARD = 5;
  static BANG = 6;
  static ID = 7;
  static STRING = 8;
  static EOF = h.EOF;
  static channelNames = ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"];
  static literalNames = [null, null, null, "'//'", "'/'", "'*'", "'!'"];
  static symbolicNames = [null, "TOKEN_REF", "RULE_REF", "ANYWHERE", "ROOT", "WILDCARD", "BANG", "ID", "STRING"];
  static modeNames = ["DEFAULT_MODE"];
  static ruleNames = ["ANYWHERE", "ROOT", "WILDCARD", "BANG", "ID", "NameChar", "NameStartChar", "STRING"];
  constructor(t) {
    super(t), this.interpreter = new Z(this, i31._ATN, i31.decisionsToDFA, new lt());
  }
  get grammarFileName() {
    return "XPathLexer.g4";
  }
  get literalNames() {
    return i31.literalNames;
  }
  get symbolicNames() {
    return i31.symbolicNames;
  }
  get ruleNames() {
    return i31.ruleNames;
  }
  get serializedATN() {
    return i31._serializedATN;
  }
  get channelNames() {
    return i31.channelNames;
  }
  get modeNames() {
    return i31.modeNames;
  }
  action(t, e, n) {
    switch (e) {
      case 4:
        this.ID_action(t, n);
        break;
    }
  }
  ID_action(t, e) {
    switch (e) {
      case 0: {
        let n = this.text;
        n.charAt(0) === n.charAt(0).toUpperCase() ? this._type = i31.TOKEN_REF : this._type = i31.RULE_REF;
        break;
      }
    }
  }
  static _serializedATN = [4, 0, 8, 48, 6, -1, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 2, 1, 2, 1, 3, 1, 3, 1, 4, 1, 4, 5, 4, 29, 8, 4, 10, 4, 12, 4, 32, 9, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 6, 1, 6, 1, 7, 1, 7, 5, 7, 42, 8, 7, 10, 7, 12, 7, 45, 9, 7, 1, 7, 1, 7, 1, 43, 0, 8, 1, 3, 3, 4, 5, 5, 7, 6, 9, 7, 11, 0, 13, 0, 15, 8, 1, 0, 2, 784, 0, 0, 8, 14, 27, 48, 57, 65, 90, 95, 95, 97, 122, 127, 159, 170, 170, 173, 173, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 895, 895, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1327, 1329, 1366, 1369, 1369, 1376, 1416, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1519, 1522, 1536, 1541, 1552, 1562, 1564, 1564, 1568, 1641, 1646, 1747, 1749, 1757, 1759, 1768, 1770, 1788, 1791, 1791, 1807, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2045, 2045, 2048, 2093, 2112, 2139, 2144, 2154, 2160, 2183, 2185, 2190, 2192, 2193, 2200, 2403, 2406, 2415, 2417, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2556, 2556, 2558, 2558, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2809, 2815, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2901, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3072, 3084, 3086, 3088, 3090, 3112, 3114, 3129, 3132, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3162, 3165, 3165, 3168, 3171, 3174, 3183, 3200, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3293, 3294, 3296, 3299, 3302, 3311, 3313, 3315, 3328, 3340, 3342, 3344, 3346, 3396, 3398, 3400, 3402, 3406, 3412, 3415, 3423, 3427, 3430, 3439, 3450, 3455, 3457, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3558, 3567, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3718, 3722, 3724, 3747, 3749, 3749, 3751, 3773, 3776, 3780, 3782, 3782, 3784, 3790, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5109, 5112, 5117, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5880, 5888, 5909, 5919, 5940, 5952, 5971, 5984, 5996, 5998, 6e3, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6169, 6176, 6264, 6272, 6314, 6320, 6389, 6400, 6430, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6832, 6845, 6847, 6862, 6912, 6988, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7296, 7304, 7312, 7354, 7357, 7359, 7376, 7378, 7380, 7418, 7424, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8203, 8207, 8234, 8238, 8255, 8256, 8276, 8276, 8288, 8292, 8294, 8303, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12591, 12593, 12686, 12704, 12735, 12784, 12799, 13312, 19903, 19968, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42737, 42775, 42783, 42786, 42888, 42891, 42954, 42960, 42961, 42963, 42963, 42965, 42969, 42994, 43047, 43052, 43052, 43072, 43123, 43136, 43205, 43216, 43225, 43232, 43255, 43259, 43259, 43261, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43488, 43518, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43824, 43866, 43868, 43881, 43888, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65071, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65279, 65279, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65529, 65531, 65536, 65547, 65549, 65574, 65576, 65594, 65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786, 65856, 65908, 66045, 66045, 66176, 66204, 66208, 66256, 66272, 66272, 66304, 66335, 66349, 66378, 66384, 66426, 66432, 66461, 66464, 66499, 66504, 66511, 66513, 66517, 66560, 66717, 66720, 66729, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 66928, 66938, 66940, 66954, 66956, 66962, 66964, 66965, 66967, 66977, 66979, 66993, 66995, 67001, 67003, 67004, 67072, 67382, 67392, 67413, 67424, 67431, 67456, 67461, 67463, 67504, 67506, 67514, 67584, 67589, 67592, 67592, 67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669, 67680, 67702, 67712, 67742, 67808, 67826, 67828, 67829, 67840, 67861, 67872, 67897, 67968, 68023, 68030, 68031, 68096, 68099, 68101, 68102, 68108, 68115, 68117, 68119, 68121, 68149, 68152, 68154, 68159, 68159, 68192, 68220, 68224, 68252, 68288, 68295, 68297, 68326, 68352, 68405, 68416, 68437, 68448, 68466, 68480, 68497, 68608, 68680, 68736, 68786, 68800, 68850, 68864, 68903, 68912, 68921, 69248, 69289, 69291, 69292, 69296, 69297, 69373, 69404, 69415, 69415, 69424, 69456, 69488, 69509, 69552, 69572, 69600, 69622, 69632, 69702, 69734, 69749, 69759, 69818, 69821, 69821, 69826, 69826, 69837, 69837, 69840, 69864, 69872, 69881, 69888, 69940, 69942, 69951, 69956, 69959, 69968, 70003, 70006, 70006, 70016, 70084, 70089, 70092, 70094, 70106, 70108, 70108, 70144, 70161, 70163, 70199, 70206, 70209, 70272, 70278, 70280, 70280, 70282, 70285, 70287, 70301, 70303, 70312, 70320, 70378, 70384, 70393, 70400, 70403, 70405, 70412, 70415, 70416, 70419, 70440, 70442, 70448, 70450, 70451, 70453, 70457, 70459, 70468, 70471, 70472, 70475, 70477, 70480, 70480, 70487, 70487, 70493, 70499, 70502, 70508, 70512, 70516, 70656, 70730, 70736, 70745, 70750, 70753, 70784, 70853, 70855, 70855, 70864, 70873, 71040, 71093, 71096, 71104, 71128, 71133, 71168, 71232, 71236, 71236, 71248, 71257, 71296, 71352, 71360, 71369, 71424, 71450, 71453, 71467, 71472, 71481, 71488, 71494, 71680, 71738, 71840, 71913, 71935, 71942, 71945, 71945, 71948, 71955, 71957, 71958, 71960, 71989, 71991, 71992, 71995, 72003, 72016, 72025, 72096, 72103, 72106, 72151, 72154, 72161, 72163, 72164, 72192, 72254, 72263, 72263, 72272, 72345, 72349, 72349, 72368, 72440, 72704, 72712, 72714, 72758, 72760, 72768, 72784, 72793, 72818, 72847, 72850, 72871, 72873, 72886, 72960, 72966, 72968, 72969, 72971, 73014, 73018, 73018, 73020, 73021, 73023, 73031, 73040, 73049, 73056, 73061, 73063, 73064, 73066, 73102, 73104, 73105, 73107, 73112, 73120, 73129, 73440, 73462, 73472, 73488, 73490, 73530, 73534, 73538, 73552, 73561, 73648, 73648, 73728, 74649, 74752, 74862, 74880, 75075, 77712, 77808, 77824, 78933, 82944, 83526, 92160, 92728, 92736, 92766, 92768, 92777, 92784, 92862, 92864, 92873, 92880, 92909, 92912, 92916, 92928, 92982, 92992, 92995, 93008, 93017, 93027, 93047, 93053, 93071, 93760, 93823, 93952, 94026, 94031, 94087, 94095, 94111, 94176, 94177, 94179, 94180, 94192, 94193, 94208, 100343, 100352, 101589, 101632, 101640, 110576, 110579, 110581, 110587, 110589, 110590, 110592, 110882, 110898, 110898, 110928, 110930, 110933, 110933, 110948, 110951, 110960, 111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 113821, 113822, 113824, 113827, 118528, 118573, 118576, 118598, 119141, 119145, 119149, 119170, 119173, 119179, 119210, 119213, 119362, 119364, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 120782, 120831, 121344, 121398, 121403, 121452, 121461, 121461, 121476, 121476, 121499, 121503, 121505, 121519, 122624, 122654, 122661, 122666, 122880, 122886, 122888, 122904, 122907, 122913, 122915, 122916, 122918, 122922, 122928, 122989, 123023, 123023, 123136, 123180, 123184, 123197, 123200, 123209, 123214, 123214, 123536, 123566, 123584, 123641, 124112, 124153, 124896, 124902, 124904, 124907, 124909, 124910, 124912, 124926, 124928, 125124, 125136, 125142, 125184, 125259, 125264, 125273, 126464, 126467, 126469, 126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 130032, 130041, 131072, 173791, 173824, 177977, 177984, 178205, 178208, 183969, 183984, 191456, 194560, 195101, 196608, 201546, 201552, 205743, 917505, 917505, 917536, 917631, 917760, 917999, 662, 0, 65, 90, 97, 122, 170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 895, 895, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1327, 1329, 1366, 1369, 1369, 1376, 1416, 1488, 1514, 1519, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2144, 2154, 2160, 2183, 2185, 2190, 2208, 2249, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2432, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2556, 2556, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2809, 2809, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3129, 3133, 3133, 3160, 3162, 3165, 3165, 3168, 3169, 3200, 3200, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3293, 3294, 3296, 3297, 3313, 3314, 3332, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3412, 3414, 3423, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3718, 3722, 3724, 3747, 3749, 3749, 3751, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5109, 5112, 5117, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5880, 5888, 5905, 5919, 5937, 5952, 5969, 5984, 5996, 5998, 6e3, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6264, 6272, 6276, 6279, 6312, 6314, 6314, 6320, 6389, 6400, 6430, 6480, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6988, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7296, 7304, 7312, 7354, 7357, 7359, 7401, 7404, 7406, 7411, 7413, 7414, 7418, 7418, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12591, 12593, 12686, 12704, 12735, 12784, 12799, 13312, 19903, 19968, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42653, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42954, 42960, 42961, 42963, 42963, 42965, 42969, 42994, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43261, 43262, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43488, 43492, 43494, 43503, 43514, 43518, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43646, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43824, 43866, 43868, 43881, 43888, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594, 65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786, 65856, 65908, 66176, 66204, 66208, 66256, 66304, 66335, 66349, 66378, 66384, 66421, 66432, 66461, 66464, 66499, 66504, 66511, 66513, 66517, 66560, 66717, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 66928, 66938, 66940, 66954, 66956, 66962, 66964, 66965, 66967, 66977, 66979, 66993, 66995, 67001, 67003, 67004, 67072, 67382, 67392, 67413, 67424, 67431, 67456, 67461, 67463, 67504, 67506, 67514, 67584, 67589, 67592, 67592, 67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669, 67680, 67702, 67712, 67742, 67808, 67826, 67828, 67829, 67840, 67861, 67872, 67897, 67968, 68023, 68030, 68031, 68096, 68096, 68112, 68115, 68117, 68119, 68121, 68149, 68192, 68220, 68224, 68252, 68288, 68295, 68297, 68324, 68352, 68405, 68416, 68437, 68448, 68466, 68480, 68497, 68608, 68680, 68736, 68786, 68800, 68850, 68864, 68899, 69248, 69289, 69296, 69297, 69376, 69404, 69415, 69415, 69424, 69445, 69488, 69505, 69552, 69572, 69600, 69622, 69635, 69687, 69745, 69746, 69749, 69749, 69763, 69807, 69840, 69864, 69891, 69926, 69956, 69956, 69959, 69959, 69968, 70002, 70006, 70006, 70019, 70066, 70081, 70084, 70106, 70106, 70108, 70108, 70144, 70161, 70163, 70187, 70207, 70208, 70272, 70278, 70280, 70280, 70282, 70285, 70287, 70301, 70303, 70312, 70320, 70366, 70405, 70412, 70415, 70416, 70419, 70440, 70442, 70448, 70450, 70451, 70453, 70457, 70461, 70461, 70480, 70480, 70493, 70497, 70656, 70708, 70727, 70730, 70751, 70753, 70784, 70831, 70852, 70853, 70855, 70855, 71040, 71086, 71128, 71131, 71168, 71215, 71236, 71236, 71296, 71338, 71352, 71352, 71424, 71450, 71488, 71494, 71680, 71723, 71840, 71903, 71935, 71942, 71945, 71945, 71948, 71955, 71957, 71958, 71960, 71983, 71999, 71999, 72001, 72001, 72096, 72103, 72106, 72144, 72161, 72161, 72163, 72163, 72192, 72192, 72203, 72242, 72250, 72250, 72272, 72272, 72284, 72329, 72349, 72349, 72368, 72440, 72704, 72712, 72714, 72750, 72768, 72768, 72818, 72847, 72960, 72966, 72968, 72969, 72971, 73008, 73030, 73030, 73056, 73061, 73063, 73064, 73066, 73097, 73112, 73112, 73440, 73458, 73474, 73474, 73476, 73488, 73490, 73523, 73648, 73648, 73728, 74649, 74752, 74862, 74880, 75075, 77712, 77808, 77824, 78895, 78913, 78918, 82944, 83526, 92160, 92728, 92736, 92766, 92784, 92862, 92880, 92909, 92928, 92975, 92992, 92995, 93027, 93047, 93053, 93071, 93760, 93823, 93952, 94026, 94032, 94032, 94099, 94111, 94176, 94177, 94179, 94179, 94208, 100343, 100352, 101589, 101632, 101640, 110576, 110579, 110581, 110587, 110589, 110590, 110592, 110882, 110898, 110898, 110928, 110930, 110933, 110933, 110948, 110951, 110960, 111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 122624, 122654, 122661, 122666, 122928, 122989, 123136, 123180, 123191, 123197, 123214, 123214, 123536, 123565, 123584, 123627, 124112, 124139, 124896, 124902, 124904, 124907, 124909, 124910, 124912, 124926, 124928, 125124, 125184, 125251, 125259, 125259, 126464, 126467, 126469, 126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 131072, 173791, 173824, 177977, 177984, 178205, 178208, 183969, 183984, 191456, 194560, 195101, 196608, 201546, 201552, 205743, 47, 0, 1, 1, 0, 0, 0, 0, 3, 1, 0, 0, 0, 0, 5, 1, 0, 0, 0, 0, 7, 1, 0, 0, 0, 0, 9, 1, 0, 0, 0, 0, 15, 1, 0, 0, 0, 1, 17, 1, 0, 0, 0, 3, 20, 1, 0, 0, 0, 5, 22, 1, 0, 0, 0, 7, 24, 1, 0, 0, 0, 9, 26, 1, 0, 0, 0, 11, 35, 1, 0, 0, 0, 13, 37, 1, 0, 0, 0, 15, 39, 1, 0, 0, 0, 17, 18, 5, 47, 0, 0, 18, 19, 5, 47, 0, 0, 19, 2, 1, 0, 0, 0, 20, 21, 5, 47, 0, 0, 21, 4, 1, 0, 0, 0, 22, 23, 5, 42, 0, 0, 23, 6, 1, 0, 0, 0, 24, 25, 5, 33, 0, 0, 25, 8, 1, 0, 0, 0, 26, 30, 3, 13, 6, 0, 27, 29, 3, 11, 5, 0, 28, 27, 1, 0, 0, 0, 29, 32, 1, 0, 0, 0, 30, 28, 1, 0, 0, 0, 30, 31, 1, 0, 0, 0, 31, 33, 1, 0, 0, 0, 32, 30, 1, 0, 0, 0, 33, 34, 6, 4, 0, 0, 34, 10, 1, 0, 0, 0, 35, 36, 7, 0, 0, 0, 36, 12, 1, 0, 0, 0, 37, 38, 7, 1, 0, 0, 38, 14, 1, 0, 0, 0, 39, 43, 5, 39, 0, 0, 40, 42, 9, 0, 0, 0, 41, 40, 1, 0, 0, 0, 42, 45, 1, 0, 0, 0, 43, 44, 1, 0, 0, 0, 43, 41, 1, 0, 0, 0, 44, 46, 1, 0, 0, 0, 45, 43, 1, 0, 0, 0, 46, 47, 5, 39, 0, 0, 47, 16, 1, 0, 0, 0, 3, 0, 30, 43, 1, 1, 4, 0];
  static __ATN;
  static get _ATN() {
    return i31.__ATN || (i31.__ATN = new yt().deserialize(i31._serializedATN)), i31.__ATN;
  }
  static vocabulary = new b(i31.literalNames, i31.symbolicNames, []);
  get vocabulary() {
    return i31.vocabulary;
  }
  static decisionsToDFA = i31._ATN.decisionToState.map((t, e) => new at(t, e));
};

// ../frontend/node_modules/antlr4ng/dist/antlr4.mjs
var h2 = class {
  constructor() {
    this.source = null, this.type = null, this.channel = null, this.start = null, this.stop = null, this.tokenIndex = null, this.line = null, this.column = null, this._text = null;
  }
  getTokenSource() {
    return this.source[0];
  }
  getInputStream() {
    return this.source[1];
  }
  get text() {
    return this._text;
  }
  set text(t) {
    this._text = t;
  }
};
h2.INVALID_TYPE = 0;
h2.EPSILON = -2;
h2.MIN_USER_TOKEN_TYPE = 1;
h2.EOF = -1;
h2.DEFAULT_CHANNEL = 0;
h2.HIDDEN_CHANNEL = 1;
var Ft2 = class {
  create(t, e, n, s, r, o, l, a) {
  }
};
var ft2 = class i32 extends h2 {
  constructor(t, e, n, s, r) {
    super(), this.source = t !== void 0 ? t : i32.EMPTY_SOURCE, this.type = e !== void 0 ? e : null, this.channel = n !== void 0 ? n : h2.DEFAULT_CHANNEL, this.start = s !== void 0 ? s : -1, this.stop = r !== void 0 ? r : -1, this.tokenIndex = -1, this.source[0] !== null ? (this.line = t[0].line, this.column = t[0].column) : this.column = -1;
  }
  clone() {
    let t = new i32(this.source, this.type, this.channel, this.start, this.stop);
    return t.tokenIndex = this.tokenIndex, t.line = this.line, t.column = this.column, t.text = this.text, t;
  }
  cloneWithType(t) {
    let e = new i32(this.source, t, this.channel, this.start, this.stop);
    return e.tokenIndex = this.tokenIndex, e.line = this.line, e.column = this.column, t === h2.EOF && (e.text = ""), e;
  }
  toString(t) {
    let e = "";
    this._channel > 0 && (e = ",channel=" + this.channel);
    let n = this.text;
    n ? (n = n.replace(/\n/g, "\\n"), n = n.replace(/\r/g, "\\r"), n = n.replace(/\t/g, "\\t")) : n = "<no text>";
    let s = String(this.type);
    return t && (s = t.vocabulary.getDisplayName(this.type)), "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + n + "',<" + s + ">" + e + "," + this.line + ":" + this.column + "]";
  }
  get text() {
    if (this._text !== null)
      return this._text;
    let t = this.getInputStream();
    if (t === null)
      return null;
    let e = t.size;
    return this.start < e && this.stop < e ? t.getText(this.start, this.stop) : "<EOF>";
  }
  set text(t) {
    this._text = t;
  }
};
ft2.EMPTY_SOURCE = [null, null];
var g2 = class i33 {
  constructor(t, e) {
    this.start = t, this.stop = e;
  }
  static of(t, e) {
    return t != e || t < 0 || t > i33.INTERVAL_POOL_MAX_VALUE ? new i33(t, e) : (i33.cache[t] === null && (i33.cache[t] = new i33(t, t)), i33.cache[t]);
  }
  equals(t) {
    return t instanceof i33 ? this.start === t.start && this.stop === t.stop : false;
  }
  hashCode() {
    let t = 23;
    return t = t * 31 + this.start, t = t * 31 + this.stop, t;
  }
  startsBeforeDisjoint(t) {
    return this.start < t.start && this.stop < t.start;
  }
  startsBeforeNonDisjoint(t) {
    return this.start <= t.start && this.stop >= t.start;
  }
  startsAfter(t) {
    return this.start > t.start;
  }
  startsAfterDisjoint(t) {
    return this.start > t.stop;
  }
  startsAfterNonDisjoint(t) {
    return this.start > t.start && this.start <= t.stop;
  }
  disjoint(t) {
    return this.startsBeforeDisjoint(t) || this.startsAfterDisjoint(t);
  }
  adjacent(t) {
    return this.start === t.stop + 1 || this.stop === t.start - 1;
  }
  properlyContains(t) {
    return t.start >= this.start && t.stop <= this.stop;
  }
  union(t) {
    return i33.of(Math.min(this.start, t.start), Math.max(this.stop, t.stop));
  }
  intersection(t) {
    return i33.of(Math.max(this.start, t.start), Math.min(this.stop, t.stop));
  }
  differenceNotProperlyContained(t) {
    let e = null;
    return t.startsBeforeNonDisjoint(this) ? e = i33.of(Math.max(this.start, t.stop + 1), this.stop) : t.startsAfterNonDisjoint(this) && (e = i33.of(this.start, t.start - 1)), e;
  }
  toString() {
    return this.start === this.stop ? this.start.toString() : this.start.toString() + ".." + this.stop.toString();
  }
  get length() {
    return this.stop < this.start ? 0 : this.stop - this.start + 1;
  }
};
g2.INVALID_INTERVAL = new g2(-1, -2);
g2.INTERVAL_POOL_MAX_VALUE = 1e3;
g2.cache = new Array(g2.INTERVAL_POOL_MAX_VALUE + 1);
g2.cache.fill(null);
var $2 = class {
  syntaxError(t, e, n, s, r, o) {
  }
  reportAmbiguity(t, e, n, s, r, o, l) {
  }
  reportAttemptingFullContext(t, e, n, s, r, o) {
  }
  reportContextSensitivity(t, e, n, s, r, o) {
  }
};
var vt2 = class extends $2 {
  constructor() {
    super();
  }
  syntaxError(t, e, n, s, r, o) {
    console.error("line " + n + ":" + s + " " + r);
  }
};
vt2.INSTANCE = new vt2();
var me2 = class extends $2 {
  constructor(t) {
    if (super(), t === null)
      throw "delegates";
    return this.delegates = t, this;
  }
  syntaxError(t, e, n, s, r, o) {
    this.delegates.map((l) => l.syntaxError(t, e, n, s, r, o));
  }
  reportAmbiguity(t, e, n, s, r, o, l) {
    this.delegates.map((a) => a.reportAmbiguity(t, e, n, s, r, o, l));
  }
  reportAttemptingFullContext(t, e, n, s, r, o) {
    this.delegates.map((l) => l.reportAttemptingFullContext(t, e, n, s, r, o));
  }
  reportContextSensitivity(t, e, n, s, r, o) {
    this.delegates.map((l) => l.reportContextSensitivity(t, e, n, s, r, o));
  }
};
var bt2 = class i34 {
  static EOF = -1;
  static tokenTypeMapCache = /* @__PURE__ */ new Map();
  static ruleIndexMapCache = /* @__PURE__ */ new Map();
  constructor() {
    this._listeners = [vt2.INSTANCE], this.interpreter = null, this._stateNumber = -1;
  }
  checkVersion(t) {
    let e = "4.13.1";
    e !== t && console.log("ANTLR runtime and generated code versions disagree: " + e + "!=" + t);
  }
  addErrorListener(t) {
    this._listeners.push(t);
  }
  removeErrorListeners() {
    this._listeners = [];
  }
  getTokenTypeMap() {
    let t = this.vocabulary, e = i34.tokenTypeMapCache.get(t);
    if (!e) {
      e = /* @__PURE__ */ new Map();
      for (let n = 0; n <= this.atn.maxTokenType; n++) {
        let s = t.getLiteralName(n);
        s && e.set(s, n);
        let r = t.getSymbolicName(n);
        r && e.set(r, n);
      }
      e.set("EOF", h2.EOF), i34.tokenTypeMapCache.set(t, e);
    }
    return e;
  }
  getRuleIndexMap() {
    let t = this.ruleNames, e = i34.ruleIndexMapCache.get(t);
    return e || (e = /* @__PURE__ */ new Map(), t.forEach((n, s) => e.set(n, s)), i34.ruleIndexMapCache.set(t, e)), e;
  }
  getTokenType(t) {
    let e = this.getTokenTypeMap().get(t);
    return e || h2.INVALID_TYPE;
  }
  getErrorHeader(t) {
    let e = t.offendingToken.line, n = t.offendingToken.column;
    return "line " + e + ":" + n;
  }
  getTokenErrorDisplay(t) {
    if (t === null)
      return "<no token>";
    let e = t.text;
    return e === null && (t.type === h2.EOF ? e = "<EOF>" : e = "<" + t.type + ">"), e = e.replace(`
`, "\\n").replace("\r", "\\r").replace("	", "\\t"), "'" + e + "'";
  }
  getErrorListenerDispatch() {
    return new me2(this._listeners);
  }
  sempred(t, e, n) {
    return true;
  }
  precpred(t, e) {
    return true;
  }
  get atn() {
    return this.interpreter.atn;
  }
  get state() {
    return this._stateNumber;
  }
  set state(t) {
    this._stateNumber = t;
  }
};
var Mt2 = class extends Ft2 {
  constructor(t) {
    super(), this.copyText = t === void 0 ? false : t;
  }
  create(t, e, n, s, r, o, l, a) {
    let u = new ft2(t, e, s, r, o);
    return u.line = l, u.column = a, n !== null ? u.text = n : this.copyText && t[1] !== null && (u.text = t[1].getText(r, o)), u;
  }
  createThin(t, e) {
    let n = new ft2(null, t);
    return n.text = e, n;
  }
};
Mt2.DEFAULT = new Mt2();
var M2 = class i35 extends Error {
  constructor(t) {
    super(t.message), Error.captureStackTrace && Error.captureStackTrace(this, i35), this.message = t.message, this.recognizer = t.recognizer, this.input = t.input, this.ctx = t.ctx, this.offendingToken = null, this.offendingState = -1, this.recognizer !== null && (this.offendingState = this.recognizer.state);
  }
  getExpectedTokens() {
    return this.recognizer !== null ? this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx) : null;
  }
  toString() {
    return this.message;
  }
};
var rt2 = class extends M2 {
  constructor(t, e, n, s) {
    super({ message: "", recognizer: t, input: e, ctx: null }), this.startIndex = n, this.deadEndConfigs = s;
  }
  toString() {
    let t = "";
    return this.startIndex >= 0 && this.startIndex < this.input.size && (t = this.input.getText(new g2(this.startIndex, this.startIndex))), "LexerNoViableAltException" + t;
  }
};
var N2 = class i36 extends bt2 {
  constructor(t) {
    super(), this._input = t, this._factory = Mt2.DEFAULT, this._tokenFactorySourcePair = [this, t], this.interpreter = null, this._token = null, this._tokenStartCharIndex = -1, this._tokenStartLine = -1, this._tokenStartColumn = -1, this._hitEOF = false, this._channel = h2.DEFAULT_CHANNEL, this._type = h2.INVALID_TYPE, this._modeStack = [], this._mode = i36.DEFAULT_MODE, this._text = null;
  }
  reset() {
    this._input !== null && this._input.seek(0), this._token = null, this._type = h2.INVALID_TYPE, this._channel = h2.DEFAULT_CHANNEL, this._tokenStartCharIndex = -1, this._tokenStartColumn = -1, this._tokenStartLine = -1, this._text = null, this._hitEOF = false, this._mode = i36.DEFAULT_MODE, this._modeStack = [], this.interpreter.reset();
  }
  nextToken() {
    if (this._input === null)
      throw "nextToken requires a non-null input stream.";
    let t = this._input.mark();
    try {
      for (; ; ) {
        if (this._hitEOF)
          return this.emitEOF(), this._token;
        this._token = null, this._channel = h2.DEFAULT_CHANNEL, this._tokenStartCharIndex = this._input.index, this._tokenStartColumn = this.interpreter.column, this._tokenStartLine = this.interpreter.line, this._text = null;
        let e = false;
        for (; ; ) {
          this._type = h2.INVALID_TYPE;
          let n = i36.SKIP;
          try {
            n = this.interpreter.match(this._input, this._mode);
          } catch (s) {
            if (s instanceof M2)
              this.notifyListeners(s), this.recover(s);
            else
              throw console.log(s.stack), s;
          }
          if (this._input.LA(1) === h2.EOF && (this._hitEOF = true), this._type === h2.INVALID_TYPE && (this._type = n), this._type === i36.SKIP) {
            e = true;
            break;
          }
          if (this._type !== i36.MORE)
            break;
        }
        if (!e)
          return this._token === null && this.emit(), this._token;
      }
    } finally {
      this._input.release(t);
    }
  }
  skip() {
    this._type = i36.SKIP;
  }
  more() {
    this._type = i36.MORE;
  }
  mode(t) {
    this._mode = t;
  }
  pushMode(t) {
    this.interpreter.debug && console.log("pushMode " + t), this._modeStack.push(this._mode), this.mode(t);
  }
  popMode() {
    if (this._modeStack.length === 0)
      throw "Empty Stack";
    return this.interpreter.debug && console.log("popMode back to " + this._modeStack.slice(0, -1)), this.mode(this._modeStack.pop()), this._mode;
  }
  emitToken(t) {
    this._token = t;
  }
  emit() {
    let t = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.getCharIndex() - 1, this._tokenStartLine, this._tokenStartColumn);
    return this.emitToken(t), t;
  }
  emitEOF() {
    let t = this.column, e = this.line, n = this._factory.create(this._tokenFactorySourcePair, h2.EOF, null, h2.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, e, t);
    return this.emitToken(n), n;
  }
  getCharIndex() {
    return this._input.index;
  }
  getAllTokens() {
    let t = [], e = this.nextToken();
    for (; e.type !== h2.EOF; )
      t.push(e), e = this.nextToken();
    return t;
  }
  notifyListeners(t) {
    let e = this._tokenStartCharIndex, n = this._input.index, s = this._input.getText(e, n), r = "token recognition error at: '" + this.getErrorDisplay(s) + "'";
    this.getErrorListenerDispatch().syntaxError(this, null, this._tokenStartLine, this._tokenStartColumn, r, t);
  }
  getErrorDisplay(t) {
    let e = [];
    for (let n = 0; n < t.length; n++)
      e.push(t[n]);
    return e.join("");
  }
  getErrorDisplayForChar(t) {
    return t.charCodeAt(0) === h2.EOF ? "<EOF>" : t === `
` ? "\\n" : t === "	" ? "\\t" : t === "\r" ? "\\r" : t;
  }
  getCharErrorDisplay(t) {
    return "'" + this.getErrorDisplayForChar(t) + "'";
  }
  recover(t) {
    this._input.LA(1) !== h2.EOF && (t instanceof rt2 ? this.interpreter.consume(this._input) : this._input.consume());
  }
  get inputStream() {
    return this._input;
  }
  set inputStream(t) {
    this._input = null, this._tokenFactorySourcePair = [this, null], this.reset(), this._input = t, this._tokenFactorySourcePair = [this, t];
  }
  get sourceName() {
    return this._input.sourceName;
  }
  get type() {
    return this._type;
  }
  set type(t) {
    this._type = t;
  }
  get line() {
    return this.interpreter.line;
  }
  set line(t) {
    this.interpreter.line = t;
  }
  get column() {
    return this.interpreter.column;
  }
  set column(t) {
    this.interpreter.column = t;
  }
  get text() {
    return this._text !== null ? this._text : this.interpreter.getText(this._input);
  }
  set text(t) {
    this._text = t;
  }
};
N2.DEFAULT_MODE = 0;
N2.MORE = -2;
N2.SKIP = -3;
N2.DEFAULT_TOKEN_CHANNEL = h2.DEFAULT_CHANNEL;
N2.HIDDEN = h2.HIDDEN_CHANNEL;
N2.MIN_CHAR_VALUE = 0;
N2.MAX_CHAR_VALUE = 1114111;
var Bt2 = class {
};
var w2 = class extends Bt2 {
};
var it2 = class extends w2 {
};
var dt2 = class extends w2 {
  constructor(t) {
    super(), this._parent = null, this.symbol = t;
  }
  getChild(t) {
    return null;
  }
  getSymbol() {
    return this.symbol;
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    this._parent = t;
  }
  getPayload() {
    return this.symbol;
  }
  getSourceInterval() {
    if (this.symbol === null)
      return g2.INVALID_INTERVAL;
    let t = this.symbol.tokenIndex;
    return new g2(t, t);
  }
  getChildCount() {
    return 0;
  }
  accept(t) {
    return t.visitTerminal(this);
  }
  getText() {
    return this.symbol.text;
  }
  toString() {
    return this.symbol.type === h2.EOF ? "<EOF>" : this.symbol.text;
  }
  toStringTree() {
    return this.toString();
  }
};
var Lt2 = class extends dt2 {
  constructor(t) {
    super(t);
  }
  isErrorNode() {
    return true;
  }
  accept(t) {
    return t.visitErrorNode(this);
  }
};
function pt2(i63, t) {
  if (!Array.isArray(i63) || !Array.isArray(t))
    return false;
  if (i63 === t)
    return true;
  if (i63.length !== t.length)
    return false;
  for (let e = 0; e < i63.length; e++)
    if (i63[e] !== t[e] && (!i63[e].equals || !i63[e].equals(t[e])))
      return false;
  return true;
}
var ln2 = Math.round(Math.random() * Math.pow(2, 32));
function ge2(i63) {
  if (!i63)
    return 0;
  let t = typeof i63, e = t === "string" ? i63 : t === "object" && i63.toString ? i63.toString() : false;
  if (!e)
    return 0;
  let n, s, r = e.length & 3, o = e.length - r, l = ln2, a = 3432918353, u = 461845907, c = 0;
  for (; c < o; )
    s = e.charCodeAt(c) & 255 | (e.charCodeAt(++c) & 255) << 8 | (e.charCodeAt(++c) & 255) << 16 | (e.charCodeAt(++c) & 255) << 24, ++c, s = (s & 65535) * a + (((s >>> 16) * a & 65535) << 16) & 4294967295, s = s << 15 | s >>> 17, s = (s & 65535) * u + (((s >>> 16) * u & 65535) << 16) & 4294967295, l ^= s, l = l << 13 | l >>> 19, n = (l & 65535) * 5 + (((l >>> 16) * 5 & 65535) << 16) & 4294967295, l = (n & 65535) + 27492 + (((n >>> 16) + 58964 & 65535) << 16);
  switch (s = 0, r) {
    case 3:
      s ^= (e.charCodeAt(c + 2) & 255) << 16;
    case 2:
      s ^= (e.charCodeAt(c + 1) & 255) << 8;
    case 1:
      s ^= e.charCodeAt(c) & 255, s = (s & 65535) * a + (((s >>> 16) * a & 65535) << 16) & 4294967295, s = s << 15 | s >>> 17, s = (s & 65535) * u + (((s >>> 16) * u & 65535) << 16) & 4294967295, l ^= s;
  }
  return l ^= e.length, l ^= l >>> 16, l = (l & 65535) * 2246822507 + (((l >>> 16) * 2246822507 & 65535) << 16) & 4294967295, l ^= l >>> 13, l = (l & 65535) * 3266489909 + (((l >>> 16) * 3266489909 & 65535) << 16) & 4294967295, l ^= l >>> 16, l >>> 0;
}
var R2 = class i37 {
  constructor() {
    this.count = 0, this.hash = 0;
  }
  update() {
    for (let t = 0; t < arguments.length; t++) {
      let e = arguments[t];
      if (e != null)
        if (Array.isArray(e))
          this.update.apply(this, e);
        else {
          let n = 0;
          switch (typeof e) {
            case "undefined":
            case "function":
              continue;
            case "number":
            case "boolean":
              n = e;
              break;
            case "string":
              n = ge2(e);
              break;
            default:
              e.updateHashCode ? e.updateHashCode(this) : console.log("No updateHashCode for " + e.toString());
              continue;
          }
          n = n * 3432918353, n = n << 15 | n >>> 32 - 15, n = n * 461845907, this.count = this.count + 1;
          let s = this.hash ^ n;
          s = s << 13 | s >>> 32 - 13, s = s * 5 + 3864292196, this.hash = s;
        }
    }
  }
  finish() {
    let t = this.hash ^ this.count * 4;
    return t = t ^ t >>> 16, t = t * 2246822507, t = t ^ t >>> 13, t = t * 3266489909, t = t ^ t >>> 16, t;
  }
  static hashStuff() {
    let t = new i37();
    return t.update.apply(t, arguments), t.finish();
  }
};
function Te2(i63) {
  return i63 ? typeof i63 == "string" ? ge2(i63) : i63.hashCode() : -1;
}
function Se2(i63, t) {
  return i63 ? i63.equals(t) : i63 === t;
}
function en2(i63) {
  return i63 === null ? "null" : i63;
}
function G2(i63) {
  return Array.isArray(i63) ? "[" + i63.map(en2).join(", ") + "]" : "null";
}
var Ee2 = "h-";
var k2 = class {
  constructor(t, e) {
    this.data = {}, this.hashFunction = t || Te2, this.equalsFunction = e || Se2;
  }
  add(t) {
    let e = Ee2 + this.hashFunction(t);
    if (e in this.data) {
      let n = this.data[e];
      for (let s = 0; s < n.length; s++)
        if (this.equalsFunction(t, n[s]))
          return n[s];
      return n.push(t), t;
    } else
      return this.data[e] = [t], t;
  }
  has(t) {
    return this.get(t) != null;
  }
  get(t) {
    let e = Ee2 + this.hashFunction(t);
    if (e in this.data) {
      let n = this.data[e];
      for (let s = 0; s < n.length; s++)
        if (this.equalsFunction(t, n[s]))
          return n[s];
    }
    return null;
  }
  values() {
    return Object.keys(this.data).filter((t) => t.startsWith(Ee2)).flatMap((t) => this.data[t], this);
  }
  toString() {
    return G2(this.values());
  }
  get length() {
    return Object.keys(this.data).filter((t) => t.startsWith(Ee2)).map((t) => this.data[t].length, this).reduce((t, e) => t + e, 0);
  }
};
var T2 = class i38 {
  hashCode() {
    let t = new R2();
    return this.updateHashCode(t), t.finish();
  }
  evaluate(t, e) {
  }
  evalPrecedence(t, e) {
    return this;
  }
  static andContext(t, e) {
    if (t === null || t === i38.NONE)
      return e;
    if (e === null || e === i38.NONE)
      return t;
    let n = new $e2(t, e);
    return n.opnds.length === 1 ? n.opnds[0] : n;
  }
  static orContext(t, e) {
    if (t === null)
      return e;
    if (e === null)
      return t;
    if (t === i38.NONE || e === i38.NONE)
      return i38.NONE;
    let n = new Je2(t, e);
    return n.opnds.length === 1 ? n.opnds[0] : n;
  }
};
var $e2 = class i39 extends T2 {
  constructor(t, e) {
    super();
    let n = new k2();
    t instanceof i39 ? t.opnds.map(function(r) {
      n.add(r);
    }) : n.add(t), e instanceof i39 ? e.opnds.map(function(r) {
      n.add(r);
    }) : n.add(e);
    let s = nn2(n);
    if (s.length > 0) {
      let r = null;
      s.map(function(o) {
        (r === null || o.precedence < r.precedence) && (r = o);
      }), n.add(r);
    }
    this.opnds = Array.from(n.values());
  }
  equals(t) {
    return this === t ? true : t instanceof i39 ? pt2(this.opnds, t.opnds) : false;
  }
  updateHashCode(t) {
    t.update(this.opnds, "AND");
  }
  evaluate(t, e) {
    for (let n = 0; n < this.opnds.length; n++)
      if (!this.opnds[n].evaluate(t, e))
        return false;
    return true;
  }
  evalPrecedence(t, e) {
    let n = false, s = [];
    for (let o = 0; o < this.opnds.length; o++) {
      let l = this.opnds[o], a = l.evalPrecedence(t, e);
      if (n |= a !== l, a === null)
        return null;
      a !== T2.NONE && s.push(a);
    }
    if (!n)
      return this;
    if (s.length === 0)
      return T2.NONE;
    let r = null;
    return s.map(function(o) {
      r = r === null ? o : T2.andContext(r, o);
    }), r;
  }
  toString() {
    let t = this.opnds.map((e) => e.toString());
    return (t.length > 3 ? t.slice(3) : t).join("&&");
  }
};
var Je2 = class i40 extends T2 {
  constructor(t, e) {
    super();
    let n = new k2();
    t instanceof i40 ? t.opnds.map(function(r) {
      n.add(r);
    }) : n.add(t), e instanceof i40 ? e.opnds.map(function(r) {
      n.add(r);
    }) : n.add(e);
    let s = nn2(n);
    if (s.length > 0) {
      let r = s.sort(function(l, a) {
        return l.compareTo(a);
      }), o = r[r.length - 1];
      n.add(o);
    }
    this.opnds = Array.from(n.values());
  }
  equals(t) {
    return this === t ? true : t instanceof i40 ? pt2(this.opnds, t.opnds) : false;
  }
  updateHashCode(t) {
    t.update(this.opnds, "OR");
  }
  evaluate(t, e) {
    for (let n = 0; n < this.opnds.length; n++)
      if (this.opnds[n].evaluate(t, e))
        return true;
    return false;
  }
  evalPrecedence(t, e) {
    let n = false, s = [];
    for (let o = 0; o < this.opnds.length; o++) {
      let l = this.opnds[o], a = l.evalPrecedence(t, e);
      if (n |= a !== l, a === T2.NONE)
        return T2.NONE;
      a !== null && s.push(a);
    }
    if (!n)
      return this;
    if (s.length === 0)
      return null;
    let r = null;
    return s.map(function(o) {
      return r === null ? o : T2.orContext(r, o);
    }), r;
  }
  toString() {
    let t = this.opnds.map((e) => e.toString());
    return (t.length > 3 ? t.slice(3) : t).join("||");
  }
};
function nn2(i63) {
  let t = [];
  return i63.values().map(function(e) {
    e instanceof T2.PrecedencePredicate && t.push(e);
  }), t;
}
var re2 = class i41 extends T2 {
  constructor(t, e, n) {
    super(), this.ruleIndex = t === void 0 ? -1 : t, this.predIndex = e === void 0 ? -1 : e, this.isCtxDependent = n === void 0 ? false : n;
  }
  evaluate(t, e) {
    let n = this.isCtxDependent ? e : null;
    return t.sempred(n, this.ruleIndex, this.predIndex);
  }
  updateHashCode(t) {
    t.update(this.ruleIndex, this.predIndex, this.isCtxDependent);
  }
  equals(t) {
    return this === t ? true : t instanceof i41 ? this.ruleIndex === t.ruleIndex && this.predIndex === t.predIndex && this.isCtxDependent === t.isCtxDependent : false;
  }
  toString() {
    return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
  }
};
T2.NONE = new re2();
var O2 = class {
  constructor(t) {
    if (t == null)
      throw "target cannot be null.";
    this.target = t, this.isEpsilon = false, this.label = null;
  }
};
var mt2 = class extends O2 {
  constructor(t) {
    super(t);
  }
};
var d2 = { EPSILON: 1, RANGE: 2, RULE: 3, PREDICATE: 4, ATOM: 5, ACTION: 6, SET: 7, NOT_SET: 8, WILDCARD: 9, PRECEDENCE: 10 };
var Vt2 = class extends mt2 {
  constructor(t, e, n, s) {
    super(t), this.serializationType = d2.PREDICATE, this.ruleIndex = e, this.predIndex = n, this.isCtxDependent = s, this.isEpsilon = true;
  }
  matches(t, e, n) {
    return false;
  }
  getPredicate() {
    return new re2(this.ruleIndex, this.predIndex, this.isCtxDependent);
  }
  toString() {
    return "pred_" + this.ruleIndex + ":" + this.predIndex;
  }
};
var ut2 = class extends M2 {
  constructor(t, e, n) {
    super({ message: an2(e, n || null), recognizer: t, input: t.inputStream, ctx: t._ctx });
    let r = t.interpreter.atn.states[t.state].transitions[0];
    r instanceof Vt2 ? (this.ruleIndex = r.ruleIndex, this.predicateIndex = r.predIndex) : (this.ruleIndex = 0, this.predicateIndex = 0), this.predicate = e, this.offendingToken = t.getCurrentToken();
  }
};
function an2(i63, t) {
  return t !== null ? t : "failed predicate: {" + i63 + "}?";
}
var J2 = class extends M2 {
  constructor(t) {
    super({ message: "", recognizer: t, input: t.inputStream, ctx: t._ctx }), this.offendingToken = t.getCurrentToken();
  }
};
var xt2 = class extends M2 {
  constructor(t, e, n, s, r, o) {
    o = o ?? t._ctx, s = s ?? t.getCurrentToken(), n = n ?? t.getCurrentToken(), e = e ?? t.inputStream, super({ message: "", recognizer: t, input: e, ctx: o }), this.deadEndConfigs = r, this.startToken = n, this.offendingToken = s;
  }
};
var _2 = class i42 {
  constructor() {
    this.atn = null, this.ruleIndex = 0, this.epsilonOnlyTransitions = false, this.transitions = [], this.nextTokenWithinRule = null;
  }
  get stateType() {
    return i42.INVALID_STATE_NUMBER;
  }
  toString() {
    return `${this.stateNumber}`;
  }
  equals(t) {
    return t instanceof i42 ? this.stateNumber === t.stateNumber : false;
  }
  isNonGreedyExitState() {
    return false;
  }
  addTransition(t, e) {
    e === void 0 && (e = -1), this.transitions.length === 0 ? this.epsilonOnlyTransitions = t.isEpsilon : this.epsilonOnlyTransitions !== t.isEpsilon && (this.epsilonOnlyTransitions = false), e === -1 ? this.transitions.push(t) : this.transitions.splice(e, 1, t);
  }
};
_2.INVALID_STATE_NUMBER = -1;
var b2 = class i43 {
  constructor(t, e, n) {
    this.literalNames = t ?? i43.EMPTY_NAMES, this.symbolicNames = e ?? i43.EMPTY_NAMES, this.displayNames = n ?? i43.EMPTY_NAMES, this.maxTokenType = Math.max(this.displayNames.length, Math.max(this.literalNames.length, this.symbolicNames.length)) - 1;
  }
  static fromTokenNames(t) {
    if (t == null || t.length === 0)
      return i43.EMPTY_VOCABULARY;
    let e = [...t], n = [...t];
    for (let s = 0; s < t.length; s++) {
      let r = t[s];
      if (r != null) {
        if (!r.isEmpty()) {
          let o = r.charAt(0);
          if (o === "'") {
            n[s] = null;
            continue;
          } else if (o.toUpperCase() === o) {
            e[s] = null;
            continue;
          }
        }
        e[s] = null, n[s] = null;
      }
    }
    return new i43(e, n, t);
  }
  getMaxTokenType() {
    return this.maxTokenType;
  }
  getLiteralName(t) {
    return t >= 0 && t < this.literalNames.length ? this.literalNames[t] : null;
  }
  getSymbolicName(t) {
    return t >= 0 && t < this.symbolicNames.length ? this.symbolicNames[t] : t === h2.EOF ? "EOF" : null;
  }
  getDisplayName(t) {
    if (t >= 0 && t < this.displayNames.length) {
      let s = this.displayNames[t];
      if (s != null)
        return s;
    }
    let e = this.getLiteralName(t);
    if (e != null)
      return e;
    let n = this.getSymbolicName(t);
    return n ?? `${t}`;
  }
  getLiteralNames() {
    return this.literalNames;
  }
  getSymbolicNames() {
    return this.symbolicNames;
  }
  getDisplayNames() {
    return this.displayNames;
  }
};
b2.EMPTY_NAMES = [];
b2.EMPTY_VOCABULARY = new b2(b2.EMPTY_NAMES, b2.EMPTY_NAMES, b2.EMPTY_NAMES);
var D2 = class i44 {
  static COMPLETE_CHAR_SET = i44.of(N2.MIN_CHAR_VALUE, N2.MAX_CHAR_VALUE);
  static EMPTY_SET = new i44();
  static {
    i44.COMPLETE_CHAR_SET.readonly = true, i44.EMPTY_SET.readonly = true;
  }
  constructor(t) {
    this.intervals = [], this.readOnly = false, t && this.addSet(t);
  }
  static of(t, e) {
    let n = new i44();
    return n.addRange(t, e), n;
  }
  get minElement() {
    return this.intervals.length === 0 ? h2.INVALID_TYPE : this.intervals[0].start;
  }
  get maxElement() {
    return this.intervals.length === 0 ? h2.INVALID_TYPE : this.intervals[this.intervals.length - 1].stop;
  }
  get isNil() {
    return this.intervals.length === 0;
  }
  clear() {
    if (this.readOnly)
      throw new IllegalStateException("can't alter readonly IntervalSet");
    this.intervals = [];
  }
  addOne(t) {
    this.addInterval(new g2(t, t));
  }
  addRange(t, e) {
    this.addInterval(new g2(t, e));
  }
  addInterval(t) {
    if (this.readOnly)
      throw new IllegalStateException("can't alter readonly IntervalSet");
    if (this.intervals.length === 0)
      this.intervals.push(t);
    else {
      for (let e = 0; e < this.intervals.length; e++) {
        let n = this.intervals[e];
        if (t.equals(n))
          return;
        if (t.adjacent(n) || !t.disjoint(n)) {
          let s = t.union(n);
          this.intervals[e] = s;
          for (let r = e + 1; r < this.intervals.length; ) {
            let o = this.intervals[r];
            if (!s.adjacent(o) && s.disjoint(o))
              break;
            this.intervals.splice(r, 1), this.intervals[e] = s.union(o);
          }
          return;
        }
        if (t.startsBeforeDisjoint(n)) {
          this.intervals.splice(e, 0, t);
          return;
        }
      }
      this.intervals.push(t);
    }
  }
  addSet(t) {
    return t.intervals.forEach((e) => this.addInterval(e), this), this;
  }
  complement(t, e) {
    if (!t)
      return new i44();
    let n = new i44();
    if (t instanceof i44) {
      if (t.isNil)
        return new i44();
      n.addSet(t);
    } else
      n.addInterval(new g2(t, e));
    return n.subtract(this);
  }
  or(t) {
    let e = new i44();
    return e.addSet(this), t.forEach((n) => e.addSet(n), this), e;
  }
  and(t) {
    if (t.isNil)
      return new i44();
    let e = this.intervals, n = t.intervals, s, r = e.length, o = n.length, l = 0, a = 0;
    for (; l < r && a < o; ) {
      let u = e[l], c = n[a];
      u.startsBeforeDisjoint(c) ? l++ : c.startsBeforeDisjoint(u) ? a++ : u.properlyContains(c) ? (s || (s = new i44()), s.addInterval(u.intersection(c)), a++) : c.properlyContains(u) ? (s || (s = new i44()), s.addInterval(u.intersection(c)), l++) : u.disjoint(c) || (s || (s = new i44()), s.addInterval(u.intersection(c)), u.startsAfterNonDisjoint(c) ? a++ : c.startsAfterNonDisjoint(u) && l++);
    }
    return s || new i44();
  }
  subtract(t) {
    if (this.isNil)
      return new i44();
    let e = new i44(this);
    if (t.isNil)
      return e;
    let n = 0, s = 0;
    for (; n < e.intervals.length && s < t.intervals.length; ) {
      let r = e.intervals[n], o = t.intervals[s];
      if (o.stop < r.start) {
        s++;
        continue;
      }
      if (o.start > r.stop) {
        n++;
        continue;
      }
      let l = null, a = null;
      if (o.start > r.start && (l = new g2(r.start, o.start - 1)), o.stop < r.stop && (a = new g2(o.stop + 1, r.stop)), l != null)
        if (a != null) {
          e.intervals[n] = l, e.intervals.splice(n + 1, 0, a), n++, s++;
          continue;
        } else {
          e.intervals[n] = l, n++;
          continue;
        }
      else if (a != null) {
        e.intervals[n] = a, s++;
        continue;
      } else {
        e.intervals.splice(n, 1);
        continue;
      }
    }
    return e;
  }
  contains(t) {
    if (this.intervals === null)
      return false;
    {
      let e = this.intervals.length, n = 0, s = e - 1;
      for (; n <= s; ) {
        let r = Math.floor((n + s) / 2), o = this.intervals[r];
        if (o.stop < t)
          n = r + 1;
        else if (o.start > t)
          s = r - 1;
        else
          return true;
      }
      return false;
    }
  }
  removeRange(t) {
    if (this.readOnly)
      throw new IllegalStateException("can't alter readonly IntervalSet");
    if (t.start === t.stop)
      this.removeOne(t.start);
    else if (this.intervals !== null) {
      let e = 0;
      for (let n = 0; n < this.intervals.length; n++) {
        let s = this.intervals[e];
        if (t.stop <= s.start)
          return;
        if (t.start > s.start && t.stop < s.stop) {
          this.intervals[e] = new g2(s.start, t.start);
          let r = new g2(t.stop, s.stop);
          this.intervals.splice(e, 0, r);
          return;
        } else
          t.start <= s.start && t.stop >= s.stop ? (this.intervals.splice(e, 1), e = e - 1) : t.start < s.stop ? this.intervals[e] = new g2(s.start, t.start) : t.stop < s.stop && (this.intervals[e] = new g2(t.stop, s.stop));
        e += 1;
      }
    }
  }
  removeOne(t) {
    if (this.readOnly)
      throw new IllegalStateException("can't alter readonly IntervalSet");
    if (this.intervals !== null)
      for (let e = 0; e < this.intervals.length; e++) {
        let n = this.intervals[e];
        if (t < n.start)
          return;
        if (t === n.start && t === n.stop) {
          this.intervals.splice(e, 1);
          return;
        } else if (t === n.start) {
          this.intervals[e] = new g2(n.start + 1, n.stop);
          return;
        } else if (t === n.stop) {
          this.intervals[e] = new g2(n.start, n.stop);
          return;
        } else if (t < n.stop) {
          let s = new g2(n.start, t);
          n.start = t + 1, this.intervals.splice(e, 0, s);
          return;
        }
      }
  }
  toString(t) {
    if (this.intervals.length === 0)
      return "{}";
    let e = "";
    this.length > 1 && (e += "{");
    let n, s;
    t instanceof b2 ? (s = t, n = false) : n = t ?? false;
    for (let r = 0; r < this.intervals.length; ++r) {
      let o = this.intervals[r], l = o.start, a = o.stop;
      if (l === a)
        l == h2.EOF ? e += "<EOF>" : n ? e += "'" + String.fromCodePoint(l) + "'" : s ? e += this.elementName(s, l) : e += l;
      else if (n)
        e += "'" + String.fromCodePoint(l) + "'..'" + String.fromCodePoint(a) + "'";
      else if (s)
        for (let u = l; u <= a; ++u)
          u > l && (e += ", "), e += this.elementName(s, u);
      else
        e += l + ".." + a;
      r < this.intervals.length - 1 && (e += ", ");
    }
    return this.length > 1 && (e += "}"), e;
  }
  elementName(t, e) {
    return e === h2.EOF ? "<EOF>" : e === h2.EPSILON ? "<EPSILON>" : t.getDisplayName(e);
  }
  toArray() {
    let t = [];
    if (this.intervals !== null)
      for (let e = 0; e < this.intervals.length; e++) {
        let n = this.intervals[e];
        for (let s = n.start; s <= n.stop; s++)
          t.push(s);
      }
    return t;
  }
  get length() {
    let t = 0;
    if (this.intervals.length == 1) {
      let n = this.intervals[0];
      return n.stop - n.start + 1;
    }
    for (let n of this.intervals)
      t += n.length;
    return t;
  }
  isReadonly() {
    return this.readOnly;
  }
  setReadonly(t) {
    if (this.readOnly && !t)
      throw new IllegalStateException("can't alter readonly IntervalSet");
    this.readOnly = t;
  }
  [Symbol.iterator]() {
    return this.intervals[Symbol.iterator]();
  }
};
var m2 = { INVALID_TYPE: 0, BASIC: 1, RULE_START: 2, BLOCK_START: 3, PLUS_BLOCK_START: 4, STAR_BLOCK_START: 5, TOKEN_START: 6, RULE_STOP: 7, BLOCK_END: 8, STAR_LOOP_BACK: 9, STAR_LOOP_ENTRY: 10, PLUS_LOOP_BACK: 11, LOOP_END: 12 };
var gt2 = class {
  constructor() {
    this.errorRecoveryMode = false, this.lastErrorIndex = -1, this.lastErrorStates = null, this.nextTokensContext = null, this.nextTokenState = 0;
  }
  reset(t) {
    this.endErrorCondition(t);
  }
  beginErrorCondition(t) {
    this.errorRecoveryMode = true;
  }
  inErrorRecoveryMode(t) {
    return this.errorRecoveryMode;
  }
  endErrorCondition(t) {
    this.errorRecoveryMode = false, this.lastErrorStates = null, this.lastErrorIndex = -1;
  }
  reportMatch(t) {
    this.endErrorCondition(t);
  }
  reportError(t, e) {
    this.inErrorRecoveryMode(t) || (this.beginErrorCondition(t), e instanceof xt2 ? this.reportNoViableAlternative(t, e) : e instanceof J2 ? this.reportInputMismatch(t, e) : e instanceof ut2 ? this.reportFailedPredicate(t, e) : (console.log("unknown recognition error type: " + e.constructor.name), console.log(e.stack), t.notifyErrorListeners(e.offendingToken, e.getMessage(), e)));
  }
  recover(t, e) {
    this.lastErrorIndex === t.inputStream.index && this.lastErrorStates !== null && this.lastErrorStates.indexOf(t.state) >= 0 && t.consume(), this.lastErrorIndex = t._input.index, this.lastErrorStates === null && (this.lastErrorStates = []), this.lastErrorStates.push(t.state);
    let n = this.getErrorRecoverySet(t);
    this.consumeUntil(t, n);
  }
  sync(t) {
    if (this.inErrorRecoveryMode(t))
      return;
    let e = t.interpreter.atn.states[t.state], n = t.tokenStream.LA(1), s = t.atn.nextTokens(e);
    if (s.contains(n)) {
      this.nextTokensContext = null, this.nextTokenState = _2.INVALID_STATE_NUMBER;
      return;
    } else if (s.contains(h2.EPSILON)) {
      this.nextTokensContext === null && (this.nextTokensContext = t._ctx, this.nextTokensState = t._stateNumber);
      return;
    }
    switch (e.stateType) {
      case m2.BLOCK_START:
      case m2.STAR_BLOCK_START:
      case m2.PLUS_BLOCK_START:
      case m2.STAR_LOOP_ENTRY:
        if (this.singleTokenDeletion(t) !== null)
          return;
        throw new J2(t);
      case m2.PLUS_LOOP_BACK:
      case m2.STAR_LOOP_BACK:
        {
          this.reportUnwantedToken(t);
          let r = new D2();
          r.addSet(t.getExpectedTokens());
          let o = r.addSet(this.getErrorRecoverySet(t));
          this.consumeUntil(t, o);
        }
        break;
      default:
    }
  }
  reportNoViableAlternative(t, e) {
    let n = t.tokenStream, s;
    n !== null ? e.startToken.type === h2.EOF ? s = "<EOF>" : s = n.getText(new g2(e.startToken.tokenIndex, e.offendingToken.tokenIndex)) : s = "<unknown input>";
    let r = "no viable alternative at input " + this.escapeWSAndQuote(s);
    t.notifyErrorListeners(r, e.offendingToken, e);
  }
  reportInputMismatch(t, e) {
    let n = "mismatched input " + this.getTokenErrorDisplay(e.offendingToken) + " expecting " + e.getExpectedTokens().toString(t.vocabulary);
    t.notifyErrorListeners(n, e.offendingToken, e);
  }
  reportFailedPredicate(t, e) {
    let s = "rule " + t.ruleNames[t._ctx.ruleIndex] + " " + e.message;
    t.notifyErrorListeners(s, e.offendingToken, e);
  }
  reportUnwantedToken(t) {
    if (this.inErrorRecoveryMode(t))
      return;
    this.beginErrorCondition(t);
    let e = t.getCurrentToken(), n = this.getTokenErrorDisplay(e), s = this.getExpectedTokens(t), r = "extraneous input " + n + " expecting " + s.toString(t.vocabulary);
    t.notifyErrorListeners(r, e, null);
  }
  reportMissingToken(t) {
    if (this.inErrorRecoveryMode(t))
      return;
    this.beginErrorCondition(t);
    let e = t.getCurrentToken(), s = "missing " + this.getExpectedTokens(t).toString(t.vocabulary) + " at " + this.getTokenErrorDisplay(e);
    t.notifyErrorListeners(s, e, null);
  }
  recoverInline(t) {
    let e = this.singleTokenDeletion(t);
    if (e !== null)
      return t.consume(), e;
    if (this.singleTokenInsertion(t))
      return this.getMissingSymbol(t);
    throw new J2(t);
  }
  singleTokenInsertion(t) {
    let e = t.tokenStream.LA(1), n = t.interpreter.atn, r = n.states[t.state].transitions[0].target;
    return n.nextTokens(r, t._ctx).contains(e) ? (this.reportMissingToken(t), true) : false;
  }
  singleTokenDeletion(t) {
    let e = t.tokenStream.LA(2);
    if (this.getExpectedTokens(t).contains(e)) {
      this.reportUnwantedToken(t), t.consume();
      let s = t.getCurrentToken();
      return this.reportMatch(t), s;
    } else
      return null;
  }
  getMissingSymbol(t) {
    let e = t.getCurrentToken(), n = this.getExpectedTokens(t), s = h2.INVALID_TYPE;
    n.isNil || (s = n.minElement);
    let r;
    s === h2.EOF ? r = "<missing EOF>" : r = "<missing " + t.vocabulary.getDisplayName(s) + ">";
    let o = e, l = t.tokenStream.LT(-1);
    return o.type === h2.EOF && l !== null && (o = l), t.getTokenFactory().create(o.source, s, r, h2.DEFAULT_CHANNEL, -1, -1, o.line, o.column);
  }
  getExpectedTokens(t) {
    return t.getExpectedTokens();
  }
  getTokenErrorDisplay(t) {
    if (t === null)
      return "<no token>";
    let e = t.text;
    return e === null && (t.type === h2.EOF ? e = "<EOF>" : e = "<" + t.type + ">"), this.escapeWSAndQuote(e);
  }
  escapeWSAndQuote(t) {
    return t = t.replace(/\n/g, "\\n"), t = t.replace(/\r/g, "\\r"), t = t.replace(/\t/g, "\\t"), "'" + t + "'";
  }
  getErrorRecoverySet(t) {
    let e = t.interpreter.atn, n = t._ctx, s = new D2();
    for (; n !== null && n.invokingState >= 0; ) {
      let o = e.states[n.invokingState].transitions[0], l = e.nextTokens(o.followState);
      s.addSet(l), n = n.parent;
    }
    return s.removeOne(h2.EPSILON), s;
  }
  consumeUntil(t, e) {
    let n = t.tokenStream.LA(1);
    for (; n !== h2.EOF && !e.contains(n); )
      t.consume(), n = t.tokenStream.LA(1);
  }
};
function sn2(i63, t) {
  if (i63 === null) {
    let e = { state: null, alt: null, context: null, semanticContext: null };
    return t && (e.reachesIntoOuterContext = 0), e;
  } else {
    let e = {};
    return e.state = i63.state || null, e.alt = i63.alt === void 0 ? null : i63.alt, e.context = i63.context || null, e.semanticContext = i63.semanticContext || null, t && (e.reachesIntoOuterContext = i63.reachesIntoOuterContext || 0, e.precedenceFilterSuppressed = i63.precedenceFilterSuppressed || false), e;
  }
}
var C2 = class i45 {
  constructor(t, e) {
    this.checkContext(t, e), t = sn2(t), e = sn2(e, true), this.state = t.state !== null ? t.state : e.state, this.alt = t.alt !== null ? t.alt : e.alt, this.context = t.context !== null ? t.context : e.context, this.semanticContext = t.semanticContext !== null ? t.semanticContext : e.semanticContext !== null ? e.semanticContext : T2.NONE, this.reachesIntoOuterContext = e.reachesIntoOuterContext, this.precedenceFilterSuppressed = e.precedenceFilterSuppressed;
  }
  checkContext(t, e) {
    (t.context === null || t.context === void 0) && (e === null || e.context === null || e.context === void 0) && (this.context = null);
  }
  hashCode() {
    let t = new R2();
    return this.updateHashCode(t), t.finish();
  }
  updateHashCode(t) {
    t.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);
  }
  equals(t) {
    return this === t ? true : t instanceof i45 ? this.state.stateNumber === t.state.stateNumber && this.alt === t.alt && (this.context === null ? t.context === null : this.context.equals(t.context)) && this.semanticContext.equals(t.semanticContext) && this.precedenceFilterSuppressed === t.precedenceFilterSuppressed : false;
  }
  hashCodeForConfigSet() {
    let t = new R2();
    return t.update(this.state.stateNumber, this.alt, this.semanticContext), t.finish();
  }
  equalsForConfigSet(t) {
    return this === t ? true : t instanceof i45 ? this.state.stateNumber === t.state.stateNumber && this.alt === t.alt && this.semanticContext.equals(t.semanticContext) : false;
  }
  toString() {
    return "(" + this.state + "," + this.alt + (this.context !== null ? ",[" + this.context.toString() + "]" : "") + (this.semanticContext !== T2.NONE ? "," + this.semanticContext.toString() : "") + (this.reachesIntoOuterContext > 0 ? ",up=" + this.reachesIntoOuterContext : "") + ")";
  }
};
var L2 = class extends _2 {
  get stateType() {
    return m2.RULE_STOP;
  }
};
var ht2 = class extends O2 {
  constructor(t, e, n, s) {
    super(t), this.ruleIndex = e, this.precedence = n, this.followState = s, this.serializationType = d2.RULE, this.isEpsilon = true;
  }
  matches(t, e, n) {
    return false;
  }
};
var Tt2 = class extends O2 {
  constructor(t, e) {
    super(t), this.serializationType = d2.SET, e != null ? this.label = e : (this.label = new D2(), this.label.addOne(h2.INVALID_TYPE));
  }
  matches(t, e, n) {
    return this.label.contains(t);
  }
  toString() {
    return this.label.toString();
  }
};
var ot2 = class extends Tt2 {
  constructor(t, e) {
    super(t, e), this.serializationType = d2.NOT_SET;
  }
  matches(t, e, n) {
    return t >= e && t <= n && !super.matches(t, e, n);
  }
  toString() {
    return "~" + super.toString();
  }
};
var Yt2 = class extends O2 {
  constructor(t) {
    super(t), this.serializationType = d2.WILDCARD;
  }
  matches(t, e, n) {
    return t >= e && t <= n;
  }
  toString() {
    return ".";
  }
};
function rn2(i63, t) {
  return i63 = i63.replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r"), t && (i63 = i63.replace(/ /g, "\xB7")), i63;
}
var P2 = { toStringTree: function(i63, t, e) {
  t = t || null, e = e || null, e !== null && (t = e.ruleNames);
  let n = P2.getNodeText(i63, t);
  n = rn2(n, false);
  let s = i63.getChildCount();
  if (s === 0)
    return n;
  let r = "(" + n + " ";
  s > 0 && (n = P2.toStringTree(i63.getChild(0), t), r = r.concat(n));
  for (let o = 1; o < s; o++)
    n = P2.toStringTree(i63.getChild(o), t), r = r.concat(" " + n);
  return r = r.concat(")"), r;
}, getNodeText: function(i63, t, e) {
  if (t = t || null, e = e || null, e !== null && (t = e.ruleNames), t !== null)
    if (i63 instanceof U2) {
      let r = i63.ruleContext.getAltNumber();
      return r != 0 ? t[i63.ruleIndex] + ":" + r : t[i63.ruleIndex];
    } else {
      if (i63 instanceof it2)
        return i63.toString();
      if (i63 instanceof w2 && i63.symbol !== null)
        return i63.symbol.text;
    }
  let n = i63.getPayload();
  return n instanceof h2 ? n.text : i63.getPayload().toString();
}, getChildren: function(i63) {
  let t = [];
  for (let e = 0; e < i63.getChildCount(); e++)
    t.push(i63.getChild(e));
  return t;
}, getAncestors: function(i63) {
  let t = [];
  for (i63 = i63.getParent(); i63 !== null; )
    t = [i63].concat(t), i63 = i63.getParent();
  return t;
}, findAllTokenNodes: function(i63, t) {
  return P2.findAllNodes(i63, t, true);
}, findAllRuleNodes: function(i63, t) {
  return P2.findAllNodes(i63, t, false);
}, findAllNodes: function(i63, t, e) {
  let n = [];
  return P2._findAllNodes(i63, t, e, n), n;
}, _findAllNodes: function(i63, t, e, n) {
  e && i63 instanceof w2 ? i63.symbol.type === t && n.push(i63) : !e && i63 instanceof U2 && i63.ruleIndex === t && n.push(i63);
  for (let s = 0; s < i63.getChildCount(); s++)
    P2._findAllNodes(i63.getChild(s), t, e, n);
}, descendants: function(i63) {
  let t = [i63];
  for (let e = 0; e < i63.getChildCount(); e++)
    t = t.concat(P2.descendants(i63.getChild(e)));
  return t;
} };
var U2 = class extends Bt2 {
  constructor(t, e) {
    super(), this._parent = t ?? null, this.children = null, this.invokingState = e ?? -1;
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    this._parent = t;
  }
  depth() {
    let t = 0, e = this;
    for (; e !== null; )
      e = e.parent, t += 1;
    return t;
  }
  isEmpty() {
    return this.invokingState === -1;
  }
  getSourceInterval() {
    return g2.INVALID_INTERVAL;
  }
  get ruleContext() {
    return this;
  }
  get ruleIndex() {
    return -1;
  }
  getPayload() {
    return this;
  }
  getText() {
    return this.getChildCount() === 0 ? "" : this.children.map(function(t) {
      return t.getText();
    }).join("");
  }
  getAltNumber() {
    return 0;
  }
  setAltNumber(t) {
  }
  setParent(t) {
    this.parent = t;
  }
  getChild(t) {
    return null;
  }
  getChildCount() {
    return 0;
  }
  accept(t) {
    return t.visitChildren(this);
  }
  toStringTree(t, e) {
    return P2.toStringTree(this, t, e);
  }
  toString(t, e) {
    t = t || null, e = e || null;
    let n = this, s = "[";
    for (; n !== null && n !== e; ) {
      if (t === null)
        n.isEmpty() || (s += n.invokingState);
      else {
        let r = n.ruleIndex, o = r >= 0 && r < t.length ? t[r] : "" + r;
        s += o;
      }
      n.parent !== null && (t !== null || !n.parent.isEmpty()) && (s += " "), n = n.parent;
    }
    return s += "]", s;
  }
};
var x2 = class i46 {
  constructor(t) {
    this.cachedHashCode = t;
  }
  isEmpty() {
    return this === i46.EMPTY;
  }
  hasEmptyPath() {
    return this.getReturnState(this.length - 1) === i46.EMPTY_RETURN_STATE;
  }
  hashCode() {
    return this.cachedHashCode;
  }
  updateHashCode(t) {
    t.update(this.cachedHashCode);
  }
};
x2.EMPTY = null;
x2.EMPTY_RETURN_STATE = 2147483647;
x2.globalNodeCount = 1;
x2.id = x2.globalNodeCount;
x2.trace_atn_sim = false;
var et2 = class i47 extends x2 {
  constructor(t, e) {
    let n = new R2();
    n.update(t, e);
    let s = n.finish();
    return super(s), this.parents = t, this.returnStates = e, this;
  }
  isEmpty() {
    return this.returnStates[0] === x2.EMPTY_RETURN_STATE;
  }
  getParent(t) {
    return this.parents[t];
  }
  getReturnState(t) {
    return this.returnStates[t];
  }
  equals(t) {
    return this === t ? true : t instanceof i47 ? this.hashCode() !== t.hashCode() ? false : pt2(this.returnStates, t.returnStates) && pt2(this.parents, t.parents) : false;
  }
  toString() {
    if (this.isEmpty())
      return "[]";
    {
      let t = "[";
      for (let e = 0; e < this.returnStates.length; e++) {
        if (e > 0 && (t = t + ", "), this.returnStates[e] === x2.EMPTY_RETURN_STATE) {
          t = t + "$";
          continue;
        }
        t = t + this.returnStates[e], this.parents[e] !== null ? t = t + " " + this.parents[e] : t = t + "null";
      }
      return t + "]";
    }
  }
  get length() {
    return this.returnStates.length;
  }
};
var v2 = class i48 extends x2 {
  constructor(t, e) {
    let n = 0, s = new R2();
    t !== null ? s.update(t, e) : s.update(1), n = s.finish(), super(n), this.parent = t, this.returnState = e;
  }
  getParent(t) {
    return this.parent;
  }
  getReturnState(t) {
    return this.returnState;
  }
  equals(t) {
    return this === t ? true : t instanceof i48 ? this.hashCode() !== t.hashCode() || this.returnState !== t.returnState ? false : this.parent == null ? t.parent == null : this.parent.equals(t.parent) : false;
  }
  toString() {
    let t = this.parent === null ? "" : this.parent.toString();
    return t.length === 0 ? this.returnState === x2.EMPTY_RETURN_STATE ? "$" : "" + this.returnState : "" + this.returnState + " " + t;
  }
  get length() {
    return 1;
  }
  static create(t, e) {
    return e === x2.EMPTY_RETURN_STATE && t === null ? x2.EMPTY : new i48(t, e);
  }
};
var qt2 = class extends v2 {
  constructor() {
    super(null, x2.EMPTY_RETURN_STATE);
  }
  isEmpty() {
    return true;
  }
  getParent(t) {
    return null;
  }
  getReturnState(t) {
    return this.returnState;
  }
  equals(t) {
    return this === t;
  }
  toString() {
    return "$";
  }
};
x2.EMPTY = new qt2();
var ie2 = "h-";
var Q2 = class {
  constructor(t, e) {
    this.data = {}, this.hashFunction = t || Te2, this.equalsFunction = e || Se2;
  }
  set(t, e) {
    let n = ie2 + this.hashFunction(t);
    if (n in this.data) {
      let s = this.data[n];
      for (let r = 0; r < s.length; r++) {
        let o = s[r];
        if (this.equalsFunction(t, o.key)) {
          let l = o.value;
          return o.value = e, l;
        }
      }
      return s.push({ key: t, value: e }), e;
    } else
      return this.data[n] = [{ key: t, value: e }], e;
  }
  containsKey(t) {
    let e = ie2 + this.hashFunction(t);
    if (e in this.data) {
      let n = this.data[e];
      for (let s = 0; s < n.length; s++) {
        let r = n[s];
        if (this.equalsFunction(t, r.key))
          return true;
      }
    }
    return false;
  }
  get(t) {
    let e = ie2 + this.hashFunction(t);
    if (e in this.data) {
      let n = this.data[e];
      for (let s = 0; s < n.length; s++) {
        let r = n[s];
        if (this.equalsFunction(t, r.key))
          return r.value;
      }
    }
    return null;
  }
  entries() {
    return Object.keys(this.data).filter((t) => t.startsWith(ie2)).flatMap((t) => this.data[t], this);
  }
  getKeys() {
    return this.entries().map((t) => t.key);
  }
  getValues() {
    return this.entries().map((t) => t.value);
  }
  toString() {
    return "[" + this.entries().map((e) => "{" + e.key + ":" + e.value + "}").join(", ") + "]";
  }
  get length() {
    return Object.keys(this.data).filter((t) => t.startsWith(ie2)).map((t) => this.data[t].length, this).reduce((t, e) => t + e, 0);
  }
};
function oe2(i63, t) {
  if (t == null && (t = U2.EMPTY), t.parent === null || t === U2.EMPTY)
    return x2.EMPTY;
  let e = oe2(i63, t.parent), s = i63.states[t.invokingState].transitions[0];
  return v2.create(e, s.followState.stateNumber);
}
function Qe2(i63, t, e) {
  if (i63.isEmpty())
    return i63;
  let n = e.get(i63) || null;
  if (n !== null)
    return n;
  if (n = t.get(i63), n !== null)
    return e.set(i63, n), n;
  let s = false, r = [];
  for (let l = 0; l < r.length; l++) {
    let a = Qe2(i63.getParent(l), t, e);
    if (s || a !== i63.getParent(l)) {
      if (!s) {
        r = [];
        for (let u = 0; u < i63.length; u++)
          r[u] = i63.getParent(u);
        s = true;
      }
      r[l] = a;
    }
  }
  if (!s)
    return t.add(i63), e.set(i63, i63), i63;
  let o = null;
  return r.length === 0 ? o = x2.EMPTY : r.length === 1 ? o = v2.create(r[0], i63.getReturnState(0)) : o = new et2(r, i63.returnStates), t.add(o), e.set(o, o), e.set(i63, o), o;
}
function Ae2(i63, t, e, n) {
  if (i63 === t)
    return i63;
  if (i63 instanceof v2 && t instanceof v2)
    return cn2(i63, t, e, n);
  if (e) {
    if (i63 instanceof qt2)
      return i63;
    if (t instanceof qt2)
      return t;
  }
  return i63 instanceof v2 && (i63 = new et2([i63.getParent()], [i63.returnState])), t instanceof v2 && (t = new et2([t.getParent()], [t.returnState])), un2(i63, t, e, n);
}
function un2(i63, t, e, n) {
  if (n !== null) {
    let c = n.get(i63, t);
    if (c !== null)
      return x2.trace_atn_sim && console.log("mergeArrays a=" + i63 + ",b=" + t + " -> previous"), c;
    if (c = n.get(t, i63), c !== null)
      return x2.trace_atn_sim && console.log("mergeArrays a=" + i63 + ",b=" + t + " -> previous"), c;
  }
  let s = 0, r = 0, o = 0, l = new Array(i63.returnStates.length + t.returnStates.length).fill(0), a = new Array(i63.returnStates.length + t.returnStates.length).fill(null);
  for (; s < i63.returnStates.length && r < t.returnStates.length; ) {
    let c = i63.parents[s], f = t.parents[r];
    if (i63.returnStates[s] === t.returnStates[r]) {
      let p = i63.returnStates[s];
      p === x2.EMPTY_RETURN_STATE && c === null && f === null || c !== null && f !== null && c === f ? (a[o] = c, l[o] = p) : (a[o] = Ae2(c, f, e, n), l[o] = p), s += 1, r += 1;
    } else
      i63.returnStates[s] < t.returnStates[r] ? (a[o] = c, l[o] = i63.returnStates[s], s += 1) : (a[o] = f, l[o] = t.returnStates[r], r += 1);
    o += 1;
  }
  if (s < i63.returnStates.length)
    for (let c = s; c < i63.returnStates.length; c++)
      a[o] = i63.parents[c], l[o] = i63.returnStates[c], o += 1;
  else
    for (let c = r; c < t.returnStates.length; c++)
      a[o] = t.parents[c], l[o] = t.returnStates[c], o += 1;
  if (o < a.length) {
    if (o === 1) {
      let c = v2.create(a[0], l[0]);
      return n !== null && n.set(i63, t, c), c;
    }
    a = a.slice(0, o), l = l.slice(0, o);
  }
  let u = new et2(a, l);
  return u.equals(i63) ? (n !== null && n.set(i63, t, i63), x2.trace_atn_sim && console.log("mergeArrays a=" + i63 + ",b=" + t + " -> a"), i63) : u.equals(t) ? (n !== null && n.set(i63, t, t), x2.trace_atn_sim && console.log("mergeArrays a=" + i63 + ",b=" + t + " -> b"), t) : (hn2(a), n !== null && n.set(i63, t, u), x2.trace_atn_sim && console.log("mergeArrays a=" + i63 + ",b=" + t + " -> " + u), u);
}
function hn2(i63) {
  let t = new Q2();
  for (let e = 0; e < i63.length; e++) {
    let n = i63[e];
    t.containsKey(n) || t.set(n, n);
  }
  for (let e = 0; e < i63.length; e++)
    i63[e] = t.get(i63[e]);
}
function cn2(i63, t, e, n) {
  if (n !== null) {
    let r = n.get(i63, t);
    if (r !== null || (r = n.get(t, i63), r !== null))
      return r;
  }
  let s = fn2(i63, t, e);
  if (s !== null)
    return n !== null && n.set(i63, t, s), s;
  if (i63.returnState === t.returnState) {
    let r = Ae2(i63.parent, t.parent, e, n);
    if (r === i63.parent)
      return i63;
    if (r === t.parent)
      return t;
    let o = v2.create(r, i63.returnState);
    return n !== null && n.set(i63, t, o), o;
  } else {
    let r = null;
    if ((i63 === t || i63.parent !== null && i63.parent === t.parent) && (r = i63.parent), r !== null) {
      let u = [i63.returnState, t.returnState];
      i63.returnState > t.returnState && (u[0] = t.returnState, u[1] = i63.returnState);
      let c = [r, r], f = new et2(c, u);
      return n !== null && n.set(i63, t, f), f;
    }
    let o = [i63.returnState, t.returnState], l = [i63.parent, t.parent];
    i63.returnState > t.returnState && (o[0] = t.returnState, o[1] = i63.returnState, l = [t.parent, i63.parent]);
    let a = new et2(l, o);
    return n !== null && n.set(i63, t, a), a;
  }
}
function fn2(i63, t, e) {
  if (e) {
    if (i63 === x2.EMPTY)
      return x2.EMPTY;
    if (t === x2.EMPTY)
      return x2.EMPTY;
  } else {
    if (i63 === x2.EMPTY && t === x2.EMPTY)
      return x2.EMPTY;
    if (i63 === x2.EMPTY) {
      let n = [t.returnState, x2.EMPTY_RETURN_STATE], s = [t.parent, null];
      return new et2(s, n);
    } else if (t === x2.EMPTY) {
      let n = [i63.returnState, x2.EMPTY_RETURN_STATE], s = [i63.parent, null];
      return new et2(s, n);
    }
  }
  return null;
}
var H2 = class {
  constructor() {
    this.data = [];
  }
  clear(t) {
    t === void 0 ? this.data = [] : (this.resize(t), this.data[t >>> 5] &= ~(1 << t));
  }
  or(t) {
    let e = Math.min(this.data.length, t.data.length), n = 0;
    for (; n + 7 < e; n += 8)
      this.data[n] |= t.data[n], this.data[n + 1] |= t.data[n + 1], this.data[n + 2] |= t.data[n + 2], this.data[n + 3] |= t.data[n + 3], this.data[n + 4] |= t.data[n + 4], this.data[n + 5] |= t.data[n + 5], this.data[n + 6] |= t.data[n + 6], this.data[n + 7] |= t.data[n + 7];
    for (; n < e; ++n)
      this.data[n] |= t.data[n];
    if (this.data.length < t.data.length) {
      this.resize((t.data.length << 5) - 1);
      let s = t.data.length;
      for (let r = e; r < s; ++r)
        this.data[r] = t.data[r];
    }
  }
  get(t) {
    return (this.data[t >>> 5] & 1 << t) !== 0;
  }
  get length() {
    let t = 0, e = this.data.length, n = this.data;
    for (let s = 0; s < e; s++)
      t += this.bitCount(n[s]);
    return t;
  }
  values() {
    let t = new Array(this.length()), e = 0, n = this.data.length;
    for (let s = 0; s < n; ++s) {
      let r = this.data[s];
      for (; r != 0; ) {
        let o = r & -r;
        t[e++] = (s << 5) + this.bitCount(o - 1 | 0), r ^= o;
      }
    }
    return t;
  }
  nextSetBit(t) {
    for (let e of this)
      if (e > t)
        return e;
  }
  set(t) {
    this.resize(t), this.data[t >>> 5] |= 1 << t;
  }
  toString() {
    return "{" + this.values().join(", ") + "}";
  }
  resize(t) {
    let e = t + 32 >>> 5;
    for (let n = this.data.length; n < e; n++)
      this.data[n] = 0;
  }
  bitCount(t) {
    return t -= t >>> 1 & 1431655765, t = (t & 858993459) + (t >>> 2 & 858993459), (t + (t >>> 4) & 252645135) * 16843009 >>> 24;
  }
  [Symbol.iterator]() {
    let t = this.data.length, e = 0, n = this.data[e], s = this.bitCount, r = this.data;
    return { [Symbol.iterator]() {
      return this;
    }, next() {
      for (; e < t; )
        if (n !== 0) {
          let o = n & -n, l = (e << 5) + s(o - 1 | 0);
          return n ^= o, { done: false, value: l };
        } else
          e++, e < t && (n = r[e]);
      return { done: true, value: void 0 };
    } };
  }
};
var Rt2 = class i49 {
  constructor(t) {
    this.atn = t;
  }
  getDecisionLookahead(t) {
    if (t === null)
      return null;
    let e = t.transitions.length, n = [];
    for (let s = 0; s < e; s++) {
      n[s] = new D2();
      let r = new k2(), o = false;
      this._LOOK(t.transition(s).target, null, x2.EMPTY, n[s], r, new H2(), o, false), (n[s].length === 0 || n[s].contains(i49.HIT_PRED)) && (n[s] = null);
    }
    return n;
  }
  LOOK(t, e, n) {
    let s = new D2(), r = true;
    n = n || null;
    let o = n !== null ? oe2(t.atn, n) : null;
    return this._LOOK(t, e, o, s, new k2(), new H2(), r, true), s;
  }
  _LOOK(t, e, n, s, r, o, l, a) {
    let u = new C2({ state: t, alt: 0, context: n }, null);
    if (!r.has(u)) {
      if (r.add(u), t === e) {
        if (n === null) {
          s.addOne(h2.EPSILON);
          return;
        } else if (n.isEmpty() && a) {
          s.addOne(h2.EOF);
          return;
        }
      }
      if (t instanceof L2) {
        if (n === null) {
          s.addOne(h2.EPSILON);
          return;
        } else if (n.isEmpty() && a) {
          s.addOne(h2.EOF);
          return;
        }
        if (n !== x2.EMPTY) {
          let c = o.get(t.ruleIndex);
          try {
            o.clear(t.ruleIndex);
            for (let f = 0; f < n.length; f++) {
              let p = this.atn.states[n.getReturnState(f)];
              this._LOOK(p, e, n.getParent(f), s, r, o, l, a);
            }
          } finally {
            c && o.set(t.ruleIndex);
          }
          return;
        }
      }
      for (let c = 0; c < t.transitions.length; c++) {
        let f = t.transitions[c];
        if (f.constructor === ht2) {
          if (o.get(f.target.ruleIndex))
            continue;
          let p = v2.create(n, f.followState.stateNumber);
          try {
            o.set(f.target.ruleIndex), this._LOOK(f.target, e, p, s, r, o, l, a);
          } finally {
            o.clear(f.target.ruleIndex);
          }
        } else if (f instanceof mt2)
          l ? this._LOOK(f.target, e, n, s, r, o, l, a) : s.addOne(i49.HIT_PRED);
        else if (f.isEpsilon)
          this._LOOK(f.target, e, n, s, r, o, l, a);
        else if (f.constructor === Yt2)
          s.addRange(h2.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
        else {
          let p = f.label;
          p !== null && (f instanceof ot2 && (p = p.complement(h2.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType)), s.addSet(p));
        }
      }
    }
  }
};
Rt2.HIT_PRED = h2.INVALID_TYPE;
var S2 = class {
  constructor(t, e) {
    this.grammarType = t, this.maxTokenType = e, this.states = [], this.decisionToState = [], this.ruleToStartState = [], this.ruleToStopState = [], this.modeNameToStartState = {}, this.ruleToTokenType = [], this.lexerActions = [], this.modeToStartState = [];
  }
  nextTokensInContext(t, e) {
    return new Rt2(this).LOOK(t, null, e);
  }
  nextTokensNoContext(t) {
    return t.nextTokenWithinRule !== null || (t.nextTokenWithinRule = this.nextTokensInContext(t, null), t.nextTokenWithinRule.readOnly = true), t.nextTokenWithinRule;
  }
  nextTokens(t, e) {
    return e === void 0 ? this.nextTokensNoContext(t) : this.nextTokensInContext(t, e);
  }
  addState(t) {
    t !== null && (t.atn = this, t.stateNumber = this.states.length), this.states.push(t);
  }
  removeState(t) {
    this.states[t.stateNumber] = null;
  }
  defineDecisionState(t) {
    return this.decisionToState.push(t), t.decision = this.decisionToState.length - 1, t.decision;
  }
  getDecisionState(t) {
    return this.decisionToState.length === 0 ? null : this.decisionToState[t];
  }
  getExpectedTokens(t, e) {
    if (t < 0 || t >= this.states.length)
      throw "Invalid state number.";
    let n = this.states[t], s = this.nextTokens(n);
    if (!s.contains(h2.EPSILON))
      return s;
    let r = new D2();
    for (r.addSet(s), r.removeOne(h2.EPSILON); e !== null && e.invokingState >= 0 && s.contains(h2.EPSILON); ) {
      let l = this.states[e.invokingState].transitions[0];
      s = this.nextTokens(l.followState), r.addSet(s), r.removeOne(h2.EPSILON), e = e.parent;
    }
    return s.contains(h2.EPSILON) && r.addOne(h2.EOF), r;
  }
};
S2.INVALID_ALT_NUMBER = 0;
var wt2 = { LEXER: 0, PARSER: 1 };
var Ot2 = class extends _2 {
  get stateType() {
    return m2.BASIC;
  }
};
var B2 = class extends _2 {
  constructor() {
    return super(), this.decision = -1, this.nonGreedy = false, this;
  }
};
var q2 = class extends B2 {
  constructor() {
    return super(), this.endState = null, this;
  }
};
var Kt2 = class extends _2 {
  get stateType() {
    return m2.BLOCK_END;
  }
};
var W2 = class extends _2 {
  get stateType() {
    return m2.LOOP_END;
  }
};
var le2 = class extends _2 {
  constructor() {
    super(), this.isPrecedenceRule = false;
  }
  get stateType() {
    return m2.RULE_START;
  }
};
var jt2 = class extends B2 {
  get stateType() {
    return m2.TOKEN_START;
  }
};
var Dt2 = class extends B2 {
  get stateType() {
    return m2.PLUS_LOOP_BACK;
  }
};
var St2 = class extends _2 {
  get stateType() {
    return m2.STAR_LOOP_BACK;
  }
};
var Y2 = class extends B2 {
  constructor() {
    super(), this.precedenceRuleDecision = false;
  }
  get stateType() {
    return m2.STAR_LOOP_ENTRY;
  }
};
var Et2 = class extends q2 {
  get stateType() {
    return m2.PLUS_BLOCK_START;
  }
};
var At2 = class extends q2 {
  get stateType() {
    return m2.STAR_BLOCK_START;
  }
};
var ae2 = class extends q2 {
  get stateType() {
    return m2.BLOCK_START;
  }
};
var Nt2 = class extends O2 {
  constructor(t, e) {
    super(t), this.label_ = e, this.label = this.makeLabel(), this.serializationType = d2.ATOM;
  }
  makeLabel() {
    let t = new D2();
    return t.addOne(this.label_), t;
  }
  matches(t, e, n) {
    return this.label_ === t;
  }
  toString() {
    return this.label_;
  }
};
var ue2 = class extends O2 {
  constructor(t, e, n) {
    super(t), this.serializationType = d2.RANGE, this.start = e, this.stop = n, this.label = this.makeLabel();
  }
  makeLabel() {
    let t = new D2();
    return t.addRange(this.start, this.stop), t;
  }
  matches(t, e, n) {
    return t >= this.start && t <= this.stop;
  }
  toString() {
    return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
  }
};
var Gt2 = class extends O2 {
  constructor(t, e, n, s) {
    super(t), this.serializationType = d2.ACTION, this.ruleIndex = e, this.actionIndex = n === void 0 ? -1 : n, this.isCtxDependent = s === void 0 ? false : s, this.isEpsilon = true;
  }
  matches(t, e, n) {
    return false;
  }
  toString() {
    return "action_" + this.ruleIndex + ":" + this.actionIndex;
  }
};
var Ct2 = class extends O2 {
  constructor(t, e) {
    super(t), this.serializationType = d2.EPSILON, this.isEpsilon = true, this.outermostPrecedenceReturn = e;
  }
  matches(t, e, n) {
    return false;
  }
  toString() {
    return "epsilon";
  }
};
var he2 = class i50 extends T2 {
  constructor(t) {
    super(), this.precedence = t === void 0 ? 0 : t;
  }
  evaluate(t, e) {
    return t.precpred(e, this.precedence);
  }
  evalPrecedence(t, e) {
    return t.precpred(e, this.precedence) ? T2.NONE : null;
  }
  compareTo(t) {
    return this.precedence - t.precedence;
  }
  updateHashCode(t) {
    t.update(this.precedence);
  }
  equals(t) {
    return this === t ? true : t instanceof i50 ? this.precedence === t.precedence : false;
  }
  toString() {
    return "{" + this.precedence + ">=prec}?";
  }
};
T2.PrecedencePredicate = he2;
var Ne2 = class extends mt2 {
  constructor(t, e) {
    super(t), this.serializationType = d2.PRECEDENCE, this.precedence = e, this.isEpsilon = true;
  }
  matches(t, e, n) {
    return false;
  }
  getPredicate() {
    return new he2(this.precedence);
  }
  toString() {
    return this.precedence + " >= _p";
  }
};
var ct2 = class {
  constructor(t) {
    t === void 0 && (t = null), this.readOnly = false, this.verifyATN = t === null ? true : t.verifyATN, this.generateRuleBypassTransitions = t === null ? false : t.generateRuleBypassTransitions;
  }
};
ct2.defaultOptions = new ct2();
ct2.defaultOptions.readOnly = true;
var y2 = { CHANNEL: 0, CUSTOM: 1, MODE: 2, MORE: 3, POP_MODE: 4, PUSH_MODE: 5, SKIP: 6, TYPE: 7 };
var F2 = class {
  constructor(t) {
    this.actionType = t, this.isPositionDependent = false;
  }
  hashCode() {
    let t = new R2();
    return this.updateHashCode(t), t.finish();
  }
  updateHashCode(t) {
    t.update(this.actionType);
  }
  equals(t) {
    return this === t;
  }
};
var Wt2 = class extends F2 {
  constructor() {
    super(y2.SKIP);
  }
  execute(t) {
    t.skip();
  }
  toString() {
    return "skip";
  }
};
Wt2.INSTANCE = new Wt2();
var Ce2 = class i51 extends F2 {
  constructor(t) {
    super(y2.CHANNEL), this.channel = t;
  }
  execute(t) {
    t._channel = this.channel;
  }
  updateHashCode(t) {
    t.update(this.actionType, this.channel);
  }
  equals(t) {
    return this === t ? true : t instanceof i51 ? this.channel === t.channel : false;
  }
  toString() {
    return "channel(" + this.channel + ")";
  }
};
var ye2 = class i52 extends F2 {
  constructor(t, e) {
    super(y2.CUSTOM), this.ruleIndex = t, this.actionIndex = e, this.isPositionDependent = true;
  }
  execute(t) {
    t.action(null, this.ruleIndex, this.actionIndex);
  }
  updateHashCode(t) {
    t.update(this.actionType, this.ruleIndex, this.actionIndex);
  }
  equals(t) {
    return this === t ? true : t instanceof i52 ? this.ruleIndex === t.ruleIndex && this.actionIndex === t.actionIndex : false;
  }
};
var Xt2 = class extends F2 {
  constructor() {
    super(y2.MORE);
  }
  execute(t) {
    t.more();
  }
  toString() {
    return "more";
  }
};
Xt2.INSTANCE = new Xt2();
var _e2 = class i53 extends F2 {
  constructor(t) {
    super(y2.TYPE), this.type = t;
  }
  execute(t) {
    t.type = this.type;
  }
  updateHashCode(t) {
    t.update(this.actionType, this.type);
  }
  equals(t) {
    return this === t ? true : t instanceof i53 ? this.type === t.type : false;
  }
  toString() {
    return "type(" + this.type + ")";
  }
};
var Ie2 = class i54 extends F2 {
  constructor(t) {
    super(y2.PUSH_MODE), this.mode = t;
  }
  execute(t) {
    t.pushMode(this.mode);
  }
  updateHashCode(t) {
    t.update(this.actionType, this.mode);
  }
  equals(t) {
    return this === t ? true : t instanceof i54 ? this.mode === t.mode : false;
  }
  toString() {
    return "pushMode(" + this.mode + ")";
  }
};
var zt2 = class extends F2 {
  constructor() {
    super(y2.POP_MODE);
  }
  execute(t) {
    t.popMode();
  }
  toString() {
    return "popMode";
  }
};
zt2.INSTANCE = new zt2();
var ke2 = class i55 extends F2 {
  constructor(t) {
    super(y2.MODE), this.mode = t;
  }
  execute(t) {
    t.mode(this.mode);
  }
  updateHashCode(t) {
    t.update(this.actionType, this.mode);
  }
  equals(t) {
    return this === t ? true : t instanceof i55 ? this.mode === t.mode : false;
  }
  toString() {
    return "mode(" + this.mode + ")";
  }
};
var Ze2 = 4;
function Le2(i63, t) {
  let e = [];
  return e[i63 - 1] = t, e.map(function(n) {
    return t;
  });
}
var yt2 = class {
  constructor(t) {
    t == null && (t = ct2.defaultOptions), this.deserializationOptions = t, this.stateFactories = null, this.actionFactories = null;
  }
  deserialize(t) {
    let e = this.reset(t);
    this.checkVersion(e), e && this.skipUUID();
    let n = this.readATN();
    this.readStates(n, e), this.readRules(n, e), this.readModes(n);
    let s = [];
    return this.readSets(n, s, this.readInt.bind(this)), e && this.readSets(n, s, this.readInt32.bind(this)), this.readEdges(n, s), this.readDecisions(n), this.readLexerActions(n, e), this.markPrecedenceDecisions(n), this.verifyATN(n), this.deserializationOptions.generateRuleBypassTransitions && n.grammarType === wt2.PARSER && (this.generateRuleBypassTransitions(n), this.verifyATN(n)), n;
  }
  reset(t) {
    if ((t.charCodeAt ? t.charCodeAt(0) : t[0]) === Ze2 - 1) {
      let n = function(r) {
        let o = r.charCodeAt(0);
        return o > 1 ? o - 2 : o + 65534;
      }, s = t.split("").map(n);
      return s[0] = t.charCodeAt(0), this.data = s, this.pos = 0, true;
    } else
      return this.data = t, this.pos = 0, false;
  }
  skipUUID() {
    let t = 0;
    for (; t++ < 8; )
      this.readInt();
  }
  checkVersion(t) {
    let e = this.readInt();
    if (!t && e !== Ze2)
      throw "Could not deserialize ATN with version " + e + " (expected " + Ze2 + ").";
  }
  readATN() {
    let t = this.readInt(), e = this.readInt();
    return new S2(t, e);
  }
  readStates(t, e) {
    let n, s, r, o = [], l = [], a = this.readInt();
    for (let f = 0; f < a; f++) {
      let p = this.readInt();
      if (p === m2.INVALID_TYPE) {
        t.addState(null);
        continue;
      }
      let E = this.readInt();
      e && E === 65535 && (E = -1);
      let tt = this.stateFactory(p, E);
      if (p === m2.LOOP_END) {
        let kt = this.readInt();
        o.push([tt, kt]);
      } else if (tt instanceof q2) {
        let kt = this.readInt();
        l.push([tt, kt]);
      }
      t.addState(tt);
    }
    for (n = 0; n < o.length; n++)
      s = o[n], s[0].loopBackState = t.states[s[1]];
    for (n = 0; n < l.length; n++)
      s = l[n], s[0].endState = t.states[s[1]];
    let u = this.readInt();
    for (n = 0; n < u; n++)
      r = this.readInt(), t.states[r].nonGreedy = true;
    let c = this.readInt();
    for (n = 0; n < c; n++)
      r = this.readInt(), t.states[r].isPrecedenceRule = true;
  }
  readRules(t, e) {
    let n, s = this.readInt();
    for (t.grammarType === wt2.LEXER && (t.ruleToTokenType = Le2(s, 0)), t.ruleToStartState = Le2(s, 0), n = 0; n < s; n++) {
      let r = this.readInt();
      if (t.ruleToStartState[n] = t.states[r], t.grammarType === wt2.LEXER) {
        let o = this.readInt();
        e && o === 65535 && (o = h2.EOF), t.ruleToTokenType[n] = o;
      }
    }
    for (t.ruleToStopState = Le2(s, 0), n = 0; n < t.states.length; n++) {
      let r = t.states[n];
      r instanceof L2 && (t.ruleToStopState[r.ruleIndex] = r, t.ruleToStartState[r.ruleIndex].stopState = r);
    }
  }
  readModes(t) {
    let e = this.readInt();
    for (let n = 0; n < e; n++) {
      let s = this.readInt();
      t.modeToStartState.push(t.states[s]);
    }
  }
  readSets(t, e, n) {
    let s = this.readInt();
    for (let r = 0; r < s; r++) {
      let o = new D2();
      e.push(o);
      let l = this.readInt();
      this.readInt() !== 0 && o.addOne(-1);
      for (let u = 0; u < l; u++) {
        let c = n(), f = n();
        o.addRange(c, f);
      }
    }
  }
  readEdges(t, e) {
    let n, s, r, o, l, a = this.readInt();
    for (n = 0; n < a; n++) {
      let u = this.readInt(), c = this.readInt(), f = this.readInt(), p = this.readInt(), E = this.readInt(), tt = this.readInt();
      o = this.edgeFactory(t, f, u, c, p, E, tt, e), t.states[u].addTransition(o);
    }
    for (n = 0; n < t.states.length; n++)
      for (r = t.states[n], s = 0; s < r.transitions.length; s++) {
        let u = r.transitions[s];
        if (!(u instanceof ht2))
          continue;
        let c = -1;
        t.ruleToStartState[u.target.ruleIndex].isPrecedenceRule && u.precedence === 0 && (c = u.target.ruleIndex), o = new Ct2(u.followState, c), t.ruleToStopState[u.target.ruleIndex].addTransition(o);
      }
    for (n = 0; n < t.states.length; n++) {
      if (r = t.states[n], r instanceof q2) {
        if (r.endState === null || r.endState.startState)
          throw "IllegalState";
        r.endState.startState = r;
      }
      if (r instanceof Dt2)
        for (s = 0; s < r.transitions.length; s++)
          l = r.transitions[s].target, l instanceof Et2 && (l.loopBackState = r);
      else if (r instanceof St2)
        for (s = 0; s < r.transitions.length; s++)
          l = r.transitions[s].target, l instanceof Y2 && (l.loopBackState = r);
    }
  }
  readDecisions(t) {
    let e = this.readInt();
    for (let n = 0; n < e; n++) {
      let s = this.readInt(), r = t.states[s];
      t.decisionToState.push(r), r.decision = n;
    }
  }
  readLexerActions(t, e) {
    if (t.grammarType === wt2.LEXER) {
      let n = this.readInt();
      t.lexerActions = Le2(n, null);
      for (let s = 0; s < n; s++) {
        let r = this.readInt(), o = this.readInt();
        e && o === 65535 && (o = -1);
        let l = this.readInt();
        e && l === 65535 && (l = -1), t.lexerActions[s] = this.lexerActionFactory(r, o, l);
      }
    }
  }
  generateRuleBypassTransitions(t) {
    let e, n = t.ruleToStartState.length;
    for (e = 0; e < n; e++)
      t.ruleToTokenType[e] = t.maxTokenType + e + 1;
    for (e = 0; e < n; e++)
      this.generateRuleBypassTransition(t, e);
  }
  generateRuleBypassTransition(t, e) {
    let n, s, r = new ae2();
    r.ruleIndex = e, t.addState(r);
    let o = new Kt2();
    o.ruleIndex = e, t.addState(o), r.endState = o, t.defineDecisionState(r), o.startState = r;
    let l = null, a = null;
    if (t.ruleToStartState[e].isPrecedenceRule) {
      for (a = null, n = 0; n < t.states.length; n++)
        if (s = t.states[n], this.stateIsEndStateFor(s, e)) {
          a = s, l = s.loopBackState.transitions[0];
          break;
        }
      if (l === null)
        throw "Couldn't identify final state of the precedence rule prefix section.";
    } else
      a = t.ruleToStopState[e];
    for (n = 0; n < t.states.length; n++) {
      s = t.states[n];
      for (let p = 0; p < s.transitions.length; p++) {
        let E = s.transitions[p];
        E !== l && E.target === a && (E.target = o);
      }
    }
    let u = t.ruleToStartState[e], c = u.transitions.length;
    for (; c > 0; )
      r.addTransition(u.transitions[c - 1]), u.transitions = u.transitions.slice(-1);
    t.ruleToStartState[e].addTransition(new Ct2(r)), o.addTransition(new Ct2(a));
    let f = new Ot2();
    t.addState(f), f.addTransition(new Nt2(o, t.ruleToTokenType[e])), r.addTransition(new Ct2(f));
  }
  stateIsEndStateFor(t, e) {
    if (t.ruleIndex !== e || !(t instanceof Y2))
      return null;
    let n = t.transitions[t.transitions.length - 1].target;
    return n instanceof W2 && n.epsilonOnlyTransitions && n.transitions[0].target instanceof L2 ? t : null;
  }
  markPrecedenceDecisions(t) {
    for (let e = 0; e < t.states.length; e++) {
      let n = t.states[e];
      if (n instanceof Y2 && t.ruleToStartState[n.ruleIndex].isPrecedenceRule) {
        let s = n.transitions[n.transitions.length - 1].target;
        s instanceof W2 && s.epsilonOnlyTransitions && s.transitions[0].target instanceof L2 && (n.precedenceRuleDecision = true);
      }
    }
  }
  verifyATN(t) {
    if (this.deserializationOptions.verifyATN)
      for (let e = 0; e < t.states.length; e++) {
        let n = t.states[e];
        if (n !== null)
          if (this.checkCondition(n.epsilonOnlyTransitions || n.transitions.length <= 1), n instanceof Et2)
            this.checkCondition(n.loopBackState !== null);
          else if (n instanceof Y2)
            if (this.checkCondition(n.loopBackState !== null), this.checkCondition(n.transitions.length === 2), n.transitions[0].target instanceof At2)
              this.checkCondition(n.transitions[1].target instanceof W2), this.checkCondition(!n.nonGreedy);
            else if (n.transitions[0].target instanceof W2)
              this.checkCondition(n.transitions[1].target instanceof At2), this.checkCondition(n.nonGreedy);
            else
              throw "IllegalState";
          else
            n instanceof St2 ? (this.checkCondition(n.transitions.length === 1), this.checkCondition(n.transitions[0].target instanceof Y2)) : n instanceof W2 ? this.checkCondition(n.loopBackState !== null) : n instanceof le2 ? this.checkCondition(n.stopState !== null) : n instanceof q2 ? this.checkCondition(n.endState !== null) : n instanceof Kt2 ? this.checkCondition(n.startState !== null) : n instanceof B2 ? this.checkCondition(n.transitions.length <= 1 || n.decision >= 0) : this.checkCondition(n.transitions.length <= 1 || n instanceof L2);
      }
  }
  checkCondition(t, e) {
    if (!t)
      throw e == null && (e = "IllegalState"), e;
  }
  readInt() {
    return this.data[this.pos++];
  }
  readInt32() {
    let t = this.readInt(), e = this.readInt();
    return t | e << 16;
  }
  edgeFactory(t, e, n, s, r, o, l, a) {
    let u = t.states[s];
    switch (e) {
      case d2.EPSILON:
        return new Ct2(u);
      case d2.RANGE:
        return l !== 0 ? new ue2(u, h2.EOF, o) : new ue2(u, r, o);
      case d2.RULE:
        return new ht2(t.states[r], o, l, u);
      case d2.PREDICATE:
        return new Vt2(u, r, o, l !== 0);
      case d2.PRECEDENCE:
        return new Ne2(u, r);
      case d2.ATOM:
        return l !== 0 ? new Nt2(u, h2.EOF) : new Nt2(u, r);
      case d2.ACTION:
        return new Gt2(u, r, o, l !== 0);
      case d2.SET:
        return new Tt2(u, a[r]);
      case d2.NOT_SET:
        return new ot2(u, a[r]);
      case d2.WILDCARD:
        return new Yt2(u);
      default:
        throw "The specified transition type: " + e + " is not valid.";
    }
  }
  stateFactory(t, e) {
    if (this.stateFactories === null) {
      let n = [];
      n[m2.INVALID_TYPE] = null, n[m2.BASIC] = () => new Ot2(), n[m2.RULE_START] = () => new le2(), n[m2.BLOCK_START] = () => new ae2(), n[m2.PLUS_BLOCK_START] = () => new Et2(), n[m2.STAR_BLOCK_START] = () => new At2(), n[m2.TOKEN_START] = () => new jt2(), n[m2.RULE_STOP] = () => new L2(), n[m2.BLOCK_END] = () => new Kt2(), n[m2.STAR_LOOP_BACK] = () => new St2(), n[m2.STAR_LOOP_ENTRY] = () => new Y2(), n[m2.PLUS_LOOP_BACK] = () => new Dt2(), n[m2.LOOP_END] = () => new W2(), this.stateFactories = n;
    }
    if (t > this.stateFactories.length || this.stateFactories[t] === null)
      throw "The specified state type " + t + " is not valid.";
    {
      let n = this.stateFactories[t]();
      if (n !== null)
        return n.ruleIndex = e, n;
    }
  }
  lexerActionFactory(t, e, n) {
    if (this.actionFactories === null) {
      let s = [];
      s[y2.CHANNEL] = (r, o) => new Ce2(r), s[y2.CUSTOM] = (r, o) => new ye2(r, o), s[y2.MODE] = (r, o) => new ke2(r), s[y2.MORE] = (r, o) => Xt2.INSTANCE, s[y2.POP_MODE] = (r, o) => zt2.INSTANCE, s[y2.PUSH_MODE] = (r, o) => new Ie2(r), s[y2.SKIP] = (r, o) => Wt2.INSTANCE, s[y2.TYPE] = (r, o) => new _e2(r), this.actionFactories = s;
    }
    if (t > this.actionFactories.length || this.actionFactories[t] === null)
      throw "The specified lexer action type " + t + " is not valid.";
    return this.actionFactories[t](e, n);
  }
};
var $t2 = class {
  visitTerminal(t) {
  }
  visitErrorNode(t) {
  }
  enterEveryRule(t) {
  }
  exitEveryRule(t) {
  }
};
var Re2 = class extends $t2 {
  constructor(t) {
    super(), this.parser = t;
  }
  enterEveryRule(t) {
    console.log("enter   " + this.parser.ruleNames[t.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
  }
  visitTerminal(t) {
    console.log("consume " + t.symbol + " rule " + this.parser.ruleNames[this.parser._ctx.ruleIndex]);
  }
  exitEveryRule(t) {
    console.log("exit    " + this.parser.ruleNames[t.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
  }
};
var Pt2 = class extends bt2 {
  constructor(t) {
    super(), this._input = null, this.errorHandler = new gt2(), this._precedenceStack = [], this._precedenceStack.push(0), this._ctx = null, this.buildParseTrees = true, this._tracer = null, this._parseListeners = null, this._syntaxErrors = 0, this.tokenStream = t;
  }
  get context() {
    return this._ctx;
  }
  reset() {
    this._input !== null && this._input.seek(0), this.errorHandler.reset(this), this._ctx = null, this._syntaxErrors = 0, this.setTrace(false), this._precedenceStack = [], this._precedenceStack.push(0), this.interpreter !== null && this.interpreter.reset();
  }
  match(t) {
    let e = this.getCurrentToken();
    return e.type === t ? (this.errorHandler.reportMatch(this), this.consume()) : (e = this.errorHandler.recoverInline(this), this.buildParseTrees && e.tokenIndex === -1 && this._ctx.addErrorNode(e)), e;
  }
  matchWildcard() {
    let t = this.getCurrentToken();
    return t.type > 0 ? (this.errorHandler.reportMatch(this), this.consume()) : (t = this.errorHandler.recoverInline(this), this.buildParseTrees && t.tokenIndex === -1 && this._ctx.addErrorNode(t)), t;
  }
  getParseListeners() {
    return this._parseListeners || [];
  }
  addParseListener(t) {
    if (t === null)
      throw "listener";
    this._parseListeners === null && (this._parseListeners = []), this._parseListeners.push(t);
  }
  removeParseListener(t) {
    if (this._parseListeners !== null) {
      let e = this._parseListeners.indexOf(t);
      e >= 0 && this._parseListeners.splice(e, 1), this._parseListeners.length === 0 && (this._parseListeners = null);
    }
  }
  removeParseListeners() {
    this._parseListeners = null;
  }
  triggerEnterRuleEvent() {
    if (this._parseListeners !== null) {
      let t = this._ctx;
      this._parseListeners.forEach(function(e) {
        e.enterEveryRule(t), t.enterRule(e);
      });
    }
  }
  triggerExitRuleEvent() {
    if (this._parseListeners !== null) {
      let t = this._ctx;
      this._parseListeners.slice(0).reverse().forEach(function(e) {
        t.exitRule(e), e.exitEveryRule(t);
      });
    }
  }
  getTokenFactory() {
    return this._input.tokenSource._factory;
  }
  setTokenFactory(t) {
    this._input.tokenSource._factory = t;
  }
  getATNWithBypassAlts() {
    let t = this.getSerializedATN();
    if (t === null)
      throw "The current parser does not support an ATN with bypass alternatives.";
    let e = this.bypassAltsAtnCache[t];
    if (e === null) {
      let n = new ct2();
      n.generateRuleBypassTransitions = true, e = new yt2(n).deserialize(t), this.bypassAltsAtnCache[t] = e;
    }
    return e;
  }
  get tokenStream() {
    return this._input;
  }
  set tokenStream(t) {
    this._input = null, this.reset(), this._input = t;
  }
  get inputStream() {
    return this._input;
  }
  set inputStream(t) {
    this.tokenStream = t;
  }
  get syntaxErrorsCount() {
    return this._syntaxErrors;
  }
  getCurrentToken() {
    return this._input.LT(1);
  }
  notifyErrorListeners(t, e, n) {
    e = e || null, n = n || null, e === null && (e = this.getCurrentToken()), this._syntaxErrors += 1;
    let s = e.line, r = e.column;
    this.getErrorListenerDispatch().syntaxError(this, e, s, r, t, n);
  }
  consume() {
    let t = this.getCurrentToken();
    t.type !== h2.EOF && this.tokenStream.consume();
    let e = this._parseListeners !== null && this._parseListeners.length > 0;
    if (this.buildParseTrees || e) {
      let n;
      this.errorHandler.inErrorRecoveryMode(this) ? n = this._ctx.addErrorNode(t) : n = this._ctx.addTokenNode(t), n.invokingState = this.state, e && this._parseListeners.forEach(function(s) {
        n instanceof it2 || n.isErrorNode !== void 0 && n.isErrorNode() ? s.visitErrorNode(n) : n instanceof w2 && s.visitTerminal(n);
      });
    }
    return t;
  }
  addContextToParseTree() {
    this._ctx.parent !== null && this._ctx.parent.addChild(this._ctx);
  }
  enterRule(t, e, n) {
    this.state = e, this._ctx = t, this._ctx.start = this._input.LT(1), this.buildParseTrees && this.addContextToParseTree(), this.triggerEnterRuleEvent();
  }
  exitRule() {
    this._ctx.stop = this._input.LT(-1), this.triggerExitRuleEvent(), this.state = this._ctx.invokingState, this._ctx = this._ctx.parent;
  }
  enterOuterAlt(t, e) {
    t.setAltNumber(e), this.buildParseTrees && this._ctx !== t && this._ctx.parent !== null && (this._ctx.parent.removeLastChild(), this._ctx.parent.addChild(t)), this._ctx = t;
  }
  getPrecedence() {
    return this._precedenceStack.length === 0 ? -1 : this._precedenceStack[this._precedenceStack.length - 1];
  }
  enterRecursionRule(t, e, n, s) {
    this.state = e, this._precedenceStack.push(s), this._ctx = t, this._ctx.start = this._input.LT(1), this.triggerEnterRuleEvent();
  }
  pushNewRecursionContext(t, e, n) {
    let s = this._ctx;
    s._parent = t, s.invokingState = e, s.stop = this._input.LT(-1), this._ctx = t, this._ctx.start = s.start, this.buildParseTrees && this._ctx.addChild(s), this.triggerEnterRuleEvent();
  }
  unrollRecursionContexts(t) {
    this._precedenceStack.pop(), this._ctx.stop = this._input.LT(-1);
    let e = this._ctx, n = this.getParseListeners();
    if (n !== null && n.length > 0)
      for (; this._ctx !== t; )
        this.triggerExitRuleEvent(), this._ctx = this._ctx.parent;
    else
      this._ctx = t;
    e._parent = t, this.buildParseTrees && t !== null && t.addChild(e);
  }
  getInvokingContext(t) {
    let e = this._ctx;
    for (; e !== null; ) {
      if (e.ruleIndex === t)
        return e;
      e = e.parent;
    }
    return null;
  }
  precpred(t, e) {
    return e >= this._precedenceStack[this._precedenceStack.length - 1];
  }
  inContext(t) {
    return false;
  }
  isExpectedToken(t) {
    let e = this.interpreter.atn, n = this._ctx, s = e.states[this.state], r = e.nextTokens(s);
    if (r.contains(t))
      return true;
    if (!r.contains(h2.EPSILON))
      return false;
    for (; n !== null && n.invokingState >= 0 && r.contains(h2.EPSILON); ) {
      let l = e.states[n.invokingState].transitions[0];
      if (r = e.nextTokens(l.followState), r.contains(t))
        return true;
      n = n.parent;
    }
    return !!(r.contains(h2.EPSILON) && t === h2.EOF);
  }
  getExpectedTokens() {
    return this.interpreter.atn.getExpectedTokens(this.state, this._ctx);
  }
  getExpectedTokensWithinCurrentRule() {
    let t = this.interpreter.atn, e = t.states[this.state];
    return t.nextTokens(e);
  }
  getRuleIndex(t) {
    let e = this.getRuleIndexMap().get(t);
    return e !== null ? e : -1;
  }
  getRuleInvocationStack(t) {
    t = t || null, t === null && (t = this._ctx);
    let e = [];
    for (; t !== null; ) {
      let n = t.ruleIndex;
      n < 0 ? e.push("n/a") : e.push(this.ruleNames[n]), t = t.parent;
    }
    return e;
  }
  getDFAStrings() {
    return this.interpreter.decisionToDFA.toString();
  }
  dumpDFA() {
    let t = false;
    for (let e = 0; e < this.interpreter.decisionToDFA.length; e++) {
      let n = this.interpreter.decisionToDFA[e];
      n.states.length > 0 && (t && console.log(), console.log("Decision " + n.decision + ":"), console.log(n.toString(this.vocabulary)), t = true);
    }
  }
  getSourceName() {
    return this._input.sourceName;
  }
  setTrace(t) {
    t ? (this._tracer !== null && this.removeParseListener(this._tracer), this._tracer = new Re2(this), this.addParseListener(this._tracer)) : (this.removeParseListener(this._tracer), this._tracer = null);
  }
  createTerminalNode(t, e) {
    return new dt2(e);
  }
  createErrorNode(t, e) {
    return new Lt2(e);
  }
};
Pt2.bypassAltsAtnCache = {};
function dn2(i63) {
  return i63.hashCodeForConfigSet();
}
function pn2(i63, t) {
  return i63 === t ? true : i63 === null || t === null ? false : i63.equalsForConfigSet(t);
}
var I2 = class i56 {
  constructor(t) {
    this.configLookup = new k2(dn2, pn2), this.fullCtx = t === void 0 ? true : t, this.readOnly = false, this.configs = [], this.uniqueAlt = 0, this.conflictingAlts = null, this.hasSemanticContext = false, this.dipsIntoOuterContext = false, this.cachedHashCode = -1;
  }
  add(t, e) {
    if (e === void 0 && (e = null), this.readOnly)
      throw "This set is readonly";
    t.semanticContext !== T2.NONE && (this.hasSemanticContext = true), t.reachesIntoOuterContext > 0 && (this.dipsIntoOuterContext = true);
    let n = this.configLookup.add(t);
    if (n === t)
      return this.cachedHashCode = -1, this.configs.push(t), true;
    let s = !this.fullCtx, r = Ae2(n.context, t.context, s, e);
    return n.reachesIntoOuterContext = Math.max(n.reachesIntoOuterContext, t.reachesIntoOuterContext), t.precedenceFilterSuppressed && (n.precedenceFilterSuppressed = true), n.context = r, true;
  }
  getStates() {
    let t = new k2();
    for (let e = 0; e < this.configs.length; e++)
      t.add(this.configs[e].state);
    return t;
  }
  getPredicates() {
    let t = [];
    for (let e = 0; e < this.configs.length; e++) {
      let n = this.configs[e].semanticContext;
      n !== T2.NONE && t.push(n.semanticContext);
    }
    return t;
  }
  optimizeConfigs(t) {
    if (this.readOnly)
      throw "This set is readonly";
    if (this.configLookup.length !== 0)
      for (let e = 0; e < this.configs.length; e++) {
        let n = this.configs[e];
        n.context = t.getCachedContext(n.context);
      }
  }
  addAll(t) {
    for (let e = 0; e < t.length; e++)
      this.add(t[e]);
    return false;
  }
  equals(t) {
    return this === t || t instanceof i56 && pt2(this.configs, t.configs) && this.fullCtx === t.fullCtx && this.uniqueAlt === t.uniqueAlt && this.conflictingAlts === t.conflictingAlts && this.hasSemanticContext === t.hasSemanticContext && this.dipsIntoOuterContext === t.dipsIntoOuterContext;
  }
  hashCode() {
    let t = new R2();
    return t.update(this.configs), t.finish();
  }
  updateHashCode(t) {
    this.readOnly ? (this.cachedHashCode === -1 && (this.cachedHashCode = this.hashCode()), t.update(this.cachedHashCode)) : t.update(this.hashCode());
  }
  isEmpty() {
    return this.configs.length === 0;
  }
  contains(t) {
    if (this.configLookup === null)
      throw "This method is not implemented for readonly sets.";
    return this.configLookup.contains(t);
  }
  containsFast(t) {
    if (this.configLookup === null)
      throw "This method is not implemented for readonly sets.";
    return this.configLookup.containsFast(t);
  }
  clear() {
    if (this.readOnly)
      throw "This set is readonly";
    this.configs = [], this.cachedHashCode = -1, this.configLookup = new k2();
  }
  setReadonly(t) {
    this.readOnly = t, t && (this.configLookup = null);
  }
  toString() {
    return G2(this.configs) + (this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") + (this.uniqueAlt !== S2.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") + (this.conflictingAlts !== null ? ",conflictingAlts=" + this.conflictingAlts : "") + (this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
  }
  get items() {
    return this.configs;
  }
  get length() {
    return this.configs.length;
  }
};
var X2 = class i57 {
  constructor(t, e) {
    return t === null && (t = -1), e === null && (e = new I2()), this.stateNumber = t, this.configs = e, this.edges = null, this.isAcceptState = false, this.prediction = 0, this.lexerActionExecutor = null, this.requiresFullContext = false, this.predicates = null, this;
  }
  getAltSet() {
    let t = new k2();
    if (this.configs !== null)
      for (let e = 0; e < this.configs.length; e++) {
        let n = this.configs[e];
        t.add(n.alt);
      }
    return t.length === 0 ? null : t;
  }
  equals(t) {
    return this === t || t instanceof i57 && this.configs.equals(t.configs);
  }
  toString() {
    let t = "" + this.stateNumber + ":" + this.configs;
    return this.isAcceptState && (t = t + "=>", this.predicates !== null ? t = t + this.predicates : t = t + this.prediction), t;
  }
  hashCode() {
    let t = new R2();
    return t.update(this.configs), t.finish();
  }
};
var V2 = class {
  constructor(t, e) {
    return this.atn = t, this.sharedContextCache = e, this;
  }
  getCachedContext(t) {
    if (this.sharedContextCache === null)
      return t;
    let e = new Q2();
    return Qe2(t, this.sharedContextCache, e);
  }
};
V2.ERROR = new X2(2147483647, new I2());
var ce2 = class extends I2 {
  constructor() {
    super(), this.configLookup = new k2();
  }
};
var z2 = class i58 extends C2 {
  constructor(t, e) {
    super(t, e);
    let n = t.lexerActionExecutor || null;
    return this.lexerActionExecutor = n || (e !== null ? e.lexerActionExecutor : null), this.passedThroughNonGreedyDecision = e !== null ? this.checkNonGreedyDecision(e, this.state) : false, this.hashCodeForConfigSet = i58.prototype.hashCode, this.equalsForConfigSet = i58.prototype.equals, this;
  }
  updateHashCode(t) {
    t.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);
  }
  equals(t) {
    return this === t || t instanceof i58 && this.passedThroughNonGreedyDecision === t.passedThroughNonGreedyDecision && (this.lexerActionExecutor ? this.lexerActionExecutor.equals(t.lexerActionExecutor) : !t.lexerActionExecutor) && super.equals(t);
  }
  checkNonGreedyDecision(t, e) {
    return t.passedThroughNonGreedyDecision || e instanceof B2 && e.nonGreedy;
  }
};
var Qt2 = class i59 extends F2 {
  constructor(t, e) {
    super(e.actionType), this.offset = t, this.action = e, this.isPositionDependent = true;
  }
  execute(t) {
    this.action.execute(t);
  }
  updateHashCode(t) {
    t.update(this.actionType, this.offset, this.action);
  }
  equals(t) {
    return this === t ? true : t instanceof i59 ? this.offset === t.offset && this.action === t.action : false;
  }
};
var Pe2 = class i60 {
  constructor(t) {
    return this.lexerActions = t === null ? [] : t, this.cachedHashCode = R2.hashStuff(t), this;
  }
  fixOffsetBeforeMatch(t) {
    let e = null;
    for (let n = 0; n < this.lexerActions.length; n++)
      this.lexerActions[n].isPositionDependent && !(this.lexerActions[n] instanceof Qt2) && (e === null && (e = this.lexerActions.concat([])), e[n] = new Qt2(t, this.lexerActions[n]));
    return e === null ? this : new i60(e);
  }
  execute(t, e, n) {
    let s = false, r = e.index;
    try {
      for (let o = 0; o < this.lexerActions.length; o++) {
        let l = this.lexerActions[o];
        if (l instanceof Qt2) {
          let a = l.offset;
          e.seek(n + a), l = l.action, s = n + a !== r;
        } else
          l.isPositionDependent && (e.seek(r), s = false);
        l.execute(t);
      }
    } finally {
      s && e.seek(r);
    }
  }
  hashCode() {
    return this.cachedHashCode;
  }
  updateHashCode(t) {
    t.update(this.cachedHashCode);
  }
  equals(t) {
    if (this === t)
      return true;
    if (t instanceof i60) {
      if (this.cachedHashCode != t.cachedHashCode)
        return false;
      if (this.lexerActions.length != t.lexerActions.length)
        return false;
      {
        let e = this.lexerActions.length;
        for (let n = 0; n < e; ++n)
          if (!this.lexerActions[n].equals(t.lexerActions[n]))
            return false;
        return true;
      }
    } else
      return false;
  }
  static append(t, e) {
    if (t === null)
      return new i60([e]);
    let n = t.lexerActions.concat([e]);
    return new i60(n);
  }
};
function on2(i63) {
  i63.index = -1, i63.line = 0, i63.column = -1, i63.dfaState = null;
}
var tn2 = class {
  constructor() {
    on2(this);
  }
  reset() {
    on2(this);
  }
};
var Z2 = class i61 extends V2 {
  constructor(t, e, n, s) {
    super(e, s), this.decisionToDFA = n, this.recog = t, this.startIndex = -1, this.line = 1, this.column = 0, this.mode = N2.DEFAULT_MODE, this.prevAccept = new tn2();
  }
  copyState(t) {
    this.column = t.column, this.line = t.line, this.mode = t.mode, this.startIndex = t.startIndex;
  }
  match(t, e) {
    this.mode = e;
    let n = t.mark();
    try {
      this.startIndex = t.index, this.prevAccept.reset();
      let s = this.decisionToDFA[e];
      return s.s0 === null ? this.matchATN(t) : this.execATN(t, s.s0);
    } finally {
      t.release(n);
    }
  }
  reset() {
    this.prevAccept.reset(), this.startIndex = -1, this.line = 1, this.column = 0, this.mode = N2.DEFAULT_MODE;
  }
  matchATN(t) {
    let e = this.atn.modeToStartState[this.mode];
    i61.debug && console.log("matchATN mode " + this.mode + " start: " + e);
    let n = this.mode, s = this.computeStartState(t, e), r = s.hasSemanticContext;
    s.hasSemanticContext = false;
    let o = this.addDFAState(s);
    r || (this.decisionToDFA[this.mode].s0 = o);
    let l = this.execATN(t, o);
    return i61.debug && console.log("DFA after matchATN: " + this.decisionToDFA[n].toLexerString()), l;
  }
  execATN(t, e) {
    i61.debug && console.log("start state closure=" + e.configs), e.isAcceptState && this.captureSimState(this.prevAccept, t, e);
    let n = t.LA(1), s = e;
    for (; ; ) {
      i61.debug && console.log("execATN loop starting closure: " + s.configs);
      let r = this.getExistingTargetState(s, n);
      if (r === null && (r = this.computeTargetState(t, s, n)), r === V2.ERROR || (n !== h2.EOF && this.consume(t), r.isAcceptState && (this.captureSimState(this.prevAccept, t, r), n === h2.EOF)))
        break;
      n = t.LA(1), s = r;
    }
    return this.failOrAccept(this.prevAccept, t, s.configs, n);
  }
  getExistingTargetState(t, e) {
    if (t.edges === null || e < i61.MIN_DFA_EDGE || e > i61.MAX_DFA_EDGE)
      return null;
    let n = t.edges[e - i61.MIN_DFA_EDGE];
    return n === void 0 && (n = null), i61.debug && n !== null && console.log("reuse state " + t.stateNumber + " edge to " + n.stateNumber), n;
  }
  computeTargetState(t, e, n) {
    let s = new ce2();
    return this.getReachableConfigSet(t, e.configs, s, n), s.items.length === 0 ? (s.hasSemanticContext || this.addDFAEdge(e, n, V2.ERROR), V2.ERROR) : this.addDFAEdge(e, n, null, s);
  }
  failOrAccept(t, e, n, s) {
    if (this.prevAccept.dfaState !== null) {
      let r = t.dfaState.lexerActionExecutor;
      return this.accept(e, r, this.startIndex, t.index, t.line, t.column), t.dfaState.prediction;
    } else {
      if (s === h2.EOF && e.index === this.startIndex)
        return h2.EOF;
      throw new rt2(this.recog, e, this.startIndex, n);
    }
  }
  getReachableConfigSet(t, e, n, s) {
    let r = S2.INVALID_ALT_NUMBER;
    for (let o = 0; o < e.items.length; o++) {
      let l = e.items[o], a = l.alt === r;
      if (!(a && l.passedThroughNonGreedyDecision)) {
        i61.debug && console.log(`testing %s at %s
`, this.getTokenName(s), l.toString(this.recog, true));
        for (let u = 0; u < l.state.transitions.length; u++) {
          let c = l.state.transitions[u], f = this.getReachableTarget(c, s);
          if (f !== null) {
            let p = l.lexerActionExecutor;
            p !== null && (p = p.fixOffsetBeforeMatch(t.index - this.startIndex));
            let E = s === h2.EOF, tt = new z2({ state: f, lexerActionExecutor: p }, l);
            this.closure(t, tt, n, a, true, E) && (r = l.alt);
          }
        }
      }
    }
  }
  accept(t, e, n, s, r, o) {
    i61.debug && console.log(`ACTION %s
`, e), t.seek(s), this.line = r, this.column = o, e !== null && this.recog !== null && e.execute(this.recog, t, n);
  }
  getReachableTarget(t, e) {
    return t.matches(e, 0, N2.MAX_CHAR_VALUE) ? t.target : null;
  }
  computeStartState(t, e) {
    let n = x2.EMPTY, s = new ce2();
    for (let r = 0; r < e.transitions.length; r++) {
      let o = e.transitions[r].target, l = new z2({ state: o, alt: r + 1, context: n }, null);
      this.closure(t, l, s, false, false, false);
    }
    return s;
  }
  closure(t, e, n, s, r, o) {
    let l = null;
    if (i61.debug && console.log("closure(" + e.toString(this.recog, true) + ")"), e.state instanceof L2) {
      if (i61.debug && (this.recog !== null ? console.log(`closure at %s rule stop %s
`, this.recog.ruleNames[e.state.ruleIndex], e) : console.log(`closure at rule stop %s
`, e)), e.context === null || e.context.hasEmptyPath()) {
        if (e.context === null || e.context.isEmpty())
          return n.add(e), true;
        n.add(new z2({ state: e.state, context: x2.EMPTY }, e)), s = true;
      }
      if (e.context !== null && !e.context.isEmpty()) {
        for (let a = 0; a < e.context.length; a++)
          if (e.context.getReturnState(a) !== x2.EMPTY_RETURN_STATE) {
            let u = e.context.getParent(a), c = this.atn.states[e.context.getReturnState(a)];
            l = new z2({ state: c, context: u }, e), s = this.closure(t, l, n, s, r, o);
          }
      }
      return s;
    }
    e.state.epsilonOnlyTransitions || (!s || !e.passedThroughNonGreedyDecision) && n.add(e);
    for (let a = 0; a < e.state.transitions.length; a++) {
      let u = e.state.transitions[a];
      l = this.getEpsilonTarget(t, e, u, n, r, o), l !== null && (s = this.closure(t, l, n, s, r, o));
    }
    return s;
  }
  getEpsilonTarget(t, e, n, s, r, o) {
    let l = null;
    if (n.serializationType === d2.RULE) {
      let a = v2.create(e.context, n.followState.stateNumber);
      l = new z2({ state: n.target, context: a }, e);
    } else {
      if (n.serializationType === d2.PRECEDENCE)
        throw "Precedence predicates are not supported in lexers.";
      if (n.serializationType === d2.PREDICATE)
        i61.debug && console.log("EVAL rule " + n.ruleIndex + ":" + n.predIndex), s.hasSemanticContext = true, this.evaluatePredicate(t, n.ruleIndex, n.predIndex, r) && (l = new z2({ state: n.target }, e));
      else if (n.serializationType === d2.ACTION)
        if (e.context === null || e.context.hasEmptyPath()) {
          let a = Pe2.append(e.lexerActionExecutor, this.atn.lexerActions[n.actionIndex]);
          l = new z2({ state: n.target, lexerActionExecutor: a }, e);
        } else
          l = new z2({ state: n.target }, e);
      else
        n.serializationType === d2.EPSILON ? l = new z2({ state: n.target }, e) : (n.serializationType === d2.ATOM || n.serializationType === d2.RANGE || n.serializationType === d2.SET) && o && n.matches(h2.EOF, 0, N2.MAX_CHAR_VALUE) && (l = new z2({ state: n.target }, e));
    }
    return l;
  }
  evaluatePredicate(t, e, n, s) {
    if (this.recog === null)
      return true;
    if (!s)
      return this.recog.sempred(null, e, n);
    let r = this.column, o = this.line, l = t.index, a = t.mark();
    try {
      return this.consume(t), this.recog.sempred(null, e, n);
    } finally {
      this.column = r, this.line = o, t.seek(l), t.release(a);
    }
  }
  captureSimState(t, e, n) {
    t.index = e.index, t.line = this.line, t.column = this.column, t.dfaState = n;
  }
  addDFAEdge(t, e, n, s) {
    if (n === void 0 && (n = null), s === void 0 && (s = null), n === null && s !== null) {
      let r = s.hasSemanticContext;
      if (s.hasSemanticContext = false, n = this.addDFAState(s), r)
        return n;
    }
    return e < i61.MIN_DFA_EDGE || e > i61.MAX_DFA_EDGE || (i61.debug && console.log("EDGE " + t + " -> " + n + " upon " + e), t.edges === null && (t.edges = []), t.edges[e - i61.MIN_DFA_EDGE] = n), n;
  }
  addDFAState(t) {
    let e = new X2(null, t), n = null;
    for (let l = 0; l < t.items.length; l++) {
      let a = t.items[l];
      if (a.state instanceof L2) {
        n = a;
        break;
      }
    }
    n !== null && (e.isAcceptState = true, e.lexerActionExecutor = n.lexerActionExecutor, e.prediction = this.atn.ruleToTokenType[n.state.ruleIndex]);
    let s = this.decisionToDFA[this.mode], r = s.states.get(e);
    if (r !== null)
      return r;
    let o = e;
    return o.stateNumber = s.states.length, t.setReadonly(true), o.configs = t, s.states.add(o), o;
  }
  getDFA(t) {
    return this.decisionToDFA[t];
  }
  getText(t) {
    return t.getText(this.startIndex, t.index - 1);
  }
  consume(t) {
    t.LA(1) === `
`.charCodeAt(0) ? (this.line += 1, this.column = 0) : this.column += 1, t.consume();
  }
  getTokenName(t) {
    return t === -1 ? "EOF" : "'" + String.fromCharCode(t) + "'";
  }
};
Z2.debug = false;
Z2.dfa_debug = false;
Z2.MIN_DFA_EDGE = 0;
Z2.MAX_DFA_EDGE = 127;
var lt2 = class {
  constructor() {
    this.cache = new Q2();
  }
  add(t) {
    if (t === x2.EMPTY)
      return x2.EMPTY;
    let e = this.cache.get(t) || null;
    return e !== null ? e : (this.cache.set(t, t), t);
  }
  get(t) {
    return this.cache.get(t) || null;
  }
  get length() {
    return this.cache.length;
  }
};
var Zt2 = class {
  constructor(t, e, n) {
    this.dfa = t, this.literalNames = e || [], this.symbolicNames = n || [];
  }
  toString() {
    if (this.dfa.s0 === null)
      return null;
    let t = "", e = this.dfa.sortedStates();
    for (let n = 0; n < e.length; n++) {
      let s = e[n];
      if (s.edges !== null) {
        let r = s.edges.length;
        for (let o = 0; o < r; o++) {
          let l = s.edges[o] || null;
          l !== null && l.stateNumber !== 2147483647 && (t = t.concat(this.getStateString(s)), t = t.concat("-"), t = t.concat(this.getEdgeLabel(o)), t = t.concat("->"), t = t.concat(this.getStateString(l)), t = t.concat(`
`));
        }
      }
    }
    return t.length === 0 ? null : t;
  }
  getEdgeLabel(t) {
    return t === 0 ? "EOF" : this.literalNames !== null || this.symbolicNames !== null ? this.literalNames[t - 1] || this.symbolicNames[t - 1] : String.fromCharCode(t - 1);
  }
  getStateString(t) {
    let e = (t.isAcceptState ? ":" : "") + "s" + t.stateNumber + (t.requiresFullContext ? "^" : "");
    return t.isAcceptState ? t.predicates !== null ? e + "=>" + G2(t.predicates) : e + "=>" + t.prediction.toString() : e;
  }
};
var Fe2 = class extends Zt2 {
  constructor(t) {
    super(t, null);
  }
  getEdgeLabel(t) {
    return "'" + String.fromCharCode(t) + "'";
  }
};
var at2 = class {
  constructor(t, e) {
    if (e === void 0 && (e = 0), this.atnStartState = t, this.decision = e, this._states = new k2(), this.s0 = null, this.precedenceDfa = false, t instanceof Y2 && t.precedenceRuleDecision) {
      this.precedenceDfa = true;
      let n = new X2(null, new I2());
      n.edges = [], n.isAcceptState = false, n.requiresFullContext = false, this.s0 = n;
    }
  }
  getPrecedenceStartState(t) {
    if (!this.precedenceDfa)
      throw "Only precedence DFAs may contain a precedence start state.";
    return t < 0 || t >= this.s0.edges.length ? null : this.s0.edges[t] || null;
  }
  setPrecedenceStartState(t, e) {
    if (!this.precedenceDfa)
      throw "Only precedence DFAs may contain a precedence start state.";
    t < 0 || (this.s0.edges[t] = e);
  }
  setPrecedenceDfa(t) {
    if (this.precedenceDfa !== t) {
      if (this._states = new k2(), t) {
        let e = new X2(null, new I2());
        e.edges = [], e.isAcceptState = false, e.requiresFullContext = false, this.s0 = e;
      } else
        this.s0 = null;
      this.precedenceDfa = t;
    }
  }
  sortedStates() {
    return this._states.values().sort(function(e, n) {
      return e.stateNumber - n.stateNumber;
    });
  }
  toString(t, e) {
    return t = t || null, e = e || null, this.s0 === null ? "" : new Zt2(this, t, e).toString();
  }
  toLexerString() {
    return this.s0 === null ? "" : new Fe2(this).toString();
  }
  get states() {
    return this._states;
  }
};
var nt2 = class extends U2 {
  constructor(t, e) {
    super(t, e), this.children = null, this.start = null, this.stop = null, this.exception = null;
  }
  copyFrom(t) {
    this._parent = t._parent, this.invokingState = t.invokingState, this.children = null, this.start = t.start, this.stop = t.stop, t.children && (this.children = [], t.children.map(function(e) {
      e instanceof Lt2 && (this.children.push(e), e.parent = this);
    }, this));
  }
  enterRule(t) {
  }
  exitRule(t) {
  }
  addChild(t) {
    return this.children === null && (this.children = []), this.children.push(t), t;
  }
  removeLastChild() {
    this.children !== null && this.children.pop();
  }
  addTokenNode(t) {
    let e = new dt2(t);
    return this.addChild(e), e.parent = this, e;
  }
  addErrorNode(t) {
    let e = new Lt2(t);
    return this.addChild(e), e.parent = this, e;
  }
  getChild(t, e) {
    if (e = e ?? null, this.children === null || t < 0 || t >= this.children.length)
      return null;
    if (e === null)
      return this.children[t];
    for (let n = 0; n < this.children.length; n++) {
      let s = this.children[n];
      if (s instanceof e) {
        if (t === 0)
          return s;
        t -= 1;
      }
    }
    return null;
  }
  getToken(t, e) {
    if (this.children === null || e < 0 || e >= this.children.length)
      return null;
    for (let n = 0; n < this.children.length; n++) {
      let s = this.children[n];
      if (s instanceof w2 && s.symbol.type === t) {
        if (e === 0)
          return s;
        e -= 1;
      }
    }
    return null;
  }
  getTokens(t) {
    if (this.children === null)
      return [];
    {
      let e = [];
      for (let n = 0; n < this.children.length; n++) {
        let s = this.children[n];
        s instanceof w2 && s.symbol.type === t && e.push(s);
      }
      return e;
    }
  }
  getRuleContext(t, e) {
    return this.getChild(t, e);
  }
  getRuleContexts(t) {
    if (this.children === null)
      return [];
    {
      let e = [];
      for (let n = 0; n < this.children.length; n++) {
        let s = this.children[n];
        s instanceof t && e.push(s);
      }
      return e;
    }
  }
  getChildCount() {
    return this.children === null ? 0 : this.children.length;
  }
  getSourceInterval() {
    return this.start === null || this.stop === null ? g2.INVALID_INTERVAL : new g2(this.start.tokenIndex, this.stop.tokenIndex);
  }
};
U2.EMPTY = new nt2();
var se2 = class {
  walk(t, e) {
    if (e instanceof it2 || e.isErrorNode !== void 0 && e.isErrorNode())
      t.visitErrorNode(e);
    else if (e instanceof w2)
      t.visitTerminal(e);
    else {
      this.enterRule(t, e);
      for (let s = 0; s < e.getChildCount(); s++) {
        let r = e.getChild(s);
        this.walk(t, r);
      }
      this.exitRule(t, e);
    }
  }
  enterRule(t, e) {
    let n = e.ruleContext;
    t.enterEveryRule(n), n.enterRule(t);
  }
  exitRule(t, e) {
    let n = e.ruleContext;
    n.exitRule(t), t.exitEveryRule(n);
  }
};
se2.DEFAULT = new se2();
var K2 = class i62 extends N2 {
  static TOKEN_REF = 1;
  static RULE_REF = 2;
  static ANYWHERE = 3;
  static ROOT = 4;
  static WILDCARD = 5;
  static BANG = 6;
  static ID = 7;
  static STRING = 8;
  static EOF = h2.EOF;
  static channelNames = ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"];
  static literalNames = [null, null, null, "'//'", "'/'", "'*'", "'!'"];
  static symbolicNames = [null, "TOKEN_REF", "RULE_REF", "ANYWHERE", "ROOT", "WILDCARD", "BANG", "ID", "STRING"];
  static modeNames = ["DEFAULT_MODE"];
  static ruleNames = ["ANYWHERE", "ROOT", "WILDCARD", "BANG", "ID", "NameChar", "NameStartChar", "STRING"];
  constructor(t) {
    super(t), this.interpreter = new Z2(this, i62._ATN, i62.decisionsToDFA, new lt2());
  }
  get grammarFileName() {
    return "XPathLexer.g4";
  }
  get literalNames() {
    return i62.literalNames;
  }
  get symbolicNames() {
    return i62.symbolicNames;
  }
  get ruleNames() {
    return i62.ruleNames;
  }
  get serializedATN() {
    return i62._serializedATN;
  }
  get channelNames() {
    return i62.channelNames;
  }
  get modeNames() {
    return i62.modeNames;
  }
  action(t, e, n) {
    switch (e) {
      case 4:
        this.ID_action(t, n);
        break;
    }
  }
  ID_action(t, e) {
    switch (e) {
      case 0: {
        let n = this.text;
        n.charAt(0) === n.charAt(0).toUpperCase() ? this._type = i62.TOKEN_REF : this._type = i62.RULE_REF;
        break;
      }
    }
  }
  static _serializedATN = [4, 0, 8, 48, 6, -1, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 2, 1, 2, 1, 3, 1, 3, 1, 4, 1, 4, 5, 4, 29, 8, 4, 10, 4, 12, 4, 32, 9, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 6, 1, 6, 1, 7, 1, 7, 5, 7, 42, 8, 7, 10, 7, 12, 7, 45, 9, 7, 1, 7, 1, 7, 1, 43, 0, 8, 1, 3, 3, 4, 5, 5, 7, 6, 9, 7, 11, 0, 13, 0, 15, 8, 1, 0, 2, 784, 0, 0, 8, 14, 27, 48, 57, 65, 90, 95, 95, 97, 122, 127, 159, 170, 170, 173, 173, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 895, 895, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1327, 1329, 1366, 1369, 1369, 1376, 1416, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1519, 1522, 1536, 1541, 1552, 1562, 1564, 1564, 1568, 1641, 1646, 1747, 1749, 1757, 1759, 1768, 1770, 1788, 1791, 1791, 1807, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2045, 2045, 2048, 2093, 2112, 2139, 2144, 2154, 2160, 2183, 2185, 2190, 2192, 2193, 2200, 2403, 2406, 2415, 2417, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2556, 2556, 2558, 2558, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2809, 2815, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2901, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3072, 3084, 3086, 3088, 3090, 3112, 3114, 3129, 3132, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3162, 3165, 3165, 3168, 3171, 3174, 3183, 3200, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3293, 3294, 3296, 3299, 3302, 3311, 3313, 3315, 3328, 3340, 3342, 3344, 3346, 3396, 3398, 3400, 3402, 3406, 3412, 3415, 3423, 3427, 3430, 3439, 3450, 3455, 3457, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3558, 3567, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3718, 3722, 3724, 3747, 3749, 3749, 3751, 3773, 3776, 3780, 3782, 3782, 3784, 3790, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5109, 5112, 5117, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5880, 5888, 5909, 5919, 5940, 5952, 5971, 5984, 5996, 5998, 6e3, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6169, 6176, 6264, 6272, 6314, 6320, 6389, 6400, 6430, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6832, 6845, 6847, 6862, 6912, 6988, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7296, 7304, 7312, 7354, 7357, 7359, 7376, 7378, 7380, 7418, 7424, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8203, 8207, 8234, 8238, 8255, 8256, 8276, 8276, 8288, 8292, 8294, 8303, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12591, 12593, 12686, 12704, 12735, 12784, 12799, 13312, 19903, 19968, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42737, 42775, 42783, 42786, 42888, 42891, 42954, 42960, 42961, 42963, 42963, 42965, 42969, 42994, 43047, 43052, 43052, 43072, 43123, 43136, 43205, 43216, 43225, 43232, 43255, 43259, 43259, 43261, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43488, 43518, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43824, 43866, 43868, 43881, 43888, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65071, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65279, 65279, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65529, 65531, 65536, 65547, 65549, 65574, 65576, 65594, 65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786, 65856, 65908, 66045, 66045, 66176, 66204, 66208, 66256, 66272, 66272, 66304, 66335, 66349, 66378, 66384, 66426, 66432, 66461, 66464, 66499, 66504, 66511, 66513, 66517, 66560, 66717, 66720, 66729, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 66928, 66938, 66940, 66954, 66956, 66962, 66964, 66965, 66967, 66977, 66979, 66993, 66995, 67001, 67003, 67004, 67072, 67382, 67392, 67413, 67424, 67431, 67456, 67461, 67463, 67504, 67506, 67514, 67584, 67589, 67592, 67592, 67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669, 67680, 67702, 67712, 67742, 67808, 67826, 67828, 67829, 67840, 67861, 67872, 67897, 67968, 68023, 68030, 68031, 68096, 68099, 68101, 68102, 68108, 68115, 68117, 68119, 68121, 68149, 68152, 68154, 68159, 68159, 68192, 68220, 68224, 68252, 68288, 68295, 68297, 68326, 68352, 68405, 68416, 68437, 68448, 68466, 68480, 68497, 68608, 68680, 68736, 68786, 68800, 68850, 68864, 68903, 68912, 68921, 69248, 69289, 69291, 69292, 69296, 69297, 69373, 69404, 69415, 69415, 69424, 69456, 69488, 69509, 69552, 69572, 69600, 69622, 69632, 69702, 69734, 69749, 69759, 69818, 69821, 69821, 69826, 69826, 69837, 69837, 69840, 69864, 69872, 69881, 69888, 69940, 69942, 69951, 69956, 69959, 69968, 70003, 70006, 70006, 70016, 70084, 70089, 70092, 70094, 70106, 70108, 70108, 70144, 70161, 70163, 70199, 70206, 70209, 70272, 70278, 70280, 70280, 70282, 70285, 70287, 70301, 70303, 70312, 70320, 70378, 70384, 70393, 70400, 70403, 70405, 70412, 70415, 70416, 70419, 70440, 70442, 70448, 70450, 70451, 70453, 70457, 70459, 70468, 70471, 70472, 70475, 70477, 70480, 70480, 70487, 70487, 70493, 70499, 70502, 70508, 70512, 70516, 70656, 70730, 70736, 70745, 70750, 70753, 70784, 70853, 70855, 70855, 70864, 70873, 71040, 71093, 71096, 71104, 71128, 71133, 71168, 71232, 71236, 71236, 71248, 71257, 71296, 71352, 71360, 71369, 71424, 71450, 71453, 71467, 71472, 71481, 71488, 71494, 71680, 71738, 71840, 71913, 71935, 71942, 71945, 71945, 71948, 71955, 71957, 71958, 71960, 71989, 71991, 71992, 71995, 72003, 72016, 72025, 72096, 72103, 72106, 72151, 72154, 72161, 72163, 72164, 72192, 72254, 72263, 72263, 72272, 72345, 72349, 72349, 72368, 72440, 72704, 72712, 72714, 72758, 72760, 72768, 72784, 72793, 72818, 72847, 72850, 72871, 72873, 72886, 72960, 72966, 72968, 72969, 72971, 73014, 73018, 73018, 73020, 73021, 73023, 73031, 73040, 73049, 73056, 73061, 73063, 73064, 73066, 73102, 73104, 73105, 73107, 73112, 73120, 73129, 73440, 73462, 73472, 73488, 73490, 73530, 73534, 73538, 73552, 73561, 73648, 73648, 73728, 74649, 74752, 74862, 74880, 75075, 77712, 77808, 77824, 78933, 82944, 83526, 92160, 92728, 92736, 92766, 92768, 92777, 92784, 92862, 92864, 92873, 92880, 92909, 92912, 92916, 92928, 92982, 92992, 92995, 93008, 93017, 93027, 93047, 93053, 93071, 93760, 93823, 93952, 94026, 94031, 94087, 94095, 94111, 94176, 94177, 94179, 94180, 94192, 94193, 94208, 100343, 100352, 101589, 101632, 101640, 110576, 110579, 110581, 110587, 110589, 110590, 110592, 110882, 110898, 110898, 110928, 110930, 110933, 110933, 110948, 110951, 110960, 111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 113821, 113822, 113824, 113827, 118528, 118573, 118576, 118598, 119141, 119145, 119149, 119170, 119173, 119179, 119210, 119213, 119362, 119364, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 120782, 120831, 121344, 121398, 121403, 121452, 121461, 121461, 121476, 121476, 121499, 121503, 121505, 121519, 122624, 122654, 122661, 122666, 122880, 122886, 122888, 122904, 122907, 122913, 122915, 122916, 122918, 122922, 122928, 122989, 123023, 123023, 123136, 123180, 123184, 123197, 123200, 123209, 123214, 123214, 123536, 123566, 123584, 123641, 124112, 124153, 124896, 124902, 124904, 124907, 124909, 124910, 124912, 124926, 124928, 125124, 125136, 125142, 125184, 125259, 125264, 125273, 126464, 126467, 126469, 126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 130032, 130041, 131072, 173791, 173824, 177977, 177984, 178205, 178208, 183969, 183984, 191456, 194560, 195101, 196608, 201546, 201552, 205743, 917505, 917505, 917536, 917631, 917760, 917999, 662, 0, 65, 90, 97, 122, 170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 895, 895, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1327, 1329, 1366, 1369, 1369, 1376, 1416, 1488, 1514, 1519, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2144, 2154, 2160, 2183, 2185, 2190, 2208, 2249, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2432, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2556, 2556, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2809, 2809, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3129, 3133, 3133, 3160, 3162, 3165, 3165, 3168, 3169, 3200, 3200, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3293, 3294, 3296, 3297, 3313, 3314, 3332, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3412, 3414, 3423, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3718, 3722, 3724, 3747, 3749, 3749, 3751, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5109, 5112, 5117, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5880, 5888, 5905, 5919, 5937, 5952, 5969, 5984, 5996, 5998, 6e3, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6264, 6272, 6276, 6279, 6312, 6314, 6314, 6320, 6389, 6400, 6430, 6480, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6988, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7296, 7304, 7312, 7354, 7357, 7359, 7401, 7404, 7406, 7411, 7413, 7414, 7418, 7418, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12591, 12593, 12686, 12704, 12735, 12784, 12799, 13312, 19903, 19968, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42653, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42954, 42960, 42961, 42963, 42963, 42965, 42969, 42994, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43261, 43262, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43488, 43492, 43494, 43503, 43514, 43518, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43646, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43824, 43866, 43868, 43881, 43888, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594, 65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786, 65856, 65908, 66176, 66204, 66208, 66256, 66304, 66335, 66349, 66378, 66384, 66421, 66432, 66461, 66464, 66499, 66504, 66511, 66513, 66517, 66560, 66717, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 66928, 66938, 66940, 66954, 66956, 66962, 66964, 66965, 66967, 66977, 66979, 66993, 66995, 67001, 67003, 67004, 67072, 67382, 67392, 67413, 67424, 67431, 67456, 67461, 67463, 67504, 67506, 67514, 67584, 67589, 67592, 67592, 67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669, 67680, 67702, 67712, 67742, 67808, 67826, 67828, 67829, 67840, 67861, 67872, 67897, 67968, 68023, 68030, 68031, 68096, 68096, 68112, 68115, 68117, 68119, 68121, 68149, 68192, 68220, 68224, 68252, 68288, 68295, 68297, 68324, 68352, 68405, 68416, 68437, 68448, 68466, 68480, 68497, 68608, 68680, 68736, 68786, 68800, 68850, 68864, 68899, 69248, 69289, 69296, 69297, 69376, 69404, 69415, 69415, 69424, 69445, 69488, 69505, 69552, 69572, 69600, 69622, 69635, 69687, 69745, 69746, 69749, 69749, 69763, 69807, 69840, 69864, 69891, 69926, 69956, 69956, 69959, 69959, 69968, 70002, 70006, 70006, 70019, 70066, 70081, 70084, 70106, 70106, 70108, 70108, 70144, 70161, 70163, 70187, 70207, 70208, 70272, 70278, 70280, 70280, 70282, 70285, 70287, 70301, 70303, 70312, 70320, 70366, 70405, 70412, 70415, 70416, 70419, 70440, 70442, 70448, 70450, 70451, 70453, 70457, 70461, 70461, 70480, 70480, 70493, 70497, 70656, 70708, 70727, 70730, 70751, 70753, 70784, 70831, 70852, 70853, 70855, 70855, 71040, 71086, 71128, 71131, 71168, 71215, 71236, 71236, 71296, 71338, 71352, 71352, 71424, 71450, 71488, 71494, 71680, 71723, 71840, 71903, 71935, 71942, 71945, 71945, 71948, 71955, 71957, 71958, 71960, 71983, 71999, 71999, 72001, 72001, 72096, 72103, 72106, 72144, 72161, 72161, 72163, 72163, 72192, 72192, 72203, 72242, 72250, 72250, 72272, 72272, 72284, 72329, 72349, 72349, 72368, 72440, 72704, 72712, 72714, 72750, 72768, 72768, 72818, 72847, 72960, 72966, 72968, 72969, 72971, 73008, 73030, 73030, 73056, 73061, 73063, 73064, 73066, 73097, 73112, 73112, 73440, 73458, 73474, 73474, 73476, 73488, 73490, 73523, 73648, 73648, 73728, 74649, 74752, 74862, 74880, 75075, 77712, 77808, 77824, 78895, 78913, 78918, 82944, 83526, 92160, 92728, 92736, 92766, 92784, 92862, 92880, 92909, 92928, 92975, 92992, 92995, 93027, 93047, 93053, 93071, 93760, 93823, 93952, 94026, 94032, 94032, 94099, 94111, 94176, 94177, 94179, 94179, 94208, 100343, 100352, 101589, 101632, 101640, 110576, 110579, 110581, 110587, 110589, 110590, 110592, 110882, 110898, 110898, 110928, 110930, 110933, 110933, 110948, 110951, 110960, 111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 122624, 122654, 122661, 122666, 122928, 122989, 123136, 123180, 123191, 123197, 123214, 123214, 123536, 123565, 123584, 123627, 124112, 124139, 124896, 124902, 124904, 124907, 124909, 124910, 124912, 124926, 124928, 125124, 125184, 125251, 125259, 125259, 126464, 126467, 126469, 126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 131072, 173791, 173824, 177977, 177984, 178205, 178208, 183969, 183984, 191456, 194560, 195101, 196608, 201546, 201552, 205743, 47, 0, 1, 1, 0, 0, 0, 0, 3, 1, 0, 0, 0, 0, 5, 1, 0, 0, 0, 0, 7, 1, 0, 0, 0, 0, 9, 1, 0, 0, 0, 0, 15, 1, 0, 0, 0, 1, 17, 1, 0, 0, 0, 3, 20, 1, 0, 0, 0, 5, 22, 1, 0, 0, 0, 7, 24, 1, 0, 0, 0, 9, 26, 1, 0, 0, 0, 11, 35, 1, 0, 0, 0, 13, 37, 1, 0, 0, 0, 15, 39, 1, 0, 0, 0, 17, 18, 5, 47, 0, 0, 18, 19, 5, 47, 0, 0, 19, 2, 1, 0, 0, 0, 20, 21, 5, 47, 0, 0, 21, 4, 1, 0, 0, 0, 22, 23, 5, 42, 0, 0, 23, 6, 1, 0, 0, 0, 24, 25, 5, 33, 0, 0, 25, 8, 1, 0, 0, 0, 26, 30, 3, 13, 6, 0, 27, 29, 3, 11, 5, 0, 28, 27, 1, 0, 0, 0, 29, 32, 1, 0, 0, 0, 30, 28, 1, 0, 0, 0, 30, 31, 1, 0, 0, 0, 31, 33, 1, 0, 0, 0, 32, 30, 1, 0, 0, 0, 33, 34, 6, 4, 0, 0, 34, 10, 1, 0, 0, 0, 35, 36, 7, 0, 0, 0, 36, 12, 1, 0, 0, 0, 37, 38, 7, 1, 0, 0, 38, 14, 1, 0, 0, 0, 39, 43, 5, 39, 0, 0, 40, 42, 9, 0, 0, 0, 41, 40, 1, 0, 0, 0, 42, 45, 1, 0, 0, 0, 43, 44, 1, 0, 0, 0, 43, 41, 1, 0, 0, 0, 44, 46, 1, 0, 0, 0, 45, 43, 1, 0, 0, 0, 46, 47, 5, 39, 0, 0, 47, 16, 1, 0, 0, 0, 3, 0, 30, 43, 1, 1, 4, 0];
  static __ATN;
  static get _ATN() {
    return i62.__ATN || (i62.__ATN = new yt2().deserialize(i62._serializedATN)), i62.__ATN;
  }
  static vocabulary = new b2(i62.literalNames, i62.symbolicNames, []);
  get vocabulary() {
    return i62.vocabulary;
  }
  static decisionsToDFA = i62._ATN.decisionToState.map((t, e) => new at2(t, e));
};

// ../frontend/src/parsing/python/PythonLexerBase.ts
var PythonLexerBase = class _PythonLexerBase extends N2 {
  static tabSize = 8;
  // The amount of opened braces, brackets and parenthesis.
  opened = 0;
  // The stack that keeps track of the indentation level.
  indents = [];
  buffer = [];
  lastToken;
  constructor(input) {
    super(input);
  }
  emit(token) {
    if (!token) {
      return super.emit();
    }
    super._token = token;
    this.buffer.push(token);
    this.lastToken = token;
    return token;
  }
  nextToken() {
    if (this.inputStream.LA(1) === PythonLexer.EOF && this.indents.length > 0) {
      const token = this.buffer[this.buffer.length - 1];
      if (!token || token.type !== PythonLexer.LINE_BREAK) {
        this.emitToken(PythonLexer.LINE_BREAK);
      }
      while (this.indents.length !== 0) {
        this.emitToken(PythonLexer.DEDENT);
        this.indents.pop();
      }
    }
    const candidate = this.buffer.shift();
    if (candidate) {
      return candidate;
    }
    return super.nextToken();
  }
  emitToken(tokenOrTokenType, channel, text) {
    if (tokenOrTokenType instanceof h2) {
      this.emit(tokenOrTokenType);
      return;
    }
    channel = channel ?? _PythonLexerBase.DEFAULT_TOKEN_CHANNEL;
    text = text ?? "";
    const charIndex = this._tokenStartCharIndex;
    const token = new ft2(
      this._tokenFactorySourcePair,
      tokenOrTokenType,
      channel,
      charIndex - text.length,
      charIndex
    );
    token.text = text;
    token.line = this.line;
    if (tokenOrTokenType !== PythonLexer.NEWLINE) {
      token.column = this.column - text.length;
    }
    this.emit(token);
  }
  handleNewLine() {
    this.emitToken(PythonLexer.NEWLINE, _PythonLexerBase.HIDDEN, this.text);
    const next = String.fromCharCode(this.inputStream.LA(1));
    if (next !== " " && next !== "	" && this.isNotNewLineOrComment(next)) {
      this.processNewLine(0);
    }
  }
  handleSpaces() {
    const next = String.fromCharCode(this.inputStream.LA(1));
    if ((!this.lastToken || this.lastToken.type === PythonLexer.NEWLINE) && this.isNotNewLineOrComment(next)) {
      let indent = 0;
      const text = this.text;
      for (let i63 = 0; i63 < text.length; ++i63) {
        indent += text.charAt(i63) === "	" ? _PythonLexerBase.tabSize - indent % _PythonLexerBase.tabSize : 1;
      }
      this.processNewLine(indent);
    }
    this.emitToken(PythonLexer.WS, _PythonLexerBase.HIDDEN, this.text);
  }
  incIndentLevel() {
    this.opened++;
  }
  decIndentLevel() {
    if (this.opened > 0) {
      --this.opened;
    }
  }
  isNotNewLineOrComment(next) {
    return this.opened === 0 && next !== "\r" && next !== "\n" && next !== "\f" && next !== "#";
  }
  processNewLine(indent) {
    this.emitToken(PythonLexer.LINE_BREAK);
    const previous = this.indents.length === 0 ? 0 : this.indents[0];
    if (indent > previous) {
      this.indents.push(indent);
      this.emitToken(PythonLexer.INDENT);
    } else {
      while (this.indents.length !== 0 && this.indents[0] > indent) {
        this.emitToken(PythonLexer.DEDENT);
        this.indents.pop();
      }
    }
  }
};

// ../frontend/src/parsing/python/generated/PythonLexer.ts
var PythonLexer = class _PythonLexer extends PythonLexerBase {
  static INDENT = 1;
  static DEDENT = 2;
  static LINE_BREAK = 3;
  static DEF = 4;
  static RETURN = 5;
  static RAISE = 6;
  static FROM = 7;
  static IMPORT = 8;
  static NONLOCAL = 9;
  static AS = 10;
  static GLOBAL = 11;
  static ASSERT = 12;
  static IF = 13;
  static ELIF = 14;
  static ELSE = 15;
  static WHILE = 16;
  static FOR = 17;
  static IN = 18;
  static TRY = 19;
  static NONE = 20;
  static FINALLY = 21;
  static WITH = 22;
  static EXCEPT = 23;
  static LAMBDA = 24;
  static OR = 25;
  static AND = 26;
  static NOT = 27;
  static IS = 28;
  static CLASS = 29;
  static YIELD = 30;
  static DEL = 31;
  static PASS = 32;
  static CONTINUE = 33;
  static BREAK = 34;
  static ASYNC = 35;
  static AWAIT = 36;
  static PRINT = 37;
  static EXEC = 38;
  static TRUE = 39;
  static FALSE = 40;
  static DOT = 41;
  static ELLIPSIS = 42;
  static REVERSE_QUOTE = 43;
  static STAR = 44;
  static COMMA = 45;
  static COLON = 46;
  static SEMI_COLON = 47;
  static POWER = 48;
  static ASSIGN = 49;
  static OR_OP = 50;
  static XOR = 51;
  static AND_OP = 52;
  static LEFT_SHIFT = 53;
  static RIGHT_SHIFT = 54;
  static ADD = 55;
  static MINUS = 56;
  static DIV = 57;
  static MOD = 58;
  static IDIV = 59;
  static NOT_OP = 60;
  static LESS_THAN = 61;
  static GREATER_THAN = 62;
  static EQUALS = 63;
  static GT_EQ = 64;
  static LT_EQ = 65;
  static NOT_EQ_1 = 66;
  static NOT_EQ_2 = 67;
  static AT = 68;
  static ARROW = 69;
  static ADD_ASSIGN = 70;
  static SUB_ASSIGN = 71;
  static MULT_ASSIGN = 72;
  static AT_ASSIGN = 73;
  static DIV_ASSIGN = 74;
  static MOD_ASSIGN = 75;
  static AND_ASSIGN = 76;
  static OR_ASSIGN = 77;
  static XOR_ASSIGN = 78;
  static LEFT_SHIFT_ASSIGN = 79;
  static RIGHT_SHIFT_ASSIGN = 80;
  static POWER_ASSIGN = 81;
  static IDIV_ASSIGN = 82;
  static STRING = 83;
  static DECIMAL_INTEGER = 84;
  static OCT_INTEGER = 85;
  static HEX_INTEGER = 86;
  static BIN_INTEGER = 87;
  static IMAG_NUMBER = 88;
  static FLOAT_NUMBER = 89;
  static OPEN_PAREN = 90;
  static CLOSE_PAREN = 91;
  static OPEN_BRACE = 92;
  static CLOSE_BRACE = 93;
  static OPEN_BRACKET = 94;
  static CLOSE_BRACKET = 95;
  static NAME = 96;
  static LINE_JOIN = 97;
  static NEWLINE = 98;
  static WS = 99;
  static COMMENT = 100;
  static channelNames = [
    "DEFAULT_TOKEN_CHANNEL",
    "HIDDEN"
  ];
  static literalNames = [
    null,
    null,
    null,
    null,
    "'def'",
    "'return'",
    "'raise'",
    "'from'",
    "'import'",
    "'nonlocal'",
    "'as'",
    "'global'",
    "'assert'",
    "'if'",
    "'elif'",
    "'else'",
    "'while'",
    "'for'",
    "'in'",
    "'try'",
    "'None'",
    "'finally'",
    "'with'",
    "'except'",
    "'lambda'",
    "'or'",
    "'and'",
    "'not'",
    "'is'",
    "'class'",
    "'yield'",
    "'del'",
    "'pass'",
    "'continue'",
    "'break'",
    "'async'",
    "'await'",
    "'print'",
    "'exec'",
    "'True'",
    "'False'",
    "'.'",
    "'...'",
    "'`'",
    "'*'",
    "','",
    "':'",
    "';'",
    "'**'",
    "'='",
    "'|'",
    "'^'",
    "'&'",
    "'<<'",
    "'>>'",
    "'+'",
    "'-'",
    "'/'",
    "'%'",
    "'//'",
    "'~'",
    "'<'",
    "'>'",
    "'=='",
    "'>='",
    "'<='",
    "'<>'",
    "'!='",
    "'@'",
    "'->'",
    "'+='",
    "'-='",
    "'*='",
    "'@='",
    "'/='",
    "'%='",
    "'&='",
    "'|='",
    "'^='",
    "'<<='",
    "'>>='",
    "'**='",
    "'//='",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "'('",
    "')'",
    "'{'",
    "'}'",
    "'['",
    "']'"
  ];
  static symbolicNames = [
    null,
    "INDENT",
    "DEDENT",
    "LINE_BREAK",
    "DEF",
    "RETURN",
    "RAISE",
    "FROM",
    "IMPORT",
    "NONLOCAL",
    "AS",
    "GLOBAL",
    "ASSERT",
    "IF",
    "ELIF",
    "ELSE",
    "WHILE",
    "FOR",
    "IN",
    "TRY",
    "NONE",
    "FINALLY",
    "WITH",
    "EXCEPT",
    "LAMBDA",
    "OR",
    "AND",
    "NOT",
    "IS",
    "CLASS",
    "YIELD",
    "DEL",
    "PASS",
    "CONTINUE",
    "BREAK",
    "ASYNC",
    "AWAIT",
    "PRINT",
    "EXEC",
    "TRUE",
    "FALSE",
    "DOT",
    "ELLIPSIS",
    "REVERSE_QUOTE",
    "STAR",
    "COMMA",
    "COLON",
    "SEMI_COLON",
    "POWER",
    "ASSIGN",
    "OR_OP",
    "XOR",
    "AND_OP",
    "LEFT_SHIFT",
    "RIGHT_SHIFT",
    "ADD",
    "MINUS",
    "DIV",
    "MOD",
    "IDIV",
    "NOT_OP",
    "LESS_THAN",
    "GREATER_THAN",
    "EQUALS",
    "GT_EQ",
    "LT_EQ",
    "NOT_EQ_1",
    "NOT_EQ_2",
    "AT",
    "ARROW",
    "ADD_ASSIGN",
    "SUB_ASSIGN",
    "MULT_ASSIGN",
    "AT_ASSIGN",
    "DIV_ASSIGN",
    "MOD_ASSIGN",
    "AND_ASSIGN",
    "OR_ASSIGN",
    "XOR_ASSIGN",
    "LEFT_SHIFT_ASSIGN",
    "RIGHT_SHIFT_ASSIGN",
    "POWER_ASSIGN",
    "IDIV_ASSIGN",
    "STRING",
    "DECIMAL_INTEGER",
    "OCT_INTEGER",
    "HEX_INTEGER",
    "BIN_INTEGER",
    "IMAG_NUMBER",
    "FLOAT_NUMBER",
    "OPEN_PAREN",
    "CLOSE_PAREN",
    "OPEN_BRACE",
    "CLOSE_BRACE",
    "OPEN_BRACKET",
    "CLOSE_BRACKET",
    "NAME",
    "LINE_JOIN",
    "NEWLINE",
    "WS",
    "COMMENT"
  ];
  static modeNames = [
    "DEFAULT_MODE"
  ];
  static ruleNames = [
    "DEF",
    "RETURN",
    "RAISE",
    "FROM",
    "IMPORT",
    "NONLOCAL",
    "AS",
    "GLOBAL",
    "ASSERT",
    "IF",
    "ELIF",
    "ELSE",
    "WHILE",
    "FOR",
    "IN",
    "TRY",
    "NONE",
    "FINALLY",
    "WITH",
    "EXCEPT",
    "LAMBDA",
    "OR",
    "AND",
    "NOT",
    "IS",
    "CLASS",
    "YIELD",
    "DEL",
    "PASS",
    "CONTINUE",
    "BREAK",
    "ASYNC",
    "AWAIT",
    "PRINT",
    "EXEC",
    "TRUE",
    "FALSE",
    "DOT",
    "ELLIPSIS",
    "REVERSE_QUOTE",
    "STAR",
    "COMMA",
    "COLON",
    "SEMI_COLON",
    "POWER",
    "ASSIGN",
    "OR_OP",
    "XOR",
    "AND_OP",
    "LEFT_SHIFT",
    "RIGHT_SHIFT",
    "ADD",
    "MINUS",
    "DIV",
    "MOD",
    "IDIV",
    "NOT_OP",
    "LESS_THAN",
    "GREATER_THAN",
    "EQUALS",
    "GT_EQ",
    "LT_EQ",
    "NOT_EQ_1",
    "NOT_EQ_2",
    "AT",
    "ARROW",
    "ADD_ASSIGN",
    "SUB_ASSIGN",
    "MULT_ASSIGN",
    "AT_ASSIGN",
    "DIV_ASSIGN",
    "MOD_ASSIGN",
    "AND_ASSIGN",
    "OR_ASSIGN",
    "XOR_ASSIGN",
    "LEFT_SHIFT_ASSIGN",
    "RIGHT_SHIFT_ASSIGN",
    "POWER_ASSIGN",
    "IDIV_ASSIGN",
    "STRING",
    "DECIMAL_INTEGER",
    "OCT_INTEGER",
    "HEX_INTEGER",
    "BIN_INTEGER",
    "IMAG_NUMBER",
    "FLOAT_NUMBER",
    "OPEN_PAREN",
    "CLOSE_PAREN",
    "OPEN_BRACE",
    "CLOSE_BRACE",
    "OPEN_BRACKET",
    "CLOSE_BRACKET",
    "NAME",
    "LINE_JOIN",
    "NEWLINE",
    "WS",
    "COMMENT",
    "SHORT_STRING",
    "LONG_STRING",
    "LONG_STRING_ITEM",
    "RN",
    "EXPONENT_OR_POINT_FLOAT",
    "POINT_FLOAT",
    "SHORT_BYTES",
    "LONG_BYTES",
    "LONG_BYTES_ITEM",
    "SHORT_BYTES_CHAR_NO_SINGLE_QUOTE",
    "SHORT_BYTES_CHAR_NO_DOUBLE_QUOTE",
    "LONG_BYTES_CHAR",
    "BYTES_ESCAPE_SEQ",
    "ID_CONTINUE",
    "ID_START"
  ];
  constructor(input) {
    super(input);
    this.interpreter = new Z2(this, _PythonLexer._ATN, _PythonLexer.decisionsToDFA, new lt2());
  }
  get grammarFileName() {
    return "PythonLexer.g4";
  }
  get literalNames() {
    return _PythonLexer.literalNames;
  }
  get symbolicNames() {
    return _PythonLexer.symbolicNames;
  }
  get ruleNames() {
    return _PythonLexer.ruleNames;
  }
  get serializedATN() {
    return _PythonLexer._serializedATN;
  }
  get channelNames() {
    return _PythonLexer.channelNames;
  }
  get modeNames() {
    return _PythonLexer.modeNames;
  }
  action(localContext, ruleIndex, actionIndex) {
    switch (ruleIndex) {
      case 86:
        this.OPEN_PAREN_action(localContext, actionIndex);
        break;
      case 87:
        this.CLOSE_PAREN_action(localContext, actionIndex);
        break;
      case 88:
        this.OPEN_BRACE_action(localContext, actionIndex);
        break;
      case 89:
        this.CLOSE_BRACE_action(localContext, actionIndex);
        break;
      case 90:
        this.OPEN_BRACKET_action(localContext, actionIndex);
        break;
      case 91:
        this.CLOSE_BRACKET_action(localContext, actionIndex);
        break;
      case 94:
        this.NEWLINE_action(localContext, actionIndex);
        break;
      case 95:
        this.WS_action(localContext, actionIndex);
        break;
    }
  }
  OPEN_PAREN_action(localContext, actionIndex) {
    switch (actionIndex) {
      case 0:
        this.incIndentLevel();
        break;
    }
  }
  CLOSE_PAREN_action(localContext, actionIndex) {
    switch (actionIndex) {
      case 1:
        this.decIndentLevel();
        break;
    }
  }
  OPEN_BRACE_action(localContext, actionIndex) {
    switch (actionIndex) {
      case 2:
        this.incIndentLevel();
        break;
    }
  }
  CLOSE_BRACE_action(localContext, actionIndex) {
    switch (actionIndex) {
      case 3:
        this.decIndentLevel();
        break;
    }
  }
  OPEN_BRACKET_action(localContext, actionIndex) {
    switch (actionIndex) {
      case 4:
        this.incIndentLevel();
        break;
    }
  }
  CLOSE_BRACKET_action(localContext, actionIndex) {
    switch (actionIndex) {
      case 5:
        this.decIndentLevel();
        break;
    }
  }
  NEWLINE_action(localContext, actionIndex) {
    switch (actionIndex) {
      case 6:
        this.handleNewLine();
        break;
    }
  }
  WS_action(localContext, actionIndex) {
    switch (actionIndex) {
      case 7:
        this.handleSpaces();
        break;
    }
  }
  static _serializedATN = [
    4,
    0,
    100,
    854,
    6,
    -1,
    2,
    0,
    7,
    0,
    2,
    1,
    7,
    1,
    2,
    2,
    7,
    2,
    2,
    3,
    7,
    3,
    2,
    4,
    7,
    4,
    2,
    5,
    7,
    5,
    2,
    6,
    7,
    6,
    2,
    7,
    7,
    7,
    2,
    8,
    7,
    8,
    2,
    9,
    7,
    9,
    2,
    10,
    7,
    10,
    2,
    11,
    7,
    11,
    2,
    12,
    7,
    12,
    2,
    13,
    7,
    13,
    2,
    14,
    7,
    14,
    2,
    15,
    7,
    15,
    2,
    16,
    7,
    16,
    2,
    17,
    7,
    17,
    2,
    18,
    7,
    18,
    2,
    19,
    7,
    19,
    2,
    20,
    7,
    20,
    2,
    21,
    7,
    21,
    2,
    22,
    7,
    22,
    2,
    23,
    7,
    23,
    2,
    24,
    7,
    24,
    2,
    25,
    7,
    25,
    2,
    26,
    7,
    26,
    2,
    27,
    7,
    27,
    2,
    28,
    7,
    28,
    2,
    29,
    7,
    29,
    2,
    30,
    7,
    30,
    2,
    31,
    7,
    31,
    2,
    32,
    7,
    32,
    2,
    33,
    7,
    33,
    2,
    34,
    7,
    34,
    2,
    35,
    7,
    35,
    2,
    36,
    7,
    36,
    2,
    37,
    7,
    37,
    2,
    38,
    7,
    38,
    2,
    39,
    7,
    39,
    2,
    40,
    7,
    40,
    2,
    41,
    7,
    41,
    2,
    42,
    7,
    42,
    2,
    43,
    7,
    43,
    2,
    44,
    7,
    44,
    2,
    45,
    7,
    45,
    2,
    46,
    7,
    46,
    2,
    47,
    7,
    47,
    2,
    48,
    7,
    48,
    2,
    49,
    7,
    49,
    2,
    50,
    7,
    50,
    2,
    51,
    7,
    51,
    2,
    52,
    7,
    52,
    2,
    53,
    7,
    53,
    2,
    54,
    7,
    54,
    2,
    55,
    7,
    55,
    2,
    56,
    7,
    56,
    2,
    57,
    7,
    57,
    2,
    58,
    7,
    58,
    2,
    59,
    7,
    59,
    2,
    60,
    7,
    60,
    2,
    61,
    7,
    61,
    2,
    62,
    7,
    62,
    2,
    63,
    7,
    63,
    2,
    64,
    7,
    64,
    2,
    65,
    7,
    65,
    2,
    66,
    7,
    66,
    2,
    67,
    7,
    67,
    2,
    68,
    7,
    68,
    2,
    69,
    7,
    69,
    2,
    70,
    7,
    70,
    2,
    71,
    7,
    71,
    2,
    72,
    7,
    72,
    2,
    73,
    7,
    73,
    2,
    74,
    7,
    74,
    2,
    75,
    7,
    75,
    2,
    76,
    7,
    76,
    2,
    77,
    7,
    77,
    2,
    78,
    7,
    78,
    2,
    79,
    7,
    79,
    2,
    80,
    7,
    80,
    2,
    81,
    7,
    81,
    2,
    82,
    7,
    82,
    2,
    83,
    7,
    83,
    2,
    84,
    7,
    84,
    2,
    85,
    7,
    85,
    2,
    86,
    7,
    86,
    2,
    87,
    7,
    87,
    2,
    88,
    7,
    88,
    2,
    89,
    7,
    89,
    2,
    90,
    7,
    90,
    2,
    91,
    7,
    91,
    2,
    92,
    7,
    92,
    2,
    93,
    7,
    93,
    2,
    94,
    7,
    94,
    2,
    95,
    7,
    95,
    2,
    96,
    7,
    96,
    2,
    97,
    7,
    97,
    2,
    98,
    7,
    98,
    2,
    99,
    7,
    99,
    2,
    100,
    7,
    100,
    2,
    101,
    7,
    101,
    2,
    102,
    7,
    102,
    2,
    103,
    7,
    103,
    2,
    104,
    7,
    104,
    2,
    105,
    7,
    105,
    2,
    106,
    7,
    106,
    2,
    107,
    7,
    107,
    2,
    108,
    7,
    108,
    2,
    109,
    7,
    109,
    2,
    110,
    7,
    110,
    2,
    111,
    7,
    111,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    3,
    1,
    3,
    1,
    3,
    1,
    3,
    1,
    3,
    1,
    4,
    1,
    4,
    1,
    4,
    1,
    4,
    1,
    4,
    1,
    4,
    1,
    4,
    1,
    5,
    1,
    5,
    1,
    5,
    1,
    5,
    1,
    5,
    1,
    5,
    1,
    5,
    1,
    5,
    1,
    5,
    1,
    6,
    1,
    6,
    1,
    6,
    1,
    7,
    1,
    7,
    1,
    7,
    1,
    7,
    1,
    7,
    1,
    7,
    1,
    7,
    1,
    8,
    1,
    8,
    1,
    8,
    1,
    8,
    1,
    8,
    1,
    8,
    1,
    8,
    1,
    9,
    1,
    9,
    1,
    9,
    1,
    10,
    1,
    10,
    1,
    10,
    1,
    10,
    1,
    10,
    1,
    11,
    1,
    11,
    1,
    11,
    1,
    11,
    1,
    11,
    1,
    12,
    1,
    12,
    1,
    12,
    1,
    12,
    1,
    12,
    1,
    12,
    1,
    13,
    1,
    13,
    1,
    13,
    1,
    13,
    1,
    14,
    1,
    14,
    1,
    14,
    1,
    15,
    1,
    15,
    1,
    15,
    1,
    15,
    1,
    16,
    1,
    16,
    1,
    16,
    1,
    16,
    1,
    16,
    1,
    17,
    1,
    17,
    1,
    17,
    1,
    17,
    1,
    17,
    1,
    17,
    1,
    17,
    1,
    17,
    1,
    18,
    1,
    18,
    1,
    18,
    1,
    18,
    1,
    18,
    1,
    19,
    1,
    19,
    1,
    19,
    1,
    19,
    1,
    19,
    1,
    19,
    1,
    19,
    1,
    20,
    1,
    20,
    1,
    20,
    1,
    20,
    1,
    20,
    1,
    20,
    1,
    20,
    1,
    21,
    1,
    21,
    1,
    21,
    1,
    22,
    1,
    22,
    1,
    22,
    1,
    22,
    1,
    23,
    1,
    23,
    1,
    23,
    1,
    23,
    1,
    24,
    1,
    24,
    1,
    24,
    1,
    25,
    1,
    25,
    1,
    25,
    1,
    25,
    1,
    25,
    1,
    25,
    1,
    26,
    1,
    26,
    1,
    26,
    1,
    26,
    1,
    26,
    1,
    26,
    1,
    27,
    1,
    27,
    1,
    27,
    1,
    27,
    1,
    28,
    1,
    28,
    1,
    28,
    1,
    28,
    1,
    28,
    1,
    29,
    1,
    29,
    1,
    29,
    1,
    29,
    1,
    29,
    1,
    29,
    1,
    29,
    1,
    29,
    1,
    29,
    1,
    30,
    1,
    30,
    1,
    30,
    1,
    30,
    1,
    30,
    1,
    30,
    1,
    31,
    1,
    31,
    1,
    31,
    1,
    31,
    1,
    31,
    1,
    31,
    1,
    32,
    1,
    32,
    1,
    32,
    1,
    32,
    1,
    32,
    1,
    32,
    1,
    33,
    1,
    33,
    1,
    33,
    1,
    33,
    1,
    33,
    1,
    33,
    1,
    34,
    1,
    34,
    1,
    34,
    1,
    34,
    1,
    34,
    1,
    35,
    1,
    35,
    1,
    35,
    1,
    35,
    1,
    35,
    1,
    36,
    1,
    36,
    1,
    36,
    1,
    36,
    1,
    36,
    1,
    36,
    1,
    37,
    1,
    37,
    1,
    38,
    1,
    38,
    1,
    38,
    1,
    38,
    1,
    39,
    1,
    39,
    1,
    40,
    1,
    40,
    1,
    41,
    1,
    41,
    1,
    42,
    1,
    42,
    1,
    43,
    1,
    43,
    1,
    44,
    1,
    44,
    1,
    44,
    1,
    45,
    1,
    45,
    1,
    46,
    1,
    46,
    1,
    47,
    1,
    47,
    1,
    48,
    1,
    48,
    1,
    49,
    1,
    49,
    1,
    49,
    1,
    50,
    1,
    50,
    1,
    50,
    1,
    51,
    1,
    51,
    1,
    52,
    1,
    52,
    1,
    53,
    1,
    53,
    1,
    54,
    1,
    54,
    1,
    55,
    1,
    55,
    1,
    55,
    1,
    56,
    1,
    56,
    1,
    57,
    1,
    57,
    1,
    58,
    1,
    58,
    1,
    59,
    1,
    59,
    1,
    59,
    1,
    60,
    1,
    60,
    1,
    60,
    1,
    61,
    1,
    61,
    1,
    61,
    1,
    62,
    1,
    62,
    1,
    62,
    1,
    63,
    1,
    63,
    1,
    63,
    1,
    64,
    1,
    64,
    1,
    65,
    1,
    65,
    1,
    65,
    1,
    66,
    1,
    66,
    1,
    66,
    1,
    67,
    1,
    67,
    1,
    67,
    1,
    68,
    1,
    68,
    1,
    68,
    1,
    69,
    1,
    69,
    1,
    69,
    1,
    70,
    1,
    70,
    1,
    70,
    1,
    71,
    1,
    71,
    1,
    71,
    1,
    72,
    1,
    72,
    1,
    72,
    1,
    73,
    1,
    73,
    1,
    73,
    1,
    74,
    1,
    74,
    1,
    74,
    1,
    75,
    1,
    75,
    1,
    75,
    1,
    75,
    1,
    76,
    1,
    76,
    1,
    76,
    1,
    76,
    1,
    77,
    1,
    77,
    1,
    77,
    1,
    77,
    1,
    78,
    1,
    78,
    1,
    78,
    1,
    78,
    1,
    79,
    1,
    79,
    1,
    79,
    3,
    79,
    543,
    8,
    79,
    1,
    79,
    1,
    79,
    3,
    79,
    547,
    8,
    79,
    3,
    79,
    549,
    8,
    79,
    1,
    79,
    1,
    79,
    3,
    79,
    553,
    8,
    79,
    1,
    79,
    1,
    79,
    3,
    79,
    557,
    8,
    79,
    1,
    79,
    1,
    79,
    3,
    79,
    561,
    8,
    79,
    1,
    79,
    1,
    79,
    3,
    79,
    565,
    8,
    79,
    3,
    79,
    567,
    8,
    79,
    1,
    80,
    1,
    80,
    5,
    80,
    571,
    8,
    80,
    10,
    80,
    12,
    80,
    574,
    9,
    80,
    1,
    80,
    4,
    80,
    577,
    8,
    80,
    11,
    80,
    12,
    80,
    578,
    3,
    80,
    581,
    8,
    80,
    1,
    81,
    1,
    81,
    1,
    81,
    4,
    81,
    586,
    8,
    81,
    11,
    81,
    12,
    81,
    587,
    1,
    82,
    1,
    82,
    1,
    82,
    4,
    82,
    593,
    8,
    82,
    11,
    82,
    12,
    82,
    594,
    1,
    83,
    1,
    83,
    1,
    83,
    4,
    83,
    600,
    8,
    83,
    11,
    83,
    12,
    83,
    601,
    1,
    84,
    1,
    84,
    4,
    84,
    606,
    8,
    84,
    11,
    84,
    12,
    84,
    607,
    3,
    84,
    610,
    8,
    84,
    1,
    84,
    1,
    84,
    1,
    85,
    1,
    85,
    1,
    86,
    1,
    86,
    1,
    86,
    1,
    87,
    1,
    87,
    1,
    87,
    1,
    88,
    1,
    88,
    1,
    88,
    1,
    89,
    1,
    89,
    1,
    89,
    1,
    90,
    1,
    90,
    1,
    90,
    1,
    91,
    1,
    91,
    1,
    91,
    1,
    92,
    1,
    92,
    5,
    92,
    636,
    8,
    92,
    10,
    92,
    12,
    92,
    639,
    9,
    92,
    1,
    93,
    1,
    93,
    5,
    93,
    643,
    8,
    93,
    10,
    93,
    12,
    93,
    646,
    9,
    93,
    1,
    93,
    1,
    93,
    1,
    93,
    1,
    93,
    1,
    94,
    1,
    94,
    1,
    94,
    1,
    94,
    1,
    94,
    1,
    95,
    4,
    95,
    658,
    8,
    95,
    11,
    95,
    12,
    95,
    659,
    1,
    95,
    1,
    95,
    1,
    95,
    1,
    95,
    1,
    96,
    1,
    96,
    5,
    96,
    668,
    8,
    96,
    10,
    96,
    12,
    96,
    671,
    9,
    96,
    1,
    96,
    1,
    96,
    1,
    97,
    1,
    97,
    1,
    97,
    1,
    97,
    3,
    97,
    679,
    8,
    97,
    1,
    97,
    5,
    97,
    682,
    8,
    97,
    10,
    97,
    12,
    97,
    685,
    9,
    97,
    1,
    97,
    1,
    97,
    1,
    97,
    1,
    97,
    1,
    97,
    3,
    97,
    692,
    8,
    97,
    1,
    97,
    5,
    97,
    695,
    8,
    97,
    10,
    97,
    12,
    97,
    698,
    9,
    97,
    1,
    97,
    3,
    97,
    701,
    8,
    97,
    1,
    98,
    1,
    98,
    1,
    98,
    1,
    98,
    1,
    98,
    5,
    98,
    708,
    8,
    98,
    10,
    98,
    12,
    98,
    711,
    9,
    98,
    1,
    98,
    1,
    98,
    1,
    98,
    1,
    98,
    1,
    98,
    1,
    98,
    1,
    98,
    1,
    98,
    5,
    98,
    721,
    8,
    98,
    10,
    98,
    12,
    98,
    724,
    9,
    98,
    1,
    98,
    1,
    98,
    1,
    98,
    3,
    98,
    729,
    8,
    98,
    1,
    99,
    1,
    99,
    1,
    99,
    1,
    99,
    3,
    99,
    735,
    8,
    99,
    3,
    99,
    737,
    8,
    99,
    1,
    100,
    3,
    100,
    740,
    8,
    100,
    1,
    100,
    1,
    100,
    1,
    101,
    4,
    101,
    745,
    8,
    101,
    11,
    101,
    12,
    101,
    746,
    1,
    101,
    3,
    101,
    750,
    8,
    101,
    1,
    101,
    1,
    101,
    3,
    101,
    754,
    8,
    101,
    1,
    101,
    4,
    101,
    757,
    8,
    101,
    11,
    101,
    12,
    101,
    758,
    1,
    101,
    3,
    101,
    762,
    8,
    101,
    1,
    102,
    5,
    102,
    765,
    8,
    102,
    10,
    102,
    12,
    102,
    768,
    9,
    102,
    1,
    102,
    1,
    102,
    4,
    102,
    772,
    8,
    102,
    11,
    102,
    12,
    102,
    773,
    1,
    102,
    4,
    102,
    777,
    8,
    102,
    11,
    102,
    12,
    102,
    778,
    1,
    102,
    3,
    102,
    782,
    8,
    102,
    1,
    103,
    1,
    103,
    1,
    103,
    5,
    103,
    787,
    8,
    103,
    10,
    103,
    12,
    103,
    790,
    9,
    103,
    1,
    103,
    1,
    103,
    1,
    103,
    1,
    103,
    5,
    103,
    796,
    8,
    103,
    10,
    103,
    12,
    103,
    799,
    9,
    103,
    1,
    103,
    3,
    103,
    802,
    8,
    103,
    1,
    104,
    1,
    104,
    1,
    104,
    1,
    104,
    1,
    104,
    5,
    104,
    809,
    8,
    104,
    10,
    104,
    12,
    104,
    812,
    9,
    104,
    1,
    104,
    1,
    104,
    1,
    104,
    1,
    104,
    1,
    104,
    1,
    104,
    1,
    104,
    1,
    104,
    5,
    104,
    822,
    8,
    104,
    10,
    104,
    12,
    104,
    825,
    9,
    104,
    1,
    104,
    1,
    104,
    1,
    104,
    3,
    104,
    830,
    8,
    104,
    1,
    105,
    1,
    105,
    3,
    105,
    834,
    8,
    105,
    1,
    106,
    3,
    106,
    837,
    8,
    106,
    1,
    107,
    3,
    107,
    840,
    8,
    107,
    1,
    108,
    3,
    108,
    843,
    8,
    108,
    1,
    109,
    1,
    109,
    1,
    109,
    1,
    110,
    1,
    110,
    3,
    110,
    850,
    8,
    110,
    1,
    111,
    3,
    111,
    853,
    8,
    111,
    4,
    709,
    722,
    810,
    823,
    0,
    112,
    1,
    4,
    3,
    5,
    5,
    6,
    7,
    7,
    9,
    8,
    11,
    9,
    13,
    10,
    15,
    11,
    17,
    12,
    19,
    13,
    21,
    14,
    23,
    15,
    25,
    16,
    27,
    17,
    29,
    18,
    31,
    19,
    33,
    20,
    35,
    21,
    37,
    22,
    39,
    23,
    41,
    24,
    43,
    25,
    45,
    26,
    47,
    27,
    49,
    28,
    51,
    29,
    53,
    30,
    55,
    31,
    57,
    32,
    59,
    33,
    61,
    34,
    63,
    35,
    65,
    36,
    67,
    37,
    69,
    38,
    71,
    39,
    73,
    40,
    75,
    41,
    77,
    42,
    79,
    43,
    81,
    44,
    83,
    45,
    85,
    46,
    87,
    47,
    89,
    48,
    91,
    49,
    93,
    50,
    95,
    51,
    97,
    52,
    99,
    53,
    101,
    54,
    103,
    55,
    105,
    56,
    107,
    57,
    109,
    58,
    111,
    59,
    113,
    60,
    115,
    61,
    117,
    62,
    119,
    63,
    121,
    64,
    123,
    65,
    125,
    66,
    127,
    67,
    129,
    68,
    131,
    69,
    133,
    70,
    135,
    71,
    137,
    72,
    139,
    73,
    141,
    74,
    143,
    75,
    145,
    76,
    147,
    77,
    149,
    78,
    151,
    79,
    153,
    80,
    155,
    81,
    157,
    82,
    159,
    83,
    161,
    84,
    163,
    85,
    165,
    86,
    167,
    87,
    169,
    88,
    171,
    89,
    173,
    90,
    175,
    91,
    177,
    92,
    179,
    93,
    181,
    94,
    183,
    95,
    185,
    96,
    187,
    97,
    189,
    98,
    191,
    99,
    193,
    100,
    195,
    0,
    197,
    0,
    199,
    0,
    201,
    0,
    203,
    0,
    205,
    0,
    207,
    0,
    209,
    0,
    211,
    0,
    213,
    0,
    215,
    0,
    217,
    0,
    219,
    0,
    221,
    0,
    223,
    0,
    1,
    0,
    25,
    2,
    0,
    85,
    85,
    117,
    117,
    2,
    0,
    70,
    70,
    102,
    102,
    2,
    0,
    82,
    82,
    114,
    114,
    2,
    0,
    66,
    66,
    98,
    98,
    1,
    0,
    49,
    57,
    1,
    0,
    48,
    57,
    2,
    0,
    79,
    79,
    111,
    111,
    1,
    0,
    48,
    55,
    2,
    0,
    88,
    88,
    120,
    120,
    3,
    0,
    48,
    57,
    65,
    70,
    97,
    102,
    1,
    0,
    48,
    49,
    2,
    0,
    74,
    74,
    106,
    106,
    2,
    0,
    9,
    9,
    32,
    32,
    2,
    0,
    10,
    10,
    12,
    13,
    4,
    0,
    10,
    10,
    13,
    13,
    39,
    39,
    92,
    92,
    4,
    0,
    10,
    10,
    13,
    13,
    34,
    34,
    92,
    92,
    1,
    0,
    92,
    92,
    2,
    0,
    69,
    69,
    101,
    101,
    2,
    0,
    43,
    43,
    45,
    45,
    5,
    0,
    0,
    9,
    11,
    12,
    14,
    38,
    40,
    91,
    93,
    127,
    5,
    0,
    0,
    9,
    11,
    12,
    14,
    33,
    35,
    91,
    93,
    127,
    2,
    0,
    0,
    91,
    93,
    127,
    1,
    0,
    0,
    127,
    148,
    0,
    48,
    57,
    768,
    879,
    1155,
    1158,
    1425,
    1465,
    1467,
    1469,
    1471,
    1471,
    1473,
    1474,
    1476,
    1477,
    1479,
    1479,
    1552,
    1557,
    1611,
    1630,
    1632,
    1641,
    1648,
    1648,
    1750,
    1756,
    1759,
    1764,
    1767,
    1768,
    1770,
    1773,
    1776,
    1785,
    1809,
    1809,
    1840,
    1866,
    1958,
    1968,
    2305,
    2307,
    2364,
    2364,
    2366,
    2381,
    2385,
    2388,
    2402,
    2403,
    2406,
    2415,
    2433,
    2435,
    2492,
    2492,
    2494,
    2500,
    2503,
    2504,
    2507,
    2509,
    2519,
    2519,
    2530,
    2531,
    2534,
    2543,
    2561,
    2563,
    2620,
    2620,
    2622,
    2626,
    2631,
    2632,
    2635,
    2637,
    2662,
    2673,
    2689,
    2691,
    2748,
    2748,
    2750,
    2757,
    2759,
    2761,
    2763,
    2765,
    2786,
    2787,
    2790,
    2799,
    2817,
    2819,
    2876,
    2876,
    2878,
    2883,
    2887,
    2888,
    2891,
    2893,
    2902,
    2903,
    2918,
    2927,
    2946,
    2946,
    3006,
    3010,
    3014,
    3016,
    3018,
    3021,
    3031,
    3031,
    3046,
    3055,
    3073,
    3075,
    3134,
    3140,
    3142,
    3144,
    3146,
    3149,
    3157,
    3158,
    3174,
    3183,
    3202,
    3203,
    3260,
    3260,
    3262,
    3268,
    3270,
    3272,
    3274,
    3277,
    3285,
    3286,
    3302,
    3311,
    3330,
    3331,
    3390,
    3395,
    3398,
    3400,
    3402,
    3405,
    3415,
    3415,
    3430,
    3439,
    3458,
    3459,
    3530,
    3530,
    3535,
    3540,
    3542,
    3542,
    3544,
    3551,
    3570,
    3571,
    3633,
    3633,
    3636,
    3642,
    3655,
    3662,
    3664,
    3673,
    3761,
    3761,
    3764,
    3769,
    3771,
    3772,
    3784,
    3789,
    3792,
    3801,
    3864,
    3865,
    3872,
    3881,
    3893,
    3893,
    3895,
    3895,
    3897,
    3897,
    3902,
    3903,
    3953,
    3972,
    3974,
    3975,
    3984,
    3991,
    3993,
    4028,
    4038,
    4038,
    4140,
    4146,
    4150,
    4153,
    4160,
    4169,
    4182,
    4185,
    4959,
    4959,
    4969,
    4977,
    5906,
    5908,
    5938,
    5940,
    5970,
    5971,
    6002,
    6003,
    6070,
    6099,
    6109,
    6109,
    6112,
    6121,
    6155,
    6157,
    6160,
    6169,
    6313,
    6313,
    6432,
    6443,
    6448,
    6459,
    6470,
    6479,
    6576,
    6592,
    6600,
    6601,
    6608,
    6617,
    6679,
    6683,
    7616,
    7619,
    8255,
    8256,
    8276,
    8276,
    8400,
    8412,
    8417,
    8417,
    8421,
    8427,
    12330,
    12335,
    12441,
    12442,
    43010,
    43010,
    43014,
    43014,
    43019,
    43019,
    43043,
    43047,
    64286,
    64286,
    65024,
    65039,
    65056,
    65059,
    65075,
    65076,
    65101,
    65103,
    65296,
    65305,
    65343,
    65343,
    295,
    0,
    65,
    90,
    95,
    95,
    97,
    122,
    170,
    170,
    181,
    181,
    186,
    186,
    192,
    214,
    216,
    246,
    248,
    577,
    592,
    705,
    710,
    721,
    736,
    740,
    750,
    750,
    890,
    890,
    902,
    902,
    904,
    906,
    908,
    908,
    910,
    929,
    931,
    974,
    976,
    1013,
    1015,
    1153,
    1162,
    1230,
    1232,
    1273,
    1280,
    1295,
    1329,
    1366,
    1369,
    1369,
    1377,
    1415,
    1488,
    1514,
    1520,
    1522,
    1569,
    1594,
    1600,
    1610,
    1646,
    1647,
    1649,
    1747,
    1749,
    1749,
    1765,
    1766,
    1774,
    1775,
    1786,
    1788,
    1791,
    1791,
    1808,
    1808,
    1810,
    1839,
    1869,
    1901,
    1920,
    1957,
    1969,
    1969,
    2308,
    2361,
    2365,
    2365,
    2384,
    2384,
    2392,
    2401,
    2429,
    2429,
    2437,
    2444,
    2447,
    2448,
    2451,
    2472,
    2474,
    2480,
    2482,
    2482,
    2486,
    2489,
    2493,
    2493,
    2510,
    2510,
    2524,
    2525,
    2527,
    2529,
    2544,
    2545,
    2565,
    2570,
    2575,
    2576,
    2579,
    2600,
    2602,
    2608,
    2610,
    2611,
    2613,
    2614,
    2616,
    2617,
    2649,
    2652,
    2654,
    2654,
    2674,
    2676,
    2693,
    2701,
    2703,
    2705,
    2707,
    2728,
    2730,
    2736,
    2738,
    2739,
    2741,
    2745,
    2749,
    2749,
    2768,
    2768,
    2784,
    2785,
    2821,
    2828,
    2831,
    2832,
    2835,
    2856,
    2858,
    2864,
    2866,
    2867,
    2869,
    2873,
    2877,
    2877,
    2908,
    2909,
    2911,
    2913,
    2929,
    2929,
    2947,
    2947,
    2949,
    2954,
    2958,
    2960,
    2962,
    2965,
    2969,
    2970,
    2972,
    2972,
    2974,
    2975,
    2979,
    2980,
    2984,
    2986,
    2990,
    3001,
    3077,
    3084,
    3086,
    3088,
    3090,
    3112,
    3114,
    3123,
    3125,
    3129,
    3168,
    3169,
    3205,
    3212,
    3214,
    3216,
    3218,
    3240,
    3242,
    3251,
    3253,
    3257,
    3261,
    3261,
    3294,
    3294,
    3296,
    3297,
    3333,
    3340,
    3342,
    3344,
    3346,
    3368,
    3370,
    3385,
    3424,
    3425,
    3461,
    3478,
    3482,
    3505,
    3507,
    3515,
    3517,
    3517,
    3520,
    3526,
    3585,
    3632,
    3634,
    3635,
    3648,
    3654,
    3713,
    3714,
    3716,
    3716,
    3719,
    3720,
    3722,
    3722,
    3725,
    3725,
    3732,
    3735,
    3737,
    3743,
    3745,
    3747,
    3749,
    3749,
    3751,
    3751,
    3754,
    3755,
    3757,
    3760,
    3762,
    3763,
    3773,
    3773,
    3776,
    3780,
    3782,
    3782,
    3804,
    3805,
    3840,
    3840,
    3904,
    3911,
    3913,
    3946,
    3976,
    3979,
    4096,
    4129,
    4131,
    4135,
    4137,
    4138,
    4176,
    4181,
    4256,
    4293,
    4304,
    4346,
    4348,
    4348,
    4352,
    4441,
    4447,
    4514,
    4520,
    4601,
    4608,
    4680,
    4682,
    4685,
    4688,
    4694,
    4696,
    4696,
    4698,
    4701,
    4704,
    4744,
    4746,
    4749,
    4752,
    4784,
    4786,
    4789,
    4792,
    4798,
    4800,
    4800,
    4802,
    4805,
    4808,
    4822,
    4824,
    4880,
    4882,
    4885,
    4888,
    4954,
    4992,
    5007,
    5024,
    5108,
    5121,
    5740,
    5743,
    5750,
    5761,
    5786,
    5792,
    5866,
    5870,
    5872,
    5888,
    5900,
    5902,
    5905,
    5920,
    5937,
    5952,
    5969,
    5984,
    5996,
    5998,
    6e3,
    6016,
    6067,
    6103,
    6103,
    6108,
    6108,
    6176,
    6263,
    6272,
    6312,
    6400,
    6428,
    6480,
    6509,
    6512,
    6516,
    6528,
    6569,
    6593,
    6599,
    6656,
    6678,
    7424,
    7615,
    7680,
    7835,
    7840,
    7929,
    7936,
    7957,
    7960,
    7965,
    7968,
    8005,
    8008,
    8013,
    8016,
    8023,
    8025,
    8025,
    8027,
    8027,
    8029,
    8029,
    8031,
    8061,
    8064,
    8116,
    8118,
    8124,
    8126,
    8126,
    8130,
    8132,
    8134,
    8140,
    8144,
    8147,
    8150,
    8155,
    8160,
    8172,
    8178,
    8180,
    8182,
    8188,
    8305,
    8305,
    8319,
    8319,
    8336,
    8340,
    8450,
    8450,
    8455,
    8455,
    8458,
    8467,
    8469,
    8469,
    8472,
    8477,
    8484,
    8484,
    8486,
    8486,
    8488,
    8488,
    8490,
    8497,
    8499,
    8505,
    8508,
    8511,
    8517,
    8521,
    8544,
    8579,
    11264,
    11310,
    11312,
    11358,
    11392,
    11492,
    11520,
    11557,
    11568,
    11621,
    11631,
    11631,
    11648,
    11670,
    11680,
    11686,
    11688,
    11694,
    11696,
    11702,
    11704,
    11710,
    11712,
    11718,
    11720,
    11726,
    11728,
    11734,
    11736,
    11742,
    12293,
    12295,
    12321,
    12329,
    12337,
    12341,
    12344,
    12348,
    12353,
    12438,
    12443,
    12447,
    12449,
    12538,
    12540,
    12543,
    12549,
    12588,
    12593,
    12686,
    12704,
    12727,
    12784,
    12799,
    13312,
    19893,
    19968,
    40891,
    40960,
    42124,
    43008,
    43009,
    43011,
    43013,
    43015,
    43018,
    43020,
    43042,
    44032,
    55203,
    63744,
    64045,
    64048,
    64106,
    64112,
    64217,
    64256,
    64262,
    64275,
    64279,
    64285,
    64285,
    64287,
    64296,
    64298,
    64310,
    64312,
    64316,
    64318,
    64318,
    64320,
    64321,
    64323,
    64324,
    64326,
    64433,
    64467,
    64829,
    64848,
    64911,
    64914,
    64967,
    65008,
    65019,
    65136,
    65140,
    65142,
    65276,
    65313,
    65338,
    65345,
    65370,
    65382,
    65470,
    65474,
    65479,
    65482,
    65487,
    65490,
    65495,
    65498,
    65500,
    892,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    3,
    1,
    0,
    0,
    0,
    0,
    5,
    1,
    0,
    0,
    0,
    0,
    7,
    1,
    0,
    0,
    0,
    0,
    9,
    1,
    0,
    0,
    0,
    0,
    11,
    1,
    0,
    0,
    0,
    0,
    13,
    1,
    0,
    0,
    0,
    0,
    15,
    1,
    0,
    0,
    0,
    0,
    17,
    1,
    0,
    0,
    0,
    0,
    19,
    1,
    0,
    0,
    0,
    0,
    21,
    1,
    0,
    0,
    0,
    0,
    23,
    1,
    0,
    0,
    0,
    0,
    25,
    1,
    0,
    0,
    0,
    0,
    27,
    1,
    0,
    0,
    0,
    0,
    29,
    1,
    0,
    0,
    0,
    0,
    31,
    1,
    0,
    0,
    0,
    0,
    33,
    1,
    0,
    0,
    0,
    0,
    35,
    1,
    0,
    0,
    0,
    0,
    37,
    1,
    0,
    0,
    0,
    0,
    39,
    1,
    0,
    0,
    0,
    0,
    41,
    1,
    0,
    0,
    0,
    0,
    43,
    1,
    0,
    0,
    0,
    0,
    45,
    1,
    0,
    0,
    0,
    0,
    47,
    1,
    0,
    0,
    0,
    0,
    49,
    1,
    0,
    0,
    0,
    0,
    51,
    1,
    0,
    0,
    0,
    0,
    53,
    1,
    0,
    0,
    0,
    0,
    55,
    1,
    0,
    0,
    0,
    0,
    57,
    1,
    0,
    0,
    0,
    0,
    59,
    1,
    0,
    0,
    0,
    0,
    61,
    1,
    0,
    0,
    0,
    0,
    63,
    1,
    0,
    0,
    0,
    0,
    65,
    1,
    0,
    0,
    0,
    0,
    67,
    1,
    0,
    0,
    0,
    0,
    69,
    1,
    0,
    0,
    0,
    0,
    71,
    1,
    0,
    0,
    0,
    0,
    73,
    1,
    0,
    0,
    0,
    0,
    75,
    1,
    0,
    0,
    0,
    0,
    77,
    1,
    0,
    0,
    0,
    0,
    79,
    1,
    0,
    0,
    0,
    0,
    81,
    1,
    0,
    0,
    0,
    0,
    83,
    1,
    0,
    0,
    0,
    0,
    85,
    1,
    0,
    0,
    0,
    0,
    87,
    1,
    0,
    0,
    0,
    0,
    89,
    1,
    0,
    0,
    0,
    0,
    91,
    1,
    0,
    0,
    0,
    0,
    93,
    1,
    0,
    0,
    0,
    0,
    95,
    1,
    0,
    0,
    0,
    0,
    97,
    1,
    0,
    0,
    0,
    0,
    99,
    1,
    0,
    0,
    0,
    0,
    101,
    1,
    0,
    0,
    0,
    0,
    103,
    1,
    0,
    0,
    0,
    0,
    105,
    1,
    0,
    0,
    0,
    0,
    107,
    1,
    0,
    0,
    0,
    0,
    109,
    1,
    0,
    0,
    0,
    0,
    111,
    1,
    0,
    0,
    0,
    0,
    113,
    1,
    0,
    0,
    0,
    0,
    115,
    1,
    0,
    0,
    0,
    0,
    117,
    1,
    0,
    0,
    0,
    0,
    119,
    1,
    0,
    0,
    0,
    0,
    121,
    1,
    0,
    0,
    0,
    0,
    123,
    1,
    0,
    0,
    0,
    0,
    125,
    1,
    0,
    0,
    0,
    0,
    127,
    1,
    0,
    0,
    0,
    0,
    129,
    1,
    0,
    0,
    0,
    0,
    131,
    1,
    0,
    0,
    0,
    0,
    133,
    1,
    0,
    0,
    0,
    0,
    135,
    1,
    0,
    0,
    0,
    0,
    137,
    1,
    0,
    0,
    0,
    0,
    139,
    1,
    0,
    0,
    0,
    0,
    141,
    1,
    0,
    0,
    0,
    0,
    143,
    1,
    0,
    0,
    0,
    0,
    145,
    1,
    0,
    0,
    0,
    0,
    147,
    1,
    0,
    0,
    0,
    0,
    149,
    1,
    0,
    0,
    0,
    0,
    151,
    1,
    0,
    0,
    0,
    0,
    153,
    1,
    0,
    0,
    0,
    0,
    155,
    1,
    0,
    0,
    0,
    0,
    157,
    1,
    0,
    0,
    0,
    0,
    159,
    1,
    0,
    0,
    0,
    0,
    161,
    1,
    0,
    0,
    0,
    0,
    163,
    1,
    0,
    0,
    0,
    0,
    165,
    1,
    0,
    0,
    0,
    0,
    167,
    1,
    0,
    0,
    0,
    0,
    169,
    1,
    0,
    0,
    0,
    0,
    171,
    1,
    0,
    0,
    0,
    0,
    173,
    1,
    0,
    0,
    0,
    0,
    175,
    1,
    0,
    0,
    0,
    0,
    177,
    1,
    0,
    0,
    0,
    0,
    179,
    1,
    0,
    0,
    0,
    0,
    181,
    1,
    0,
    0,
    0,
    0,
    183,
    1,
    0,
    0,
    0,
    0,
    185,
    1,
    0,
    0,
    0,
    0,
    187,
    1,
    0,
    0,
    0,
    0,
    189,
    1,
    0,
    0,
    0,
    0,
    191,
    1,
    0,
    0,
    0,
    0,
    193,
    1,
    0,
    0,
    0,
    1,
    225,
    1,
    0,
    0,
    0,
    3,
    229,
    1,
    0,
    0,
    0,
    5,
    236,
    1,
    0,
    0,
    0,
    7,
    242,
    1,
    0,
    0,
    0,
    9,
    247,
    1,
    0,
    0,
    0,
    11,
    254,
    1,
    0,
    0,
    0,
    13,
    263,
    1,
    0,
    0,
    0,
    15,
    266,
    1,
    0,
    0,
    0,
    17,
    273,
    1,
    0,
    0,
    0,
    19,
    280,
    1,
    0,
    0,
    0,
    21,
    283,
    1,
    0,
    0,
    0,
    23,
    288,
    1,
    0,
    0,
    0,
    25,
    293,
    1,
    0,
    0,
    0,
    27,
    299,
    1,
    0,
    0,
    0,
    29,
    303,
    1,
    0,
    0,
    0,
    31,
    306,
    1,
    0,
    0,
    0,
    33,
    310,
    1,
    0,
    0,
    0,
    35,
    315,
    1,
    0,
    0,
    0,
    37,
    323,
    1,
    0,
    0,
    0,
    39,
    328,
    1,
    0,
    0,
    0,
    41,
    335,
    1,
    0,
    0,
    0,
    43,
    342,
    1,
    0,
    0,
    0,
    45,
    345,
    1,
    0,
    0,
    0,
    47,
    349,
    1,
    0,
    0,
    0,
    49,
    353,
    1,
    0,
    0,
    0,
    51,
    356,
    1,
    0,
    0,
    0,
    53,
    362,
    1,
    0,
    0,
    0,
    55,
    368,
    1,
    0,
    0,
    0,
    57,
    372,
    1,
    0,
    0,
    0,
    59,
    377,
    1,
    0,
    0,
    0,
    61,
    386,
    1,
    0,
    0,
    0,
    63,
    392,
    1,
    0,
    0,
    0,
    65,
    398,
    1,
    0,
    0,
    0,
    67,
    404,
    1,
    0,
    0,
    0,
    69,
    410,
    1,
    0,
    0,
    0,
    71,
    415,
    1,
    0,
    0,
    0,
    73,
    420,
    1,
    0,
    0,
    0,
    75,
    426,
    1,
    0,
    0,
    0,
    77,
    428,
    1,
    0,
    0,
    0,
    79,
    432,
    1,
    0,
    0,
    0,
    81,
    434,
    1,
    0,
    0,
    0,
    83,
    436,
    1,
    0,
    0,
    0,
    85,
    438,
    1,
    0,
    0,
    0,
    87,
    440,
    1,
    0,
    0,
    0,
    89,
    442,
    1,
    0,
    0,
    0,
    91,
    445,
    1,
    0,
    0,
    0,
    93,
    447,
    1,
    0,
    0,
    0,
    95,
    449,
    1,
    0,
    0,
    0,
    97,
    451,
    1,
    0,
    0,
    0,
    99,
    453,
    1,
    0,
    0,
    0,
    101,
    456,
    1,
    0,
    0,
    0,
    103,
    459,
    1,
    0,
    0,
    0,
    105,
    461,
    1,
    0,
    0,
    0,
    107,
    463,
    1,
    0,
    0,
    0,
    109,
    465,
    1,
    0,
    0,
    0,
    111,
    467,
    1,
    0,
    0,
    0,
    113,
    470,
    1,
    0,
    0,
    0,
    115,
    472,
    1,
    0,
    0,
    0,
    117,
    474,
    1,
    0,
    0,
    0,
    119,
    476,
    1,
    0,
    0,
    0,
    121,
    479,
    1,
    0,
    0,
    0,
    123,
    482,
    1,
    0,
    0,
    0,
    125,
    485,
    1,
    0,
    0,
    0,
    127,
    488,
    1,
    0,
    0,
    0,
    129,
    491,
    1,
    0,
    0,
    0,
    131,
    493,
    1,
    0,
    0,
    0,
    133,
    496,
    1,
    0,
    0,
    0,
    135,
    499,
    1,
    0,
    0,
    0,
    137,
    502,
    1,
    0,
    0,
    0,
    139,
    505,
    1,
    0,
    0,
    0,
    141,
    508,
    1,
    0,
    0,
    0,
    143,
    511,
    1,
    0,
    0,
    0,
    145,
    514,
    1,
    0,
    0,
    0,
    147,
    517,
    1,
    0,
    0,
    0,
    149,
    520,
    1,
    0,
    0,
    0,
    151,
    523,
    1,
    0,
    0,
    0,
    153,
    527,
    1,
    0,
    0,
    0,
    155,
    531,
    1,
    0,
    0,
    0,
    157,
    535,
    1,
    0,
    0,
    0,
    159,
    566,
    1,
    0,
    0,
    0,
    161,
    580,
    1,
    0,
    0,
    0,
    163,
    582,
    1,
    0,
    0,
    0,
    165,
    589,
    1,
    0,
    0,
    0,
    167,
    596,
    1,
    0,
    0,
    0,
    169,
    609,
    1,
    0,
    0,
    0,
    171,
    613,
    1,
    0,
    0,
    0,
    173,
    615,
    1,
    0,
    0,
    0,
    175,
    618,
    1,
    0,
    0,
    0,
    177,
    621,
    1,
    0,
    0,
    0,
    179,
    624,
    1,
    0,
    0,
    0,
    181,
    627,
    1,
    0,
    0,
    0,
    183,
    630,
    1,
    0,
    0,
    0,
    185,
    633,
    1,
    0,
    0,
    0,
    187,
    640,
    1,
    0,
    0,
    0,
    189,
    651,
    1,
    0,
    0,
    0,
    191,
    657,
    1,
    0,
    0,
    0,
    193,
    665,
    1,
    0,
    0,
    0,
    195,
    700,
    1,
    0,
    0,
    0,
    197,
    728,
    1,
    0,
    0,
    0,
    199,
    736,
    1,
    0,
    0,
    0,
    201,
    739,
    1,
    0,
    0,
    0,
    203,
    761,
    1,
    0,
    0,
    0,
    205,
    781,
    1,
    0,
    0,
    0,
    207,
    801,
    1,
    0,
    0,
    0,
    209,
    829,
    1,
    0,
    0,
    0,
    211,
    833,
    1,
    0,
    0,
    0,
    213,
    836,
    1,
    0,
    0,
    0,
    215,
    839,
    1,
    0,
    0,
    0,
    217,
    842,
    1,
    0,
    0,
    0,
    219,
    844,
    1,
    0,
    0,
    0,
    221,
    849,
    1,
    0,
    0,
    0,
    223,
    852,
    1,
    0,
    0,
    0,
    225,
    226,
    5,
    100,
    0,
    0,
    226,
    227,
    5,
    101,
    0,
    0,
    227,
    228,
    5,
    102,
    0,
    0,
    228,
    2,
    1,
    0,
    0,
    0,
    229,
    230,
    5,
    114,
    0,
    0,
    230,
    231,
    5,
    101,
    0,
    0,
    231,
    232,
    5,
    116,
    0,
    0,
    232,
    233,
    5,
    117,
    0,
    0,
    233,
    234,
    5,
    114,
    0,
    0,
    234,
    235,
    5,
    110,
    0,
    0,
    235,
    4,
    1,
    0,
    0,
    0,
    236,
    237,
    5,
    114,
    0,
    0,
    237,
    238,
    5,
    97,
    0,
    0,
    238,
    239,
    5,
    105,
    0,
    0,
    239,
    240,
    5,
    115,
    0,
    0,
    240,
    241,
    5,
    101,
    0,
    0,
    241,
    6,
    1,
    0,
    0,
    0,
    242,
    243,
    5,
    102,
    0,
    0,
    243,
    244,
    5,
    114,
    0,
    0,
    244,
    245,
    5,
    111,
    0,
    0,
    245,
    246,
    5,
    109,
    0,
    0,
    246,
    8,
    1,
    0,
    0,
    0,
    247,
    248,
    5,
    105,
    0,
    0,
    248,
    249,
    5,
    109,
    0,
    0,
    249,
    250,
    5,
    112,
    0,
    0,
    250,
    251,
    5,
    111,
    0,
    0,
    251,
    252,
    5,
    114,
    0,
    0,
    252,
    253,
    5,
    116,
    0,
    0,
    253,
    10,
    1,
    0,
    0,
    0,
    254,
    255,
    5,
    110,
    0,
    0,
    255,
    256,
    5,
    111,
    0,
    0,
    256,
    257,
    5,
    110,
    0,
    0,
    257,
    258,
    5,
    108,
    0,
    0,
    258,
    259,
    5,
    111,
    0,
    0,
    259,
    260,
    5,
    99,
    0,
    0,
    260,
    261,
    5,
    97,
    0,
    0,
    261,
    262,
    5,
    108,
    0,
    0,
    262,
    12,
    1,
    0,
    0,
    0,
    263,
    264,
    5,
    97,
    0,
    0,
    264,
    265,
    5,
    115,
    0,
    0,
    265,
    14,
    1,
    0,
    0,
    0,
    266,
    267,
    5,
    103,
    0,
    0,
    267,
    268,
    5,
    108,
    0,
    0,
    268,
    269,
    5,
    111,
    0,
    0,
    269,
    270,
    5,
    98,
    0,
    0,
    270,
    271,
    5,
    97,
    0,
    0,
    271,
    272,
    5,
    108,
    0,
    0,
    272,
    16,
    1,
    0,
    0,
    0,
    273,
    274,
    5,
    97,
    0,
    0,
    274,
    275,
    5,
    115,
    0,
    0,
    275,
    276,
    5,
    115,
    0,
    0,
    276,
    277,
    5,
    101,
    0,
    0,
    277,
    278,
    5,
    114,
    0,
    0,
    278,
    279,
    5,
    116,
    0,
    0,
    279,
    18,
    1,
    0,
    0,
    0,
    280,
    281,
    5,
    105,
    0,
    0,
    281,
    282,
    5,
    102,
    0,
    0,
    282,
    20,
    1,
    0,
    0,
    0,
    283,
    284,
    5,
    101,
    0,
    0,
    284,
    285,
    5,
    108,
    0,
    0,
    285,
    286,
    5,
    105,
    0,
    0,
    286,
    287,
    5,
    102,
    0,
    0,
    287,
    22,
    1,
    0,
    0,
    0,
    288,
    289,
    5,
    101,
    0,
    0,
    289,
    290,
    5,
    108,
    0,
    0,
    290,
    291,
    5,
    115,
    0,
    0,
    291,
    292,
    5,
    101,
    0,
    0,
    292,
    24,
    1,
    0,
    0,
    0,
    293,
    294,
    5,
    119,
    0,
    0,
    294,
    295,
    5,
    104,
    0,
    0,
    295,
    296,
    5,
    105,
    0,
    0,
    296,
    297,
    5,
    108,
    0,
    0,
    297,
    298,
    5,
    101,
    0,
    0,
    298,
    26,
    1,
    0,
    0,
    0,
    299,
    300,
    5,
    102,
    0,
    0,
    300,
    301,
    5,
    111,
    0,
    0,
    301,
    302,
    5,
    114,
    0,
    0,
    302,
    28,
    1,
    0,
    0,
    0,
    303,
    304,
    5,
    105,
    0,
    0,
    304,
    305,
    5,
    110,
    0,
    0,
    305,
    30,
    1,
    0,
    0,
    0,
    306,
    307,
    5,
    116,
    0,
    0,
    307,
    308,
    5,
    114,
    0,
    0,
    308,
    309,
    5,
    121,
    0,
    0,
    309,
    32,
    1,
    0,
    0,
    0,
    310,
    311,
    5,
    78,
    0,
    0,
    311,
    312,
    5,
    111,
    0,
    0,
    312,
    313,
    5,
    110,
    0,
    0,
    313,
    314,
    5,
    101,
    0,
    0,
    314,
    34,
    1,
    0,
    0,
    0,
    315,
    316,
    5,
    102,
    0,
    0,
    316,
    317,
    5,
    105,
    0,
    0,
    317,
    318,
    5,
    110,
    0,
    0,
    318,
    319,
    5,
    97,
    0,
    0,
    319,
    320,
    5,
    108,
    0,
    0,
    320,
    321,
    5,
    108,
    0,
    0,
    321,
    322,
    5,
    121,
    0,
    0,
    322,
    36,
    1,
    0,
    0,
    0,
    323,
    324,
    5,
    119,
    0,
    0,
    324,
    325,
    5,
    105,
    0,
    0,
    325,
    326,
    5,
    116,
    0,
    0,
    326,
    327,
    5,
    104,
    0,
    0,
    327,
    38,
    1,
    0,
    0,
    0,
    328,
    329,
    5,
    101,
    0,
    0,
    329,
    330,
    5,
    120,
    0,
    0,
    330,
    331,
    5,
    99,
    0,
    0,
    331,
    332,
    5,
    101,
    0,
    0,
    332,
    333,
    5,
    112,
    0,
    0,
    333,
    334,
    5,
    116,
    0,
    0,
    334,
    40,
    1,
    0,
    0,
    0,
    335,
    336,
    5,
    108,
    0,
    0,
    336,
    337,
    5,
    97,
    0,
    0,
    337,
    338,
    5,
    109,
    0,
    0,
    338,
    339,
    5,
    98,
    0,
    0,
    339,
    340,
    5,
    100,
    0,
    0,
    340,
    341,
    5,
    97,
    0,
    0,
    341,
    42,
    1,
    0,
    0,
    0,
    342,
    343,
    5,
    111,
    0,
    0,
    343,
    344,
    5,
    114,
    0,
    0,
    344,
    44,
    1,
    0,
    0,
    0,
    345,
    346,
    5,
    97,
    0,
    0,
    346,
    347,
    5,
    110,
    0,
    0,
    347,
    348,
    5,
    100,
    0,
    0,
    348,
    46,
    1,
    0,
    0,
    0,
    349,
    350,
    5,
    110,
    0,
    0,
    350,
    351,
    5,
    111,
    0,
    0,
    351,
    352,
    5,
    116,
    0,
    0,
    352,
    48,
    1,
    0,
    0,
    0,
    353,
    354,
    5,
    105,
    0,
    0,
    354,
    355,
    5,
    115,
    0,
    0,
    355,
    50,
    1,
    0,
    0,
    0,
    356,
    357,
    5,
    99,
    0,
    0,
    357,
    358,
    5,
    108,
    0,
    0,
    358,
    359,
    5,
    97,
    0,
    0,
    359,
    360,
    5,
    115,
    0,
    0,
    360,
    361,
    5,
    115,
    0,
    0,
    361,
    52,
    1,
    0,
    0,
    0,
    362,
    363,
    5,
    121,
    0,
    0,
    363,
    364,
    5,
    105,
    0,
    0,
    364,
    365,
    5,
    101,
    0,
    0,
    365,
    366,
    5,
    108,
    0,
    0,
    366,
    367,
    5,
    100,
    0,
    0,
    367,
    54,
    1,
    0,
    0,
    0,
    368,
    369,
    5,
    100,
    0,
    0,
    369,
    370,
    5,
    101,
    0,
    0,
    370,
    371,
    5,
    108,
    0,
    0,
    371,
    56,
    1,
    0,
    0,
    0,
    372,
    373,
    5,
    112,
    0,
    0,
    373,
    374,
    5,
    97,
    0,
    0,
    374,
    375,
    5,
    115,
    0,
    0,
    375,
    376,
    5,
    115,
    0,
    0,
    376,
    58,
    1,
    0,
    0,
    0,
    377,
    378,
    5,
    99,
    0,
    0,
    378,
    379,
    5,
    111,
    0,
    0,
    379,
    380,
    5,
    110,
    0,
    0,
    380,
    381,
    5,
    116,
    0,
    0,
    381,
    382,
    5,
    105,
    0,
    0,
    382,
    383,
    5,
    110,
    0,
    0,
    383,
    384,
    5,
    117,
    0,
    0,
    384,
    385,
    5,
    101,
    0,
    0,
    385,
    60,
    1,
    0,
    0,
    0,
    386,
    387,
    5,
    98,
    0,
    0,
    387,
    388,
    5,
    114,
    0,
    0,
    388,
    389,
    5,
    101,
    0,
    0,
    389,
    390,
    5,
    97,
    0,
    0,
    390,
    391,
    5,
    107,
    0,
    0,
    391,
    62,
    1,
    0,
    0,
    0,
    392,
    393,
    5,
    97,
    0,
    0,
    393,
    394,
    5,
    115,
    0,
    0,
    394,
    395,
    5,
    121,
    0,
    0,
    395,
    396,
    5,
    110,
    0,
    0,
    396,
    397,
    5,
    99,
    0,
    0,
    397,
    64,
    1,
    0,
    0,
    0,
    398,
    399,
    5,
    97,
    0,
    0,
    399,
    400,
    5,
    119,
    0,
    0,
    400,
    401,
    5,
    97,
    0,
    0,
    401,
    402,
    5,
    105,
    0,
    0,
    402,
    403,
    5,
    116,
    0,
    0,
    403,
    66,
    1,
    0,
    0,
    0,
    404,
    405,
    5,
    112,
    0,
    0,
    405,
    406,
    5,
    114,
    0,
    0,
    406,
    407,
    5,
    105,
    0,
    0,
    407,
    408,
    5,
    110,
    0,
    0,
    408,
    409,
    5,
    116,
    0,
    0,
    409,
    68,
    1,
    0,
    0,
    0,
    410,
    411,
    5,
    101,
    0,
    0,
    411,
    412,
    5,
    120,
    0,
    0,
    412,
    413,
    5,
    101,
    0,
    0,
    413,
    414,
    5,
    99,
    0,
    0,
    414,
    70,
    1,
    0,
    0,
    0,
    415,
    416,
    5,
    84,
    0,
    0,
    416,
    417,
    5,
    114,
    0,
    0,
    417,
    418,
    5,
    117,
    0,
    0,
    418,
    419,
    5,
    101,
    0,
    0,
    419,
    72,
    1,
    0,
    0,
    0,
    420,
    421,
    5,
    70,
    0,
    0,
    421,
    422,
    5,
    97,
    0,
    0,
    422,
    423,
    5,
    108,
    0,
    0,
    423,
    424,
    5,
    115,
    0,
    0,
    424,
    425,
    5,
    101,
    0,
    0,
    425,
    74,
    1,
    0,
    0,
    0,
    426,
    427,
    5,
    46,
    0,
    0,
    427,
    76,
    1,
    0,
    0,
    0,
    428,
    429,
    5,
    46,
    0,
    0,
    429,
    430,
    5,
    46,
    0,
    0,
    430,
    431,
    5,
    46,
    0,
    0,
    431,
    78,
    1,
    0,
    0,
    0,
    432,
    433,
    5,
    96,
    0,
    0,
    433,
    80,
    1,
    0,
    0,
    0,
    434,
    435,
    5,
    42,
    0,
    0,
    435,
    82,
    1,
    0,
    0,
    0,
    436,
    437,
    5,
    44,
    0,
    0,
    437,
    84,
    1,
    0,
    0,
    0,
    438,
    439,
    5,
    58,
    0,
    0,
    439,
    86,
    1,
    0,
    0,
    0,
    440,
    441,
    5,
    59,
    0,
    0,
    441,
    88,
    1,
    0,
    0,
    0,
    442,
    443,
    5,
    42,
    0,
    0,
    443,
    444,
    5,
    42,
    0,
    0,
    444,
    90,
    1,
    0,
    0,
    0,
    445,
    446,
    5,
    61,
    0,
    0,
    446,
    92,
    1,
    0,
    0,
    0,
    447,
    448,
    5,
    124,
    0,
    0,
    448,
    94,
    1,
    0,
    0,
    0,
    449,
    450,
    5,
    94,
    0,
    0,
    450,
    96,
    1,
    0,
    0,
    0,
    451,
    452,
    5,
    38,
    0,
    0,
    452,
    98,
    1,
    0,
    0,
    0,
    453,
    454,
    5,
    60,
    0,
    0,
    454,
    455,
    5,
    60,
    0,
    0,
    455,
    100,
    1,
    0,
    0,
    0,
    456,
    457,
    5,
    62,
    0,
    0,
    457,
    458,
    5,
    62,
    0,
    0,
    458,
    102,
    1,
    0,
    0,
    0,
    459,
    460,
    5,
    43,
    0,
    0,
    460,
    104,
    1,
    0,
    0,
    0,
    461,
    462,
    5,
    45,
    0,
    0,
    462,
    106,
    1,
    0,
    0,
    0,
    463,
    464,
    5,
    47,
    0,
    0,
    464,
    108,
    1,
    0,
    0,
    0,
    465,
    466,
    5,
    37,
    0,
    0,
    466,
    110,
    1,
    0,
    0,
    0,
    467,
    468,
    5,
    47,
    0,
    0,
    468,
    469,
    5,
    47,
    0,
    0,
    469,
    112,
    1,
    0,
    0,
    0,
    470,
    471,
    5,
    126,
    0,
    0,
    471,
    114,
    1,
    0,
    0,
    0,
    472,
    473,
    5,
    60,
    0,
    0,
    473,
    116,
    1,
    0,
    0,
    0,
    474,
    475,
    5,
    62,
    0,
    0,
    475,
    118,
    1,
    0,
    0,
    0,
    476,
    477,
    5,
    61,
    0,
    0,
    477,
    478,
    5,
    61,
    0,
    0,
    478,
    120,
    1,
    0,
    0,
    0,
    479,
    480,
    5,
    62,
    0,
    0,
    480,
    481,
    5,
    61,
    0,
    0,
    481,
    122,
    1,
    0,
    0,
    0,
    482,
    483,
    5,
    60,
    0,
    0,
    483,
    484,
    5,
    61,
    0,
    0,
    484,
    124,
    1,
    0,
    0,
    0,
    485,
    486,
    5,
    60,
    0,
    0,
    486,
    487,
    5,
    62,
    0,
    0,
    487,
    126,
    1,
    0,
    0,
    0,
    488,
    489,
    5,
    33,
    0,
    0,
    489,
    490,
    5,
    61,
    0,
    0,
    490,
    128,
    1,
    0,
    0,
    0,
    491,
    492,
    5,
    64,
    0,
    0,
    492,
    130,
    1,
    0,
    0,
    0,
    493,
    494,
    5,
    45,
    0,
    0,
    494,
    495,
    5,
    62,
    0,
    0,
    495,
    132,
    1,
    0,
    0,
    0,
    496,
    497,
    5,
    43,
    0,
    0,
    497,
    498,
    5,
    61,
    0,
    0,
    498,
    134,
    1,
    0,
    0,
    0,
    499,
    500,
    5,
    45,
    0,
    0,
    500,
    501,
    5,
    61,
    0,
    0,
    501,
    136,
    1,
    0,
    0,
    0,
    502,
    503,
    5,
    42,
    0,
    0,
    503,
    504,
    5,
    61,
    0,
    0,
    504,
    138,
    1,
    0,
    0,
    0,
    505,
    506,
    5,
    64,
    0,
    0,
    506,
    507,
    5,
    61,
    0,
    0,
    507,
    140,
    1,
    0,
    0,
    0,
    508,
    509,
    5,
    47,
    0,
    0,
    509,
    510,
    5,
    61,
    0,
    0,
    510,
    142,
    1,
    0,
    0,
    0,
    511,
    512,
    5,
    37,
    0,
    0,
    512,
    513,
    5,
    61,
    0,
    0,
    513,
    144,
    1,
    0,
    0,
    0,
    514,
    515,
    5,
    38,
    0,
    0,
    515,
    516,
    5,
    61,
    0,
    0,
    516,
    146,
    1,
    0,
    0,
    0,
    517,
    518,
    5,
    124,
    0,
    0,
    518,
    519,
    5,
    61,
    0,
    0,
    519,
    148,
    1,
    0,
    0,
    0,
    520,
    521,
    5,
    94,
    0,
    0,
    521,
    522,
    5,
    61,
    0,
    0,
    522,
    150,
    1,
    0,
    0,
    0,
    523,
    524,
    5,
    60,
    0,
    0,
    524,
    525,
    5,
    60,
    0,
    0,
    525,
    526,
    5,
    61,
    0,
    0,
    526,
    152,
    1,
    0,
    0,
    0,
    527,
    528,
    5,
    62,
    0,
    0,
    528,
    529,
    5,
    62,
    0,
    0,
    529,
    530,
    5,
    61,
    0,
    0,
    530,
    154,
    1,
    0,
    0,
    0,
    531,
    532,
    5,
    42,
    0,
    0,
    532,
    533,
    5,
    42,
    0,
    0,
    533,
    534,
    5,
    61,
    0,
    0,
    534,
    156,
    1,
    0,
    0,
    0,
    535,
    536,
    5,
    47,
    0,
    0,
    536,
    537,
    5,
    47,
    0,
    0,
    537,
    538,
    5,
    61,
    0,
    0,
    538,
    158,
    1,
    0,
    0,
    0,
    539,
    549,
    7,
    0,
    0,
    0,
    540,
    542,
    7,
    1,
    0,
    0,
    541,
    543,
    7,
    2,
    0,
    0,
    542,
    541,
    1,
    0,
    0,
    0,
    542,
    543,
    1,
    0,
    0,
    0,
    543,
    549,
    1,
    0,
    0,
    0,
    544,
    546,
    7,
    2,
    0,
    0,
    545,
    547,
    7,
    1,
    0,
    0,
    546,
    545,
    1,
    0,
    0,
    0,
    546,
    547,
    1,
    0,
    0,
    0,
    547,
    549,
    1,
    0,
    0,
    0,
    548,
    539,
    1,
    0,
    0,
    0,
    548,
    540,
    1,
    0,
    0,
    0,
    548,
    544,
    1,
    0,
    0,
    0,
    548,
    549,
    1,
    0,
    0,
    0,
    549,
    552,
    1,
    0,
    0,
    0,
    550,
    553,
    3,
    195,
    97,
    0,
    551,
    553,
    3,
    197,
    98,
    0,
    552,
    550,
    1,
    0,
    0,
    0,
    552,
    551,
    1,
    0,
    0,
    0,
    553,
    567,
    1,
    0,
    0,
    0,
    554,
    556,
    7,
    3,
    0,
    0,
    555,
    557,
    7,
    2,
    0,
    0,
    556,
    555,
    1,
    0,
    0,
    0,
    556,
    557,
    1,
    0,
    0,
    0,
    557,
    561,
    1,
    0,
    0,
    0,
    558,
    559,
    7,
    2,
    0,
    0,
    559,
    561,
    7,
    3,
    0,
    0,
    560,
    554,
    1,
    0,
    0,
    0,
    560,
    558,
    1,
    0,
    0,
    0,
    561,
    564,
    1,
    0,
    0,
    0,
    562,
    565,
    3,
    207,
    103,
    0,
    563,
    565,
    3,
    209,
    104,
    0,
    564,
    562,
    1,
    0,
    0,
    0,
    564,
    563,
    1,
    0,
    0,
    0,
    565,
    567,
    1,
    0,
    0,
    0,
    566,
    548,
    1,
    0,
    0,
    0,
    566,
    560,
    1,
    0,
    0,
    0,
    567,
    160,
    1,
    0,
    0,
    0,
    568,
    572,
    7,
    4,
    0,
    0,
    569,
    571,
    7,
    5,
    0,
    0,
    570,
    569,
    1,
    0,
    0,
    0,
    571,
    574,
    1,
    0,
    0,
    0,
    572,
    570,
    1,
    0,
    0,
    0,
    572,
    573,
    1,
    0,
    0,
    0,
    573,
    581,
    1,
    0,
    0,
    0,
    574,
    572,
    1,
    0,
    0,
    0,
    575,
    577,
    5,
    48,
    0,
    0,
    576,
    575,
    1,
    0,
    0,
    0,
    577,
    578,
    1,
    0,
    0,
    0,
    578,
    576,
    1,
    0,
    0,
    0,
    578,
    579,
    1,
    0,
    0,
    0,
    579,
    581,
    1,
    0,
    0,
    0,
    580,
    568,
    1,
    0,
    0,
    0,
    580,
    576,
    1,
    0,
    0,
    0,
    581,
    162,
    1,
    0,
    0,
    0,
    582,
    583,
    5,
    48,
    0,
    0,
    583,
    585,
    7,
    6,
    0,
    0,
    584,
    586,
    7,
    7,
    0,
    0,
    585,
    584,
    1,
    0,
    0,
    0,
    586,
    587,
    1,
    0,
    0,
    0,
    587,
    585,
    1,
    0,
    0,
    0,
    587,
    588,
    1,
    0,
    0,
    0,
    588,
    164,
    1,
    0,
    0,
    0,
    589,
    590,
    5,
    48,
    0,
    0,
    590,
    592,
    7,
    8,
    0,
    0,
    591,
    593,
    7,
    9,
    0,
    0,
    592,
    591,
    1,
    0,
    0,
    0,
    593,
    594,
    1,
    0,
    0,
    0,
    594,
    592,
    1,
    0,
    0,
    0,
    594,
    595,
    1,
    0,
    0,
    0,
    595,
    166,
    1,
    0,
    0,
    0,
    596,
    597,
    5,
    48,
    0,
    0,
    597,
    599,
    7,
    3,
    0,
    0,
    598,
    600,
    7,
    10,
    0,
    0,
    599,
    598,
    1,
    0,
    0,
    0,
    600,
    601,
    1,
    0,
    0,
    0,
    601,
    599,
    1,
    0,
    0,
    0,
    601,
    602,
    1,
    0,
    0,
    0,
    602,
    168,
    1,
    0,
    0,
    0,
    603,
    610,
    3,
    203,
    101,
    0,
    604,
    606,
    7,
    5,
    0,
    0,
    605,
    604,
    1,
    0,
    0,
    0,
    606,
    607,
    1,
    0,
    0,
    0,
    607,
    605,
    1,
    0,
    0,
    0,
    607,
    608,
    1,
    0,
    0,
    0,
    608,
    610,
    1,
    0,
    0,
    0,
    609,
    603,
    1,
    0,
    0,
    0,
    609,
    605,
    1,
    0,
    0,
    0,
    610,
    611,
    1,
    0,
    0,
    0,
    611,
    612,
    7,
    11,
    0,
    0,
    612,
    170,
    1,
    0,
    0,
    0,
    613,
    614,
    3,
    203,
    101,
    0,
    614,
    172,
    1,
    0,
    0,
    0,
    615,
    616,
    5,
    40,
    0,
    0,
    616,
    617,
    6,
    86,
    0,
    0,
    617,
    174,
    1,
    0,
    0,
    0,
    618,
    619,
    5,
    41,
    0,
    0,
    619,
    620,
    6,
    87,
    1,
    0,
    620,
    176,
    1,
    0,
    0,
    0,
    621,
    622,
    5,
    123,
    0,
    0,
    622,
    623,
    6,
    88,
    2,
    0,
    623,
    178,
    1,
    0,
    0,
    0,
    624,
    625,
    5,
    125,
    0,
    0,
    625,
    626,
    6,
    89,
    3,
    0,
    626,
    180,
    1,
    0,
    0,
    0,
    627,
    628,
    5,
    91,
    0,
    0,
    628,
    629,
    6,
    90,
    4,
    0,
    629,
    182,
    1,
    0,
    0,
    0,
    630,
    631,
    5,
    93,
    0,
    0,
    631,
    632,
    6,
    91,
    5,
    0,
    632,
    184,
    1,
    0,
    0,
    0,
    633,
    637,
    3,
    223,
    111,
    0,
    634,
    636,
    3,
    221,
    110,
    0,
    635,
    634,
    1,
    0,
    0,
    0,
    636,
    639,
    1,
    0,
    0,
    0,
    637,
    635,
    1,
    0,
    0,
    0,
    637,
    638,
    1,
    0,
    0,
    0,
    638,
    186,
    1,
    0,
    0,
    0,
    639,
    637,
    1,
    0,
    0,
    0,
    640,
    644,
    5,
    92,
    0,
    0,
    641,
    643,
    7,
    12,
    0,
    0,
    642,
    641,
    1,
    0,
    0,
    0,
    643,
    646,
    1,
    0,
    0,
    0,
    644,
    642,
    1,
    0,
    0,
    0,
    644,
    645,
    1,
    0,
    0,
    0,
    645,
    647,
    1,
    0,
    0,
    0,
    646,
    644,
    1,
    0,
    0,
    0,
    647,
    648,
    3,
    201,
    100,
    0,
    648,
    649,
    1,
    0,
    0,
    0,
    649,
    650,
    6,
    93,
    6,
    0,
    650,
    188,
    1,
    0,
    0,
    0,
    651,
    652,
    3,
    201,
    100,
    0,
    652,
    653,
    6,
    94,
    7,
    0,
    653,
    654,
    1,
    0,
    0,
    0,
    654,
    655,
    6,
    94,
    6,
    0,
    655,
    190,
    1,
    0,
    0,
    0,
    656,
    658,
    7,
    12,
    0,
    0,
    657,
    656,
    1,
    0,
    0,
    0,
    658,
    659,
    1,
    0,
    0,
    0,
    659,
    657,
    1,
    0,
    0,
    0,
    659,
    660,
    1,
    0,
    0,
    0,
    660,
    661,
    1,
    0,
    0,
    0,
    661,
    662,
    6,
    95,
    8,
    0,
    662,
    663,
    1,
    0,
    0,
    0,
    663,
    664,
    6,
    95,
    6,
    0,
    664,
    192,
    1,
    0,
    0,
    0,
    665,
    669,
    5,
    35,
    0,
    0,
    666,
    668,
    8,
    13,
    0,
    0,
    667,
    666,
    1,
    0,
    0,
    0,
    668,
    671,
    1,
    0,
    0,
    0,
    669,
    667,
    1,
    0,
    0,
    0,
    669,
    670,
    1,
    0,
    0,
    0,
    670,
    672,
    1,
    0,
    0,
    0,
    671,
    669,
    1,
    0,
    0,
    0,
    672,
    673,
    6,
    96,
    6,
    0,
    673,
    194,
    1,
    0,
    0,
    0,
    674,
    683,
    5,
    39,
    0,
    0,
    675,
    678,
    5,
    92,
    0,
    0,
    676,
    679,
    3,
    201,
    100,
    0,
    677,
    679,
    9,
    0,
    0,
    0,
    678,
    676,
    1,
    0,
    0,
    0,
    678,
    677,
    1,
    0,
    0,
    0,
    679,
    682,
    1,
    0,
    0,
    0,
    680,
    682,
    8,
    14,
    0,
    0,
    681,
    675,
    1,
    0,
    0,
    0,
    681,
    680,
    1,
    0,
    0,
    0,
    682,
    685,
    1,
    0,
    0,
    0,
    683,
    681,
    1,
    0,
    0,
    0,
    683,
    684,
    1,
    0,
    0,
    0,
    684,
    686,
    1,
    0,
    0,
    0,
    685,
    683,
    1,
    0,
    0,
    0,
    686,
    701,
    5,
    39,
    0,
    0,
    687,
    696,
    5,
    34,
    0,
    0,
    688,
    691,
    5,
    92,
    0,
    0,
    689,
    692,
    3,
    201,
    100,
    0,
    690,
    692,
    9,
    0,
    0,
    0,
    691,
    689,
    1,
    0,
    0,
    0,
    691,
    690,
    1,
    0,
    0,
    0,
    692,
    695,
    1,
    0,
    0,
    0,
    693,
    695,
    8,
    15,
    0,
    0,
    694,
    688,
    1,
    0,
    0,
    0,
    694,
    693,
    1,
    0,
    0,
    0,
    695,
    698,
    1,
    0,
    0,
    0,
    696,
    694,
    1,
    0,
    0,
    0,
    696,
    697,
    1,
    0,
    0,
    0,
    697,
    699,
    1,
    0,
    0,
    0,
    698,
    696,
    1,
    0,
    0,
    0,
    699,
    701,
    5,
    34,
    0,
    0,
    700,
    674,
    1,
    0,
    0,
    0,
    700,
    687,
    1,
    0,
    0,
    0,
    701,
    196,
    1,
    0,
    0,
    0,
    702,
    703,
    5,
    39,
    0,
    0,
    703,
    704,
    5,
    39,
    0,
    0,
    704,
    705,
    5,
    39,
    0,
    0,
    705,
    709,
    1,
    0,
    0,
    0,
    706,
    708,
    3,
    199,
    99,
    0,
    707,
    706,
    1,
    0,
    0,
    0,
    708,
    711,
    1,
    0,
    0,
    0,
    709,
    710,
    1,
    0,
    0,
    0,
    709,
    707,
    1,
    0,
    0,
    0,
    710,
    712,
    1,
    0,
    0,
    0,
    711,
    709,
    1,
    0,
    0,
    0,
    712,
    713,
    5,
    39,
    0,
    0,
    713,
    714,
    5,
    39,
    0,
    0,
    714,
    729,
    5,
    39,
    0,
    0,
    715,
    716,
    5,
    34,
    0,
    0,
    716,
    717,
    5,
    34,
    0,
    0,
    717,
    718,
    5,
    34,
    0,
    0,
    718,
    722,
    1,
    0,
    0,
    0,
    719,
    721,
    3,
    199,
    99,
    0,
    720,
    719,
    1,
    0,
    0,
    0,
    721,
    724,
    1,
    0,
    0,
    0,
    722,
    723,
    1,
    0,
    0,
    0,
    722,
    720,
    1,
    0,
    0,
    0,
    723,
    725,
    1,
    0,
    0,
    0,
    724,
    722,
    1,
    0,
    0,
    0,
    725,
    726,
    5,
    34,
    0,
    0,
    726,
    727,
    5,
    34,
    0,
    0,
    727,
    729,
    5,
    34,
    0,
    0,
    728,
    702,
    1,
    0,
    0,
    0,
    728,
    715,
    1,
    0,
    0,
    0,
    729,
    198,
    1,
    0,
    0,
    0,
    730,
    737,
    8,
    16,
    0,
    0,
    731,
    734,
    5,
    92,
    0,
    0,
    732,
    735,
    3,
    201,
    100,
    0,
    733,
    735,
    9,
    0,
    0,
    0,
    734,
    732,
    1,
    0,
    0,
    0,
    734,
    733,
    1,
    0,
    0,
    0,
    735,
    737,
    1,
    0,
    0,
    0,
    736,
    730,
    1,
    0,
    0,
    0,
    736,
    731,
    1,
    0,
    0,
    0,
    737,
    200,
    1,
    0,
    0,
    0,
    738,
    740,
    5,
    13,
    0,
    0,
    739,
    738,
    1,
    0,
    0,
    0,
    739,
    740,
    1,
    0,
    0,
    0,
    740,
    741,
    1,
    0,
    0,
    0,
    741,
    742,
    5,
    10,
    0,
    0,
    742,
    202,
    1,
    0,
    0,
    0,
    743,
    745,
    7,
    5,
    0,
    0,
    744,
    743,
    1,
    0,
    0,
    0,
    745,
    746,
    1,
    0,
    0,
    0,
    746,
    744,
    1,
    0,
    0,
    0,
    746,
    747,
    1,
    0,
    0,
    0,
    747,
    750,
    1,
    0,
    0,
    0,
    748,
    750,
    3,
    205,
    102,
    0,
    749,
    744,
    1,
    0,
    0,
    0,
    749,
    748,
    1,
    0,
    0,
    0,
    750,
    751,
    1,
    0,
    0,
    0,
    751,
    753,
    7,
    17,
    0,
    0,
    752,
    754,
    7,
    18,
    0,
    0,
    753,
    752,
    1,
    0,
    0,
    0,
    753,
    754,
    1,
    0,
    0,
    0,
    754,
    756,
    1,
    0,
    0,
    0,
    755,
    757,
    7,
    5,
    0,
    0,
    756,
    755,
    1,
    0,
    0,
    0,
    757,
    758,
    1,
    0,
    0,
    0,
    758,
    756,
    1,
    0,
    0,
    0,
    758,
    759,
    1,
    0,
    0,
    0,
    759,
    762,
    1,
    0,
    0,
    0,
    760,
    762,
    3,
    205,
    102,
    0,
    761,
    749,
    1,
    0,
    0,
    0,
    761,
    760,
    1,
    0,
    0,
    0,
    762,
    204,
    1,
    0,
    0,
    0,
    763,
    765,
    7,
    5,
    0,
    0,
    764,
    763,
    1,
    0,
    0,
    0,
    765,
    768,
    1,
    0,
    0,
    0,
    766,
    764,
    1,
    0,
    0,
    0,
    766,
    767,
    1,
    0,
    0,
    0,
    767,
    769,
    1,
    0,
    0,
    0,
    768,
    766,
    1,
    0,
    0,
    0,
    769,
    771,
    5,
    46,
    0,
    0,
    770,
    772,
    7,
    5,
    0,
    0,
    771,
    770,
    1,
    0,
    0,
    0,
    772,
    773,
    1,
    0,
    0,
    0,
    773,
    771,
    1,
    0,
    0,
    0,
    773,
    774,
    1,
    0,
    0,
    0,
    774,
    782,
    1,
    0,
    0,
    0,
    775,
    777,
    7,
    5,
    0,
    0,
    776,
    775,
    1,
    0,
    0,
    0,
    777,
    778,
    1,
    0,
    0,
    0,
    778,
    776,
    1,
    0,
    0,
    0,
    778,
    779,
    1,
    0,
    0,
    0,
    779,
    780,
    1,
    0,
    0,
    0,
    780,
    782,
    5,
    46,
    0,
    0,
    781,
    766,
    1,
    0,
    0,
    0,
    781,
    776,
    1,
    0,
    0,
    0,
    782,
    206,
    1,
    0,
    0,
    0,
    783,
    788,
    5,
    39,
    0,
    0,
    784,
    787,
    3,
    213,
    106,
    0,
    785,
    787,
    3,
    219,
    109,
    0,
    786,
    784,
    1,
    0,
    0,
    0,
    786,
    785,
    1,
    0,
    0,
    0,
    787,
    790,
    1,
    0,
    0,
    0,
    788,
    786,
    1,
    0,
    0,
    0,
    788,
    789,
    1,
    0,
    0,
    0,
    789,
    791,
    1,
    0,
    0,
    0,
    790,
    788,
    1,
    0,
    0,
    0,
    791,
    802,
    5,
    39,
    0,
    0,
    792,
    797,
    5,
    34,
    0,
    0,
    793,
    796,
    3,
    215,
    107,
    0,
    794,
    796,
    3,
    219,
    109,
    0,
    795,
    793,
    1,
    0,
    0,
    0,
    795,
    794,
    1,
    0,
    0,
    0,
    796,
    799,
    1,
    0,
    0,
    0,
    797,
    795,
    1,
    0,
    0,
    0,
    797,
    798,
    1,
    0,
    0,
    0,
    798,
    800,
    1,
    0,
    0,
    0,
    799,
    797,
    1,
    0,
    0,
    0,
    800,
    802,
    5,
    34,
    0,
    0,
    801,
    783,
    1,
    0,
    0,
    0,
    801,
    792,
    1,
    0,
    0,
    0,
    802,
    208,
    1,
    0,
    0,
    0,
    803,
    804,
    5,
    39,
    0,
    0,
    804,
    805,
    5,
    39,
    0,
    0,
    805,
    806,
    5,
    39,
    0,
    0,
    806,
    810,
    1,
    0,
    0,
    0,
    807,
    809,
    3,
    211,
    105,
    0,
    808,
    807,
    1,
    0,
    0,
    0,
    809,
    812,
    1,
    0,
    0,
    0,
    810,
    811,
    1,
    0,
    0,
    0,
    810,
    808,
    1,
    0,
    0,
    0,
    811,
    813,
    1,
    0,
    0,
    0,
    812,
    810,
    1,
    0,
    0,
    0,
    813,
    814,
    5,
    39,
    0,
    0,
    814,
    815,
    5,
    39,
    0,
    0,
    815,
    830,
    5,
    39,
    0,
    0,
    816,
    817,
    5,
    34,
    0,
    0,
    817,
    818,
    5,
    34,
    0,
    0,
    818,
    819,
    5,
    34,
    0,
    0,
    819,
    823,
    1,
    0,
    0,
    0,
    820,
    822,
    3,
    211,
    105,
    0,
    821,
    820,
    1,
    0,
    0,
    0,
    822,
    825,
    1,
    0,
    0,
    0,
    823,
    824,
    1,
    0,
    0,
    0,
    823,
    821,
    1,
    0,
    0,
    0,
    824,
    826,
    1,
    0,
    0,
    0,
    825,
    823,
    1,
    0,
    0,
    0,
    826,
    827,
    5,
    34,
    0,
    0,
    827,
    828,
    5,
    34,
    0,
    0,
    828,
    830,
    5,
    34,
    0,
    0,
    829,
    803,
    1,
    0,
    0,
    0,
    829,
    816,
    1,
    0,
    0,
    0,
    830,
    210,
    1,
    0,
    0,
    0,
    831,
    834,
    3,
    217,
    108,
    0,
    832,
    834,
    3,
    219,
    109,
    0,
    833,
    831,
    1,
    0,
    0,
    0,
    833,
    832,
    1,
    0,
    0,
    0,
    834,
    212,
    1,
    0,
    0,
    0,
    835,
    837,
    7,
    19,
    0,
    0,
    836,
    835,
    1,
    0,
    0,
    0,
    837,
    214,
    1,
    0,
    0,
    0,
    838,
    840,
    7,
    20,
    0,
    0,
    839,
    838,
    1,
    0,
    0,
    0,
    840,
    216,
    1,
    0,
    0,
    0,
    841,
    843,
    7,
    21,
    0,
    0,
    842,
    841,
    1,
    0,
    0,
    0,
    843,
    218,
    1,
    0,
    0,
    0,
    844,
    845,
    5,
    92,
    0,
    0,
    845,
    846,
    7,
    22,
    0,
    0,
    846,
    220,
    1,
    0,
    0,
    0,
    847,
    850,
    3,
    223,
    111,
    0,
    848,
    850,
    7,
    23,
    0,
    0,
    849,
    847,
    1,
    0,
    0,
    0,
    849,
    848,
    1,
    0,
    0,
    0,
    850,
    222,
    1,
    0,
    0,
    0,
    851,
    853,
    7,
    24,
    0,
    0,
    852,
    851,
    1,
    0,
    0,
    0,
    853,
    224,
    1,
    0,
    0,
    0,
    57,
    0,
    542,
    546,
    548,
    552,
    556,
    560,
    564,
    566,
    572,
    578,
    580,
    587,
    594,
    601,
    607,
    609,
    637,
    644,
    659,
    669,
    678,
    681,
    683,
    691,
    694,
    696,
    700,
    709,
    722,
    728,
    734,
    736,
    739,
    746,
    749,
    753,
    758,
    761,
    766,
    773,
    778,
    781,
    786,
    788,
    795,
    797,
    801,
    810,
    823,
    829,
    833,
    836,
    839,
    842,
    849,
    852,
    9,
    1,
    86,
    0,
    1,
    87,
    1,
    1,
    88,
    2,
    1,
    89,
    3,
    1,
    90,
    4,
    1,
    91,
    5,
    0,
    1,
    0,
    1,
    94,
    6,
    1,
    95,
    7
  ];
  static __ATN;
  static get _ATN() {
    if (!_PythonLexer.__ATN) {
      _PythonLexer.__ATN = new yt2().deserialize(_PythonLexer._serializedATN);
    }
    return _PythonLexer.__ATN;
  }
  static vocabulary = new b2(_PythonLexer.literalNames, _PythonLexer.symbolicNames, []);
  get vocabulary() {
    return _PythonLexer.vocabulary;
  }
  static decisionsToDFA = _PythonLexer._ATN.decisionToState.map((ds, index) => new at2(ds, index));
};

// src/CodeBlocks.ts
var CodeBlocks = class _CodeBlocks {
  static nextSpanId = 1;
  // Decoration handle for code markup.
  blockDecorationType;
  // All marked code ranges we manage here. These are linked to an editor in the web app.
  codeBlocks = /* @__PURE__ */ new Map();
  setup(context) {
    this.initializeBlockDecorations();
    requisitions.register("proxyRequest", this.proxyRequest);
    context.subscriptions.push(import_vscode7.workspace.onDidCloseTextDocument((document2) => {
      if (document2.uri.scheme === "file") {
        this.codeBlocks.delete(document2.uri);
      }
    }));
    context.subscriptions.push(import_vscode7.window.onDidChangeActiveTextEditor((editor) => {
      if (editor && this.codeBlocks.has(editor.document.uri)) {
        this.updateCodeDecorations(editor.document);
      }
    }));
    context.subscriptions.push(import_vscode7.workspace.onDidChangeTextDocument((event) => {
      const spans = this.codeBlocks.get(event.document.uri);
      if (spans) {
        event.contentChanges.forEach((change) => {
          const changeLength = change.text.length - change.rangeLength;
          let startIndex = -1;
          let count = 0;
          spans.forEach((current, index) => {
            if (this.spansOverlap(current.start, current.length, change.rangeOffset, changeLength)) {
              if (startIndex === -1) {
                startIndex = index;
              }
              ++count;
            }
          });
          let needUpdate = false;
          if (count > 0) {
            const startSpan = spans[startIndex];
            if (count > 1 || change.rangeOffset < startSpan.start || change.rangeOffset + change.rangeLength > startSpan.start + startSpan.length) {
              spans.splice(startIndex--, count);
              needUpdate = true;
            } else {
              spans[startIndex].length -= changeLength;
            }
          }
          for (let i63 = startIndex + 1; i63 < spans.length; ++i63) {
            spans[i63].start -= changeLength;
          }
          if (needUpdate) {
            this.updateCodeDecorations(event.document);
          }
        });
      }
    }));
  }
  executeSqlFromEditor(editor, caption, connectionId) {
    const content = editor.document.getText();
    const { line, character } = editor.selection.active;
    const input = pe.fromString(content);
    let lexer;
    let stringType;
    switch (editor.document.languageId) {
      case "python": {
        lexer = new PythonLexer(input);
        stringType = PythonLexer.STRING;
        break;
      }
      case "javascript":
      case "typescript": {
        return;
      }
      default: {
        return;
      }
    }
    const tokenStream = new Ht(lexer);
    try {
      tokenStream.fill();
      const tokens = tokenStream.getTokens();
      let index = 0;
      while (index < tokens.length) {
        let token = tokens[index];
        const tokenLine = token.line - 1;
        if (tokenLine > line || tokenLine === line && token.column > character) {
          if (index > 0) {
            token = tokens[index - 1];
            if (token.line - 1 < line || token.column <= character) {
              if (token.type === stringType && token.text) {
                const [prefix, postfix] = this.determinePythonQuotes(token.text);
                const sql = token.text.substring(prefix, token.text.length - postfix);
                const [beautified, whiteSpaces] = this.beautifyQuery(sql);
                const span = {
                  id: _CodeBlocks.nextSpanId++,
                  originalCode: sql,
                  whiteSpaces,
                  start: token.start + prefix,
                  length: token.stop + 1 - postfix - (token.start + prefix)
                };
                let ranges = this.codeBlocks.get(editor.document.uri);
                if (!ranges) {
                  ranges = [];
                  this.codeBlocks.set(editor.document.uri, ranges);
                }
                const existing = ranges.findIndex((candidate) => {
                  return candidate.start === span.start;
                });
                if (existing === -1) {
                  ranges.push(span);
                  ranges.sort((lhs, rhs) => {
                    return lhs.start - rhs.start;
                  });
                  this.updateCodeDecorations(editor.document);
                } else {
                  ranges[existing] = span;
                }
                const data = {
                  caption,
                  connectionId: String(connectionId)
                };
                void requisitions.execute("editorRunQuery", {
                  data,
                  query: beautified,
                  linkId: span.id,
                  parameters: []
                });
              }
              break;
            }
          }
        }
        ++index;
      }
    } catch (reason) {
      printChannelOutput(String(reason));
    }
  }
  /**
   * Registers a block decoration type used to mark linked code blocks.
   */
  initializeBlockDecorations() {
    this.blockDecorationType = import_vscode7.window.createTextEditorDecorationType({
      isWholeLine: false,
      rangeBehavior: import_vscode7.DecorationRangeBehavior.OpenOpen,
      overviewRulerLane: import_vscode7.OverviewRulerLane.Left,
      light: {
        backgroundColor: "#db8f0015",
        overviewRulerColor: "#db8f00",
        gutterIconPath: import_path4.default.join(__dirname, "..", "images", "light", "query-marker.svg"),
        before: {
          contentIconPath: import_path4.default.join(__dirname, "..", "images", "light", "sqlBlockStart.svg"),
          width: "24px",
          height: "14px",
          margin: "0px 6px 0px 6px",
          color: "#db8f00"
        },
        after: {
          contentIconPath: import_path4.default.join(__dirname, "..", "images", "light", "sqlBlockEnd.svg"),
          width: "24px",
          height: "14px",
          margin: "0px 6px 0px 6px",
          color: "#db8f00"
        }
      },
      dark: {
        backgroundColor: "#db8f0015",
        overviewRulerColor: "#db8f00",
        gutterIconPath: import_path4.default.join(__dirname, "..", "images", "dark", "query-marker.svg"),
        before: {
          contentIconPath: import_path4.default.join(__dirname, "..", "images", "dark", "sqlBlockStart.svg"),
          width: "24px",
          height: "14px",
          margin: "0px 6px 0px 6px",
          color: "#db8f00"
        },
        after: {
          contentIconPath: import_path4.default.join(__dirname, "..", "images", "dark", "sqlBlockEnd.svg"),
          width: "24px",
          height: "14px",
          margin: "0px 6px 0px 6px",
          color: "#db8f00"
        }
      }
    });
  }
  /**
   * Triggered when the application sent code that must be written to a text document.
   *
   * @param data The details of the code block to update.
   *
   * @param data.linkId The code block's ID.
   * @param data.code The new code to set for that block.
   *
   * @returns A promise which immediately resolves.
   */
  codeBlocksUpdate = (data) => {
    let entry;
    let documentUri;
    this.codeBlocks.forEach((blocks, uri) => {
      blocks.forEach((block) => {
        if (block.id === data.linkId) {
          entry = block;
          documentUri = uri;
        }
      });
    });
    if (entry && documentUri) {
      if (import_vscode7.window.activeTextEditor?.document.uri !== documentUri) {
        const options = {
          viewColumn: import_vscode7.ViewColumn.One,
          preserveFocus: true
        };
        void import_vscode7.window.showTextDocument(documentUri, options).then((editor) => {
          this.checkAndApplyCodeBlockChanges(editor, data.code, entry);
        });
      } else {
        this.checkAndApplyCodeBlockChanges(import_vscode7.window.activeTextEditor, data.code, entry);
      }
    } else {
      void import_vscode7.window.showInformationMessage("The original code block no longer exists and cannot be updated.");
    }
    return Promise.resolve(true);
  };
  /**
   * Examines the given text, which must be a Python string and determines the number of leading and trailing
   * quote characters. This includes also string prefixes.
   *
   * @param text The text to check.
   *
   * @returns A pair of numbers, holding the leading and trailing quote count, respectively.
   */
  determinePythonQuotes(text) {
    const match = text.match(/^(u|br?|r(f|b)?|fr?)?(["']{1,3})/i);
    if (match) {
      const prefixLength = match[0].length;
      const postfixLength = prefixLength - (match[1] ?? "").length;
      return [prefixLength, postfixLength];
    }
    return [0, 0];
  }
  /**
   * Makes the given query text a bit friendlier by removing leading and trailing line breaks and removes
   * unnecessary indentation.
   *
   * @param text The text to beautify.
   *
   * @returns A pair with the converted text and the removed indentation.
   */
  beautifyQuery(text) {
    const whiteSpaces = {
      leading: "",
      indentation: "",
      trailing: ""
    };
    text = text.replace(/\t/g, "    ");
    const lines = text.split("\n");
    let count = 0;
    for (const line of lines) {
      if (line.trim().length === 0) {
        ++count;
        whiteSpaces.leading += line + "\n";
      } else {
        break;
      }
    }
    lines.splice(0, count);
    count = 0;
    for (const line of lines.reverse()) {
      if (line.trim().length === 0) {
        ++count;
        whiteSpaces.trailing += "\n" + line;
      } else {
        break;
      }
    }
    lines.splice(0, count);
    lines.reverse();
    if (lines.length > 0) {
      const match = lines[0].match(/(:?\s+).*/);
      whiteSpaces.indentation = match?.[1] ?? "";
      if (whiteSpaces.indentation) {
        lines.forEach((line, index) => {
          if (line.startsWith(whiteSpaces.indentation)) {
            lines[index] = line.substring(whiteSpaces.indentation.length);
          }
        });
      }
    }
    return [lines.join("\n"), whiteSpaces];
  }
  updateCodeDecorations(document2) {
    const blocks = this.codeBlocks.get(document2.uri);
    if (blocks) {
      const ranges = blocks.map((block) => {
        const startPosition = document2.positionAt(block.start);
        const endPosition = document2.positionAt(block.start + block.length);
        return new import_vscode7.Range(startPosition, endPosition);
      });
      import_vscode7.window.activeTextEditor?.setDecorations(this.blockDecorationType, ranges);
    }
  }
  /**
   * @param start1 The begin of the first span.
   * @param length1 The length of the first span.
   * @param start2 The begin of the second span.
   * @param length2 The length of the second span.
   *
   * @returns True if the given spans overlap each other. Otherwise false.
   */
  spansOverlap(start1, length1, start2, length2) {
    const end1 = start1 + length1;
    const end2 = start2 + length2;
    if (start1 <= start2) {
      return start2 <= end1;
    }
    return start1 <= end2;
  }
  /**
   * Applies the new code to the range given by the block. Checks, if the original code was changed in the text
   * editor and asks the user if it's still ok to overwrite that code, if that's the case.
   *
   * @param editor The editor to update.
   * @param newCode The new code to write.
   * @param block The block description for the part in the editor to change.
   */
  checkAndApplyCodeBlockChanges(editor, newCode, block) {
    if (block) {
      const lines = newCode.split("\n").map((line) => {
        return line.trim().length === 0 ? "" : block.whiteSpaces.indentation + line;
      });
      newCode = block.whiteSpaces.leading + lines.join("\n") + block.whiteSpaces.trailing;
      const start = editor.document.positionAt(block.start);
      const end = editor.document.positionAt(block.start + block.length);
      const range = new import_vscode7.Range(start, end);
      const currentText = editor.document.getText(range);
      if (currentText !== block.originalCode) {
        void import_vscode7.window.showWarningMessage("The original code was changed meanwhile. Do you still want to update it with your application code?", "Update", "Cancel").then((input) => {
          if (input === "Update") {
            void editor.edit((builder) => {
              builder.replace(range, newCode);
            }).then((success) => {
              if (!success) {
                void import_vscode7.window.showErrorMessage("The changes could not be applied.");
              } else {
                block.originalCode = newCode;
              }
            });
          }
        });
      } else {
        void editor.edit((builder) => {
          builder.replace(range, newCode);
        }).then((success) => {
          if (!success) {
            void import_vscode7.window.showErrorMessage("The changes could not be applied.");
          } else {
            block.originalCode = newCode;
          }
        });
      }
    }
  }
  proxyRequest = (request) => {
    switch (request.original.requestType) {
      case "codeBlocksUpdate": {
        const response = request.original.parameter;
        return this.codeBlocksUpdate(response);
      }
      default:
    }
    return Promise.resolve(false);
  };
};

// src/tree-providers/ConnectionsTreeProvider/ConnectionsTreeBaseItem.ts
var path6 = __toESM(require("path"), 1);
var import_vscode8 = require("vscode");
var ConnectionsTreeBaseItem = class extends import_vscode8.TreeItem {
  constructor(name, schema, backend, connectionId, iconName, hasChildren, command) {
    super(name, hasChildren ? import_vscode8.TreeItemCollapsibleState.Collapsed : import_vscode8.TreeItemCollapsibleState.None);
    this.name = name;
    this.schema = schema;
    this.backend = backend;
    this.connectionId = connectionId;
    this.iconPath = {
      light: path6.join(__dirname, "..", "images", "light", iconName),
      dark: path6.join(__dirname, "..", "images", "dark", iconName)
    };
    this.command = command;
  }
  copyNameToClipboard() {
    void import_vscode8.env.clipboard.writeText(this.name).then(() => {
      showMessageWithTimeout("The name was copied to the system clipboard");
    });
  }
  copyCreateScriptToClipboard(withDelimiter = false, withDrop = false) {
    this.backend.execute(`show create ${this.dbType} ${this.qualifiedName}`).then((data) => {
      if (data) {
        if (data.rows && data.rows.length > 0) {
          const firstRow = data.rows[0];
          const index = this.createScriptResultIndex;
          if (firstRow.length > index) {
            let stmt = firstRow[index];
            if (withDelimiter) {
              if (withDrop) {
                let name = Array.from(stmt.matchAll(/PROCEDURE `(.*?)`/gm), (m3) => {
                  return m3[1];
                });
                if (name.length > 0) {
                  stmt = `DROP PROCEDURE \`${name[0]}\`$$
${stmt}`;
                } else {
                  name = Array.from(stmt.matchAll(/FUNCTION `(.*?)`/gm), (m3) => {
                    return m3[1];
                  });
                  if (name.length) {
                    stmt = `DROP FUNCTION \`${name[0]}\`$$
${stmt}`;
                  }
                }
              }
              stmt = `DELIMITER $$
${stmt}$$
DELIMITER ;`;
            }
            void import_vscode8.env.clipboard.writeText(stmt).then(() => {
              showMessageWithTimeout("The create script was copied to the system clipboard");
            });
          }
        }
      }
    }).catch((event) => {
      void import_vscode8.window.showErrorMessage("Error while getting create script: " + event.message);
    });
  }
  dropItem() {
    const message = `Do you want to drop the ${this.dbType} ${this.name}?`;
    const okText = `Drop ${this.name}`;
    void showModalDialog(message, okText, "This operation cannot be reverted!").then((accepted) => {
      if (accepted) {
        const query = `drop ${this.dbType} ${this.qualifiedName}`;
        this.backend.execute(query).then(() => {
          void import_vscode8.commands.executeCommand("msg.refreshConnections");
          showMessageWithTimeout(`The object ${this.name} has been dropped successfully.`);
        }).catch((errorEvent) => {
          void import_vscode8.window.showErrorMessage(`Error dropping the object: ${errorEvent.message}`);
        });
      }
    });
  }
  get qualifiedName() {
    return "";
  }
  get dbType() {
    return "";
  }
  /**
   * The result for create script retrieval differs for certain DB types.
   *
   * @returns the index in the result row, where to find the correct text.
   *
   */
  get createScriptResultIndex() {
    return 1;
  }
};

// src/tree-providers/OpenEditorsTreeProvider/OpenEditorsTreeProvider.ts
var import_vscode14 = require("vscode");

// src/tree-providers/OpenEditorsTreeProvider/EditorOverviewTreeItem.ts
var path7 = __toESM(require("path"), 1);
var import_vscode9 = require("vscode");
var EditorOverviewTreeItem = class extends import_vscode9.TreeItem {
  contextValue = "editorOverview";
  constructor(caption, tooltip, command) {
    super(caption, import_vscode9.TreeItemCollapsibleState.None);
    this.tooltip = tooltip;
    this.command = command;
    this.iconPath = {
      light: path7.join(__dirname, "..", "images", "light", "overviewPage.svg"),
      dark: path7.join(__dirname, "..", "images", "dark", "overviewPage.svg")
    };
  }
};

// src/tree-providers/OpenEditorsTreeProvider/EditorConnectionTreeItem.ts
var path8 = __toESM(require("path"), 1);
var import_vscode10 = require("vscode");
var EditorConnectionTreeItem = class extends import_vscode10.TreeItem {
  entry;
  constructor(caption, dbType, connectionId) {
    super(caption, import_vscode10.TreeItemCollapsibleState.Expanded);
    this.entry = {
      details: {
        caption,
        id: connectionId,
        dbType
      }
    };
    let iconName;
    if (dbType === "MySQL" /* MySQL */) {
      iconName = "connectionMysql";
      this.contextValue = "editorConnectionMySQL";
    } else {
      iconName = "connectionSqlite";
      this.contextValue = "editorConnectionSQLite";
    }
    this.iconPath = {
      light: path8.join(__dirname, "..", "images", "light", iconName + ".svg"),
      dark: path8.join(__dirname, "..", "images", "dark", iconName + ".svg")
    };
  }
};

// src/tree-providers/OpenEditorsTreeProvider/EditorTabTreeItem.ts
var path9 = __toESM(require("path"), 1);
var import_vscode11 = require("vscode");
var EditorTabTreeItem = class extends import_vscode11.TreeItem {
  contextValue = "editorTab";
  constructor(caption) {
    super(caption, import_vscode11.TreeItemCollapsibleState.Expanded);
    this.iconPath = {
      light: path9.join(__dirname, "..", "images", "light", "tab.svg"),
      dark: path9.join(__dirname, "..", "images", "dark", "tab.svg")
    };
  }
};

// src/tree-providers/OpenEditorsTreeProvider/EditorTreeItem.ts
var path10 = __toESM(require("path"), 1);
var import_vscode12 = require("vscode");
var EditorTreeItem = class _EditorTreeItem extends import_vscode12.TreeItem {
  constructor(normalCaption, alternativeCaption, language, editorType, command) {
    super(normalCaption, import_vscode12.TreeItemCollapsibleState.None);
    this.normalCaption = normalCaption;
    this.alternativeCaption = alternativeCaption;
    this.command = command;
    if (editorType === 1 /* Script */ || editorType === 0 /* Notebook */) {
      if (language === "msg") {
        this.iconPath = {
          light: path10.join(__dirname, "..", "images", "light", "notebook.svg"),
          dark: path10.join(__dirname, "..", "images", "dark", "notebook.svg")
        };
      } else {
        let name;
        switch (language) {
          case "sql": {
            name = "scriptSqlite";
            break;
          }
          case "mysql": {
            name = "scriptMysql";
            break;
          }
          case "javascript": {
            name = "scriptJs";
            break;
          }
          case "typescript": {
            name = "scriptTs";
            break;
          }
          case "python": {
            name = "scriptPy";
            break;
          }
          default: {
            name = "default";
            break;
          }
        }
        this.iconPath = {
          light: path10.join(__dirname, "..", "images", "light", "file-icons", name + ".svg"),
          dark: path10.join(__dirname, "..", "images", "dark", "file-icons", name + ".svg")
        };
      }
    } else {
      const icon = _EditorTreeItem.#entityIconMap.get(editorType) ?? "default";
      this.iconPath = {
        light: path10.join(__dirname, "..", "images", "light", icon + ".svg"),
        dark: path10.join(__dirname, "..", "images", "dark", icon + ".svg")
      };
    }
  }
  static #entityIconMap = /* @__PURE__ */ new Map([
    [0 /* Notebook */, "terminal"],
    [1 /* Script */, "script"],
    [2 /* Folder */, "folder"],
    [3 /* Status */, "adminServerStatus"],
    [4 /* Connections */, "clientConnections"],
    [5 /* Dashboard */, "adminPerformanceDashboard"]
  ]);
  contextValue = "editorItem";
  updateLabel(simpleView) {
    this.label = simpleView ? this.alternativeCaption : this.normalCaption;
  }
};

// src/tree-providers/ShellTreeProvider/ShellConsoleSessionTreeItem.ts
var path11 = __toESM(require("path"), 1);
var import_vscode13 = require("vscode");
var ShellConsoleSessionTreeItem = class extends import_vscode13.TreeItem {
  contextValue = "session";
  constructor(caption, command) {
    super(caption, import_vscode13.TreeItemCollapsibleState.None);
    this.iconPath = {
      light: path11.join(__dirname, "..", "images", "light", "terminal.svg"),
      dark: path11.join(__dirname, "..", "images", "dark", "terminal.svg")
    };
    this.command = command;
  }
};

// src/tree-providers/OpenEditorsTreeProvider/OpenEditorsTreeProvider.ts
var OpenEditorsTreeDataProvider = class {
  #openProviders = /* @__PURE__ */ new Map();
  #openSessions = /* @__PURE__ */ new Map();
  #lastSelectedItems = /* @__PURE__ */ new Map();
  #changeEvent = new import_vscode14.EventEmitter();
  #selectCallback;
  // Standalone overview entry which is used if no provider exists.
  #connectionOverview;
  get onDidChangeTreeData() {
    return this.#changeEvent.event;
  }
  set onSelect(callback) {
    this.#selectCallback = callback;
  }
  constructor() {
    requisitions.register("proxyRequest", this.proxyRequest);
    requisitions.register("editorSaved", this.editorSaved);
    this.#connectionOverview = this.createOverviewItems(null);
  }
  dispose() {
    requisitions.unregister("proxyRequest", this.proxyRequest);
    requisitions.unregister("editorSaved", this.editorSaved);
  }
  /**
   * Removes the given provider from the list of open providers.
   *
   * @param provider The provider to remove. If not given, all providers are removed.
   *
   * @returns True if the list of open providers is empty after the removal, false otherwise.
   */
  clear(provider) {
    if (provider) {
      this.#openProviders.delete(provider);
    } else {
      this.#openProviders.clear();
    }
    this.#changeEvent.fire(void 0);
    return this.#openProviders.size === 0;
  }
  /**
   * Checks if the connection represented by the given tree item is already open in any webview provider.
   *
   * @param item The item to check.
   *
   * @returns True if the connection is already open, false otherwise.
   */
  isOpen(item) {
    for (const [_3, entry] of this.#openProviders.entries()) {
      if (entry.connections.some((connection) => {
        return connection.connectionId === item.details.id;
      })) {
        return true;
      }
    }
    return false;
  }
  /**
   * @returns the connection ID of the last selected item. If no item is selected, null is returned.
   *
   * @param provider The provider to get the connection ID for.
   */
  currentConnectionId(provider) {
    const item = this.#lastSelectedItems.get(provider);
    if (item && item.type === "editor") {
      const parent = item.parent;
      return parent.connectionId;
    } else if (item && item.type === "connection") {
      return item.connectionId;
    }
    return null;
  }
  /**
   * Creates a new caption for a new provider, based on the number of tabs already open.
   *
   * @returns The new caption.
   */
  createUniqueCaption = () => {
    if (this.#openProviders.size === 0) {
      return "MySQL Shell";
    }
    let index = 2;
    while (index < 100) {
      const caption = `MySQL Shell (${index})`;
      let found = false;
      this.#openProviders.forEach((entry) => {
        if (entry.caption === caption) {
          found = true;
        }
      });
      if (!found) {
        return caption;
      }
      ++index;
    }
    return "";
  };
  getTreeItem(element) {
    return element.treeItem;
  }
  getParent(element) {
    if (element.type === "editor") {
      return element.parent;
    }
    if (element.type === "connection") {
      return element.parent;
    }
    return null;
  }
  getChildren(element) {
    if (!element) {
      const connectionProviders = [...this.#openProviders.values()];
      const sessionProviders = [...this.#openSessions.values()];
      if (connectionProviders.length === 0) {
        return [this.#connectionOverview, ...sessionProviders.values()];
      }
      if (connectionProviders.length === 1) {
        const provider = [...this.#openProviders.values()][0];
        return [
          provider.connectionOverview,
          ...provider.connections,
          ...sessionProviders.values()
        ];
      }
      return [...this.#openProviders.values(), ...sessionProviders.values()];
    }
    if (element.type === "connectionProvider") {
      const provider = element;
      return [provider.connectionOverview, ...provider.connections];
    }
    if (element.type === "sessionProvider") {
      const provider = element;
      return [...provider.sessions];
    }
    if (element.type === "connection") {
      return element.editors;
    }
    return null;
  }
  updateEditors = (provider, details) => {
    if (details.opened) {
      let entry = this.#openProviders.get(provider);
      if (!entry) {
        entry = {
          type: "connectionProvider",
          provider,
          caption: provider.caption,
          treeItem: new EditorTabTreeItem(provider.caption),
          connections: []
        };
        this.#openProviders.set(provider, entry);
        entry.connectionOverview = this.createOverviewItems(provider);
        entry.connectionOverview.parent = entry;
      }
      let connection = entry.connections.find((item) => {
        return item.connectionId === details.connectionId;
      });
      const editorCommand = {
        title: "",
        command: "",
        arguments: [provider, details.connectionCaption, details.connectionId, details.editorId]
      };
      switch (details.editorType) {
        case 0 /* Notebook */: {
          editorCommand.command = "msg.showNotebook";
          break;
        }
        case 1 /* Script */: {
          editorCommand.command = "msg.showScript";
          break;
        }
        case 3 /* Status */: {
          editorCommand.command = "msg.showServerStatus";
          break;
        }
        case 4 /* Connections */: {
          editorCommand.command = "msg.showClientConnections";
          break;
        }
        case 5 /* Dashboard */: {
          editorCommand.command = "msg.showPerformanceDashboard";
          break;
        }
        default:
      }
      if (connection) {
        const alternativeCaption = `${details.editorCaption} (${details.connectionCaption})`;
        connection.editors.push({
          type: "editor",
          caption: details.editorCaption,
          alternativeCaption,
          id: details.editorId,
          language: details.language,
          editorType: details.editorType,
          parent: connection,
          treeItem: new EditorTreeItem(
            details.editorCaption,
            alternativeCaption,
            details.language,
            details.editorType,
            editorCommand
          )
        });
      } else {
        connection = {
          type: "connection",
          connectionId: details.connectionId,
          caption: details.connectionCaption,
          dbType: details.dbType,
          editors: [],
          parent: entry,
          treeItem: new EditorConnectionTreeItem(
            details.connectionCaption,
            details.dbType,
            details.connectionId
          )
        };
        const alternativeCaption = `${details.editorCaption} (${details.connectionCaption})`;
        connection.editors.push({
          type: "editor",
          caption: details.editorCaption,
          alternativeCaption,
          id: details.editorId,
          language: details.language,
          editorType: details.editorType,
          parent: connection,
          treeItem: new EditorTreeItem(
            details.editorCaption,
            alternativeCaption,
            details.language,
            details.editorType,
            editorCommand
          )
        });
        entry.connections.push(connection);
      }
      const itemToSelect = connection.editors[connection.editors.length - 1];
      this.#changeEvent.fire(void 0);
      this.#lastSelectedItems.set(provider, itemToSelect);
      if (itemToSelect.caption !== "DB Connection Overview") {
        provider.caption = details.connectionCaption;
      }
      this.#selectCallback(itemToSelect);
    } else {
      const entry = this.#openProviders.get(provider);
      if (!entry) {
        return;
      }
      const connectionIndex = entry.connections.findIndex((item) => {
        return item.connectionId === details.connectionId;
      });
      if (connectionIndex > -1) {
        const connection = entry.connections[connectionIndex];
        if (details.editorId === void 0) {
          connection.editors = [];
        } else {
          const editorIndex = connection.editors.findIndex((item) => {
            return item.id === details.editorId;
          });
          if (editorIndex !== -1) {
            connection.editors.splice(editorIndex, 1);
          }
        }
        if (connection.editors.length === 0) {
          entry.connections.splice(connectionIndex, 1);
        }
      }
      if (entry.connections.length === 0) {
        this.#openProviders.delete(provider);
      }
      this.#changeEvent.fire(void 0);
    }
  };
  createOverviewItems = (provider) => {
    const connectionCommand = {
      command: "msg.openDBBrowser",
      arguments: [provider]
    };
    const connectionOverview = {
      type: "connectionOverview",
      caption: "DB Connection Overview",
      treeItem: new EditorOverviewTreeItem(
        "DB Connection Overview",
        "Open the DB Connection Overview",
        connectionCommand
      ),
      parent: null
    };
    return connectionOverview;
  };
  /**
   * Requests sent from one of the providers.
   *
   * @param request The request to handle.
   * @param request.provider The provider that sent the request.
   * @param request.original The original request.
   *
   * @returns A promise that resolves to true if the request was handled.
   */
  proxyRequest = (request) => {
    switch (request.original.requestType) {
      case "editorsChanged": {
        const response = request.original.parameter;
        this.updateEditors(request.provider, response);
        return Promise.resolve(true);
      }
      case "editorSelect": {
        const response = request.original.parameter;
        return this.selectItem(request.provider, response.connectionId, response.editorId);
      }
      case "selectConnectionTab": {
        const response = request.original.parameter;
        return this.selectItem(request.provider, response.connectionId, response.page);
      }
      case "refreshSessions": {
        const response = request.original.parameter;
        return this.refreshSessions(request.provider, response);
      }
      default:
    }
    return Promise.resolve(false);
  };
  selectItem = (provider, connectionId, editorOrPage) => {
    const entry = this.#openProviders.get(provider);
    if (!entry) {
      return Promise.resolve(false);
    }
    if (connectionId < 0 && editorOrPage.length === 0) {
      const lastItem = this.#lastSelectedItems.get(provider);
      if (lastItem) {
        this.#selectCallback(lastItem);
      }
      return Promise.resolve(true);
    }
    const connection = entry.connections.find((item) => {
      return item.connectionId === connectionId;
    });
    if (connection) {
      const editor = connection.editors.find((item) => {
        return item.id === editorOrPage;
      }) ?? connection.editors[0];
      if (editor) {
        this.#lastSelectedItems.set(provider, editor);
        this.#selectCallback(editor);
      }
    } else {
      this.#lastSelectedItems.set(provider, entry.connectionOverview);
      if (editorOrPage === "DB Connection Overview") {
        provider.caption = entry.caption;
      } else {
        provider.caption = editorOrPage ?? entry.caption;
      }
      this.#selectCallback(entry.connectionOverview);
    }
    return Promise.resolve(false);
  };
  refreshSessions = (provider, sessions) => {
    if (sessions.length === 0) {
      provider.close();
      this.#openSessions.delete(provider);
    } else {
      let entry = this.#openSessions.get(provider);
      if (!entry) {
        entry = {
          type: "sessionProvider",
          provider,
          caption: provider.caption,
          treeItem: new EditorTabTreeItem(provider.caption),
          sessions: []
        };
        this.#openSessions.set(provider, entry);
      }
      entry.sessions = sessions.map((details) => {
        return {
          type: "shellSession",
          caption: details.caption,
          id: details.sessionId,
          parent: entry,
          details,
          treeItem: new ShellConsoleSessionTreeItem(details.caption ?? "Unknown", {
            title: "Open Shell GUI Console",
            command: "msg.openSession",
            arguments: [details]
          })
        };
      });
    }
    this.#changeEvent.fire(void 0);
    return Promise.resolve(true);
  };
  editorSaved = (details) => {
    for (const entry of this.#openProviders.values()) {
      for (const connection of entry.connections) {
        for (const editor of connection.editors) {
          if (editor.id === details.id) {
            editor.caption = details.newName;
            editor.treeItem.label = details.newName;
            this.#changeEvent.fire(editor);
          }
        }
      }
    }
    return Promise.resolve(true);
  };
  /**
   * Updates the caption of all editor tree items of a provider entry, depending on the view mode.
   *
   * @param provider The provider entry to update.
   * @param simpleView True if the simple view is active, false otherwise.
   */
  updateEditorItemCaptions = (provider, simpleView) => {
    for (const connection of provider.connections) {
      for (const editor of connection.editors) {
        editor.treeItem.updateLabel(simpleView);
      }
    }
  };
};

// src/DBEditorCommandHandler.ts
var DBEditorCommandHandler = class {
  constructor(connectionsProvider) {
    this.connectionsProvider = connectionsProvider;
  }
  #isConnected = false;
  #host;
  #codeBlocks = new CodeBlocks();
  // For each open editor a list of open scripts is held (via a mapping of script IDs and their target URI).
  #openScripts = /* @__PURE__ */ new Map();
  #openEditorsTreeDataProvider;
  #initialDisplayOfOpenEditorsView = true;
  #displayDbConnectionOverviewWhenConnected = false;
  setup(host2) {
    this.#host = host2;
    const context = host2.context;
    this.#codeBlocks.setup(context);
    const dbConnectionsTreeView = import_vscode15.window.createTreeView(
      "msg.connections",
      {
        treeDataProvider: this.connectionsProvider,
        showCollapseAll: true,
        canSelectMany: false
      }
    );
    context.subscriptions.push(dbConnectionsTreeView);
    dbConnectionsTreeView.onDidExpandElement((event) => {
      this.connectionsProvider.didExpandElement(event.element);
    });
    dbConnectionsTreeView.onDidCollapseElement((event) => {
      this.connectionsProvider.didCollapseElement(event.element);
    });
    this.#openEditorsTreeDataProvider = new OpenEditorsTreeDataProvider();
    const openEditorsTreeView = import_vscode15.window.createTreeView(
      "msg.openEditors",
      {
        treeDataProvider: this.#openEditorsTreeDataProvider,
        showCollapseAll: true,
        canSelectMany: false
      }
    );
    context.subscriptions.push(openEditorsTreeView);
    this.#openEditorsTreeDataProvider.onSelect = (item) => {
      void openEditorsTreeView.reveal(item, { select: true, focus: false, expand: 3 });
    };
    openEditorsTreeView.onDidChangeVisibility((e) => {
      const showDbConnectionsTab = import_vscode15.workspace.getConfiguration(`msg.startup`).get("showDbConnectionsTab", true);
      if (e.visible && this.#initialDisplayOfOpenEditorsView && showDbConnectionsTab) {
        this.#initialDisplayOfOpenEditorsView = false;
        if (this.#isConnected) {
          void import_vscode15.commands.executeCommand("msg.openDBBrowser");
        } else {
          this.#displayDbConnectionOverviewWhenConnected = true;
        }
      }
    });
    requisitions.register("connectedToUrl", this.connectedToUrl);
    requisitions.register("editorRunQuery", this.editorRunQuery);
    requisitions.register("proxyRequest", this.proxyRequest);
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.refreshConnections", () => {
      void requisitions.execute("refreshConnections", void 0);
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.refreshVisibleRouters", () => {
      this.connectionsProvider.refreshMrsRouters();
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.openConnection", (entry) => {
      if (entry) {
        let provider;
        if (this.#openEditorsTreeDataProvider.isOpen(entry.treeItem)) {
          provider = this.#host.newProvider;
        } else {
          provider = this.#host.currentProvider;
        }
        void provider?.show(String(entry.treeItem.details.id));
      }
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand(
      "msg.openConnectionNewTab",
      (entry) => {
        if (entry) {
          const provider = this.#host.newProvider;
          void provider?.show(String(entry.treeItem.details.id));
        }
      }
    ));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.showTableData", (entry) => {
      if (entry) {
        const provider = this.#host.currentProvider;
        const configuration = import_vscode15.workspace.getConfiguration(`msg.dbEditor`);
        const uppercaseKeywords = configuration.get("upperCaseKeywords", true);
        const select = uppercaseKeywords ? "SELECT" : "select";
        const from = uppercaseKeywords ? "FROM" : "from";
        const item = entry.treeItem;
        const query = `${select} * ${from} \`${item.schema}\`.\`${item.label}\``;
        const name = `${item.schema}.${item.label} - Data`;
        void provider?.runScript(String(item.connectionId), {
          scriptId: uuid(),
          language: "mysql",
          content: query,
          name
        });
      }
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.selectTableRows", (entry) => {
      if (entry) {
        const provider = this.#host.currentProvider;
        const configuration = import_vscode15.workspace.getConfiguration(`msg.dbEditor`);
        const uppercaseKeywords = configuration.get("upperCaseKeywords", true);
        const select = uppercaseKeywords ? "SELECT" : "select";
        const from = uppercaseKeywords ? "FROM" : "from";
        const item = entry.treeItem;
        const query = `${select} * ${from} \`${item.schema}\`.\`${item.label}\``;
        void provider?.runQuery(String(item.connectionId), {
          query,
          data: {},
          linkId: -1,
          parameters: []
        });
      }
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand(
      "msg.showNotebook",
      (provider, caption, connectionId, itemId) => {
        provider ??= this.#host.currentProvider;
        if (provider instanceof DBConnectionViewProvider) {
          provider.caption = caption;
          void provider.showPageSection(String(connectionId), 0 /* Notebook */, itemId);
        }
      }
    ));
    context.subscriptions.push(import_vscode15.commands.registerCommand(
      "msg.showScript",
      (provider, caption, connectionId, itemId) => {
        provider ??= this.#host.currentProvider;
        if (provider instanceof DBConnectionViewProvider) {
          provider.caption = caption;
          void provider.showPageSection(String(connectionId), 1 /* Script */, itemId);
        }
      }
    ));
    context.subscriptions.push(import_vscode15.commands.registerCommand(
      "msg.showServerStatus",
      (provider, caption, connectionId, itemId) => {
        provider ??= this.#host.currentProvider;
        if (provider instanceof DBConnectionViewProvider) {
          provider.caption = caption;
          void provider.showPageSection(String(connectionId), 3 /* Status */, itemId);
        }
      }
    ));
    context.subscriptions.push(import_vscode15.commands.registerCommand(
      "msg.showClientConnections",
      (provider, caption, connectionId, itemId) => {
        provider ??= this.#host.currentProvider;
        if (provider instanceof DBConnectionViewProvider) {
          provider.caption = caption;
          void provider.showPageSection(String(connectionId), 4 /* Connections */, itemId);
        }
      }
    ));
    context.subscriptions.push(import_vscode15.commands.registerCommand(
      "msg.showPerformanceDashboard",
      (provider, caption, connectionId, itemId) => {
        provider ??= this.#host.currentProvider;
        if (provider instanceof DBConnectionViewProvider) {
          provider.caption = caption;
          void provider.showPageSection(String(connectionId), 5 /* Dashboard */, itemId);
        }
      }
    ));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.insertScript", (item) => {
      if (item) {
        const provider = this.#host.currentProvider;
        void provider?.insertScriptData(item.entry);
      }
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.addConnection", () => {
      const provider = this.#host.currentProvider;
      void provider?.addConnection();
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand(
      "msg.refreshConnection",
      (item) => {
        void requisitions.execute("refreshConnections", { item });
      }
    ));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.removeConnection", (entry) => {
      if (entry) {
        const provider = this.#host.currentProvider;
        void provider?.removeConnection(entry.treeItem.details.id);
      }
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.editConnection", (entry) => {
      if (entry) {
        const provider = this.#host.currentProvider;
        void provider?.editConnection(entry?.treeItem.details.id);
      }
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand(
      "msg.duplicateConnection",
      (entry) => {
        if (entry) {
          const provider = this.#host.currentProvider;
          void provider?.duplicateConnection(entry.treeItem.details.id);
        }
      }
    ));
    context.subscriptions.push(import_vscode15.commands.registerCommand(
      "msg.showSystemSchemasOnConnection",
      (entry) => {
        if (entry) {
          entry.treeItem.details.hideSystemSchemas = false;
          void requisitions.execute("refreshConnections", { entry });
        }
      }
    ));
    context.subscriptions.push(import_vscode15.commands.registerCommand(
      "msg.hideSystemSchemasOnConnection",
      (entry) => {
        if (entry) {
          entry.treeItem.details.hideSystemSchemas = true;
          void requisitions.execute("refreshConnections", { entry });
        }
      }
    ));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.openDBBrowser", (provider) => {
      provider ??= this.#host.currentProvider;
      if (provider instanceof DBConnectionViewProvider) {
        void provider.show("connections");
      } else {
        const provider2 = this.#host.currentProvider;
        if (provider2) {
          void provider2.show("connections");
        }
      }
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.makeCurrentSchema", (entry) => {
      if (entry) {
        const provider = this.#host.currentProvider;
        if (provider) {
          void provider?.makeCurrentSchema(entry.parent.treeItem.details.id, entry.treeItem.name).then((success) => {
            if (success) {
              this.connectionsProvider.makeCurrentSchema(entry);
            }
          });
        }
      }
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.dropSchema", (entry) => {
      entry?.treeItem.dropItem();
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.dropTable", (entry) => {
      entry?.treeItem.dropItem();
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.dropView", (entry) => {
      entry?.treeItem.dropItem();
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.dropRoutine", (entry) => {
      entry?.treeItem.dropItem();
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.dropTrigger", (entry) => {
      entry?.treeItem.dropItem();
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.dropEvent", (item) => {
      item?.dropItem();
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand(
      "msg.defaultConnection",
      (entry) => {
        if (entry) {
          const configuration = import_vscode15.workspace.getConfiguration(`msg.editor`);
          void configuration.update(
            "defaultDbConnection",
            entry.treeItem.details.caption,
            import_vscode15.ConfigurationTarget.Global
          ).then(() => {
            void import_vscode15.window.showInformationMessage(
              `"${entry.treeItem.label}" has been set as default DB Connection.`
            );
          });
        }
      }
    ));
    context.subscriptions.push(import_vscode15.commands.registerCommand(
      "msg.copyNameToClipboard",
      (entry) => {
        if (entry && entry.treeItem instanceof ConnectionsTreeBaseItem) {
          entry.treeItem.copyNameToClipboard();
        }
      }
    ));
    context.subscriptions.push(import_vscode15.commands.registerCommand(
      "msg.copyCreateScriptToClipboard",
      (entry) => {
        if (entry && entry.treeItem instanceof ConnectionsTreeBaseItem) {
          entry.treeItem.copyCreateScriptToClipboard();
        }
      }
    ));
    context.subscriptions.push(import_vscode15.commands.registerCommand(
      "msg.copyCreateScriptWithDelimitersToClipboard",
      (entry) => {
        if (entry && entry.treeItem instanceof ConnectionsTreeBaseItem) {
          entry.treeItem.copyCreateScriptToClipboard(true);
        }
      }
    ));
    context.subscriptions.push(import_vscode15.commands.registerCommand(
      "msg.copyDropCreateScriptWithDelimitersToClipboard",
      (entry) => {
        if (entry && entry.treeItem instanceof ConnectionsTreeBaseItem) {
          entry.treeItem.copyCreateScriptToClipboard(true, true);
        }
      }
    ));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.editInScriptEditor", async (uri) => {
      if (uri?.scheme === "file") {
        if (!import_fs4.default.existsSync(uri.fsPath)) {
          void import_vscode15.window.showErrorMessage(`The file ${uri.fsPath} could not be found.`);
        } else {
          const stat = await import_vscode15.workspace.fs.stat(uri);
          if (stat.size >= 1e7) {
            await import_vscode15.window.showInformationMessage(`The file "${uri.fsPath}" is too large to edit it in a web view. Instead use the VS Code built-in editor.`);
          } else {
            const connection = await host2.determineConnection();
            if (connection) {
              await import_vscode15.workspace.fs.readFile(uri).then((value) => {
                const content = value.toString();
                const provider = this.#host.currentProvider;
                if (provider) {
                  const name = (0, import_path5.basename)(uri.fsPath);
                  const details = {
                    scriptId: uuid(),
                    name,
                    content,
                    language: this.languageFromConnection(connection)
                  };
                  let scripts = this.#openScripts.get(provider);
                  if (!scripts) {
                    scripts = /* @__PURE__ */ new Map();
                    this.#openScripts.set(provider, scripts);
                  }
                  scripts.set(details.scriptId, uri);
                  void provider.editScript(String(connection.treeItem.details.id), details);
                }
              });
            }
          }
        }
      }
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.loadScriptFromDisk", (entry) => {
      if (entry) {
        void import_vscode15.window.showOpenDialog({
          title: "Select the script file to load to MySQL Shell",
          openLabel: "Select Script File",
          canSelectFiles: true,
          canSelectFolders: false,
          canSelectMany: false,
          filters: {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            SQL: ["sql", "mysql"],
            TypeScript: ["ts"],
            JavaScript: ["js"]
          }
        }).then(async (value) => {
          if (value && value.length === 1) {
            const uri = value[0];
            const stat = await import_vscode15.workspace.fs.stat(uri);
            if (stat.size >= 1e7) {
              await import_vscode15.window.showInformationMessage(`The file "${uri.fsPath}" is too large to edit it in a web view. Instead use the VS Code built-in editor.`);
            } else {
              await import_vscode15.workspace.fs.readFile(uri).then((value2) => {
                const content = value2.toString();
                const provider = this.#host.currentProvider;
                if (provider) {
                  let language = "mysql";
                  const name = (0, import_path5.basename)(uri.fsPath);
                  const ext = name.substring(name.lastIndexOf(".") ?? 0);
                  switch (ext) {
                    case ".ts": {
                      language = "typescript";
                      break;
                    }
                    case ".js": {
                      language = "javascript";
                      break;
                    }
                    case ".sql": {
                      if (entry.treeItem.details.dbType === "Sqlite" /* Sqlite */) {
                        language = "sql";
                      }
                      break;
                    }
                    default:
                  }
                  const details = {
                    scriptId: uuid(),
                    name,
                    content,
                    language
                  };
                  let scripts = this.#openScripts.get(provider);
                  if (!scripts) {
                    scripts = /* @__PURE__ */ new Map();
                    this.#openScripts.set(provider, scripts);
                  }
                  scripts.set(details.scriptId, uri);
                  void provider.editScript(String(entry.treeItem.details.id), details);
                }
              });
            }
          }
        });
      }
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand(
      "msg.mds.createConnectionViaBastionService",
      (item) => {
        if (item) {
          const provider = this.#host.currentProvider;
          void provider?.addConnection(item.dbSystem, item.profile.profile);
        }
      }
    ));
    context.subscriptions.push(import_vscode15.commands.registerTextEditorCommand(
      "msg.executeEmbeddedSqlFromEditor",
      (editor) => {
        if (editor) {
          void host2.determineConnection().then((connection) => {
            if (connection) {
              this.#codeBlocks.executeSqlFromEditor(
                editor,
                connection.treeItem.details.caption,
                connection.treeItem.details.id
              );
            }
          });
        }
      }
    ));
    context.subscriptions.push(import_vscode15.commands.registerTextEditorCommand(
      "msg.executeSelectedSqlFromEditor",
      (editor) => {
        if (editor) {
          void host2.determineConnection().then((connection) => {
            if (connection) {
              const provider = this.#host.currentProvider;
              if (provider) {
                let sql = "";
                if (!editor.selection.isEmpty) {
                  editor.selections.forEach((selection) => {
                    sql += editor.document.getText(selection);
                  });
                } else {
                  sql = editor.document.getText();
                }
                return provider.runScript(String(connection.treeItem.details.id), {
                  scriptId: uuid(),
                  content: sql,
                  language: this.languageFromConnection(connection)
                });
              }
            }
          });
        }
      }
    ));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.closeEditor", (entry) => {
      if (entry) {
        const provider = entry.parent.parent.provider;
        if (provider instanceof DBConnectionViewProvider) {
          void provider.closeEditor(entry.parent.connectionId, entry.id);
        }
      }
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand(
      "msg.newNotebookMysql",
      (entry) => {
        void this.createNewEditor({ entry, language: "msg" });
      }
    ));
    context.subscriptions.push(import_vscode15.commands.registerCommand(
      "msg.newNotebookSqlite",
      (entry) => {
        void this.createNewEditor({ entry, language: "msg" });
      }
    ));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.newScriptJs", (entry) => {
      void this.createNewEditor({ entry, language: "javascript" });
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.newScriptMysql", (entry) => {
      void this.createNewEditor({ entry, language: "mysql" });
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand(
      "msg.newScriptSqlite",
      (entry) => {
        void this.createNewEditor({ entry, language: "sql" });
      }
    ));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.newScriptTs", (entry) => {
      void this.createNewEditor({ entry, language: "typescript" });
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.mrs.addDbObject", (entry) => {
      if (entry) {
        let objectType;
        if (entry.type === "routine") {
          objectType = entry.treeItem.dbType.toUpperCase();
        } else {
          objectType = entry.type.toUpperCase();
        }
        const item = entry.treeItem;
        if (objectType === "TABLE" || objectType === "VIEW" || objectType === "PROCEDURE") {
          this.createNewDbObject(entry.treeItem.backend, item, objectType).then((dbObject) => {
            const provider = this.#host.currentProvider;
            void provider?.editMrsDbObject(
              String(item.connectionId),
              { dbObject, createObject: true }
            );
          }).catch((reason) => {
            void import_vscode15.window.showErrorMessage(`${String(reason)}`);
          });
        } else {
          void import_vscode15.window.showErrorMessage(
            `The database object type '${objectType}' is not supported at this time`
          );
        }
      }
    }));
    context.subscriptions.push(import_vscode15.commands.registerCommand("msg.mrs.editDbObject", (entry) => {
      if (entry) {
        const provider = this.#host.currentProvider;
        void provider?.editMrsDbObject(
          String(entry.treeItem.connectionId),
          { dbObject: entry.treeItem.value, createObject: false }
        );
      }
    }));
  }
  /**
   * Triggered on authentication, which means existing connections are no longer valid.
   */
  async refreshConnectionTree() {
    await this.connectionsProvider.closeAllConnections();
    this.connectionsProvider.refresh();
  }
  clear() {
    this.#openEditorsTreeDataProvider.clear();
  }
  providerClosed(provider) {
    this.#openScripts.delete(provider);
    if (this.#openEditorsTreeDataProvider.clear(provider)) {
      this.connectionsProvider.resetCurrentSchemas();
    }
  }
  /**
   * Helper to create a unique caption for a new provider.
   *
   * @returns The new caption.
   */
  generateNewProviderCaption() {
    return this.#openEditorsTreeDataProvider.createUniqueCaption();
  }
  providerStateChanged(provider, active) {
    this.connectionsProvider.providerStateChanged(provider, active);
  }
  createNewDbObject = async (backend, item, objectType) => {
    const dbObject = {
      comments: "",
      crudOperations: objectType === "PROCEDURE" ? ["UPDATE"] : ["READ"],
      crudOperationFormat: "FEED",
      dbSchemaId: "",
      enabled: 1,
      id: "",
      name: item.name,
      objectType,
      requestPath: `/${snakeToCamelCase(item.name)}`,
      requiresAuth: 1,
      rowUserOwnershipEnforced: 0,
      serviceId: "",
      autoDetectMediaType: 0
    };
    const services = await backend.mrs.listServices();
    let service;
    if (services.length === 1) {
      service = services[0];
    } else if (services.length > 1) {
      service = services.find((service2) => {
        return service2.isCurrent;
      });
      if (!service) {
        const items = services.map((s) => {
          return s.urlContextRoot;
        });
        const name = await import_vscode15.window.showQuickPick(items, {
          title: "Select a connection for SQL execution",
          matchOnDescription: true,
          placeHolder: "Type the name of an existing DB connection"
        });
        if (name) {
          service = services.find((candidate) => {
            return candidate.urlContextRoot === name;
          });
        }
      }
    }
    if (service) {
      const schemas = await backend.mrs.listSchemas(service.id);
      const schema = schemas.find((schema2) => {
        return schema2.name === item.schema;
      });
      dbObject.schemaName = item.schema;
      if (schema) {
        dbObject.dbSchemaId = schema.id;
      } else {
        const answer = await import_vscode15.window.showInformationMessage(
          `The database schema ${item.schema} has not been added to the REST Service. Do you want to add the schema now?`,
          "Yes",
          "No"
        );
        if (answer === "Yes") {
          dbObject.dbSchemaId = await backend.mrs.addSchema(
            service.id,
            item.schema,
            `/${snakeToCamelCase(item.schema)}`,
            false,
            null,
            null,
            void 0
          );
          void import_vscode15.commands.executeCommand("msg.refreshConnections");
          showMessageWithTimeout(`The MRS schema ${item.schema} has been added successfully.`, 5e3);
        } else {
          throw new Error("Operation cancelled.");
        }
      }
    } else {
      if (services.length === 0) {
        throw new Error("Please create a REST Service before adding DB Objects.");
      } else {
        throw new Error("No REST Service selected.");
      }
    }
    return dbObject;
  };
  connectedToUrl = (url) => {
    this.#isConnected = url !== void 0;
    if (this.#displayDbConnectionOverviewWhenConnected) {
      this.#displayDbConnectionOverviewWhenConnected = false;
      void import_vscode15.commands.executeCommand("msg.openDBBrowser");
    }
    return Promise.resolve(true);
  };
  /**
   * Triggered from CodeBlocks when an embedded query must be executed.
   *
   * @param details The request to send to the app.
   *
   * @returns A promise returning a flag if the task was successfully executed or not.
   */
  editorRunQuery = (details) => {
    const provider = this.#host.currentProvider;
    if (provider) {
      return provider.runQuery(details.data.connectionId, {
        linkId: details.linkId,
        query: details.query,
        data: {},
        parameters: []
      });
    }
    return Promise.resolve(false);
  };
  editorLoadScript = (details) => {
    const filters = {};
    switch (details.language) {
      case "mysql": {
        filters.SQL = ["mysql", "sql"];
        break;
      }
      case "sql": {
        filters.SQL = ["sql"];
        break;
      }
      case "typescript": {
        filters.TypeScript = ["ts"];
        break;
      }
      case "javascript": {
        filters.JavaScript = ["js"];
        break;
      }
      default:
    }
    void import_vscode15.window.showOpenDialog({
      title: "Load Script File",
      filters,
      canSelectFiles: true,
      canSelectFolders: false,
      canSelectMany: false
    }).then((list) => {
      if (list.length > 0) {
        void import_vscode15.workspace.fs.readFile(list[0]).then((content) => {
          const provider = this.#host.currentProvider;
          if (provider) {
            const scripts = this.#openScripts.get(provider);
            if (scripts) {
              scripts.set(details.scriptId, list[0]);
              const newName = (0, import_path5.basename)(list[0].fsPath);
              void provider.renameFile({
                scriptId: details.scriptId,
                name: newName,
                language: details.language,
                content: details.content
              });
              void requisitions.execute(
                "editorSaved",
                { id: details.scriptId, newName, saved: false }
              );
            }
            details.content = content.toString();
            const connectionId = this.#openEditorsTreeDataProvider.currentConnectionId(provider) ?? -1;
            void provider.loadScript(String(connectionId), details);
          }
        });
      }
    });
    return Promise.resolve(true);
  };
  editorSaveScript = (details) => {
    const provider = this.#host.currentProvider;
    if (provider) {
      const scripts = this.#openScripts.get(provider);
      if (scripts) {
        const uri = scripts.get(details.scriptId);
        if (uri) {
          if (uri.scheme === "untitled") {
            const filters = {};
            switch (details.language) {
              case "mysql": {
                filters.SQL = ["mysql", "sql"];
                break;
              }
              case "sql": {
                filters.SQL = ["sql"];
                break;
              }
              case "typescript": {
                filters.TypeScript = ["ts"];
                break;
              }
              case "javascript": {
                filters.JavaScript = ["js"];
                break;
              }
              default:
            }
            void import_vscode15.window.showSaveDialog({
              title: "Save Script File",
              filters
            }).then((value) => {
              if (value) {
                const newName = (0, import_path5.basename)(value.fsPath);
                scripts.set(details.scriptId, value);
                void provider.renameFile({
                  scriptId: details.scriptId,
                  name: newName,
                  language: details.language,
                  content: details.content
                });
                const buffer = Buffer.from(details.content, "utf-8");
                void import_vscode15.workspace.fs.writeFile(value, buffer);
                void requisitions.execute(
                  "editorSaved",
                  { id: details.scriptId, newName, saved: value !== void 0 }
                );
              }
            });
          } else {
            const buffer = Buffer.from(details.content, "utf-8");
            void import_vscode15.workspace.fs.writeFile(uri, buffer);
          }
        }
      }
    }
    return Promise.resolve(true);
  };
  createNewEditor = (params) => {
    return new Promise((resolve) => {
      let connectionId = -1;
      let provider;
      if (params.entry?.parent?.provider) {
        connectionId = params.entry.connectionId;
        provider = params.entry.parent.provider;
      } else {
        provider = this.#host.currentProvider;
        if (provider) {
          connectionId = this.#openEditorsTreeDataProvider.currentConnectionId(provider) ?? -1;
        }
      }
      if (connectionId === -1) {
        void import_vscode15.window.showErrorMessage("Please select a connection first.");
        resolve(false);
        return;
      }
      void import_vscode15.workspace.openTextDocument({ language: params.language, content: params.content }).then((document2) => {
        const dbProvider = params.provider ? params.provider : provider;
        if (provider) {
          const name = (0, import_path5.basename)(document2.fileName);
          if (params.language === "msg") {
            void dbProvider.createNewEditor({
              page: String(connectionId),
              language: params.language,
              content: params.content
            });
          } else {
            const request = {
              scriptId: uuid(),
              name,
              content: document2.getText(),
              language: params.language
            };
            let scripts = this.#openScripts.get(dbProvider);
            if (!scripts) {
              scripts = /* @__PURE__ */ new Map();
              this.#openScripts.set(dbProvider, scripts);
            }
            scripts.set(request.scriptId, document2.uri);
            void dbProvider.editScript(String(connectionId), request);
          }
        }
        resolve(true);
      });
    });
  };
  languageFromConnection = (entry) => {
    switch (entry.treeItem.details.dbType) {
      case "MySQL" /* MySQL */: {
        return "mysql";
      }
      default: {
        return "sql";
      }
    }
  };
  proxyRequest = (request) => {
    switch (request.original.requestType) {
      case "editorSaveScript": {
        const response = request.original.parameter;
        return this.editorSaveScript(response);
      }
      case "editorLoadScript": {
        const response = request.original.parameter;
        return this.editorLoadScript(response);
      }
      case "createNewEditor": {
        const response = request.original.parameter;
        return this.createNewEditor({
          provider: request.provider,
          language: response.language,
          content: response.content
        });
      }
      default:
    }
    return Promise.resolve(false);
  };
};

// src/editor-providers/NotebookEditorProvider.ts
var import_vscode16 = require("vscode");
var import_promises2 = require("fs/promises");

// ../frontend/src/supplement/Semaphore.ts
var Semaphore = class {
  // The list of waiters (promises) that are waiting for a notification.
  #waiters = [];
  /**
   * Adds a new waiter to the semaphore, to be notified when one of the notification methods is called.
   *
   * @param timeout An optional timeout value (in milliseconds).
   *
   * @returns A promise that resolves to true if triggered by a notification, otherwise false (in case of a timeout).
   *          If a value was specified in the notification, the promise resolves to that value.
   */
  wait(timeout) {
    const waiter = { timeout: null, resolve: () => {
    } };
    this.#waiters.push(waiter);
    const promise = new Promise((resolve) => {
      let resolved = false;
      waiter.resolve = (noRemove, value) => {
        if (resolved) {
          return;
        }
        resolved = true;
        if (waiter.timeout) {
          clearTimeout(waiter.timeout);
          waiter.timeout = null;
        }
        if (!noRemove) {
          const pos = this.#waiters.indexOf(waiter);
          if (pos > -1) {
            this.#waiters.splice(pos, 1);
          }
        }
        if (value === void 0) {
          resolve(true);
        } else {
          resolve(value);
        }
      };
    });
    if (timeout !== void 0 && timeout > 0 && isFinite(timeout)) {
      waiter.timeout = setTimeout(() => {
        waiter.timeout = null;
        waiter.resolve(false);
      }, timeout);
    }
    return promise;
  }
  /**
   * Notifies one waiter and removes that from the internal list of waiters.
   *
   * @param value An optional value that is passed to the waiter.
   */
  notify(value) {
    const waiter = this.#waiters.pop();
    waiter?.resolve(true, value);
  }
  /**
   * Notifies all waiters in reverse order and clears the internal list.
   *
   * @param value An optional value that is passed to the waiters.
   */
  notifyAll(value) {
    const list = this.#waiters.reverse();
    this.#waiters = [];
    let waiter;
    while ((waiter = list.pop()) !== void 0) {
      waiter.resolve(true, value);
    }
  }
};

// src/editor-providers/NotebookEditorProvider.ts
var NotebookEditorProvider = class {
  #host;
  #url;
  #requisitions;
  // True if the connections list was updated at least once, after a URL was connected.
  #connectionsAvailable = false;
  // Signals that the URL is ready to be used.
  #urlReady = new Semaphore();
  // Signals that the connections list is ready to be used.
  #connectionsReady = new Semaphore();
  #document;
  #saving = false;
  #panel;
  #disposables = [];
  setup(host2) {
    this.#host = host2;
    requisitions.register("connectionsUpdated", this.handleConnectionsUpdated);
    requisitions.register("connectedToUrl", this.handleConnectToUrl);
    host2.context.subscriptions.push(import_vscode16.window.registerCustomEditorProvider("msg.notebook", this, {
      webviewOptions: {
        retainContextWhenHidden: true
      }
    }));
    host2.context.subscriptions.push(import_vscode16.workspace.onDidDeleteFiles((event) => {
      for (const file of event.files) {
        if (file.fsPath.endsWith(".mysql-notebook")) {
          void host2.context.workspaceState.update(file.toString(), void 0);
        }
      }
    }));
    host2.context.subscriptions.push(import_vscode16.workspace.onDidRenameFiles((event) => {
      for (const file of event.files) {
        let usedConnectionId = -1;
        if (file.oldUri.fsPath.endsWith(".mysql-notebook")) {
          usedConnectionId = host2.context.workspaceState.get(file.oldUri.toString(), -1);
          void host2.context.workspaceState.update(file.oldUri.toString(), void 0);
        }
        if (file.newUri.fsPath.endsWith(".mysql-notebook")) {
          void host2.context.workspaceState.update(file.newUri.toString(), usedConnectionId);
        }
      }
    }));
    host2.context.subscriptions.push(import_vscode16.commands.registerCommand("msg.openNotebookWithConnection", (uri) => {
      if (!uri) {
        return;
      }
      void host2.determineConnection("MySQL" /* MySQL */, true).then((connection) => {
        if (connection) {
          void import_vscode16.workspace.openTextDocument(uri).then((document2) => {
            const item = connection.treeItem;
            void import_vscode16.commands.executeCommand("vscode.openWith", uri, "msg.notebook").then(() => {
              void host2.context.workspaceState.update(document2.uri.toString(), item.details.id);
              void this.showNotebookPage(item.details.id, document2.getText());
            });
          });
        }
      });
    }));
  }
  /**
   * Prepares the webview for the new document, by loading its initial content and wiring it about for
   * synchronization with the document.
   *
   * @param document The document which holds the content for the webview.
   * @param webviewPanel The webview panel which will display the content.
   *
   * @returns A promise which resolves when the webview is ready to be used.
   */
  resolveCustomTextEditor(document2, webviewPanel) {
    return new Promise((resolve) => {
      void this.setupWebview(document2, webviewPanel).then(() => {
        resolve();
      });
    });
  }
  /**
   * Opens a new script editor in the webview tab and loads the given content into it.
   *
   * @param connectionId The id of the connection to use for the notebook.
   * @param content The content of the script to run and other related information.
   *
   * @returns A promise which resolves after the command was executed.
   */
  showNotebookPage(connectionId, content) {
    return Promise.resolve(this.#requisitions?.executeRemote("job", [
      { requestType: "showModule", parameter: DBEditorModuleId },
      {
        requestType: "showPage",
        parameter: {
          module: DBEditorModuleId,
          page: String(connectionId),
          suppressAbout: true,
          noEditor: true
        }
      },
      { requestType: "editorLoadNotebook", parameter: { content, standalone: true } }
    ]) ?? true);
  }
  /**
   * This handler is called on every connection list refresh. This can be the initial load of the
   * connections, or a refresh triggered by the user. Also when connecting to a different
   * backend, this handler is called again.
   *
   * @returns A promise which resolves after the command was executed.
   */
  handleConnectionsUpdated = () => {
    this.#connectionsAvailable = true;
    if (this.#document && this.#panel) {
      const connectionId = this.#host.context.workspaceState.get(this.#document.uri.toString());
      if (!this.isValidConnectionId(connectionId)) {
        if (this.#document.isDirty) {
          void this.#document.save().then(() => {
            this.#panel.dispose();
            return Promise.resolve(true);
          });
        } else {
          this.#panel.dispose();
          return Promise.resolve(true);
        }
      }
    }
    this.#connectionsReady.notifyAll();
    return Promise.resolve(true);
  };
  /**
   * This handler is called when the extension connects the first time to the backend or when
   * the user switches the backend URL.
   *
   * @param url The URL of the backend.
   *
   * @returns A promise which resolves after the command was executed.
   */
  handleConnectToUrl = (url) => {
    if (this.#url) {
      this.#panel?.dispose();
      return Promise.resolve(true);
    }
    this.#url = url;
    this.#connectionsAvailable = false;
    this.#urlReady.notifyAll();
    return Promise.resolve(true);
  };
  /**
   * Promisified setup routine. The caller uses this to wait for the webview to be ready.
   *
   * @param document The document which holds the content for the webview.
   * @param webviewPanel The webview panel which will display the content.
   *
   * @returns A promise which resolves when the webview is ready to be used.
   */
  async setupWebview(document2, webviewPanel) {
    webviewPanel.webview.html = "<br/><h2>Loading...</h2>";
    if (!this.#url) {
      await this.#urlReady.wait();
    }
    prepareWebviewContent(webviewPanel, this.#url);
    if (!this.#connectionsAvailable) {
      await this.#connectionsReady.wait();
    }
    let usedConnectionId = this.#host.context.workspaceState.get(document2.uri.toString());
    if (!this.isValidConnectionId(usedConnectionId)) {
      usedConnectionId = void 0;
      await this.#host.context.workspaceState.update(document2.uri.toString(), void 0);
    }
    if (usedConnectionId === void 0) {
      const connection = await this.#host.determineConnection("MySQL" /* MySQL */);
      if (connection) {
        usedConnectionId = connection.treeItem.details.id;
      }
    }
    if (usedConnectionId !== void 0) {
      this.#panel = webviewPanel;
      this.#document = document2;
      void this.#host.context.workspaceState.update(document2.uri.toString(), usedConnectionId);
      webviewPanel.webview.options = {
        ...webviewPanel.webview.options,
        enableScripts: true
      };
      this.#requisitions = new RequisitionHub("host");
      this.#requisitions.setRemoteTarget(webviewPanel.webview);
      this.#requisitions.register("editorChanged", async () => {
        await this.makeDocumentDirty();
        return Promise.resolve(true);
      });
      this.#requisitions.register("editorSaveNotebook", this.triggerSave);
      this.#requisitions.register("editorLoadNotebook", this.triggerLoad);
      this.#requisitions.register("applicationDidStart", () => {
        return this.showNotebookPage(usedConnectionId, document2.getText());
      });
      this.#disposables.push(webviewPanel.webview.onDidReceiveMessage((message) => {
        if (message.source === "app") {
          this.#requisitions?.handleRemoteMessage(message);
        }
      }));
      this.#disposables.push(webviewPanel.onDidChangeViewState((event) => {
        if (event.webviewPanel.active) {
        }
      }));
      this.#disposables.push(import_vscode16.workspace.onWillSaveTextDocument((event) => {
        if (event.document.uri.toString() === this.#document?.uri.toString()) {
          event.waitUntil(this.saveNotebook());
        }
      }));
      this.#disposables.push(this.#panel.onDidDispose(() => {
        this.handleDispose();
      }));
    } else {
      webviewPanel.webview.html = "<br/><h2>No connection selected</h2>";
    }
  }
  /**
   * @param connectionId The connection id to check.
   *
   * @returns true if the given connection id exists in the connection list.
   */
  isValidConnectionId(connectionId) {
    return connectionId !== void 0 && this.#host.connections.find((c) => {
      return c.treeItem.details.id === connectionId;
    }) !== void 0;
  }
  handleDispose() {
    this.#disposables.forEach((d3) => {
      d3.dispose();
    });
    this.#panel = void 0;
  }
  /**
   * Causes our document to be dirty, without really changing something.
   * This is mostly for the dirty indicator in the tab.
   */
  async makeDocumentDirty() {
    if (this.#document) {
      const edits = new import_vscode16.WorkspaceEdit();
      edits.insert(this.#document.uri, new import_vscode16.Position(0, 0), " ");
      await import_vscode16.workspace.applyEdit(edits);
      const edits2 = new import_vscode16.WorkspaceEdit();
      edits2.delete(this.#document.uri, new import_vscode16.Range(new import_vscode16.Position(0, 0), new import_vscode16.Position(0, 1)));
      await import_vscode16.workspace.applyEdit(edits2);
    }
  }
  /**
   * Called from the extension to save the notebook file.
   *
   * @returns A promise which resolves always.
   */
  saveNotebook() {
    if (!this.#saving) {
      this.#requisitions.executeRemote("editorSaveNotebook", void 0);
    }
    return Promise.resolve();
  }
  /**
   * Called from the provider requisitions hub to save the notebook file. This event is triggered either by the
   * `saveNotebook()` method or by a save action in the application.
   *
   * @param content The content of the notebook.
   *
   * @returns A promise which resolves always.
   */
  triggerSave = async (content) => {
    if (this.#document && content) {
      const edit = new import_vscode16.WorkspaceEdit();
      edit.replace(this.#document.uri, new import_vscode16.Range(0, 0, this.#document.lineCount, 0), content);
      await import_vscode16.workspace.applyEdit(edit);
      this.#saving = true;
      await this.#document.save();
      this.#saving = false;
    }
    return Promise.resolve(true);
  };
  /**
   * Called from the provider requisitions hub to load a notebook file. The handling here (in contrast to
   * DBConnectionProvider) is a bit different, because we don't want to create a new notebook editor, but
   * instead replace the content of the current one.
   *
   * @returns A promise which resolves always.
   */
  triggerLoad = async () => {
    const dialogOptions = {
      title: "",
      canSelectFiles: true,
      canSelectFolders: false,
      canSelectMany: false,
      filters: {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        "MySQL Notebook": ["mysql-notebook"]
      },
      openLabel: "Open Notebook"
    };
    const paths = await import_vscode16.window.showOpenDialog(dialogOptions);
    if (paths && paths.length > 0) {
      const path25 = paths[0].fsPath;
      const content = await (0, import_promises2.readFile)(path25, { encoding: "utf-8" });
      if (this.#document) {
        const edit = new import_vscode16.WorkspaceEdit();
        edit.replace(this.#document.uri, new import_vscode16.Range(0, 0, this.#document.lineCount, 0), content);
        await import_vscode16.workspace.applyEdit(edit);
        this.#requisitions.executeRemote("editorLoadNotebook", { content, standalone: true });
      }
    }
    return true;
  };
};

// src/MDSCommandHandler.ts
var import_vscode27 = require("vscode");
var import_os2 = require("os");
var import_fs5 = require("fs");

// src/tree-providers/OCITreeProvider/OciBaseTreeItem.ts
var path12 = __toESM(require("path"), 1);
var import_vscode17 = require("vscode");
var OciBaseTreeItem = class extends import_vscode17.TreeItem {
  constructor(name, profile, collapsibleState = import_vscode17.TreeItemCollapsibleState.None) {
    super(name, collapsibleState);
    this.name = name;
    this.profile = profile;
    this.iconPath = {
      light: path12.join(__dirname, "..", "images", "light", this.iconName),
      dark: path12.join(__dirname, "..", "images", "dark", this.iconName)
    };
  }
  get iconName() {
    return "folder.svg";
  }
};

// src/tree-providers/OCITreeProvider/OciBastionTreeItem.ts
var path13 = __toESM(require("path"), 1);
var import_vscode18 = require("vscode");
var OciBastionTreeItem = class extends OciBaseTreeItem {
  constructor(profile, compartment, bastion) {
    super(bastion.name, profile, import_vscode18.TreeItemCollapsibleState.None);
    this.compartment = compartment;
    this.bastion = bastion;
    let iconName = bastion.isCurrent ? "ociBastionCurrent.svg" : "ociBastion.svg";
    if (bastion.lifecycleState !== "ACTIVE") {
      iconName = bastion.isCurrent ? "ociBastionCurrentNotActive.svg" : "ociBastionNotActive.svg";
    }
    this.iconPath = {
      light: path13.join(__dirname, "..", "images", "light", iconName),
      dark: path13.join(__dirname, "..", "images", "dark", iconName)
    };
  }
  contextValue = "mdsBastion";
};

// src/tree-providers/OCITreeProvider/OciCompartmentTreeItem.ts
var path14 = __toESM(require("path"), 1);
var import_vscode19 = require("vscode");
var OciCompartmentTreeItem = class extends OciBaseTreeItem {
  constructor(profile, compartment, collapsibleState = import_vscode19.TreeItemCollapsibleState.Collapsed) {
    super(compartment.isCurrent ? `${compartment.name} (Default)` : compartment.name, profile, collapsibleState);
    this.compartment = compartment;
    const iconName = compartment.isCurrent ? "folderCurrent.svg" : "folder.svg";
    this.iconPath = {
      light: path14.join(__dirname, "..", "images", "light", iconName),
      dark: path14.join(__dirname, "..", "images", "dark", iconName)
    };
  }
  contextValue = "mdsCompartment";
};

// src/tree-providers/OCITreeProvider/OciComputeInstanceTreeItem.ts
var import_vscode20 = require("vscode");
var OciComputeInstanceTreeItem = class extends OciBaseTreeItem {
  constructor(profile, compartment, compute, shellSession) {
    super(compute.displayName ?? "<unknown>", profile, import_vscode20.TreeItemCollapsibleState.None);
    this.compartment = compartment;
    this.compute = compute;
    this.shellSession = shellSession;
  }
  contextValue = "mdsComputeInstance";
  get iconName() {
    return "ociCompute.svg";
  }
};

// src/tree-providers/OCITreeProvider/OciDbSystemTreeItem.ts
var OciDbSystemTreeItem = class extends OciBaseTreeItem {
  constructor(profile, compartment, dbSystem, treeState) {
    super(dbSystem.displayName, profile, treeState);
    this.compartment = compartment;
    this.dbSystem = dbSystem;
  }
  contextValue = "mdsDbSystem";
};

// src/tree-providers/OCITreeProvider/OciLoadBalancerTreeItem.ts
var path15 = __toESM(require("path"), 1);
var import_vscode21 = require("vscode");
var OciLoadBalancerTreeItem = class extends OciBaseTreeItem {
  constructor(profile, compartment, loadBalancer) {
    super(loadBalancer.displayName, profile, import_vscode21.TreeItemCollapsibleState.None);
    this.compartment = compartment;
    this.loadBalancer = loadBalancer;
    let iconName = "ociLoadBalancer.svg";
    if (loadBalancer.lifecycleState !== "ACTIVE") {
      iconName = "ociLoadBalancerNotActive.svg";
    }
    this.iconPath = {
      light: path15.join(__dirname, "..", "images", "light", iconName),
      dark: path15.join(__dirname, "..", "images", "dark", iconName)
    };
  }
  contextValue = "mdsLoadBalancer";
};

// src/tree-providers/OCITreeProvider/OciProfileTreeItem.ts
var path16 = __toESM(require("path"), 1);
var import_vscode22 = require("vscode");
var OciConfigProfileTreeItem = class extends OciBaseTreeItem {
  contextValue = "mdsConfigProfile";
  constructor(profile) {
    super(profile.profile + ` (${profile.region})`, profile, import_vscode22.TreeItemCollapsibleState.Collapsed);
    const iconName = profile.isCurrent ? "ociProfileCurrent.svg" : "ociProfile.svg";
    this.iconPath = {
      light: path16.join(__dirname, "..", "images", "light", iconName),
      dark: path16.join(__dirname, "..", "images", "dark", iconName)
    };
  }
};

// src/tree-providers/OCITreeProvider/OciTreeProvider.ts
var import_vscode26 = require("vscode");

// src/tree-providers/OCITreeProvider/OciDbSystemHWTreeItem.ts
var path17 = __toESM(require("path"), 1);
var import_vscode23 = require("vscode");
var OciDbSystemHWTreeItem = class extends OciDbSystemTreeItem {
  constructor(profile, compartment, dbSystem) {
    super(profile, compartment, dbSystem, import_vscode23.TreeItemCollapsibleState.Collapsed);
    this.compartment = compartment;
    this.dbSystem = dbSystem;
    let iconName = "ociDbSystemHWNotActive.svg";
    if (dbSystem.lifecycleState === "ACTIVE") {
      iconName = "ociDbSystemHW.svg";
    } else if (dbSystem.lifecycleState === "INACTIVE" || dbSystem.lifecycleState === "FAILED") {
      iconName = "ociDbSystemHWStopped.svg";
    }
    this.iconPath = {
      light: path17.join(__dirname, "..", "images", "light", iconName),
      dark: path17.join(__dirname, "..", "images", "dark", iconName)
    };
  }
  contextValue = "mdsDbSystemHW";
};

// src/tree-providers/OCITreeProvider/OciDbSystemStandaloneTreeItem.ts
var path18 = __toESM(require("path"), 1);
var import_vscode24 = require("vscode");
var OciDbSystemStandaloneTreeItem = class extends OciDbSystemTreeItem {
  constructor(profile, compartment, dbSystem) {
    super(profile, compartment, dbSystem, import_vscode24.TreeItemCollapsibleState.None);
    this.compartment = compartment;
    this.dbSystem = dbSystem;
    let iconName = "ociDbSystemNotActive.svg";
    if (dbSystem.lifecycleState === "ACTIVE") {
      iconName = "ociDbSystem.svg";
    } else if (dbSystem.lifecycleState === "INACTIVE" || dbSystem.lifecycleState === "FAILED") {
      iconName = "ociDbSystemStopped.svg";
    }
    this.iconPath = {
      light: path18.join(__dirname, "..", "images", "light", iconName),
      dark: path18.join(__dirname, "..", "images", "dark", iconName)
    };
  }
  contextValue = "mdsDbSystem";
};

// src/tree-providers/OCITreeProvider/OciHWClusterTreeItem.ts
var path19 = __toESM(require("path"), 1);
var import_vscode25 = require("vscode");
var OciHWClusterTreeItem = class extends OciBaseTreeItem {
  constructor(profile, compartment, dbSystem) {
    super(
      `HeatWave Cluster (${dbSystem.heatWaveCluster?.clusterSize ?? ""} node${(dbSystem.heatWaveCluster?.clusterSize ?? 0) > 1 ? "s" : ""})`,
      profile,
      import_vscode25.TreeItemCollapsibleState.None
    );
    this.compartment = compartment;
    this.dbSystem = dbSystem;
    let iconName = "ociComputeNotActive.svg";
    if (dbSystem.heatWaveCluster && dbSystem.heatWaveCluster.lifecycleState === "ACTIVE") {
      iconName = "ociCompute.svg";
    } else if (dbSystem.heatWaveCluster && (dbSystem.heatWaveCluster.lifecycleState === "INACTIVE" || dbSystem.heatWaveCluster.lifecycleState === "FAILED")) {
      iconName = "ociComputeStopped.svg";
    }
    this.iconPath = {
      light: path19.join(__dirname, "..", "images", "light", iconName),
      dark: path19.join(__dirname, "..", "images", "dark", iconName)
    };
  }
  contextValue = "mdsHWCluster";
};

// src/tree-providers/OCITreeProvider/OciTreeProvider.ts
var OciTreeDataProvider = class {
  changeEvent = new import_vscode26.EventEmitter();
  shellSession = new ShellInterfaceShellSession();
  // The cache of compartments for each config profile
  compartmentCache = {};
  constructor() {
    requisitions.register("proxyRequest", this.proxyRequest);
  }
  dispose() {
    requisitions.register("proxyRequest", this.proxyRequest);
  }
  get onDidChangeTreeData() {
    return this.changeEvent.event;
  }
  refresh(item) {
    this.compartmentCache = {};
    void this.listConfigProfiles().then(() => {
      this.changeEvent.fire(item);
    });
  }
  getTreeItem(element) {
    return element;
  }
  getChildren(element) {
    if (MessageScheduler.get.isConnected) {
      if (!element) {
        return this.listConfigProfiles();
      }
      if (element instanceof OciConfigProfileTreeItem) {
        return this.listCompartments(element.profile, true, element.profile.tenancy);
      }
      if (element instanceof OciCompartmentTreeItem) {
        return new Promise((resolve, reject) => {
          Promise.all([
            this.listCompartments(element.profile, false, element.compartment.id),
            this.listDatabases(element.profile, element.compartment),
            this.listComputeInstances(element.profile, element.compartment),
            this.listBastionHosts(element.profile, element.compartment),
            this.listLoadBalancers(element.profile, element.compartment)
          ]).then(([
            compartmentItems,
            databaseItems,
            computeInstanceItems,
            bastionHostItems,
            loadBalancerItems
          ]) => {
            resolve([
              ...compartmentItems,
              ...databaseItems,
              ...computeInstanceItems,
              ...bastionHostItems,
              ...loadBalancerItems
            ]);
          }).catch((reason) => {
            reject(reason);
          });
        });
      }
      if (element instanceof OciDbSystemHWTreeItem) {
        if (element.dbSystem.heatWaveCluster && element.dbSystem.heatWaveCluster.lifecycleState !== "DELETED") {
          return [new OciHWClusterTreeItem(element.profile, element.compartment, element.dbSystem)];
        } else {
          return [];
        }
      }
    }
  }
  async listConfigProfiles() {
    const profiles = await this.shellSession.mds.getMdsConfigProfiles();
    return profiles.map((profile) => {
      return new OciConfigProfileTreeItem(profile);
    });
  }
  addOciCompartmentTreeItem(items, profile, compartment, startWithCurrent, parentId) {
    if (startWithCurrent && compartment.isCurrent) {
      items.unshift(new OciCompartmentTreeItem(
        profile,
        compartment
        /*, TreeItemCollapsibleState.Expanded*/
      ));
    } else if (startWithCurrent && compartment.id === parentId || !startWithCurrent && parentId && compartment.compartmentId === parentId || !startWithCurrent && !parentId) {
      items.push(new OciCompartmentTreeItem(profile, compartment));
    }
  }
  async listCompartments(profile, startWithCurrent, compartmentId) {
    const items = [];
    if (this.compartmentCache[profile.profile]) {
      this.compartmentCache[profile.profile].forEach((subCompartment) => {
        this.addOciCompartmentTreeItem(
          items,
          profile,
          subCompartment,
          startWithCurrent,
          compartmentId
        );
      });
      return items;
    }
    try {
      const compartments = await this.shellSession.mds.getMdsCompartments(profile.profile);
      this.compartmentCache[profile.profile] = compartments;
      this.compartmentCache[profile.profile].forEach((subCompartment) => {
        this.addOciCompartmentTreeItem(items, profile, subCompartment, startWithCurrent, compartmentId);
      });
    } catch (reason) {
      const msg = reason?.data?.requestState?.msg;
      if (msg && msg.includes("NotAuthorizedOrNotFound")) {
        import_vscode26.window.setStatusBarMessage("Not authorized to list the sub-compartment of this compartment.", 5e3);
      }
    }
    return items;
  }
  async listDatabases(profile, compartment) {
    const items = [];
    try {
      const systems = await this.shellSession.mds.getMdsMySQLDbSystems(profile.profile, compartment.id);
      systems.forEach((dbSystem) => {
        if (dbSystem.isSupportedForHwCluster || dbSystem.isSupportedForAnalyticsCluster) {
          items.push(new OciDbSystemHWTreeItem(profile, compartment, dbSystem));
        } else {
          items.push(new OciDbSystemStandaloneTreeItem(profile, compartment, dbSystem));
        }
      });
    } catch (reason) {
      const msg = reason?.data?.requestState?.msg;
      if (msg && msg.includes("NotAuthorizedOrNotFound")) {
        import_vscode26.window.setStatusBarMessage("Not authorized to list the MySQL DB Systems in this compartment.", 5e3);
      }
    }
    return items;
  }
  async listComputeInstances(profile, compartment) {
    const items = [];
    try {
      const instances = await this.shellSession.mds.getMdsComputeInstances(profile.profile, compartment.id);
      instances.forEach((compute) => {
        items.push(new OciComputeInstanceTreeItem(profile, compartment, compute, this.shellSession));
      });
    } catch (reason) {
      const msg = reason?.data?.requestState?.msg;
      if (msg && msg.includes("NotAuthorizedOrNotFound")) {
        import_vscode26.window.setStatusBarMessage("Not authorized to list the compute instances in this compartment.", 5e3);
      }
    }
    return items;
  }
  async listBastionHosts(profile, compartment) {
    const items = [];
    try {
      const bastions = await this.shellSession.mds.getMdsBastions(profile.profile, compartment.id);
      bastions.forEach((bastion) => {
        items.push(new OciBastionTreeItem(profile, compartment, bastion));
      });
    } catch (reason) {
      const msg = reason?.data?.requestState?.msg;
      if (msg && msg.includes("NotAuthorizedOrNotFound")) {
        import_vscode26.window.setStatusBarMessage("Not authorized to list the bastions in this compartment.", 5e3);
      }
    }
    return items;
  }
  async listLoadBalancers(profile, compartment) {
    const items = [];
    try {
      const loadBalancers = await this.shellSession.mds.listLoadBalancers(profile.profile, compartment.id);
      loadBalancers.forEach((loadBalancer) => {
        items.push(new OciLoadBalancerTreeItem(profile, compartment, loadBalancer));
      });
    } catch (reason) {
      const msg = reason?.data?.requestState?.msg;
      if (msg && msg.includes("NotAuthorizedOrNotFound")) {
        import_vscode26.window.setStatusBarMessage("Not authorized to list the load balancers in this compartment.", 5e3);
      }
    }
    return items;
  }
  proxyRequest = (request) => {
    switch (request.original.requestType) {
      case "refreshOciTree": {
        this.refresh();
        return Promise.resolve(true);
      }
      default:
    }
    return Promise.resolve(false);
  };
};

// src/WebviewProviders/DialogWebviewProvider.ts
var DialogWebviewManager = class {
  // Standard dialog requests awaiting a response.
  pendingDialogRequests = /* @__PURE__ */ new Map();
  // Running special dialogs. Usually only one should be active at the same time.
  runningDialogs = /* @__PURE__ */ new Set();
  url;
  constructor() {
    requisitions.register("connectedToUrl", this.connectedToUrl);
    requisitions.register("proxyRequest", this.proxyRequest);
  }
  showDialog(request, caption) {
    if (!this.url) {
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      const provider = new WebviewProvider(this.url, this.handleDispose);
      provider.caption = caption;
      this.pendingDialogRequests.set(provider, resolve);
      void provider.runCommand("showDialog", request, caption);
    });
  }
  handleDispose = (view) => {
    const resolve = this.pendingDialogRequests.get(view);
    if (resolve) {
      resolve();
      this.pendingDialogRequests.delete(view);
    }
    this.runningDialogs.delete(view);
  };
  connectedToUrl = (url) => {
    this.url = url;
    this.pendingDialogRequests.clear();
    return Promise.resolve(true);
  };
  proxyRequest = (request) => {
    switch (request.original.requestType) {
      case "dialogResponse": {
        const response = request.original.parameter;
        const resolve = this.pendingDialogRequests.get(request.provider);
        if (resolve) {
          request.provider.close();
          this.pendingDialogRequests.delete(request.provider);
          resolve(response);
          return Promise.resolve(true);
        }
        break;
      }
      case "closeInstance": {
        request.provider.close();
        break;
      }
      default:
    }
    return Promise.resolve(false);
  };
};

// src/tree-providers/ConnectionsTreeProvider/SchemaTreeItem.ts
var SchemaTreeItem = class extends ConnectionsTreeBaseItem {
  contextValue = "schemaItem";
  get qualifiedName() {
    return `\`${this.name}\``;
  }
  get dbType() {
    return "schema";
  }
};

// src/tree-providers/ConnectionsTreeProvider/SchemaMySQLTreeItem.ts
var SchemaMySQLTreeItem = class extends SchemaTreeItem {
  contextValue = "schemaItemMySQL";
  constructor(name, schema, backend, connectionId, isCurrent, hasChildren, command) {
    super(
      name,
      schema,
      backend,
      connectionId,
      isCurrent ? "schemaMySQLCurrent.svg" : "schemaMySQL.svg",
      hasChildren,
      command
    );
  }
};

// src/MDSCommandHandler.ts
var MDSCommandHandler = class {
  dialogManager = new DialogWebviewManager();
  shellSession = new ShellInterfaceShellSession();
  ociTreeDataProvider;
  setup = (host2) => {
    this.ociTreeDataProvider = new OciTreeDataProvider();
    host2.context.subscriptions.push(import_vscode27.window.registerTreeDataProvider("msg.oci", this.ociTreeDataProvider));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand("msg.mds.refreshOciProfiles", () => {
      this.ociTreeDataProvider.refresh();
    }));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand("msg.mds.configureOciProfiles", () => {
      let ociConfigFilePath = `${(0, import_os2.homedir)()}/.oci/config`;
      if (process.env.MYSQLSH_OCI_CONFIG_FILE !== void 0) {
        ociConfigFilePath = process.env.MYSQLSH_OCI_CONFIG_FILE;
      }
      const configFile = import_vscode27.Uri.file(ociConfigFilePath);
      if (!(0, import_fs5.existsSync)(configFile.fsPath)) {
        const workspaceEdit = new import_vscode27.WorkspaceEdit();
        void workspaceEdit.createFile(configFile, { ignoreIfExists: true });
        void import_vscode27.workspace.applyEdit(workspaceEdit).then(() => {
          void import_vscode27.workspace.openTextDocument(configFile).then((doc) => {
            void import_vscode27.window.showTextDocument(doc, 1, false).then((editor) => {
              void editor.edit((edit) => {
                const firstLine = doc.lineAt(0);
                const lastLine = doc.lineAt(doc.lineCount - 1);
                const textRange = new import_vscode27.Range(firstLine.range.start, lastLine.range.end);
                edit.replace(
                  textRange,
                  ";To add a new OCI Profile, please follow these instructions.\n;https://docs.oracle.com/en-us/iaas/Content/API/Concepts/devguidesetupprereq.htm.\n;Then paste your OCI Config here, replacing these lines and save.\n;Click the Reload icon in the ORACLE CLOUD INFRASTRUCTURE View."
                );
              }).then(() => {
                const position = editor.selection.start;
                editor.selection = new import_vscode27.Selection(position, position);
              });
            });
          });
        });
      } else {
        void import_vscode27.workspace.openTextDocument(configFile).then((doc) => {
          void import_vscode27.window.showTextDocument(doc, 1, false);
        });
      }
    }));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.createRouterEndpoint",
      async (item) => {
        if (item?.dbSystem.id) {
          await this.showMdsEndpointDialog(item.dbSystem, item.compartment, item.profile, host2);
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.getProfileInfo",
      (item) => {
        if (item && item.profile.profile) {
          this.showNewJsonDocument(
            `${item.profile.profile.toString()} Info.json`,
            JSON.stringify(item.profile, null, 4)
          );
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.setDefaultProfile",
      async (item) => {
        if (item && item.profile.profile) {
          import_vscode27.window.setStatusBarMessage(`Setting current config profile to ${item.profile.profile} ...`, 1e4);
          try {
            await this.shellSession.mds.setDefaultConfigProfile(item.profile.profile);
            await import_vscode27.commands.executeCommand("msg.mds.refreshOciProfiles");
            import_vscode27.window.setStatusBarMessage(`Default config profile set to ${item.profile.profile}.`, 5e3);
          } catch (reason) {
            await import_vscode27.window.showErrorMessage(`Error while setting default config profile: ${String(reason)}`);
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.getCompartmentInfo",
      (item) => {
        if (item && item.compartment.id) {
          this.showNewJsonDocument(
            `${item.compartment.name.toString()} Info.json`,
            JSON.stringify(item.compartment, null, 4)
          );
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.setCurrentCompartment",
      async (item) => {
        if (item && item.compartment.id) {
          import_vscode27.window.setStatusBarMessage(`Setting current compartment to ${item.compartment.name} ...`, 1e4);
          try {
            await this.shellSession.mds.setCurrentCompartment({
              compartmentId: item.compartment.id,
              configProfile: item.profile.profile,
              interactive: false,
              raiseExceptions: true
            });
            await import_vscode27.commands.executeCommand("msg.mds.refreshOciProfiles");
            import_vscode27.window.setStatusBarMessage(`Current compartment set to ${item.compartment.name}.`, 5e3);
          } catch (reason) {
            await import_vscode27.window.showErrorMessage(`Error while setting current compartment: ${String(reason)}`);
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.getDbSystemInfo",
      async (item) => {
        if (item?.dbSystem.id) {
          try {
            const system = await this.shellSession.mds.getMdsMySQLDbSystem(
              item.profile.profile,
              item.dbSystem.id
            );
            this.showNewJsonDocument(
              `${item.dbSystem.displayName ?? "<unknown>"} Info.json`,
              JSON.stringify(system, null, 4)
            );
          } catch (reason) {
            void import_vscode27.window.showErrorMessage(`Error while fetching the DB System data: ${String(reason)}`);
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.startDbSystem",
      async (item) => {
        if (item?.dbSystem.id) {
          const shellArgs = [
            "--",
            "mds",
            "start",
            "db-system",
            `--db_system_id=${item.dbSystem.id.toString()}`,
            `--config_profile=${item.profile.profile.toString()}`,
            "--await_completion=true",
            "--raise_exceptions=true"
          ];
          await host2.addNewShellTask("Start DB System", shellArgs, void 0, false);
          await import_vscode27.commands.executeCommand("msg.mds.refreshOciProfiles");
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.stopDbSystem",
      async (item) => {
        if (item?.dbSystem.id) {
          const shellArgs = [
            "--",
            "mds",
            "stop",
            "db-system",
            `--db_system_id=${item.dbSystem.id.toString()}`,
            `--config_profile=${item.profile.profile.toString()}`,
            "--await_completion=true",
            "--raise_exceptions=true"
          ];
          await host2.addNewShellTask("Stop DB System", shellArgs, void 0, false);
          await import_vscode27.commands.executeCommand("msg.mds.refreshOciProfiles");
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.restartDbSystem",
      async (item) => {
        if (item?.dbSystem.id) {
          const shellArgs = [
            "--",
            "mds",
            "restart",
            "db-system",
            `--db_system_id=${item.dbSystem.id.toString()}`,
            `--config_profile=${item.profile.profile.toString()}`,
            "--await_completion=true",
            "--raise_exceptions=true"
          ];
          await host2.addNewShellTask("Restart DB System", shellArgs, void 0, false);
          await import_vscode27.commands.executeCommand("msg.mds.refreshOciProfiles");
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.addHWCluster",
      async (item) => {
        if (item && item.dbSystem && item.dbSystem.id && item.compartment && item.profile) {
          await this.showMdsHWClusterDialog(item.dbSystem, item.compartment, item.profile, host2);
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.deleteDbSystem",
      async (item) => {
        if (item?.dbSystem.id) {
          const shellArgs = [
            "--",
            "mds",
            "delete",
            "db-system",
            `--db_system_id=${item.dbSystem.id.toString()}`,
            `--config_profile=${item.profile.profile.toString()}`,
            "--await_completion=true",
            "--raise_exceptions=true"
          ];
          await host2.addNewShellTask("Delete DB System", shellArgs, void 0, false);
          await import_vscode27.commands.executeCommand("msg.mds.refreshOciProfiles");
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.startHWCluster",
      async (item) => {
        if (item?.dbSystem.id) {
          const shellArgs = [
            "--",
            "mds",
            "start",
            "heat-wave-cluster",
            `--db_system_id=${item.dbSystem.id.toString()}`,
            `--config_profile=${item.profile.profile.toString()}`,
            "--await_completion=true",
            "--raise_exceptions=true"
          ];
          await host2.addNewShellTask("Start HeatWave Cluster", shellArgs, void 0, false);
          await import_vscode27.commands.executeCommand("msg.mds.refreshOciProfiles");
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.stopHWCluster",
      async (item) => {
        if (item?.dbSystem.id) {
          const shellArgs = [
            "--",
            "mds",
            "stop",
            "heat-wave-cluster",
            `--db_system_id=${item.dbSystem.id.toString()}`,
            `--config_profile=${item.profile.profile.toString()}`,
            "--await_completion=true",
            "--raise_exceptions=true"
          ];
          await host2.addNewShellTask("Stop HeatWave Cluster", shellArgs, void 0, false);
          await import_vscode27.commands.executeCommand("msg.mds.refreshOciProfiles");
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.restartHWCluster",
      async (item) => {
        if (item?.dbSystem.id) {
          const shellArgs = [
            "--",
            "mds",
            "restart",
            "heat-wave-cluster",
            `--db_system_id=${item.dbSystem.id.toString()}`,
            `--config_profile=${item.profile.profile.toString()}`,
            "--await_completion=true",
            "--raise_exceptions=true"
          ];
          await host2.addNewShellTask("Restart HeatWave Cluster", shellArgs, void 0, false);
          await import_vscode27.commands.executeCommand("msg.mds.refreshOciProfiles");
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.rescaleHWCluster",
      async (item) => {
        if (item && item.dbSystem && item.dbSystem.id && item.compartment && item.profile) {
          await this.showMdsHWClusterDialog(item.dbSystem, item.compartment, item.profile, host2);
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.deleteHWCluster",
      async (item) => {
        if (item?.dbSystem.id) {
          const shellArgs = [
            "--",
            "mds",
            "delete",
            "heat-wave-cluster",
            `--db_system_id=${item.dbSystem.id.toString()}`,
            `--config_profile=${item.profile.profile.toString()}`,
            "--await_completion=true",
            "--raise_exceptions=true"
          ];
          await host2.addNewShellTask("Delete HeatWave Cluster", shellArgs, void 0, false);
          await import_vscode27.commands.executeCommand("msg.mds.refreshOciProfiles");
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.getComputeInstance",
      (item) => {
        if (item && item.compute.id) {
          this.showNewJsonDocument(
            `${item.compute.displayName ?? "<unknown>"} Info.json`,
            JSON.stringify(item.compute, null, 4)
          );
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.getBastion",
      async (item) => {
        if (item && item.bastion.id) {
          try {
            const bastion = await this.shellSession.mds.getMdsBastion(
              item.profile.profile,
              item.bastion.id
            );
            this.showNewJsonDocument(
              `${bastion.name ?? "<unknown>"} Info.json`,
              JSON.stringify(bastion, null, 4)
            );
          } catch (reason) {
            await import_vscode27.window.showErrorMessage(`Error while fetching the bastion data: ${String(reason)}`);
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.getLoadBalancer",
      (item) => {
        if (item && item.loadBalancer) {
          this.showNewJsonDocument(
            `${item.loadBalancer.displayName ?? "<unknown>"} Info.json`,
            JSON.stringify(item.loadBalancer, null, 4)
          );
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand("msg.showTaskOutput", () => {
      taskOutputChannel.show();
    }));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.deleteBastion",
      async (item) => {
        if (item && item.bastion.id) {
          const shellArgs = [
            "--",
            "mds",
            "delete",
            "bastion",
            `--bastion_id=${item.bastion.id.toString()}`,
            `--config_profile=${item.profile.profile.toString()}`,
            "--await_deletion=true",
            "--raise_exceptions=true"
          ];
          await host2.addNewShellTask("Delete Bastion", shellArgs);
          await import_vscode27.commands.executeCommand("msg.mds.refreshOciProfiles");
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.setCurrentBastion",
      async (item) => {
        if (item && item.bastion.id) {
          import_vscode27.window.setStatusBarMessage(`Setting current bastion to ${item.bastion.name} ...`, 1e4);
          try {
            await this.shellSession.mds.setCurrentBastion({
              bastionId: item.bastion.id,
              configProfile: item.profile.profile,
              interactive: false,
              raiseExceptions: true
            });
            await import_vscode27.commands.executeCommand("msg.mds.refreshOciProfiles");
            import_vscode27.window.setStatusBarMessage(`Current compartment set to ${item.bastion.name}.`, 5e3);
          } catch (reason) {
            await import_vscode27.window.showErrorMessage(`Error while setting current bastion: ${String(reason)}`);
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.refreshOnBastionActiveState",
      async (item) => {
        if (item && item.bastion.id) {
          const shellArgs = [
            "--",
            "mds",
            "get",
            "bastion",
            `--bastion_id=${item.bastion.id.toString()}`,
            `--config_profile=${item.profile.profile.toString()}`,
            "--await_state=ACTIVE",
            "--raise_exceptions=true"
          ];
          await host2.addNewShellTask("Refresh Bastion", shellArgs);
          await import_vscode27.commands.executeCommand("msg.mds.refreshOciProfiles");
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.deleteComputeInstance",
      async (item) => {
        if (item && item.compute.id) {
          const shellArgs = [
            "--",
            "mds",
            "delete",
            "compute_instance",
            `--instance_id=${item.compute.id}`,
            `--config_profile=${item.profile.profile}`,
            "--await_deletion=true",
            "--raise_exceptions=true"
          ];
          await host2.addNewShellTask("Delete Compute Instance", shellArgs);
          await import_vscode27.commands.executeCommand("msg.mds.refreshOciProfiles");
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.openBastionSshSession",
      async (item) => {
        if (item && item.shellSession && item.shellSession.mds && item.compute.id) {
          import_vscode27.window.setStatusBarMessage("Opening Bastion Session ...", 1e4);
          try {
            const session = await item.shellSession.mds.createBastionSession(
              item.profile.profile,
              item.compute.id,
              "MANAGED_SSH",
              item.compute.compartmentId,
              true,
              (data) => {
                if (data.message) {
                  import_vscode27.window.setStatusBarMessage(data.message);
                }
              }
            );
            import_vscode27.window.setStatusBarMessage("Bastion Session available, opening Terminal ...", 5e3);
            if (session?.bastionId && this.isPortForwardingData(session.targetResourceDetails)) {
              const terminal = import_vscode27.window.createTerminal(`Terminal ${item.name}`);
              const sshHost = `${session.id}@host.bastion. ${item.profile.region}.oci.oraclecloud.com`;
              const sshTargetIp = session.targetResourceDetails.targetResourcePrivateIpAddress;
              if (sshTargetIp) {
                const sshTargetPort = session.targetResourceDetails.targetResourcePort;
                if (sshTargetPort) {
                  terminal.sendText(`ssh -o ProxyCommand="ssh -W %h:%p -p 22 ${sshHost}" -p ${sshTargetPort} opc@${sshTargetIp}`);
                  terminal.sendText("clear");
                  terminal.show();
                }
              }
            }
          } catch (reason) {
            await import_vscode27.window.showErrorMessage(`Error while creating the bastion session: ${String(reason)}`);
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode27.commands.registerCommand(
      "msg.mds.loadToHeatWave",
      async (entry, items) => {
        if (entry) {
          const schemas = [];
          if (items && items.length > 0) {
            items?.forEach((schema) => {
              if (schema instanceof SchemaMySQLTreeItem && schema.parent.treeItem.details.caption === entry.parent.treeItem.details.caption) {
                schemas.push(schema.name);
              }
            });
          } else {
            schemas.push(entry.treeItem.name);
          }
          if (schemas.length > 0) {
            try {
              const allSchemas = await entry?.treeItem.backend.getCatalogObjects("Schema");
              if (allSchemas) {
                await this.showMdsHWLoadDataDialog(
                  entry.treeItem.connectionId,
                  schemas,
                  allSchemas,
                  host2
                );
              }
            } catch (reason) {
              await import_vscode27.window.showErrorMessage(`Error retrieving schema list: ${String(reason)}`);
            }
          }
        }
      }
    ));
  };
  /**
   * Opens a new text document on a VS Code tab, with the given text.
   *
   * @param title The title of the tab.
   * @param text The text to show, interpreted as JSON.
   */
  showNewJsonDocument(title, text) {
    const path25 = `${(0, import_os2.homedir)()}/${title}`;
    const scheme = (0, import_fs5.existsSync)(path25) ? "file" : "untitled";
    const uri = import_vscode27.Uri.parse(`${scheme}:${path25}`);
    import_vscode27.workspace.openTextDocument(uri).then((doc) => {
      void import_vscode27.window.showTextDocument(doc, 1, false).then((editor) => {
        void editor.edit((edit) => {
          const firstLine = doc.lineAt(0);
          const lastLine = doc.lineAt(doc.lineCount - 1);
          const textRange = new import_vscode27.Range(firstLine.range.start, lastLine.range.end);
          edit.replace(textRange, text);
        }).then(() => {
          const position = editor.selection.start;
          editor.selection = new import_vscode27.Selection(position, position);
        });
        void import_vscode27.languages.setTextDocumentLanguage(doc, "json");
      });
    }, (error) => {
      void import_vscode27.window.showErrorMessage(`Error while showing the document: ${String(error)}`);
    });
  }
  /**
   * Shows a dialog to create a new or edit an existing MRS service.
   *
   * @param dbSystem The dbSystem of the HW Cluster
   * @param compartment The compartment of the HW Cluster
   * @param profile The OCI profile
   * @param host The extension host
   */
  async showMdsHWClusterDialog(dbSystem, compartment, profile, host2) {
    const statusbarItem = import_vscode27.window.createStatusBarItem();
    statusbarItem.text = `$(loading~spin) Fetching List of MDS HeatWave Cluster Shapes...`;
    statusbarItem.show();
    try {
      const summaries = await this.shellSession.mds.listDbSystemShapes(
        "HEATWAVECLUSTER",
        profile.profile,
        compartment.id
      );
      statusbarItem.hide();
      const title = dbSystem.heatWaveCluster && dbSystem.heatWaveCluster.lifecycleState !== "DELETED" ? "Rescale the MySQL HeatWave Cluster" : "Configure the MySQL HeatWave Cluster";
      const request = {
        id: "mdsHWClusterDialog",
        type: 20 /* MdsHeatWaveCluster */,
        title,
        parameters: { shapes: summaries },
        values: {
          clusterSize: dbSystem?.heatWaveCluster?.clusterSize,
          shapeName: dbSystem?.heatWaveCluster?.shapeName
        }
      };
      const response = await this.dialogManager.showDialog(request, title);
      if (!response || response.closure !== 0 /* Accept */) {
        return;
      }
      if (response.data) {
        const clusterSize = response.data.clusterSize;
        const shapeName = response.data.shapeName;
        if (!dbSystem.heatWaveCluster || dbSystem.heatWaveCluster.lifecycleState === "DELETED") {
          const shellArgs = [
            "--",
            "mds",
            "create",
            "heat-wave-cluster",
            `--db_system_id=${dbSystem.id.toString()}`,
            `--cluster_size=${clusterSize.toString()}`,
            `--shape_name=${shapeName}`,
            `--config_profile=${profile.profile.toString()}`,
            "--await_completion=true",
            "--raise_exceptions=true"
          ];
          await host2.addNewShellTask("Create HeatWave Cluster", shellArgs, void 0, false);
          await import_vscode27.commands.executeCommand("msg.mds.refreshOciProfiles");
        } else {
          if (dbSystem.heatWaveCluster && clusterSize === dbSystem.heatWaveCluster.clusterSize && shapeName === dbSystem.heatWaveCluster.shapeName) {
            import_vscode27.window.setStatusBarMessage("The HeatWave Cluster parameters remained unchanged.", 6e3);
          } else {
            const shellArgs = [
              "--",
              "mds",
              "update",
              "heat-wave-cluster",
              `--db_system_id=${dbSystem.id.toString()}`,
              `--cluster_size=${clusterSize.toString()}`,
              `--shape_name=${shapeName}`,
              `--config_profile=${profile.profile.toString()}`,
              "--await_completion=true",
              "--raise_exceptions=true"
            ];
            await host2.addNewShellTask("Rescale HeatWave Cluster", shellArgs, void 0, false);
            await import_vscode27.commands.executeCommand("msg.mds.refreshOciProfiles");
          }
        }
      }
    } catch (reason) {
      statusbarItem.hide();
      await import_vscode27.window.showErrorMessage(`Error while listing MySQL REST services: ${String(reason)}`);
    }
  }
  /**
   * Shows a dialog to load data to HeatWave
   *
   * @param connectionId The id of the database connection to use
   * @param selectedSchemas The list of schemas to load
   * @param allSchemas The list of all available schemas
   * @param host The extension host
   */
  async showMdsHWLoadDataDialog(connectionId, selectedSchemas, allSchemas, host2) {
    const title = "Load Data to HeatWave";
    const request = {
      id: "mdsHWLoadDataDialog",
      type: 21 /* MdsHeatWaveLoadData */,
      title,
      parameters: {},
      values: {
        selectedSchemas,
        allSchemas
      }
    };
    const response = await this.dialogManager.showDialog(request, title);
    if (!response || response.closure !== 0 /* Accept */) {
      return;
    }
    if (response.data) {
      const schemaList = response.data.schemas;
      const mode = response.data.mode;
      const output = response.data.output;
      const disableUnsupportedColumns = response.data.disableUnsupportedColumns;
      const optimizeLoadParallelism = response.data.optimizeLoadParallelism;
      const enableMemoryCheck = response.data.enableMemoryCheck;
      const sqlMode = response.data.sqlMode;
      const excludeList = response.data.excludeList;
      const shellArgs = [
        "--",
        "mds",
        "util",
        "heat-wave-load-data",
        `--schemas=${schemaList.join(",")}`,
        `--mode=${mode}`,
        `--output=${output}`,
        `--disable-unsupported-columns=${disableUnsupportedColumns ? "1" : "0"}`,
        `--optimize-load-parallelism=${optimizeLoadParallelism ? "1" : "0"}`,
        `--enable-memory-check=${enableMemoryCheck ? "1" : "0"}`,
        `--sql-mode="${sqlMode}"`,
        `--exclude-list=${excludeList}`,
        "--raise-exceptions=1",
        "--interactive=1"
      ];
      await host2.addNewShellTask("Load Data to HeatWave Cluster", shellArgs, connectionId);
      await import_vscode27.window.showInformationMessage("The data load to the HeatWave cluster operation has finished.");
    }
  }
  /**
   * Shows a dialog to create a new or edit an existing MRS service.
   *
   * @param dbSystem The dbSystem of the HW Cluster
   * @param compartment The compartment of the HW Cluster
   * @param profile The OCI profile
   * @param host The extension host
   */
  async showMdsEndpointDialog(dbSystem, compartment, profile, host2) {
    const statusbarItem = import_vscode27.window.createStatusBarItem();
    statusbarItem.text = `$(loading~spin) Fetching List of Compute Shapes...`;
    statusbarItem.show();
    try {
      const shapes = await this.shellSession.mds.listComputeShapes(
        profile.profile,
        dbSystem.compartmentId
      );
      const shapeList = shapes.map((shape, _i, _a) => {
        return shape.shape;
      });
      statusbarItem.hide();
      const title = "MySQL Endpoint Configuration";
      const request = {
        id: "mdsEndpointDialog",
        type: 22 /* MdsEndpoint */,
        title,
        parameters: { shapes: shapeList },
        values: {
          instanceName: `${dbSystem?.displayName} Endpoint`,
          shapeName: "VM.Standard.E4.Flex",
          cpuCount: 1,
          memorySize: 16,
          mysqlUserName: "dba"
        }
      };
      const response = await this.dialogManager.showDialog(request, title);
      if (!response || response.closure !== 0 /* Accept */) {
        return;
      }
      if (response.data) {
        const instanceName = response.data.instanceName;
        const shapeName = response.data.shapeName;
        const cpuCount = response.data.cpuCount;
        const memorySize = response.data.memorySize;
        const mysqlUserName = response.data.mysqlUserName;
        const mysqlUserPassword = response.data.mysqlUserPassword;
        const createDbConnection = response.data.createDbConnection;
        const publicIp = response.data.publicIp;
        const domainName = response.data.domainName;
        const sslCertificate = response.data.sslCertificate;
        const portForwarding = response.data.portForwarding;
        const mrs = response.data.mrs;
        const jwtSecret = response.data.jwtSecret;
        const shellArgs = [
          "--",
          "mds",
          "util",
          "create-endpoint",
          `--db_system_id=${dbSystem.id}`,
          `--config_profile=${profile.profile}`,
          `--instance_name=${instanceName}`,
          `--shape=${shapeName}`,
          `--cpu_count=${cpuCount}`,
          `--memory_size=${memorySize}`,
          `--mysql_user_name="${mysqlUserName}"`,
          `--public_ip=${publicIp ? "true" : "false"}`,
          `--port_forwarding=${portForwarding ? "true" : "false"}`,
          `--mrs=${mrs ? "true" : "false"}`,
          `--domain_name=${domainName}`,
          `--ssl_cert=${sslCertificate ? "true" : "false"}`,
          "--raise_exceptions=true"
        ];
        if (jwtSecret !== "") {
          shellArgs.push(`--jwt_secret="${jwtSecret}"`);
        }
        await host2.addNewShellTask(
          "Create new Router Endpoint",
          shellArgs,
          void 0,
          true,
          [mysqlUserPassword]
        );
        await import_vscode27.commands.executeCommand("msg.mds.refreshOciProfiles");
        if (createDbConnection) {
          const details = {
            id: 0,
            // Will be replaced with the ID returned from the BE call.
            dbType: "MySQL" /* MySQL */,
            caption: instanceName,
            description: "MySQL Router Connection",
            useSSH: false,
            useMDS: false,
            options: {
              /* eslint-disable @typescript-eslint/naming-convention */
              "scheme": "mysql" /* MySQL */,
              "host": domainName ?? publicIp,
              "port": 6446,
              "user": mysqlUserName,
              "schema": "",
              // "useSSL": useSsl ? undefined : "no",
              "ssl-mode": void 0,
              "compression": "PREFERRED" /* Preferred */
            }
          };
          ShellInterface.dbConnections.addDbConnection(
            webSession.currentProfileId,
            details,
            ""
          ).then((connectionId) => {
            if (connectionId !== void 0) {
              void requisitions.broadcastRequest(void 0, "refreshConnections", void 0);
            }
          }).catch((event) => {
            void import_vscode27.window.showErrorMessage(
              `Error while adding the DB Connection: ${String(event.message)}`
            );
          });
        }
      }
    } catch (reason) {
      statusbarItem.hide();
      await import_vscode27.window.showErrorMessage(`Error while listing Compute Shapes: ${String(reason)}`);
    }
  }
  isPortForwardingData(candidate) {
    return candidate.targetResourcePrivateIpAddress !== void 0;
  }
};

// src/MRSCommandHandler.ts
var import_fs6 = __toESM(require("fs"), 1);
var import_os3 = __toESM(require("os"), 1);
var import_path6 = __toESM(require("path"), 1);
var import_vscode29 = require("vscode");

// ../frontend/src/supplement/ShellInterface/ShellInterfaceDb.ts
var ShellInterfaceDb = class {
  moduleSessionLookupId = "";
  /**
   * Starts a simple DB session for certain DB object related work.
   *
   * @param id A unique ID to identify this session.
   * @param connection Either the ID of a stored DB editor connection or a set of credentials for an ad hoc
   *                   connection.
   *
   * @returns A promise which resolves when the operation was concluded.
   */
  async startSession(id, connection) {
    this.moduleSessionLookupId = `dbSession.${id}`;
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.db.start_session" /* GuiDbStartSession */,
      parameters: { args: { connection } }
    });
    webSession.setModuleSessionId(this.moduleSessionLookupId, response.result.moduleSessionId);
  }
  /**
   * Closes this session and all open connections.
   *
   * @returns A promise which resolves when the operation was concluded.
   */
  async closeSession() {
    if (!this.moduleSessionId) {
      return;
    }
    await MessageScheduler.get.sendRequest({
      requestType: "gui.db.close_session" /* GuiDbCloseSession */,
      parameters: { args: { moduleSessionId: this.moduleSessionId } }
    });
    webSession.setModuleSessionId(this.moduleSessionLookupId);
  }
  /**
   * Returns the list of available catalog objects (schemas, engines, variables and so on).
   *
   * @param type Which type of object to retrieve.
   * @param filter A search filter.
   *
   * @returns A promise which resolves when the operation was concluded.
   */
  async getCatalogObjects(type, filter) {
    if (!this.moduleSessionId) {
      return [];
    }
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.db.get_catalog_object_names" /* GuiDbGetCatalogObjectNames */,
      parameters: { args: { type, filter, moduleSessionId: this.moduleSessionId } }
    });
    const result = [];
    response.forEach((entry) => {
      result.push(...entry.result);
    });
    return result;
  }
  /**
   * Returns a list of schema object names (tables, views etc.).
   *
   * @param schema The schema for which to retrieve the names.
   * @param type Which type of object to retrieve.
   * @param routineType Valid only for routines.
   * @param filter A search filter.
   *
   * @returns A promise which resolves when the operation was concluded.
   */
  async getSchemaObjects(schema, type, routineType, filter) {
    if (!this.moduleSessionId) {
      return [];
    }
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.db.get_schema_object_names" /* GuiDbGetSchemaObjectNames */,
      parameters: {
        args: {
          type,
          filter,
          schemaName: schema,
          routineType,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    const result = [];
    response.forEach((entry) => {
      result.push(...entry.result);
    });
    return result;
  }
  /**
   * Returns a list of table objects (columns, indexes and so on).
   *
   * @param schema The schema for which to retrieve the names.
   * @param table The table for which to retrieve the names.
   * @param type Which type of object to retrieve.
   * @param filter A search filter.
   *
   * @returns A promise which resolves when the operation was concluded.
   */
  async getTableObjects(schema, table, type, filter) {
    if (!this.moduleSessionId) {
      return [];
    }
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.db.get_table_object_names" /* GuiDbGetTableObjectNames */,
      parameters: {
        args: {
          type,
          filter,
          schemaName: schema,
          tableName: table,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    const result = [];
    response.forEach((entry) => {
      result.push(...entry.result);
    });
    return result;
  }
  get moduleSessionId() {
    return webSession.moduleSessionId(this.moduleSessionLookupId);
  }
};

// ../frontend/src/supplement/ShellInterface/ShellInterfaceMrs.ts
var ShellInterfaceMrs = class {
  // The key under which the module session is stored in the WebSession instance.
  moduleSessionLookupId = "";
  async configure(enableMrs, allowRecreationOnMajorUpgrade, updateIfAvailable, options) {
    await MessageScheduler.get.sendRequest({
      requestType: "mrs.configure" /* MrsConfigure */,
      parameters: {
        args: {
          moduleSessionId: this.moduleSessionId,
          enableMrs,
          updateIfAvailable,
          options,
          allowRecreationOnMajorUpgrade
        }
      }
    });
  }
  async status() {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.status" /* MrsStatus */,
      parameters: {
        args: {
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async listServices() {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.list.services" /* MrsListServices */,
      parameters: {
        kwargs: {
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async addService(urlContextRoot, urlProtocol, urlHostName, comments, enabled, options, authPath, authCompletedUrl, authCompletedUrlValidation, authCompletedPageContent, authApps) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.add.service" /* MrsAddService */,
      parameters: {
        kwargs: {
          urlContextRoot,
          urlHostName,
          enabled,
          moduleSessionId: this.moduleSessionId,
          urlProtocol,
          authPath,
          comments,
          options,
          authCompletedUrl,
          authCompletedUrlValidation,
          authCompletedPageContent,
          authApps
        }
      }
    }, true, ["options"]);
    return response.result;
  }
  async updateService(serviceId, urlContextRoot, urlHostName, value) {
    await MessageScheduler.get.sendRequest({
      requestType: "mrs.update.service" /* MrsUpdateService */,
      parameters: {
        kwargs: {
          serviceId,
          urlContextRoot,
          urlHostName,
          value,
          moduleSessionId: this.moduleSessionId
        }
      }
    }, true, ["options"]);
  }
  async deleteService(serviceId) {
    await MessageScheduler.get.sendRequest({
      requestType: "mrs.delete.service" /* MrsDeleteService */,
      parameters: {
        kwargs: {
          serviceId,
          urlContextRoot: null,
          urlHostName: null,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
  }
  async getService(serviceId, urlContextRoot, urlHostName, getDefault, autoSelectSingle) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.get.service" /* MrsGetService */,
      parameters: {
        kwargs: {
          serviceId,
          urlContextRoot,
          urlHostName,
          getDefault,
          autoSelectSingle,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async setCurrentService(serviceId) {
    await MessageScheduler.get.sendRequest({
      requestType: "mrs.set.current_service" /* MrsSetCurrentService */,
      parameters: {
        kwargs: {
          serviceId,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
  }
  async getCurrentServiceMetadata() {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.get.current_service_metadata" /* MrsGetCurrentServiceMetadata */,
      parameters: {
        kwargs: {
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async getAuthVendors() {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.get.authentication_vendors" /* MrsGetAuthenticationVendors */,
      parameters: {
        kwargs: {
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async addAuthApp(serviceId, authApp, registerUsers) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.add.authentication_app" /* MrsAddAuthenticationApp */,
      parameters: {
        args: {
          serviceId,
          appName: authApp.name
        },
        kwargs: {
          authVendorId: authApp.authVendorId,
          description: authApp.description,
          url: authApp.url,
          urlDirectAuth: authApp.urlDirectAuth,
          accessToken: authApp.accessToken,
          appId: authApp.appId,
          limitToRegisteredUsers: authApp.limitToRegisteredUsers,
          registeredUsers: registerUsers,
          defaultRoleId: authApp.defaultRoleId,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async getAuthApps(serviceId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.list.authentication_apps" /* MrsListAuthenticationApps */,
      parameters: {
        args: {
          serviceId
        },
        kwargs: {
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async getAuthApp(appId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.get.authentication_app" /* MrsGetAuthenticationApp */,
      parameters: {
        args: {
          appId,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async deleteAuthApp(appId) {
    await MessageScheduler.get.sendRequest({
      requestType: "mrs.delete.authentication_app" /* MrsDeleteAuthenticationApp */,
      parameters: {
        kwargs: {
          appId,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
  }
  async updateAuthApp(appId, value) {
    await MessageScheduler.get.sendRequest({
      requestType: "mrs.update.authentication_app" /* MrsUpdateAuthenticationApp */,
      parameters: {
        kwargs: {
          appId,
          value,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
  }
  async listUsers(serviceId, authAppId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.list.users" /* MrsListUsers */,
      parameters: {
        kwargs: {
          serviceId,
          authAppId,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async deleteUser(userId) {
    await MessageScheduler.get.sendRequest({
      requestType: "mrs.delete.user" /* MrsDeleteUser */,
      parameters: {
        args: {
          userId,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
  }
  async addUser(authAppId, name, email, vendorUserId, loginPermitted, mappedUserId, appOptions, authString, userRoles) {
    await MessageScheduler.get.sendRequest({
      requestType: "mrs.add.user" /* MrsAddUser */,
      parameters: {
        kwargs: {
          authAppId,
          name,
          email,
          vendorUserId,
          loginPermitted,
          mappedUserId,
          appOptions,
          authString,
          userRoles,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
  }
  async updateUser(userId, value, userRoles) {
    await MessageScheduler.get.sendRequest({
      requestType: "mrs.update.user" /* MrsUpdateUser */,
      parameters: {
        kwargs: {
          userId,
          value,
          userRoles,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
  }
  async listSchemas(serviceId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.list.schemas" /* MrsListSchemas */,
      parameters: {
        args: {
          serviceId
        },
        kwargs: {
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async getSchema(schemaId, serviceId, requestPath, schemaName, autoSelectSingle) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.get.schema" /* MrsGetSchema */,
      parameters: {
        kwargs: {
          schemaId: schemaId ?? null,
          serviceId: serviceId ?? null,
          requestPath: requestPath ?? null,
          schemaName: schemaName ?? null,
          autoSelectSingle: autoSelectSingle ?? null,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async deleteSchema(schemaId, serviceId) {
    await MessageScheduler.get.sendRequest({
      requestType: "mrs.delete.schema" /* MrsDeleteSchema */,
      parameters: {
        kwargs: {
          schemaId,
          serviceId,
          schemaName: null,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
  }
  async addSchema(serviceId, schemaName, requestPath, requiresAuth, options, itemsPerPage, comments) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.add.schema" /* MrsAddSchema */,
      parameters: {
        kwargs: {
          serviceId,
          schemaName,
          requestPath,
          requiresAuth,
          enabled: true,
          itemsPerPage,
          comments,
          options,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async updateSchema(schemaId, serviceId, schemaName, requestPath, requiresAuth, enabled, itemsPerPage, comments, options) {
    await MessageScheduler.get.sendRequest({
      requestType: "mrs.update.schema" /* MrsUpdateSchema */,
      parameters: {
        kwargs: {
          moduleSessionId: this.moduleSessionId,
          schemaId,
          value: {
            serviceId,
            schemaName,
            requestPath,
            requiresAuth,
            enabled,
            itemsPerPage,
            comments,
            options
          }
        }
      }
    });
  }
  async addDbObject(dbObjectName, dbObjectType, autoAddSchema, requestPath, enabled, crudOperations, crudOperationFormat, requiresAuth, rowUserOwnershipEnforced, autoDetectMediaType, options, itemsPerPage, rowUserOwnershipColumn, schemaId, schemaName, comments, mediaType, authStoredProcedure, objects) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.add.db_object" /* MrsAddDbObject */,
      parameters: {
        kwargs: {
          moduleSessionId: this.moduleSessionId,
          dbObjectName,
          dbObjectType,
          schemaId,
          schemaName,
          autoAddSchema,
          requestPath,
          enabled,
          crudOperations,
          crudOperationFormat,
          requiresAuth,
          itemsPerPage: itemsPerPage === null ? void 0 : itemsPerPage,
          rowUserOwnershipEnforced,
          rowUserOwnershipColumn,
          comments,
          mediaType,
          autoDetectMediaType,
          authStoredProcedure,
          options,
          objects
        }
      }
    });
    return response.result;
  }
  async updateDbObject(dbObjectId, dbObjectName, requestPath, schemaId, value) {
    await MessageScheduler.get.sendRequest({
      requestType: "mrs.update.db_object" /* MrsUpdateDbObject */,
      parameters: {
        kwargs: {
          moduleSessionId: this.moduleSessionId,
          dbObjectId,
          schemaId,
          dbObjectName,
          requestPath,
          value
        }
      }
    });
  }
  async listDbObjects(schemaId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.list.db_objects" /* MrsListDbObjects */,
      parameters: {
        kwargs: {
          schemaId,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async deleteDbObject(dbObjectId) {
    await MessageScheduler.get.sendRequest({
      requestType: "mrs.delete.db_object" /* MrsDeleteDbObject */,
      parameters: {
        args: {},
        kwargs: {
          dbObjectId,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
  }
  async addContentSet(contentDir, requestPath, requiresAuth, options, serviceId, comments, enabled, replaceExisting, progress) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.add.content_set" /* MrsAddContentSet */,
      parameters: {
        args: {
          serviceId,
          contentDir
        },
        kwargs: {
          moduleSessionId: this.moduleSessionId,
          requestPath,
          requiresAuth,
          comments,
          options,
          enabled,
          replaceExisting
        }
      },
      onData: (data) => {
        if (progress && data.result.info) {
          progress(data.result.info);
        }
      }
    });
    return response.result;
  }
  async getServiceRequestPathAvailability(serviceId, requestPath) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.get.service_request_path_availability" /* MrsGetServiceRequestPathAvailability */,
      parameters: {
        kwargs: {
          moduleSessionId: this.moduleSessionId,
          serviceId,
          requestPath
        }
      }
    });
    return response.result;
  }
  async listContentSets(serviceId, requestPath) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.list.content_sets" /* MrsListContentSets */,
      parameters: {
        args: {
          serviceId
        },
        kwargs: {
          moduleSessionId: this.moduleSessionId,
          requestPath
        }
      }
    });
    return response.result;
  }
  async listContentFiles(contentSetId, includeEnableState) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.list.content_files" /* MrsListContentFiles */,
      parameters: {
        args: {
          contentSetId
        },
        kwargs: {
          moduleSessionId: this.moduleSessionId,
          includeEnableState
        }
      }
    });
    return response.result;
  }
  async deleteContentSet(contentSetId) {
    await MessageScheduler.get.sendRequest({
      requestType: "mrs.delete.content_set" /* MrsDeleteContentSet */,
      parameters: {
        kwargs: {
          moduleSessionId: this.moduleSessionId,
          contentSetId
        }
      }
    });
  }
  get moduleSessionId() {
    return webSession.moduleSessionId(this.moduleSessionLookupId);
  }
  async dumpSchema(path25, serviceId, serviceName, schemaId, schemaName) {
    await MessageScheduler.get.sendRequest({
      requestType: "mrs.dump.schema" /* MrsDumpSchema */,
      parameters: {
        args: {
          path: path25
        },
        kwargs: {
          moduleSessionId: this.moduleSessionId,
          serviceId,
          serviceName,
          schemaId,
          schemaName
        }
      }
    });
  }
  async dumpObject(path25, serviceId, serviceName, schemaId, schemaName, objectId, objectName) {
    await MessageScheduler.get.sendRequest({
      requestType: "mrs.dump.object" /* MrsDumpObject */,
      parameters: {
        args: {
          path: path25
        },
        kwargs: {
          moduleSessionId: this.moduleSessionId,
          serviceId,
          serviceName,
          schemaId,
          schemaName,
          objectId,
          objectName
        }
      }
    });
  }
  async loadSchema(path25, serviceId, serviceName) {
    await MessageScheduler.get.sendRequest({
      requestType: "mrs.load.schema" /* MrsLoadSchema */,
      parameters: {
        args: {
          path: path25
        },
        kwargs: {
          moduleSessionId: this.moduleSessionId,
          serviceId,
          serviceName
        }
      }
    });
  }
  async loadObject(path25, serviceId, serviceName, schemaId, schemaName) {
    await MessageScheduler.get.sendRequest({
      requestType: "mrs.load.object" /* MrsLoadObject */,
      parameters: {
        args: {
          path: path25
        },
        kwargs: {
          moduleSessionId: this.moduleSessionId,
          serviceId,
          serviceName,
          schemaId,
          schemaName
        }
      }
    });
  }
  async listRoles(serviceId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.list.roles" /* MrsListRoles */,
      parameters: {
        args: {
          serviceId,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async listUserRoles(userId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.list.user_roles" /* MrsListUserRoles */,
      parameters: {
        args: {
          userId,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async listRouterIds(seenWithin) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.list.router_ids" /* MrsListRouterIds */,
      parameters: {
        args: {
          seenWithin,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async listRouters(activeWhenSeenWithin) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.list.routers" /* MrsListRouters */,
      parameters: {
        args: {
          activeWhenSeenWithin,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async deleteRouter(routerId) {
    await MessageScheduler.get.sendRequest({
      requestType: "mrs.delete.router" /* MrsDeleteRouter */,
      parameters: {
        args: {
          routerId,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
  }
  async getSdkBaseClasses(sdkLanguage, prepareForRuntime) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.get.sdk_base_classes" /* MrsGetSdkBaseClasses */,
      parameters: {
        kwargs: {
          sdkLanguage,
          prepareForRuntime,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async getSdkServiceClasses(serviceId, sdkLanguage, prepareForRuntime, serviceUrl) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.get.sdk_service_classes" /* MrsGetSdkServiceClasses */,
      parameters: {
        kwargs: {
          serviceId,
          serviceUrl,
          sdkLanguage,
          prepareForRuntime,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async getRuntimeManagementCode() {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.get.runtime_management_code" /* MrsGetRuntimeManagementCode */,
      parameters: {
        kwargs: {
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async dumpSdkServiceFiles(serviceId, sdkLanguage, directory) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.dump.sdk_service_files" /* MrsDumpSdkServiceFiles */,
      parameters: {
        kwargs: {
          serviceId,
          sdkLanguage,
          directory,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async getTableColumnsWithReferences(requestPath, dbObjectName, dbObjectId, schemaId, schemaName, dbObjectType) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.get.table_columns_with_references" /* MrsGetTableColumnsWithReferences */,
      parameters: {
        args: {
          dbObjectId,
          schemaId,
          requestPath,
          dbObjectName
        },
        kwargs: {
          moduleSessionId: this.moduleSessionId,
          schemaName,
          dbObjectType
        }
      }
    });
    return response.result;
  }
  async getDbObjectParameters(dbObjectName, dbSchemaName, dbObjectId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.get.db_object_parameters" /* MrsGetDbObjectParameters */,
      parameters: {
        args: {},
        kwargs: {
          dbObjectId,
          dbSchemaName,
          dbObjectName,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async getDbObject(dbObjectId, schemaId, schemaName, absoluteRequestPath) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.get.db_object" /* MrsGetDbObject */,
      parameters: {
        args: {},
        kwargs: {
          dbObjectId,
          schemaId,
          schemaName,
          absoluteRequestPath,
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async getObjects(dbObjectId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.get.objects" /* MrsGetObjects */,
      parameters: {
        args: {
          dbObjectId
        },
        kwargs: {
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
  async getObjectFieldsWithReferences(objectId) {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "mrs.get.object_fields_with_references" /* MrsGetObjectFieldsWithReferences */,
      parameters: {
        args: {
          objectId
        },
        kwargs: {
          moduleSessionId: this.moduleSessionId
        }
      }
    });
    return response.result;
  }
};

// ../frontend/src/supplement/ShellInterface/ShellInterfaceSqlEditor.ts
var ShellInterfaceSqlEditor = class extends ShellInterfaceDb {
  mds = new ShellInterfaceMds();
  mrs = new ShellInterfaceMrs();
  /**
   * @returns a flag which indicates if a session was opened already.
   */
  get hasSession() {
    return this.moduleSessionId !== void 0;
  }
  /**
   * Begins a new session for a specific SQL editor. This overrides the underlying DB session handling.
   *
   * @param id A value identifying the SQL editor.
   *
   * @returns A promise which resolves when the operation was concluded.
   */
  async startSession(id) {
    this.moduleSessionLookupId = `sqlEditor.${id}`;
    this.mrs.moduleSessionLookupId = this.moduleSessionLookupId;
    if (!this.hasSession) {
      const response = await MessageScheduler.get.sendRequest({
        requestType: "gui.sqleditor.start_session" /* GuiSqleditorStartSession */,
        parameters: { args: {} }
      });
      if (response.result?.moduleSessionId) {
        webSession.setModuleSessionId(this.moduleSessionLookupId, response.result.moduleSessionId);
      }
    }
  }
  /**
   * Closes this editor session and all open connections.
   *
   * @returns A promise which resolves when the operation was concluded.
   */
  async closeSession() {
    const moduleSessionId = this.moduleSessionId;
    if (moduleSessionId) {
      await MessageScheduler.get.sendRequest({
        requestType: "gui.sqleditor.close_session" /* GuiSqleditorCloseSession */,
        parameters: { args: { moduleSessionId } }
      });
      webSession.setModuleSessionId(this.moduleSessionLookupId);
    }
  }
  /**
   * Returns information of how the modules should be displayed in the gui.
   *
   * @returns A promise which resolves when the operation was concluded.
   */
  async getGuiModuleDisplayInfo() {
    await MessageScheduler.get.sendRequest({
      requestType: "gui.sqleditor.get_gui_module_display_info" /* GuiSqleditorGetGuiModuleDisplayInfo */,
      parameters: { args: {} }
    });
  }
  /**
   * Returns true as this extension object holds the backend implementation of a gui module.
   *
   * @returns A promise resolving to a flag indicating the outcome of the request.
   */
  async isGuiModuleBackend() {
    const response = await MessageScheduler.get.sendRequest({
      requestType: "gui.sqleditor.is_gui_module_backend" /* GuiSqleditorIsGuiModuleBackend */,
      parameters: { args: {} }
    });
    return response.result;
  }
  /**
   * Opens the database connection.
   *
   * @param dbConnectionId The id of the db connection.
   * @param requestId The ID to use for the request sent to the backend.
   * @param callback The callback for intermediate results.
   *
   * @returns A promise resolving to various connection data or undefined if no session is open.
   */
  async openConnection(dbConnectionId, requestId, callback) {
    const moduleSessionId = this.moduleSessionId;
    if (moduleSessionId) {
      const response = await MessageScheduler.get.sendRequest({
        requestId,
        requestType: "gui.sqleditor.open_connection" /* GuiSqleditorOpenConnection */,
        parameters: { args: { moduleSessionId, dbConnectionId } },
        onData: callback
      });
      return response.result;
    }
    return void 0;
  }
  /**
   * Executes the given SQL.
   *
   * @param sql The sql command to execute.
   * @param params Parameters for the query, if it contains placeholders.
   * @param requestId The ID to use for the request sent to the backend.
   * @param callback The callback for intermediate results.
   *
   * @returns A promise resolving to a list of records or undefined if no session is open.
   */
  async execute(sql, params, requestId, callback) {
    const moduleSessionId = this.moduleSessionId;
    if (moduleSessionId) {
      const response = await MessageScheduler.get.sendRequest({
        requestType: "gui.sqleditor.execute" /* GuiSqleditorExecute */,
        requestId,
        parameters: {
          args: {
            moduleSessionId,
            sql,
            params,
            options: { rowPacketSize: Settings.get("sql.rowPacketSize", 1e3) }
          }
        },
        onData: callback
      });
      const result = {};
      response.forEach((entry) => {
        if (entry.result.executionTime) {
          result.executionTime = entry.result.executionTime;
        }
        if (entry.result.rows) {
          if (!result.rows) {
            result.rows = [];
          }
          result.rows.push(...entry.result.rows);
        }
        if (entry.result.columns) {
          if (!result.columns) {
            result.columns = [];
          }
          result.columns.push(...entry.result.columns);
        }
        if (entry.result.totalRowCount) {
          result.totalRowCount = entry.result.totalRowCount;
        }
      });
      return result;
    }
  }
  /**
   * Reconnects the database connection.
   *
   * @returns A promise which resolves when the operation was concluded.
   */
  async reconnect() {
    const moduleSessionId = this.moduleSessionId;
    if (moduleSessionId) {
      await MessageScheduler.get.sendRequest({
        requestType: "gui.sqleditor.reconnect" /* GuiSqleditorReconnect */,
        parameters: { args: { moduleSessionId } }
      });
    }
  }
  /**
   * Stops the currently running query (if there's any).
   *
   * @returns A promise which resolves when the operation was concluded.
   */
  async killQuery() {
    const moduleSessionId = this.moduleSessionId;
    if (moduleSessionId) {
      await MessageScheduler.get.sendRequest({
        requestType: "gui.sqleditor.kill_query" /* GuiSqleditorKillQuery */,
        parameters: { args: { moduleSessionId } }
      });
    }
  }
  /**
   * Sets the auto commit mode for the current connection.
   * Note: this mode can implicitly be changed by executing certain SQL code (begin, set autocommit, rollback, etc.).
   *
   * @param state A flag indicating if the mode should be enabled or disabled.
   *
   * @returns A promise which resolves when the operation was concluded.
   */
  async setAutoCommit(state) {
    const moduleSessionId = this.moduleSessionId;
    if (moduleSessionId) {
      await MessageScheduler.get.sendRequest({
        requestType: "gui.sqleditor.set_auto_commit" /* GuiSqleditorSetAutoCommit */,
        parameters: { args: { moduleSessionId, state } }
      });
    }
  }
  /**
   * Returns the current auto commit mode, if supported.
   *
   * @returns A promise resolve to the current auto commit state or undefined if no session is open.
   */
  async getAutoCommit() {
    const moduleSessionId = this.moduleSessionId;
    if (moduleSessionId) {
      const response = await MessageScheduler.get.sendRequest({
        requestType: "gui.sqleditor.get_auto_commit" /* GuiSqleditorGetAutoCommit */,
        parameters: { args: { moduleSessionId } }
      });
      return response.result;
    }
  }
  /**
   * Returns the current default schema, if supported.
   *
   * @returns A promise resolve to the current schema or undefined if no session is open.
   */
  async getCurrentSchema() {
    const moduleSessionId = this.moduleSessionId;
    if (moduleSessionId) {
      const response = await MessageScheduler.get.sendRequest({
        requestType: "gui.sqleditor.get_current_schema" /* GuiSqleditorGetCurrentSchema */,
        parameters: { args: { moduleSessionId } }
      });
      return response.result;
    }
  }
  /**
   * Sets the current default schema, if supported.
   *
   * @param schemaName The schema to set as the default.
   *
   * @returns A promise which resolves when the operation was concluded.
   */
  async setCurrentSchema(schemaName) {
    const moduleSessionId = this.moduleSessionId;
    if (moduleSessionId) {
      await MessageScheduler.get.sendRequest({
        requestType: "gui.sqleditor.set_current_schema" /* GuiSqleditorSetCurrentSchema */,
        parameters: { args: { moduleSessionId, schemaName } }
      });
    }
  }
  /**
   * Sends a reply from the user back to the backend (e.g. passwords, choices etc.).
   *
   * @param requestId The same request ID that was used to request input from the user.
   * @param type Indicates if the user accepted the request or cancelled it.
   * @param reply The reply from the user.
   * @param moduleSessionId Use this to override the module session ID.
   *
   * @returns  A promise which resolves when the operation was concluded.
   */
  async sendReply(requestId, type, reply, moduleSessionId) {
    moduleSessionId = moduleSessionId ?? this.moduleSessionId;
    if (moduleSessionId) {
      await MessageScheduler.get.sendRequest({
        requestType: "prompt_reply" /* PromptReply */,
        parameters: { moduleSessionId, requestId, type, reply }
      }, false);
    }
  }
};

// src/utilitiesShellGui.ts
var import_anser = __toESM(require_lib(), 1);
var import_vscode28 = require("vscode");
var isShellPromptResult = (response) => {
  const candidate = response;
  return candidate?.prompt !== void 0;
};
var openSqlEditorConnection = async (sqlEditor, connectionId, progress) => {
  await sqlEditor.openConnection(connectionId, void 0, (data, requestId) => {
    const result = data.result;
    if (isShellPromptResult(result)) {
      if (result.type === "password") {
        void import_vscode28.window.showInputBox({ title: result.prompt, password: true }).then((value) => {
          if (value !== void 0) {
            void sqlEditor.sendReply(requestId, "OK" /* Ok */, value);
          } else {
            void sqlEditor.sendReply(requestId, "CANCEL" /* Cancel */, "");
          }
        });
      } else if (result.prompt) {
        void import_vscode28.window.showInputBox({ title: import_anser.default.ansiToText(result.prompt), password: false, value: "N" }).then((value) => {
          if (value) {
            void sqlEditor.sendReply(requestId, "OK" /* Ok */, value);
          } else {
            void sqlEditor.sendReply(requestId, "CANCEL" /* Cancel */, "");
          }
        });
      }
    } else if (progress) {
      const raw = data;
      progress(raw.requestState.msg);
    }
  });
};
var openSqlEditorSessionAndConnection = async (sqlEditor, connectionId, sessionName) => {
  const statusbarItem = import_vscode28.window.createStatusBarItem();
  try {
    statusbarItem.text = "$(loading~spin) Starting Database Session ...";
    statusbarItem.show();
    statusbarItem.text = "$(loading~spin) Starting Database Session ...";
    await sqlEditor.startSession(String(connectionId) + sessionName);
    statusbarItem.text = "$(loading~spin) Opening Database Connection ...";
    await openSqlEditorConnection(sqlEditor, connectionId, (message) => {
      statusbarItem.text = "$(loading~spin) " + message;
    });
    statusbarItem.hide();
  } catch (error) {
    statusbarItem.hide();
    await sqlEditor.closeSession();
    throw new Error(`A error occurred when trying to open the database connection. Error: ${error instanceof Error ? error.message : String(error)}`);
  }
};

// src/MRSCommandHandler.ts
var MRSCommandHandler = class {
  #docsWebviewPanel;
  #docsCurrentFile;
  #host;
  setup = (host2) => {
    this.#host = host2;
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.configureMySQLRestService",
      async (entry) => {
        await this.configureMrs(entry);
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.disableMySQLRestService",
      async (entry) => {
        await this.configureMrs(entry?.parent, false);
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.enableMySQLRestService",
      async (entry) => {
        await this.configureMrs(entry?.parent, true);
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.bootstrapLocalRouter",
      async (entry) => {
        await this.bootstrapLocalRouter(host2.context, entry);
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.startLocalRouter",
      async (entry) => {
        await this.startStopLocalRouter(host2.context, entry);
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand("msg.mrs.killLocalRouters", () => {
      let term = import_vscode29.window.terminals.find((t) => {
        return t.name === "MySQL Router MRS";
      });
      if (term === void 0) {
        term = import_vscode29.window.createTerminal("MySQL Router MRS");
      }
      if (import_os3.default.platform() === "win32") {
        term.sendText("taskkill /IM mysqlrouter.exe /F", true);
      } else {
        term.sendText("killall -9 mysqlrouter", true);
      }
      try {
        import_fs6.default.unlinkSync(import_path6.default.join(this.getLocalRouterConfigDir(), "mysqlrouter.pid"));
      } catch (error) {
      }
    }));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.stopLocalRouter",
      async (item) => {
        await this.startStopLocalRouter(host2.context, item, false);
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand("msg.mrs.docs", () => {
      this.browseDocs();
    }));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand("msg.mrs.docs.service", () => {
      this.browseDocs("rest-service-properties");
    }));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.deleteRouter",
      async (entry) => {
        if (entry) {
          const item = entry.treeItem;
          const answer = await import_vscode29.window.showInformationMessage(
            `Are you sure the MRS router ${item.value.address} should be deleted?`,
            "Yes",
            "No"
          );
          if (answer === "Yes") {
            try {
              await item.backend?.mrs.deleteRouter(item.value.id);
              await import_vscode29.commands.executeCommand("msg.refreshConnections");
              showMessageWithTimeout("The MRS Router has been deleted successfully.");
            } catch (error) {
              void import_vscode29.window.showErrorMessage(`Error deleting the MRS Router: ${String(error)}`);
            }
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand("msg.mrs.addService", (entry) => {
      if (entry) {
        const item = entry.treeItem;
        const connectionId = String(item.connectionId);
        const provider = this.#host.currentProvider;
        if (provider) {
          void provider.runCommand("job", [
            { requestType: "showModule", parameter: DBEditorModuleId },
            { requestType: "showPage", parameter: { module: DBEditorModuleId, page: connectionId } },
            { requestType: "showMrsServiceDialog", parameter: void 0 }
          ], "newConnection");
        }
      }
    }));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.editService",
      (entry) => {
        if (entry) {
          const item = entry.treeItem;
          const connectionId = String(item.connectionId);
          const provider = this.#host.currentProvider;
          if (provider) {
            void provider.runCommand("job", [
              { requestType: "showModule", parameter: DBEditorModuleId },
              { requestType: "showPage", parameter: { module: DBEditorModuleId, page: connectionId } },
              { requestType: "showMrsServiceDialog", parameter: item.value }
            ], "newConnection");
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.deleteService",
      async (entry) => {
        if (entry) {
          const item = entry.treeItem;
          const answer = await import_vscode29.window.showInformationMessage(
            `Are you sure the MRS service ${item.value.urlContextRoot} should be deleted?`,
            "Yes",
            "No"
          );
          if (answer === "Yes") {
            try {
              await item.backend?.mrs.deleteService(item.value.id);
              await import_vscode29.commands.executeCommand("msg.refreshConnections");
              showMessageWithTimeout("The MRS service has been deleted successfully.");
            } catch (error) {
              void import_vscode29.window.showErrorMessage(`Error adding the MRS service: ${String(error)}`);
            }
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.setCurrentService",
      async (entry) => {
        if (entry) {
          try {
            const item = entry.treeItem;
            await item.backend?.mrs.setCurrentService(item.value.id);
            await import_vscode29.commands.executeCommand("msg.refreshConnections");
            showMessageWithTimeout("The MRS service has been set as the new default service.");
          } catch (reason) {
            void import_vscode29.window.showErrorMessage(`Error setting the default MRS service: ${String(reason)}`);
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.exportServiceSdk",
      async (entry) => {
        if (entry) {
          const item = entry.treeItem;
          if (item.value) {
            const backend = item.backend;
            await import_vscode29.window.showSaveDialog({
              title: "Export REST Service SDK Files...",
              defaultUri: import_vscode29.Uri.file(`${import_os3.default.homedir()}/${pathToCamelCase(item.value.urlContextRoot)}.mrs.sdk`),
              saveLabel: "Export SDK Files"
            }).then(async (value) => {
              if (value !== void 0) {
                try {
                  const path25 = value.fsPath;
                  await backend.mrs.dumpSdkServiceFiles(item.value.id, "TypeScript", path25);
                  showMessageWithTimeout("MRS Service REST Files exported successfully.");
                } catch (error) {
                  void import_vscode29.window.showErrorMessage(
                    `Error while exporting the REST Service SDK Files: ${String(error)}`
                  );
                }
              }
            });
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.deleteSchema",
      async (entry) => {
        if (entry) {
          const item = entry.treeItem;
          const answer = await import_vscode29.window.showInformationMessage(
            `Are you sure the MRS schema ${item.value.name} should be deleted?`,
            "Yes",
            "No"
          );
          if (answer === "Yes") {
            try {
              await entry.treeItem.backend.mrs.deleteSchema(item.value.id, item.value.serviceId);
              await import_vscode29.commands.executeCommand("msg.refreshConnections");
              showMessageWithTimeout("The MRS schema has been deleted successfully.");
            } catch (error) {
              void import_vscode29.window.showErrorMessage(`Error removing an MRS schema: ${String(error)}`);
            }
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.editSchema",
      (entry) => {
        if (entry) {
          const item = entry.treeItem;
          const connectionId = String(item.connectionId);
          const provider = this.#host.currentProvider;
          if (provider) {
            void provider.runCommand("job", [
              { requestType: "showModule", parameter: DBEditorModuleId },
              { requestType: "showPage", parameter: { module: DBEditorModuleId, page: connectionId } },
              {
                requestType: "showMrsSchemaDialog",
                parameter: { schemaName: item.value.name, schema: item.value }
              }
            ], "newConnection");
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.addSchema",
      async (entry) => {
        if (entry) {
          const item = entry.treeItem;
          const connectionId = String(item.connectionId);
          const provider = this.#host.currentProvider;
          if (provider) {
            const services = await item.backend.mrs.listServices();
            if (services.length > 0) {
              void provider.runCommand("job", [
                { requestType: "showModule", parameter: DBEditorModuleId },
                {
                  requestType: "showPage",
                  parameter: {
                    module: DBEditorModuleId,
                    page: connectionId
                  }
                },
                {
                  requestType: "showMrsSchemaDialog",
                  parameter: { schemaName: item.schema }
                }
              ], "newConnection");
            } else {
              void import_vscode29.window.showErrorMessage(`Please create a REST Service before adding a DB Schema.`);
            }
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.copyDbObjectRequestPath",
      async (entry) => {
        if (entry) {
          const item = entry.treeItem;
          if (item.value) {
            const o = item.value;
            await import_vscode29.env.clipboard.writeText((o.hostCtx ?? "") + (o.schemaRequestPath ?? "") + o.requestPath);
            showMessageWithTimeout("The DB Object was copied to the system clipboard");
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.openDbObjectRequestPath",
      async (entry) => {
        if (entry) {
          const item = entry.treeItem;
          if (item.value) {
            const o = item.value;
            let url = (o.hostCtx ?? "") + (o.schemaRequestPath ?? "") + o.requestPath;
            if (url.startsWith("/")) {
              url = `https://localhost:8443${url}`;
            } else {
              url = `https://${url}`;
            }
            await import_vscode29.env.openExternal(import_vscode29.Uri.parse(url));
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.openContentFileRequestPath",
      async (entry) => {
        if (entry) {
          const item = entry.treeItem;
          if (item.value) {
            const o = item.value;
            let url = (o.hostCtx ?? "") + (o.contentSetRequestPath ?? "") + o.requestPath;
            if (url.startsWith("/")) {
              url = `https://localhost:8443${url}`;
            } else {
              url = `https://${url}`;
            }
            await import_vscode29.env.openExternal(import_vscode29.Uri.parse(url));
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.deleteDbObject",
      async (entry) => {
        if (entry) {
          const item = entry.treeItem;
          if (item.value) {
            const backend = item.backend;
            const accepted = await showModalDialog(
              `Are you sure you want to delete the REST DB Object ${item.value.name}?`,
              "Delete DB Object",
              "This operation cannot be reverted!"
            );
            if (accepted) {
              try {
                await backend.mrs.deleteDbObject(item.value.id);
                void import_vscode29.commands.executeCommand("msg.refreshConnections");
                showMessageWithTimeout(`The REST DB Object ${item.value.name} has been deleted.`);
              } catch (reason) {
                void import_vscode29.window.showErrorMessage(`Error deleting the REST DB Object: ${String(reason)}`);
              }
            }
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.editAuthApp",
      (entry) => {
        if (entry) {
          const item = entry.treeItem;
          const connectionId = String(item.connectionId);
          const provider = this.#host.currentProvider;
          if (provider) {
            void provider.runCommand("job", [
              { requestType: "showModule", parameter: DBEditorModuleId },
              { requestType: "showPage", parameter: { module: DBEditorModuleId, page: connectionId } },
              { requestType: "showMrsAuthAppDialog", parameter: { authApp: item.value } }
            ], "newConnection");
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.addAuthApp",
      (entry) => {
        try {
          if (entry) {
            const item = entry.treeItem;
            if (item.value) {
              const connectionId = String(item.connectionId);
              const provider = this.#host.currentProvider;
              if (provider) {
                void provider.runCommand("job", [
                  { requestType: "showModule", parameter: DBEditorModuleId },
                  {
                    requestType: "showPage",
                    parameter: { module: DBEditorModuleId, page: connectionId }
                  },
                  { requestType: "showMrsAuthAppDialog", parameter: { service: item.value } }
                ], "newConnection");
              }
            }
          }
        } catch (reason) {
          void import_vscode29.window.showErrorMessage(`Error adding a new MRS Authentication App: ${String(reason)}`);
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.deleteAuthApp",
      async (entry) => {
        try {
          if (entry) {
            const item = entry.treeItem;
            if (item.value?.name) {
              const backend = item.backend;
              const answer = await import_vscode29.window.showInformationMessage(
                `Are you sure the MRS authentication app ${item.value.name} should be deleted?`,
                "Yes",
                "No"
              );
              if (answer === "Yes") {
                await backend.mrs.deleteAuthApp(item.value.id);
                void import_vscode29.commands.executeCommand("msg.refreshConnections");
                showMessageWithTimeout(`The MRS Authentication App ${item.value.name} has been deleted.`);
              }
            }
          }
        } catch (reason) {
          void import_vscode29.window.showErrorMessage(`Error deleting the MRS Authentication App: ${String(reason)}`);
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.deleteUser",
      async (entry) => {
        try {
          if (entry) {
            const item = entry.treeItem;
            if (item.value.id && item.value.name) {
              const backend = item.backend;
              const answer = await import_vscode29.window.showInformationMessage(
                `Are you sure the MRS user ${item.value.name ?? "unknown"} should be deleted?`,
                "Yes",
                "No"
              );
              if (answer === "Yes") {
                await backend.mrs.deleteUser(item.value.id);
                void import_vscode29.commands.executeCommand("msg.refreshConnections");
                showMessageWithTimeout(`The MRS User ${item.value.name} has been deleted.`);
              }
            }
          }
        } catch (reason) {
          void import_vscode29.window.showErrorMessage(`Error deleting the MRS User: ${String(reason)}`);
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand("msg.mrs.addUser", (entry) => {
      if (entry) {
        const item = entry.treeItem;
        if (item.value) {
          const connectionId = String(item.connectionId);
          const provider = this.#host.currentProvider;
          if (provider) {
            void provider.runCommand("job", [
              { requestType: "showModule", parameter: DBEditorModuleId },
              { requestType: "showPage", parameter: { module: DBEditorModuleId, page: connectionId } },
              { requestType: "showMrsUserDialog", parameter: { authApp: item.value } }
            ], "newConnection");
          }
        }
      }
    }));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand("msg.mrs.editUser", (entry) => {
      const item = entry?.treeItem;
      const backend = item?.backend;
      try {
        if (backend && item.value && item.value.authAppId) {
          backend.mrs.getAuthApp(item.value.authAppId).then((authApp) => {
            if (authApp) {
              const connectionId = String(item.connectionId);
              const provider = this.#host.currentProvider;
              if (provider) {
                void provider.runCommand("job", [
                  { requestType: "showModule", parameter: DBEditorModuleId },
                  {
                    requestType: "showPage",
                    parameter: {
                      module: DBEditorModuleId,
                      page: connectionId
                    }
                  },
                  { requestType: "showMrsUserDialog", parameter: { authApp, user: item.value } }
                ], "newConnection");
              }
            } else {
              throw new Error("Unable to find authApp");
            }
          }).catch((reason) => {
            void import_vscode29.window.showErrorMessage(`Error adding a new User: ${String(reason)}`);
          });
        }
      } catch (reason) {
        void import_vscode29.window.showErrorMessage(`Error adding a new User: ${String(reason)}`);
      }
    }));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.addFolderAsContentSet",
      async (directory) => {
        if (directory) {
          const connection = await host2.determineConnection("MySQL" /* MySQL */);
          if (connection) {
            const provider = this.#host.currentProvider;
            if (provider) {
              void provider.runCommand("job", [
                { requestType: "showModule", parameter: DBEditorModuleId },
                {
                  requestType: "showPage",
                  parameter: {
                    module: DBEditorModuleId,
                    page: String(connection.treeItem.details.id)
                  }
                },
                {
                  requestType: "showMrsContentSetDialog",
                  parameter: {
                    directory: directory.fsPath
                  }
                }
              ], "newConnection");
            }
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.rebuildMrsSdk",
      async (directory) => {
        if (directory) {
          const connection = await host2.determineConnection("MySQL" /* MySQL */);
          if (connection) {
            void import_vscode29.window.showErrorMessage("Not yet implemented.");
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.deleteContentSet",
      async (entry) => {
        if (entry) {
          const item = entry.treeItem;
          if (item.value) {
            const backend = item.backend;
            const accepted = await showModalDialog(
              `Are you sure you want to drop the static content set ${item.value.requestPath}?`,
              "Delete Static Content Set",
              "This operation cannot be reverted!"
            );
            if (accepted) {
              try {
                await backend.mrs.deleteContentSet(item.value.id);
                void import_vscode29.commands.executeCommand("msg.refreshConnections");
                showMessageWithTimeout(
                  "The MRS static content set has been deleted successfully."
                );
              } catch (error) {
                void import_vscode29.window.showErrorMessage(
                  `Error deleting the Static Content Set: ${String(error)}`
                );
              }
            }
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.dumpSchemaToJSONFile",
      async (entry) => {
        if (entry) {
          const item = entry.treeItem;
          if (item.value) {
            const backend = item.backend;
            await import_vscode29.window.showSaveDialog({
              title: "REST Schema Dump...",
              saveLabel: "Select the target file",
              defaultUri: import_vscode29.Uri.file(`${import_os3.default.homedir()}/${pathToCamelCase(item.value.requestPath)}.mrs.json`),
              filters: {
                // eslint-disable-next-line @typescript-eslint/naming-convention
                JSON: ["mrs.json"]
              }
            }).then(async (value) => {
              if (value !== void 0) {
                try {
                  const path25 = value.fsPath;
                  await backend.mrs.dumpSchema(path25, item.value.serviceId, void 0, item.value.id);
                  showMessageWithTimeout("The REST Schema has been dumped successfully.");
                } catch (error) {
                  void import_vscode29.window.showErrorMessage(
                    `Error dumping the REST Schema: ${String(error)}`
                  );
                }
              }
            });
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.dumpObjectToJSONFile",
      async (entry) => {
        if (entry) {
          const item = entry.treeItem;
          if (item.value) {
            const backend = item.backend;
            await import_vscode29.window.showSaveDialog({
              title: "REST Database Object Dump...",
              saveLabel: "Select the target file",
              defaultUri: import_vscode29.Uri.file(`${import_os3.default.homedir()}/${item.value.name}.mrs.json`),
              filters: {
                // eslint-disable-next-line @typescript-eslint/naming-convention
                JSON: ["mrs.json"]
              }
            }).then(async (value) => {
              if (value !== void 0) {
                try {
                  const path25 = value.fsPath;
                  await backend.mrs.dumpObject(
                    path25,
                    item.value.serviceId,
                    void 0,
                    item.value.dbSchemaId,
                    void 0,
                    item.value.id
                  );
                  showMessageWithTimeout("The REST Database Object has been dumped successfully.");
                } catch (error) {
                  void import_vscode29.window.showErrorMessage(
                    `Error dumping the REST Database Object: ${String(error)}`
                  );
                }
              }
            });
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.loadSchemaFromJSONFile",
      async (entry) => {
        if (!entry) {
          return;
        }
        if (!(entry instanceof import_vscode29.Uri)) {
          if (!entry.treeItem.value) {
            return;
          }
          const backend = entry.treeItem.backend;
          await import_vscode29.window.showOpenDialog({
            title: "REST Schema Load...",
            openLabel: "Select the source file",
            canSelectFiles: true,
            canSelectFolders: false,
            canSelectMany: false,
            filters: {
              // eslint-disable-next-line @typescript-eslint/naming-convention
              JSON: ["mrs.json"]
            }
          }).then(async (value) => {
            if (value !== void 0) {
              const statusbarItem = import_vscode29.window.createStatusBarItem();
              try {
                statusbarItem.text = "$(loading~spin) Loading REST Schema ...";
                statusbarItem.show();
                const path25 = value[0].fsPath;
                await backend.mrs.loadSchema(path25, entry.treeItem.value.id);
                void import_vscode29.commands.executeCommand("msg.refreshConnections");
                showMessageWithTimeout("The REST Schema has been loaded successfully.");
              } catch (error) {
                void import_vscode29.window.showErrorMessage(
                  `Error loading REST Schema: ${String(error)}`
                );
              } finally {
                statusbarItem.hide();
              }
            }
          });
        } else {
          const connection = await host2.determineConnection("MySQL" /* MySQL */);
          if (connection) {
            const sqlEditor = new ShellInterfaceSqlEditor();
            const statusbarItem = import_vscode29.window.createStatusBarItem();
            try {
              statusbarItem.text = "$(loading~spin) Starting Database Session ...";
              statusbarItem.show();
              statusbarItem.text = "$(loading~spin) Starting Database Session ...";
              await sqlEditor.startSession(String(connection.treeItem.details.id) + "MRSContentSetDlg");
              statusbarItem.text = "$(loading~spin) Opening Database Connection ...";
              await openSqlEditorConnection(sqlEditor, connection.treeItem.details.id, (message) => {
                statusbarItem.text = "$(loading~spin) " + message;
              });
              const services = await sqlEditor.mrs.listServices();
              let service;
              if (services.length === 0) {
                void import_vscode29.window.showErrorMessage("No MRS Services available for this connection.");
              } else if (services.length === 1) {
                service = services[0];
              } else {
                statusbarItem.text = "Please select a MRS Service ...";
                const items = services.map((service2) => {
                  return service2.hostCtx;
                });
                const serviceHostCtx = await import_vscode29.window.showQuickPick(items, {
                  title: "Select a MRS Service to load the MRS schema dump",
                  matchOnDescription: true,
                  placeHolder: "Type the name of an existing MRS Service"
                });
                service = services.find((candidate) => {
                  return candidate.hostCtx === serviceHostCtx;
                });
              }
              if (service !== void 0) {
                statusbarItem.text = "$(loading~spin) Loading REST Schema ...";
                await sqlEditor.mrs.loadSchema(entry.fsPath, service.id);
                void import_vscode29.commands.executeCommand("msg.refreshConnections");
                showMessageWithTimeout("The REST Schema has been loaded successfully.");
              }
            } catch (error) {
              void import_vscode29.window.showErrorMessage(`A error occurred when trying to show the MRS Static Content Set Dialog. Error: ${error instanceof Error ? error.message : String(error)}`);
            } finally {
              statusbarItem.hide();
              await sqlEditor.closeSession();
            }
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.loadObjectFromJSONFile",
      async (entry) => {
        if (entry) {
          const item = entry.treeItem;
          if (item.value) {
            const backend = item.backend;
            await import_vscode29.window.showOpenDialog({
              title: "REST Database Object Load...",
              openLabel: "Select the source file",
              canSelectFiles: true,
              canSelectFolders: false,
              canSelectMany: false,
              filters: {
                // eslint-disable-next-line @typescript-eslint/naming-convention
                JSON: ["mrs.json"]
              }
            }).then(async (value) => {
              if (value !== void 0) {
                try {
                  const path25 = value[0].fsPath;
                  await backend.mrs.loadObject(path25, item.value.serviceId, void 0, item.value.id);
                  void import_vscode29.commands.executeCommand("msg.refreshConnections");
                  showMessageWithTimeout("The REST Database Object has been loaded successfully.");
                } catch (error) {
                  void import_vscode29.window.showErrorMessage(
                    `Error loading REST Database Object: ${String(error)}`
                  );
                }
              }
            });
          }
        }
      }
    ));
    host2.context.subscriptions.push(import_vscode29.commands.registerCommand(
      "msg.mrs.saveExampleProject",
      async (exampleCodePath) => {
        const path25 = exampleCodePath.fsPath;
        let m3;
        if (import_os3.default.platform() === "win32") {
          m3 = path25.match(/([^\\]*)\/*$/);
        } else {
          m3 = path25.match(/([^/]*)\/*$/);
        }
        if (m3 === null) {
          void import_vscode29.window.showErrorMessage(
            `Error storing the MRS Project: Project folder contains no path.`
          );
          return;
        }
        const dirName = m3[1];
        await import_vscode29.window.showOpenDialog({
          title: `Saving MRS Example Project "${dirName}" ...`,
          openLabel: `Save ${dirName} Project`,
          canSelectFiles: false,
          canSelectFolders: true,
          canSelectMany: false,
          defaultUri: import_vscode29.Uri.file(`${import_os3.default.homedir()}/Documents`)
        }).then(async (value) => {
          if (value !== void 0) {
            try {
              const targetPath = import_vscode29.Uri.joinPath(value[0], dirName);
              const filter = (src) => {
                return src.indexOf("node_modules") === -1;
              };
              import_fs6.default.cpSync(path25, targetPath.fsPath, { filter, recursive: true });
              showMessageWithTimeout(`The MRS Project ${dirName} has been stored successfully.`);
              const answer = await import_vscode29.window.showInformationMessage(
                `Do you want to open the MRS Project ${dirName} in a new VS Code Window?`,
                "Yes",
                "No"
              );
              if (answer === "Yes") {
                void import_vscode29.commands.executeCommand(
                  `vscode.openFolder`,
                  targetPath,
                  { forceNewWindow: true }
                );
              }
            } catch (error) {
              void import_vscode29.window.showErrorMessage(
                `Error storing the MRS Project: ${String(error)}`
              );
            }
          }
        });
      }
    ));
  };
  configureMrs = async (entry, enableMrs) => {
    let answer = "Yes";
    if (enableMrs === void 0) {
      answer = await import_vscode29.window.showInformationMessage(
        `Do you want to configure this instance for MySQL REST Service Support? This operation will create the MRS metadata database schema.`,
        "Yes",
        "No"
      );
    }
    if (entry && answer === "Yes") {
      const sqlEditor = new ShellInterfaceSqlEditor();
      try {
        await openSqlEditorSessionAndConnection(
          sqlEditor,
          entry.treeItem.details.id,
          "msg.mrs.configureMySQLRestService"
        );
        const statusbarItem = import_vscode29.window.createStatusBarItem();
        try {
          statusbarItem.text = "$(loading~spin) Configuring the MySQL REST Service Metadata Schema ...";
          statusbarItem.show();
          await sqlEditor.mrs.configure(enableMrs);
        } finally {
          statusbarItem.hide();
        }
        void import_vscode29.commands.executeCommand("msg.refreshConnections");
        showMessageWithTimeout("MySQL REST Service configured successfully.");
      } catch (error) {
        void import_vscode29.window.showErrorMessage(`A error occurred when trying to configure the MySQL REST Service. Error: ${error instanceof Error ? error.message : String(error)}`);
      } finally {
        await sqlEditor.closeSession();
      }
    }
  };
  bootstrapLocalRouter = async (context, entry, waitAndClosedWhenFinished = false) => {
    if (entry) {
      if (findExecutable("mysqlrouter_bootstrap").length > 0) {
        const shellConfDir = MySQLShellLauncher.getShellUserConfigDir(
          context.extensionMode === import_vscode29.ExtensionMode.Development
        );
        const certDir = import_path6.default.join(shellConfDir, "plugin_data", "gui_plugin", "web_certs");
        const mysqlConnOptions = entry.parent.treeItem.details.options;
        if (mysqlConnOptions.scheme !== "mysql" /* MySQL */) {
          void import_vscode29.window.showErrorMessage(
            "Only DB Connections using classic MySQL protocol can be used for bootstrapping."
          );
          return;
        }
        if (mysqlConnOptions.ssh !== void 0 || mysqlConnOptions["mysql-db-system-id"] !== void 0) {
          void import_vscode29.window.showErrorMessage(
            "DB Connection using SSH Tunneling or MDS Bastion settings cannot be used for bootstrapping."
          );
          return;
        }
        const connString = `${mysqlConnOptions.user ?? ""}@${mysqlConnOptions.host}` + (mysqlConnOptions.port !== void 0 ? `:${mysqlConnOptions.port}` : "");
        let term = import_vscode29.window.terminals.find((t) => {
          return t.name === "MySQL Router MRS";
        });
        if (term === void 0) {
          term = import_vscode29.window.createTerminal("MySQL Router MRS");
        }
        let routerConfigDir;
        if (process.env.MYSQL_ROUTER_CUSTOM_DIR !== void 0) {
          routerConfigDir = process.env.MYSQL_ROUTER_CUSTOM_DIR;
        } else {
          if (import_os3.default.platform() === "win32") {
            routerConfigDir = import_path6.default.join(this.getBaseDir(), "mysqlrouter");
          } else {
            routerConfigDir = import_path6.default.join(this.getBaseDir(), ".mysqlrouter");
          }
        }
        if (import_fs6.default.existsSync(routerConfigDir)) {
          const answer = await import_vscode29.window.showInformationMessage(
            `The MySQL Router config directory ${routerConfigDir} already exists. Do you want to rename the existing directory and proceed?`,
            "Yes",
            "No"
          );
          if (answer === "Yes") {
            try {
              import_fs6.default.renameSync(routerConfigDir, routerConfigDir + "_old");
            } catch (e) {
              import_fs6.default.rmSync(routerConfigDir + "_old", { recursive: true, force: true });
              import_fs6.default.renameSync(routerConfigDir, routerConfigDir + "_old");
            }
          } else {
            return;
          }
        }
        if (term !== void 0) {
          term.show();
          term.sendText(
            `mysqlrouter_bootstrap ${connString} --mrs --directory "${routerConfigDir}" "--conf-set-option=http_server.ssl_cert=${import_path6.default.join(certDir, "server.crt")}" "--conf-set-option=http_server.ssl_key=${import_path6.default.join(certDir, "server.key")}" --conf-set-option=logger.level=DEBUG --conf-set-option=logger.sinks=consolelog`,
            !waitAndClosedWhenFinished
          );
          if (waitAndClosedWhenFinished) {
            term.sendText("; exit");
            return new Promise((resolve, reject) => {
              const disposeToken = import_vscode29.window.onDidCloseTerminal(
                (closedTerminal) => {
                  if (closedTerminal === term) {
                    disposeToken.dispose();
                    if (term.exitStatus !== void 0) {
                      resolve(term.exitStatus);
                    } else {
                      reject("Terminal exited with undefined status");
                    }
                  }
                }
              );
            });
          }
        }
      } else {
        const answer = await import_vscode29.window.showInformationMessage(
          "The mysqlrouter_bootstrap executable could not be found in any directory listed in the PATH environment variable. This seems to indicate that MySQL Router has not been installed. Do you want to download and install the MySQL Router now?",
          "Yes",
          "No"
        );
        if (answer === "Yes") {
          const labsUrl = "https://downloads.mysql.com/snapshots/pb/mysql-router-8.1.0-labs-mrs-preview-6/";
          let fileUrl;
          switch (import_os3.default.platform()) {
            case "darwin": {
              switch (import_os3.default.arch()) {
                case "arm":
                case "arm64": {
                  fileUrl = `${labsUrl}mysql-router-8.1.0-labs-mrs-6-macos13-arm64.dmg`;
                  break;
                }
                default: {
                  fileUrl = `${labsUrl}mysql-router-8.1.0-labs-mrs-6-macos13-x86_64.dmg`;
                  break;
                }
              }
              break;
            }
            case "win32": {
              fileUrl = `${labsUrl}mysql-router-8.1.0-labs-mrs-6-winx64.msi`;
              break;
            }
            default: {
              fileUrl = "https://labs.mysql.com";
              break;
            }
          }
          await import_vscode29.env.openExternal(import_vscode29.Uri.parse(fileUrl));
          await import_vscode29.window.showInformationMessage(
            "After installing MySQL Router, VS Code needs to be restarted to read the updated PATH environment variable. Please manually restart VS Code after completing the installation process.",
            "OK"
          );
        }
      }
    }
  };
  getBaseDir = () => {
    if (import_os3.default.platform() !== "win32") {
      return import_os3.default.homedir();
    }
    return import_path6.default.join(import_os3.default.homedir(), "AppData", "Roaming", "MySQL");
  };
  getLocalRouterConfigDir = () => {
    let routerConfigDir;
    if (import_os3.default.platform() === "win32") {
      routerConfigDir = import_path6.default.join(this.getBaseDir(), "mysqlrouter");
    } else {
      routerConfigDir = import_path6.default.join(this.getBaseDir(), ".mysqlrouter");
    }
    return routerConfigDir;
  };
  startStopLocalRouter = async (context, entry, start = true) => {
    if (entry) {
      if (findExecutable("mysqlrouter")) {
        const routerConfigDir = this.getLocalRouterConfigDir();
        if (import_fs6.default.existsSync(routerConfigDir)) {
          let term = import_vscode29.window.terminals.find((t) => {
            return t.name === "MySQL Router MRS";
          });
          if (term === void 0) {
            term = import_vscode29.window.createTerminal("MySQL Router MRS");
          }
          if (term !== void 0) {
            let cmd = (start ? "start" : "stop") + (import_os3.default.platform() === "win32" ? ".ps1" : ".sh");
            cmd = import_path6.default.join(routerConfigDir, cmd);
            if (cmd.includes(" ")) {
              if (import_os3.default.platform() === "win32") {
                if (cmd.includes(" ")) {
                  cmd = '& "' + cmd + '"';
                }
              } else {
                cmd = '"' + cmd + '"';
              }
            }
            term.show();
            if (import_os3.default.platform() === "win32") {
              term.sendText("Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser", true);
              term.sendText("clear", true);
            }
            term.sendText(cmd, true);
          }
        } else {
          if (start) {
            const answer = await import_vscode29.window.showInformationMessage(
              `The MySQL Router config directory ${routerConfigDir} was not found. Do you want to bootstrap a local MySQL Router instance for development now?`,
              "Yes",
              "No"
            );
            if (answer === "Yes") {
              await this.bootstrapLocalRouter(this.#host.context, entry, true);
              void this.startStopLocalRouter(this.#host.context, entry);
            }
          } else {
            showMessageWithTimeout(
              `The MySQL Router config directory ${routerConfigDir} was not found. Please bootstrap a local MySQL Router instance for development first.`
            );
          }
        }
      } else {
        const answer = await import_vscode29.window.showInformationMessage(
          `The mysqlrouter executable could not be found. Do you want to download and install the MySQL Router now?`,
          "Yes",
          "No"
        );
        if (answer === "Yes") {
          void import_vscode29.env.openExternal(import_vscode29.Uri.parse("https://labs.mysql.com"));
        }
      }
    }
  };
  browseDocs = (id, file = "index.html") => {
    const fileChange = this.#docsCurrentFile !== file;
    if (!this.#docsWebviewPanel || fileChange) {
      this.#docsCurrentFile = file;
      try {
        let data;
        let mrsPluginDir = import_path6.default.join(
          this.#host.context.extensionPath,
          "shell",
          "lib",
          "mysqlsh",
          "plugins",
          "mrs_plugin"
        );
        let indexPath = import_path6.default.join(mrsPluginDir, "docs", file);
        if (import_fs6.default.existsSync(indexPath)) {
          data = import_fs6.default.readFileSync(indexPath, "utf8");
        } else {
          if (import_os3.default.platform() === "win32") {
            mrsPluginDir = import_path6.default.join(
              this.getBaseDir(),
              "mysqlsh",
              "plugins",
              "mrs_plugin"
            );
          } else {
            mrsPluginDir = import_path6.default.join(this.getBaseDir(), ".mysqlsh", "plugins", "mrs_plugin");
          }
          indexPath = import_path6.default.join(mrsPluginDir, "docs", file);
          if (import_fs6.default.existsSync(indexPath)) {
            data = import_fs6.default.readFileSync(indexPath, "utf8");
          } else {
            throw new Error(`MRS Documentation not found.`);
          }
        }
        if (!this.#docsWebviewPanel) {
          this.#docsWebviewPanel = import_vscode29.window.createWebviewPanel(
            "mrsDocs",
            "MRS Docs",
            import_vscode29.ViewColumn.One,
            {
              enableScripts: true,
              retainContextWhenHidden: true,
              localResourceRoots: [
                import_vscode29.Uri.file(import_path6.default.join(mrsPluginDir, "docs")),
                import_vscode29.Uri.file(import_path6.default.join(mrsPluginDir, "docs", "style")),
                import_vscode29.Uri.file(import_path6.default.join(mrsPluginDir, "docs", "images"))
              ]
            }
          );
          this.#docsWebviewPanel.onDidDispose(() => {
            this.handleDocsWebviewPanelDispose();
          });
          this.#docsWebviewPanel.webview.onDidReceiveMessage(
            (message) => {
              if (message.path && typeof message.path === "string" && import_os3.default.platform() === "win32") {
                message.path = String(message.path).replaceAll("/", "\\");
              }
              switch (message.command) {
                case "openSqlFile": {
                  if (message.path && typeof message.path === "string") {
                    const fullPath = import_vscode29.Uri.file(import_path6.default.join(mrsPluginDir, String(message.path)));
                    void import_vscode29.commands.executeCommand("msg.editInScriptEditor", fullPath);
                  }
                  break;
                }
                case "loadMrsDump": {
                  if (message.path && typeof message.path === "string") {
                    const fullPath = import_vscode29.Uri.file(import_path6.default.join(mrsPluginDir, String(message.path)));
                    void import_vscode29.commands.executeCommand("msg.mrs.loadSchemaFromJSONFile", fullPath);
                  }
                  break;
                }
                case "saveProject": {
                  if (message.path && typeof message.path === "string") {
                    const fullPath = import_vscode29.Uri.file(import_path6.default.join(mrsPluginDir, String(message.path)));
                    void import_vscode29.commands.executeCommand("msg.mrs.saveExampleProject", fullPath);
                  }
                  break;
                }
                case "goto": {
                  let file2;
                  let id2;
                  if (message.path && typeof message.path === "string") {
                    file2 = message.path;
                  }
                  if (message.id && typeof message.id === "string") {
                    id2 = message.id;
                  }
                  this.browseDocs(id2, file2);
                  break;
                }
                default:
              }
            }
          );
        }
        const docUrl = this.#docsWebviewPanel.webview.asWebviewUri(
          import_vscode29.Uri.file(import_path6.default.join(mrsPluginDir, "docs/"))
        );
        data = data.replace('"style/', `"${docUrl.toString()}style/`);
        data = data.replace(/(src=")(.*)(\/images)/gm, `$1${docUrl.toString()}$3`);
        data = data.replace(/(href=")((?!http).*?\.html)(#.*?)?(")/gm, `$1$2$3$4 onclick="document.vscode.postMessage({ command: 'goto', path: '$2', id: '$3' });" `);
        this.#docsWebviewPanel.webview.html = data;
      } catch (reason) {
        this.#docsWebviewPanel = void 0;
        void import_vscode29.window.showErrorMessage(`${String(reason)}`);
      }
    } else {
      this.#docsWebviewPanel.reveal();
    }
    if (id && this.#docsWebviewPanel) {
      if (id.startsWith("#")) {
        id = id.slice(1);
      }
      if (fileChange) {
        setTimeout(() => {
          void this.#docsWebviewPanel?.webview.postMessage({ command: "goToId", id });
        }, 200);
      } else {
        void this.#docsWebviewPanel.webview.postMessage({ command: "goToId", id });
      }
    }
  };
  handleDocsWebviewPanelDispose = () => {
    this.#docsWebviewPanel = void 0;
  };
};

// src/ShellConsoleCommandHandler.ts
var import_vscode31 = require("vscode");

// src/tree-providers/ConnectionsTreeProvider/ConnectionTreeItem.ts
var path21 = __toESM(require("path"), 1);
var import_vscode30 = require("vscode");
var ConnectionTreeItem = class extends import_vscode30.TreeItem {
  constructor(details, backend) {
    super(details.caption, import_vscode30.TreeItemCollapsibleState.Collapsed);
    this.details = details;
    this.backend = backend;
    this.iconPath = {
      light: path21.join(__dirname, "..", "images", "light", "connected.svg"),
      dark: path21.join(__dirname, "..", "images", "dark", "connected.svg")
    };
  }
  contextValue = "connection";
};

// src/WebviewProviders/ShellConsoleViewProvider.ts
var ShellConsoleViewProvider = class extends WebviewProvider {
  openSessions = [];
  constructor(url, onDispose) {
    super(url, onDispose);
  }
  /**
   * Shows the given module page.
   *
   * @param page The page to show.
   *
   * @returns A promise which resolves after the command was executed.
   */
  show(page) {
    return this.runCommand("job", [
      { requestType: "showModule", parameter: ShellModuleId },
      { requestType: "showPage", parameter: { module: ShellModuleId, page } }
    ], "newShellConsole");
  }
  /**
   * Opens a page for a session with the given session id.
   *
   * @param session The session to open.
   *
   * @returns A promise which resolves after the command was executed.
   */
  openSession(session) {
    const command = session.sessionId === -1 ? "newSession" : "openSession";
    return this.runCommand("job", [
      { requestType: "showModule", parameter: ShellModuleId },
      { requestType: command, parameter: session }
    ], "newShellConsole");
  }
  /**
   * Closes the session with the given id.
   *
   * @param session The session to remove.
   *
   * @returns A promise which resolves after the command was executed.
   */
  removeSession(session) {
    return this.runCommand("removeSession", session, "newShellConsole");
  }
  requisitionsCreated() {
    super.requisitionsCreated();
    if (this.requisitions) {
      this.requisitions.register("sessionAdded", this.sessionAdded);
      this.requisitions.register("sessionRemoved", this.sessionRemoved);
    }
  }
  sessionAdded = (session) => {
    this.openSessions.push(session);
    return requisitions.execute("proxyRequest", {
      provider: this,
      original: {
        requestType: "refreshSessions",
        parameter: this.openSessions
      }
    });
  };
  sessionRemoved = (session) => {
    const index = this.openSessions.findIndex((candidate) => {
      return candidate.sessionId === session.sessionId;
    });
    if (index > -1) {
      this.openSessions.splice(index, 1);
    }
    return requisitions.execute("proxyRequest", {
      provider: this,
      original: {
        requestType: "refreshSessions",
        parameter: this.openSessions
      }
    });
  };
  handleDispose() {
    super.handleDispose();
    this.openSessions = [];
    void requisitions.execute("proxyRequest", {
      provider: this,
      original: {
        requestType: "refreshSessions",
        parameter: []
      }
    });
  }
};

// src/ShellConsoleCommandHandler.ts
var ShellConsoleCommandHandler = class {
  providers = [];
  url;
  setup(host2) {
    const context = host2.context;
    requisitions.register("connectedToUrl", this.connectedToUrl);
    context.subscriptions.push(import_vscode31.commands.registerCommand("msg.openSessionBrowser", (provider) => {
      provider ??= this.currentProvider;
      if (provider instanceof ShellConsoleViewProvider) {
        void provider?.show("sessions");
      }
    }));
    context.subscriptions.push(import_vscode31.commands.registerCommand("msg.newSession", () => {
      const provider = this.currentProvider;
      void provider?.openSession({ sessionId: -1 });
    }));
    context.subscriptions.push(import_vscode31.commands.registerCommand("msg.openSession", (details) => {
      const provider = this.currentProvider;
      void provider?.openSession(details);
    }));
    context.subscriptions.push(import_vscode31.commands.registerCommand(
      "msg.newSessionUsingConnection",
      (entry) => {
        const provider = this.currentProvider;
        let caption;
        let dbConnectionId;
        if (entry.treeItem instanceof ConnectionTreeItem) {
          caption = entry.treeItem.details.caption;
          dbConnectionId = entry.treeItem.details.id;
        } else {
          caption = entry.caption;
          dbConnectionId = entry.connectionId;
        }
        const details = {
          sessionId: -1,
          caption: `Session to ${caption}`,
          dbConnectionId
        };
        void provider?.openSession(details);
      }
    ));
    context.subscriptions.push(import_vscode31.commands.registerCommand(
      "msg.removeSession",
      (entry) => {
        const provider = entry.parent.provider;
        if (provider instanceof ShellConsoleViewProvider) {
          void provider.removeSession(entry.details);
        }
      }
    ));
  }
  closeProviders() {
    this.providers.forEach((provider) => {
      provider.close();
    });
    this.providers = [];
  }
  get currentProvider() {
    if (this.providers.length > 0) {
      return this.providers[this.providers.length - 1];
    } else if (this.url) {
      const caption = this.createTabCaption();
      const provider = new ShellConsoleViewProvider(this.url, (view) => {
        const index = this.providers.findIndex((candidate) => {
          return candidate === view;
        });
        if (index > -1) {
          this.providers.splice(index, 1);
        }
      });
      provider.caption = caption;
      this.providers.push(provider);
      return provider;
    }
    return void 0;
  }
  connectedToUrl = (url) => {
    this.url = url;
    this.closeProviders();
    return Promise.resolve(true);
  };
  createTabCaption = () => {
    if (this.providers.length === 0) {
      return "MySQL Shell Consoles";
    }
    let index = 1;
    while (true) {
      const caption = `MySQL Shell Consoles (${index})`;
      if (!this.providers.find((candidate) => {
        return candidate.caption === caption;
      })) {
        return caption;
      }
      ++index;
    }
  };
};

// src/tree-providers/ConnectionsTreeProvider/ConnectionsTreeProvider.ts
var import_vscode33 = require("vscode");

// src/tree-providers/ConnectionsTreeProvider/SchemaGroupTreeItem.ts
var SchemaGroupTreeItem = class _SchemaGroupTreeItem extends ConnectionsTreeBaseItem {
  constructor(schema, backend, connectionId, groupType) {
    super(groupType, schema, backend, connectionId, _SchemaGroupTreeItem.getIonName(groupType), true);
    this.groupType = groupType;
  }
  contextValue = `${String(this.label)}GroupItem`;
  static getIonName(label) {
    switch (label) {
      case "Tables" /* Tables */: {
        return "schemaTables.svg";
      }
      case "Views" /* Views */: {
        return "schemaViews.svg";
      }
      case "Routines" /* Routines */: {
        return "schemaRoutines.svg";
      }
      case "Events" /* Events */: {
        return "schemaEvents.svg";
      }
      default: {
        return "";
      }
    }
  }
};

// src/tree-providers/ConnectionsTreeProvider/AdminSectionTreeItem.ts
var AdminSectionTreeItem = class extends ConnectionsTreeBaseItem {
  contextValue = "adminSection";
  constructor(name, backend, connectionId, iconName, hasChildren, command) {
    super(name, "", backend, connectionId, iconName, hasChildren, command);
  }
};

// src/tree-providers/ConnectionsTreeProvider/AdminTreeItem.ts
var AdminTreeItem = class extends ConnectionsTreeBaseItem {
  contextValue = "admin";
  constructor(name, backend, connectionId, hasChildren) {
    super(name, "", backend, connectionId, "adminDashboard.svg", hasChildren);
  }
};

// src/tree-providers/ConnectionsTreeProvider/ConnectionMySQLTreeItem.ts
var path22 = __toESM(require("path"), 1);
var ConnectionMySQLTreeItem = class extends ConnectionTreeItem {
  contextValue = "connectionMySQL";
  constructor(details, backend) {
    super(details, backend);
    let fileName = "connectionMySQL.svg";
    const optionsMySQL = details.options;
    if (optionsMySQL["mysql-db-system-id"] !== void 0) {
      fileName = "ociDbSystem.svg";
    }
    this.iconPath = {
      light: path22.join(__dirname, "..", "images", "light", fileName),
      dark: path22.join(__dirname, "..", "images", "dark", fileName)
    };
  }
};

// src/tree-providers/ConnectionsTreeProvider/ConnectionSqliteTreeItem.ts
var path23 = __toESM(require("path"), 1);
var ConnectionSqliteTreeItem = class extends ConnectionTreeItem {
  contextValue = "connectionSqlite";
  constructor(details, backend) {
    super(details, backend);
    this.iconPath = {
      light: path23.join(__dirname, "..", "images", "light", "connectionSqlite.svg"),
      dark: path23.join(__dirname, "..", "images", "dark", "connectionSqlite.svg")
    };
  }
};

// src/tree-providers/ConnectionsTreeProvider/MrsTreeBaseItem.ts
var path24 = __toESM(require("path"), 1);
var import_vscode32 = require("vscode");
var MrsTreeBaseItem = class extends import_vscode32.TreeItem {
  constructor(label, backend, connectionId, iconName, hasChildren) {
    super(label, hasChildren ? import_vscode32.TreeItemCollapsibleState.Collapsed : import_vscode32.TreeItemCollapsibleState.None);
    this.backend = backend;
    this.connectionId = connectionId;
    this.iconPath = {
      light: path24.join(__dirname, "..", "images", "light", iconName),
      dark: path24.join(__dirname, "..", "images", "dark", iconName)
    };
  }
};

// src/tree-providers/ConnectionsTreeProvider/MrsAuthAppTreeItem.ts
var MrsAuthAppTreeItem = class extends MrsTreeBaseItem {
  constructor(label, value, backend, connectionId) {
    super(label, backend, connectionId, value.enabled ? "shield.svg" : "shieldDisabled.svg", true);
    this.value = value;
    this.tooltip = value.description ?? label;
  }
  contextValue = "mrsAuthApp";
};

// src/tree-providers/ConnectionsTreeProvider/MrsContentFileTreeItem.ts
var MrsContentFileTreeItem = class extends MrsTreeBaseItem {
  constructor(label, value, backend, connectionId) {
    super(label, backend, connectionId, value.enabled ? "mrsContentFile.svg" : "mrsContentFileDisabled.svg", false);
    this.value = value;
  }
  contextValue = "mrsContentFile";
};

// src/tree-providers/ConnectionsTreeProvider/MrsContentSetTreeItem.ts
var MrsContentSetTreeItem = class extends MrsTreeBaseItem {
  constructor(label, value, backend, connectionId) {
    super(label, backend, connectionId, value.enabled === 1 ? "mrsContentSet.svg" : "mrsContentSetDisabled.svg", true);
    this.value = value;
  }
  contextValue = "mrsContentSet";
};

// src/tree-providers/ConnectionsTreeProvider/MrsDbObjectTreeItem.ts
var MrsDbObjectTreeItem = class _MrsDbObjectTreeItem extends MrsTreeBaseItem {
  constructor(label, value, backend, connectionId) {
    super(label, backend, connectionId, _MrsDbObjectTreeItem.getIconName(value), false);
    this.value = value;
  }
  contextValue = "mrsDbObject";
  static getIconName = (value) => {
    let iconName = "mrsDbObject" + convertToPascalCase(value.objectType.toLowerCase());
    iconName += value.requiresAuth === 1 ? "Locked" : "";
    iconName += value.enabled !== 1 ? "Disabled" : "";
    return iconName + ".svg";
  };
};

// src/tree-providers/ConnectionsTreeProvider/MrsRouterTreeItem.ts
var MrsRouterTreeItem = class _MrsRouterTreeItem extends MrsTreeBaseItem {
  constructor(label, value, backend, connectionId, requiresUpgrade) {
    super(label, backend, connectionId, _MrsRouterTreeItem.getIconName(value, requiresUpgrade), false);
    this.value = value;
    this.description = value.version;
    this.tooltip = requiresUpgrade ? "This MySQL Router requires an upgrade." : `MySQL Router ${value.version} - ${value.address}`;
  }
  contextValue = "mrsRouter";
  static getIconName = (value, requiresUpgrade) => {
    if (requiresUpgrade) {
      return "routerError.svg";
    }
    if (!value.active) {
      return "routerNotActive.svg";
    }
    return "router.svg";
  };
};

// src/tree-providers/ConnectionsTreeProvider/MrsSchemaTreeItem.ts
var MrsSchemaTreeItem = class extends MrsTreeBaseItem {
  constructor(label, value, backend, connectionId) {
    const iconName = value.enabled === 1 ? value.requiresAuth === 1 ? "mrsSchemaLocked.svg" : "mrsSchema.svg" : "mrsSchemaDisabled.svg";
    super(label, backend, connectionId, iconName, true);
    this.value = value;
  }
  contextValue = "mrsSchema";
};

// src/tree-providers/ConnectionsTreeProvider/MrsServiceTreeItem.ts
var MrsServiceTreeItem = class extends MrsTreeBaseItem {
  constructor(label, value, backend, connectionId) {
    const iconName = value.isCurrent ? !value.enabled ? "mrsServiceDefaultDisabled.svg" : "mrsServiceDefault.svg" : !value.enabled ? "mrsServiceDisabled.svg" : "mrsService.svg";
    super(label, backend, connectionId, iconName, true);
    this.value = value;
  }
  contextValue = "mrsService";
};

// src/tree-providers/ConnectionsTreeProvider/MrsTreeItem.ts
var MrsTreeItem = class extends ConnectionsTreeBaseItem {
  contextValue = "mrs";
  constructor(name, schema, backend, connectionId, hasChildren, enabled, command) {
    super(name, schema, backend, connectionId, enabled ? "mrs.svg" : "mrsDisabled.svg", hasChildren, command);
  }
};

// src/tree-providers/ConnectionsTreeProvider/MrsUserTreeItem.ts
var MrsUserTreeItem = class extends MrsTreeBaseItem {
  constructor(label, value, backend, connectionId) {
    super(label, backend, connectionId, "ociProfile.svg", false);
    this.value = value;
  }
  contextValue = "mrsUser";
};

// src/tree-providers/ConnectionsTreeProvider/SchemaEventTreeItem.ts
var SchemaEventTreeItem = class extends ConnectionsTreeBaseItem {
  contextValue = "schemaEventItem";
  constructor(name, schema, backend, connectionId, hasChildren) {
    super(name, schema, backend, connectionId, "schemaEvent.svg", hasChildren);
  }
  get qualifiedName() {
    return `\`${this.schema}\`.\`${this.name}\``;
  }
  get dbType() {
    return "event";
  }
};

// src/tree-providers/ConnectionsTreeProvider/SchemaRoutineTreeItem.ts
var SchemaRoutineTreeItem = class extends ConnectionsTreeBaseItem {
  constructor(name, schema, type, backend, connectionId, hasChildren, command) {
    super(
      name,
      schema,
      backend,
      connectionId,
      type === "procedure" ? "schemaRoutine.svg" : "schemaFunction.svg",
      hasChildren,
      command
    );
    this.type = type;
  }
  contextValue = "schemaRoutineItem";
  get qualifiedName() {
    return `\`${this.schema}\`.\`${this.name}\``;
  }
  get dbType() {
    return this.type;
  }
  get createScriptResultIndex() {
    return 2;
  }
};

// src/tree-providers/ConnectionsTreeProvider/SchemaRoutineMySQLTreeItem.ts
var SchemaRoutineMySQLTreeItem = class extends SchemaRoutineTreeItem {
  contextValue = "schemaRoutineItemMySQL";
  get iconName() {
    return this.dbType === "procedure" ? "schemaRoutine.svg" : "schemaFunction.svg";
  }
};

// src/tree-providers/ConnectionsTreeProvider/SchemaSqliteTreeItem.ts
var SchemaSqliteTreeItem = class extends SchemaTreeItem {
  contextValue = "schemaItem";
  constructor(name, schema, backend, connectionId, isCurrent, hasChildren, command) {
    super(
      name,
      schema,
      backend,
      connectionId,
      isCurrent ? "schemaSqliteCurrent.svg" : "schemaSqlite.svg",
      hasChildren,
      command
    );
  }
  get qualifiedName() {
    return `\`${this.name}\``;
  }
  get dbType() {
    return "schema";
  }
};

// src/tree-providers/ConnectionsTreeProvider/SchemaTableColumnTreeItem.ts
var SchemaTableColumnTreeItem = class extends ConnectionsTreeBaseItem {
  constructor(name, schema, table, backend, connectionId) {
    super(name, schema, backend, connectionId, "schemaTableColumn.svg", false);
    this.table = table;
  }
  contextValue = "schemaTableColumnItem";
  get qualifiedName() {
    return `\`${this.schema}\`.\`${this.table}\`.\`${this.name}\``;
  }
  get dbType() {
    return "column";
  }
};

// src/tree-providers/ConnectionsTreeProvider/SchemaTableForeignKeyTreeItem.ts
var SchemaTableForeignKeyTreeItem = class extends ConnectionsTreeBaseItem {
  constructor(name, schema, table, backend, connectionId) {
    super(name, schema, backend, connectionId, "schemaTableForeignKey.svg", false);
    this.table = table;
  }
  contextValue = "schemaTableForeignKeyItem";
};

// src/tree-providers/ConnectionsTreeProvider/SchemaTableGroupTreeItem.ts
var TableGroupTreeItem = class _TableGroupTreeItem extends ConnectionsTreeBaseItem {
  constructor(schema, table, backend, connectionId, groupType) {
    super(groupType, schema, backend, connectionId, _TableGroupTreeItem.getIconName(groupType), true);
    this.table = table;
    this.groupType = groupType;
  }
  contextValue = `schemaTable${String(this.label)}GroupItem`;
  static getIconName(label) {
    switch (label) {
      case "Columns" /* Columns */: {
        return "schemaTableColumns.svg";
      }
      case "Indexes" /* Indexes */: {
        return "schemaTableIndexes.svg";
      }
      case "Foreign Keys" /* ForeignKeys */: {
        return "schemaTableForeignKey.svg";
      }
      case "Triggers" /* Triggers */: {
        return "schemaTableTriggers.svg";
      }
      default: {
        return "";
      }
    }
  }
};

// src/tree-providers/ConnectionsTreeProvider/SchemaTableIndexTreeItem.ts
var SchemaTableIndexTreeItem = class extends ConnectionsTreeBaseItem {
  constructor(name, schema, table, backend, connectionId) {
    super(name, schema, backend, connectionId, "schemaTableIndex.svg", false);
    this.table = table;
  }
  contextValue = "schemaTableIndexItem";
  get qualifiedName() {
    return `\`${this.schema}\`.\`${this.table}\`.\`${this.name}\``;
  }
  get dbType() {
    return "index";
  }
};

// src/tree-providers/ConnectionsTreeProvider/SchemaTableTreeItem.ts
var SchemaTableTreeItem = class extends ConnectionsTreeBaseItem {
  contextValue = "schemaTableItem";
  constructor(name, schema, backend, connectionId, iconName, hasChildren) {
    super(name, schema, backend, connectionId, iconName, hasChildren);
  }
  get qualifiedName() {
    return `\`${this.schema}\`.\`${this.name}\``;
  }
  get dbType() {
    return "table";
  }
};

// src/tree-providers/ConnectionsTreeProvider/SchemaTableMySQLTreeItem.ts
var SchemaTableMySQLTreeItem = class extends SchemaTableTreeItem {
  contextValue = "schemaTableItemMySQL";
  constructor(name, schema, backend, connectionId, hasChildren) {
    super(name, schema, backend, connectionId, "schemaTable.svg", hasChildren);
  }
};

// src/tree-providers/ConnectionsTreeProvider/SchemaTableSqliteTreeItem.ts
var SchemaTableSqliteTreeItem = class extends SchemaTableTreeItem {
  contextValue = "schemaTableItem";
  constructor(name, schema, backend, connectionId, hasChildren) {
    super(name, schema, backend, connectionId, "schemaTable.svg", hasChildren);
  }
};

// src/tree-providers/ConnectionsTreeProvider/SchemaTableTriggerTreeItem.ts
var SchemaTableTriggerTreeItem = class extends ConnectionsTreeBaseItem {
  constructor(name, schema, table, backend, connectionId) {
    super(name, schema, backend, connectionId, "schemaTableTrigger.svg", false);
    this.table = table;
  }
  contextValue = "schemaTableTriggerItem";
  get qualifiedName() {
    return `\`${this.schema}\`.\`${this.name}\``;
  }
  get dbType() {
    return "trigger";
  }
};

// src/tree-providers/ConnectionsTreeProvider/SchemaViewTreeItem.ts
var SchemaViewTreeItem = class extends ConnectionsTreeBaseItem {
  contextValue = "schemaViewItem";
  constructor(name, schema, backend, connectionId, iconName, hasChildren) {
    super(name, schema, backend, connectionId, iconName, hasChildren);
  }
  get qualifiedName() {
    return `\`${this.schema}\`.\`${this.name}\``;
  }
  get dbType() {
    return "view";
  }
};

// src/tree-providers/ConnectionsTreeProvider/SchemaViewMySQLTreeItem.ts
var SchemaViewMySQLTreeItem = class extends SchemaViewTreeItem {
  contextValue = "schemaViewItemMySQL";
  constructor(name, schema, backend, connectionId, hasChildren) {
    super(name, schema, backend, connectionId, "schemaView.svg", hasChildren);
  }
};

// src/tree-providers/ConnectionsTreeProvider/SchemaViewSqliteTreeItem.ts
var SchemaViewSqliteTreeItem = class extends SchemaViewTreeItem {
  contextValue = "schemaViewItem";
  constructor(name, schema, backend, connectionId, hasChildren) {
    super(name, schema, backend, connectionId, "schemaView.svg", hasChildren);
  }
};

// src/tree-providers/ConnectionsTreeProvider/ConnectionsTreeProvider.ts
var ConnectionsTreeDataProvider = class _ConnectionsTreeDataProvider {
  // A running number to identify uniquely every connection entry.
  static nextId = 1;
  connections = [];
  // List to keep track of visible MrsTreeItems
  expandedMrsTreeItems = /* @__PURE__ */ new Set();
  changeEvent = new import_vscode33.EventEmitter();
  refreshMrsRoutersTimer = null;
  requiredRouterVersion;
  // When set a timer will be started to remove all current schemas from the tree.
  clearCurrentSchemas = false;
  // Make sure the same error is not displayed again and again
  #errorAlreadyDisplayed = false;
  get onDidChangeTreeData() {
    return this.changeEvent.event;
  }
  constructor() {
    requisitions.register("refreshConnections", this.refreshConnections);
    requisitions.register("proxyRequest", this.proxyRequest);
  }
  dispose() {
    if (this.refreshMrsRoutersTimer !== null) {
      clearTimeout(this.refreshMrsRoutersTimer);
      this.refreshMrsRoutersTimer = null;
    }
    requisitions.unregister("refreshConnections", this.refreshConnections);
    requisitions.unregister("proxyRequest", this.proxyRequest);
    void this.closeAllConnections();
  }
  refresh(entry) {
    if (!entry) {
      void this.updateConnections().then(() => {
        this.changeEvent.fire(entry);
        if (this.refreshMrsRoutersTimer === null) {
          this.refreshMrsRouters();
        }
        void requisitions.execute("connectionsUpdated", void 0);
      });
    } else {
      this.changeEvent.fire(entry);
    }
  }
  /**
   * Updates the current schema when the user switches between different providers (that is, different app tabs).
   *
   * @param provider The provider that has changed its visibility state.
   * @param active Indicates whether the provider is now active or not.
   */
  providerStateChanged(provider, active) {
    if (active) {
      this.clearCurrentSchemas = false;
      const currentSchemas = provider.currentSchemas;
      this.connections.forEach((connection) => {
        connection.currentSchema = currentSchemas.get(connection.treeItem.details.id) ?? "";
      });
      this.changeEvent.fire(void 0);
    } else {
      this.clearCurrentSchemas = true;
      setTimeout(() => {
        if (this.clearCurrentSchemas) {
          this.clearCurrentSchemas = false;
          this.resetCurrentSchemas();
        }
      }, 300);
    }
  }
  makeCurrentSchema(entry) {
    entry.parent.currentSchema = entry.treeItem.schema;
    this.changeEvent.fire(entry.parent);
  }
  resetCurrentSchemas() {
    this.connections.forEach((connection) => {
      connection.currentSchema = "";
    });
    this.changeEvent.fire(void 0);
  }
  getTreeItem(entry) {
    return entry.treeItem;
  }
  getParent(entry) {
    if ("parent" in entry) {
      return entry.parent;
    }
    return void 0;
  }
  async getChildren(entry) {
    if (!entry) {
      return this.connections;
    }
    switch (entry.type) {
      case "connection": {
        const entries = [];
        await this.updateSchemaList(entry);
        if (entry.mrsEntry !== void 0) {
          entries.push(entry.mrsEntry);
        }
        if (entry.adminEntry !== void 0) {
          entries.push(entry.adminEntry);
        }
        entries.push(...entry.schemaEntries);
        return entries;
      }
      case "admin": {
        const serverStatusCommand = {
          title: "Show Server Status",
          command: "msg.showServerStatus",
          // The first argument is undefined to show the page on the currently selected connection.
          arguments: [void 0, "Server Status", entry.treeItem.connectionId, uuid()]
        };
        const clientConnectionsCommand = {
          title: "Show Client Connections",
          command: "msg.showClientConnections",
          arguments: [void 0, "Client Connections", entry.treeItem.connectionId, uuid()]
        };
        const performanceDashboardCommand = {
          title: "Show Performance Dashboard",
          command: "msg.showPerformanceDashboard",
          arguments: [void 0, "Performance Dashboard", entry.treeItem.connectionId, uuid()]
        };
        const item = entry.treeItem;
        entry.sections = [
          {
            parent: entry,
            type: "adminSection",
            treeItem: new AdminSectionTreeItem(
              "Server Status",
              item.backend,
              item.connectionId,
              "adminServerStatus.svg",
              false,
              serverStatusCommand
            )
          },
          {
            parent: entry,
            type: "adminSection",
            treeItem: new AdminSectionTreeItem(
              "Client Connections",
              item.backend,
              item.connectionId,
              "clientConnections.svg",
              false,
              clientConnectionsCommand
            )
          },
          {
            parent: entry,
            type: "adminSection",
            treeItem: new AdminSectionTreeItem(
              "Performance Dashboard",
              item.backend,
              item.connectionId,
              "adminPerformanceDashboard.svg",
              false,
              performanceDashboardCommand
            )
          }
        ];
        return entry.sections;
      }
      case "schema": {
        const item = entry.treeItem;
        entry.groups = [
          {
            parent: entry,
            type: "schemaMemberGroup",
            treeItem: new SchemaGroupTreeItem(
              item.schema,
              item.backend,
              item.connectionId,
              "Tables" /* Tables */
            ),
            members: []
          },
          {
            parent: entry,
            type: "schemaMemberGroup",
            treeItem: new SchemaGroupTreeItem(
              item.schema,
              item.backend,
              item.connectionId,
              "Views" /* Views */
            ),
            members: []
          }
        ];
        if (entry.parent.treeItem.details.dbType === "MySQL" /* MySQL */) {
          entry.groups.push(
            {
              parent: entry,
              type: "schemaMemberGroup",
              treeItem: new SchemaGroupTreeItem(
                item.schema,
                item.backend,
                item.connectionId,
                "Routines" /* Routines */
              ),
              members: []
            },
            {
              parent: entry,
              type: "schemaMemberGroup",
              treeItem: new SchemaGroupTreeItem(
                item.schema,
                item.backend,
                item.connectionId,
                "Events" /* Events */
              ),
              members: []
            }
          );
        }
        return entry.groups;
      }
      case "schemaMemberGroup": {
        await this.loadSchemaGroupMembers(entry);
        return entry.members;
      }
      case "table": {
        const item = entry.treeItem;
        entry.groups = [];
        for (const type of [
          "Columns" /* Columns */,
          "Indexes" /* Indexes */,
          "Foreign Keys" /* ForeignKeys */,
          "Triggers" /* Triggers */
        ]) {
          entry.groups.push(
            {
              parent: entry,
              type: "tableMemberGroup",
              treeItem: new TableGroupTreeItem(
                item.schema,
                item.name,
                item.backend,
                item.connectionId,
                type
              ),
              members: []
            }
          );
        }
        return entry.groups;
      }
      case "tableMemberGroup": {
        await this.loadTableMembers(entry);
        return entry.members;
      }
      case "mrs": {
        await this.loadMrsServices(entry);
        return [...entry.services, ...entry.routers];
      }
      case "mrsService": {
        await this.loadMrsServiceEntries(entry);
        return [...entry.schemas, ...entry.contentSets, ...entry.authApps];
      }
      case "mrsAuthApp": {
        await this.loadMrsAuthAppUsers(entry);
        return entry.users;
      }
      case "mrsContentSet": {
        await this.loadMrsContentSetFiles(entry);
        return entry.files;
      }
      case "mrsSchema": {
        await this.loadMrsDbObjects(entry);
        return entry.dbObjects;
      }
      default: {
        return Promise.resolve([]);
      }
    }
  }
  async closeAllConnections() {
    for (const entry of this.connections) {
      await entry.treeItem.backend.closeSession().catch(() => {
      });
    }
    this.connections = [];
  }
  /**
   * When assigned to the TreeView.onDidExpandElement it updates the list of expanded MrsTreeView nodes.
   *
   * @param entry The tree entry that got expanded.
   */
  didExpandElement = (entry) => {
    if (entry.type === "mrs") {
      this.expandedMrsTreeItems.add(entry);
    }
  };
  /**
   * When assigned to the TreeView.onDidCollapseElement it updates the list of expanded MrsTreeView nodes.
   *
   * @param entry The tree entry that got collapsed.
   */
  didCollapseElement = (entry) => {
    if (entry.type === "mrs") {
      this.expandedMrsTreeItems.delete(entry);
    }
  };
  /**
   * Refreshes all visible MrsTreeItems every 10 seconds to visualize MySQL Routers getting inactive.
   */
  refreshMrsRouters = () => {
    if (this.refreshMrsRoutersTimer !== null) {
      clearTimeout(this.refreshMrsRoutersTimer);
    }
    for (const item of this.expandedMrsTreeItems) {
      this.refresh(item);
    }
    this.refreshMrsRoutersTimer = setTimeout(() => {
      this.refreshMrsRouters();
    }, 1e4);
  };
  /**
   * Queries the backend for a list of stored user DB connections and updates our connection entries.
   */
  async updateConnections() {
    if (webSession.currentProfileId === -1) {
      await this.closeAllConnections();
    } else {
      try {
        const detailList = await ShellInterface.dbConnections.listDbConnections(webSession.currentProfileId);
        let left = 0;
        let right = 0;
        while (left < this.connections.length && detailList.length > 0) {
          if (this.connections[left].treeItem.details.caption === detailList[right].caption) {
            if (right > 0) {
              for (let i63 = 0; i63 < right; ++i63) {
                const details = detailList[i63];
                this.connections.splice(left, 0, {
                  id: _ConnectionsTreeDataProvider.nextId++,
                  type: "connection",
                  isOpen: false,
                  openEditors: 0,
                  currentSchema: "",
                  treeItem: details.dbType === "MySQL" /* MySQL */ ? new ConnectionMySQLTreeItem(details, new ShellInterfaceSqlEditor()) : new ConnectionSqliteTreeItem(details, new ShellInterfaceSqlEditor()),
                  schemaEntries: []
                });
              }
              detailList.splice(0, right);
              right = 0;
            }
            ++left;
            detailList.shift();
          } else {
            while (++right < detailList.length) {
              if (this.connections[left].treeItem.details.caption === detailList[right].caption) {
                break;
              }
            }
            if (right === detailList.length) {
              const entry = this.connections.splice(left, 1)[0];
              void entry.treeItem.backend.closeSession();
              right = 0;
            }
          }
        }
        while (detailList.length > 0) {
          ++left;
          const details = detailList.shift();
          this.connections.push({
            id: _ConnectionsTreeDataProvider.nextId++,
            type: "connection",
            isOpen: false,
            openEditors: 0,
            currentSchema: "",
            treeItem: details.dbType === "MySQL" /* MySQL */ ? new ConnectionMySQLTreeItem(details, new ShellInterfaceSqlEditor()) : new ConnectionSqliteTreeItem(details, new ShellInterfaceSqlEditor()),
            schemaEntries: []
          });
        }
        while (left < this.connections.length) {
          const entry = this.connections.splice(left, 1)[0];
          await entry.treeItem.backend.closeSession();
        }
      } catch (reason) {
        void import_vscode33.window.showErrorMessage(`Cannot load DB connections: ${String(reason)}`);
        throw reason;
      }
    }
  }
  /**
   * Updates the list of schemas for the given connection entry.
   * If no session exists yet it will be created and a connection will be opened.
   *
   * @param entry The entry of the connection.
   *
   * @returns A promise that resolves to a list of tree items for the UI.
   */
  updateSchemaList = async (entry) => {
    if (entry.isOpen) {
      return this.doUpdateSchemaList(entry);
    }
    const item = entry.treeItem;
    await item.backend.startSession(String(entry.id) + "ConnectionTreeProvider");
    try {
      if (item.details.dbType === "Sqlite" /* Sqlite */) {
        const options = item.details.options;
        if (await ShellInterface.core.validatePath(options.dbFile)) {
          await openSqlEditorConnection(item.backend, item.details.id, (message) => {
            showStatusText(message);
          });
          entry.isOpen = true;
          return this.doUpdateSchemaList(entry);
        } else {
          try {
            await ShellInterface.core.createDatabaseFile(options.dbFile);
            return this.doUpdateSchemaList(entry);
          } catch (error) {
            throw Error(`DB Creation Error: 
${String(error) ?? "<unknown>"}`);
          }
        }
      } else {
        await openSqlEditorConnection(item.backend, item.details.id, (message) => {
          showStatusText(message);
        });
        entry.isOpen = true;
        return this.doUpdateSchemaList(entry);
      }
    } catch (error) {
      await item.backend.closeSession();
      throw new Error(`Error during module session creation: 
${error instanceof Error ? error.message : String(error)}`);
    }
  };
  /**
   * Does the actual schema update work for the given session and creates schema tree items for all schema entries.
   *
   * @param entry The entry to update.
   *
   * @returns A promise that resolves once the schema list has been updated.
   */
  doUpdateSchemaList = async (entry) => {
    try {
      const item = entry.treeItem;
      entry.schemaEntries = [];
      if (item.details.dbType === "MySQL" /* MySQL */) {
        entry.adminEntry = {
          parent: entry,
          type: "admin",
          treeItem: new AdminTreeItem("MySQL Administration", item.backend, item.details.id, true),
          sections: []
        };
      }
      const schemas = await item.backend.getCatalogObjects("Schema");
      for (const schema of schemas) {
        if (item.details.dbType === "MySQL") {
          if (schema === "mysql_rest_service_metadata") {
            try {
              let addMrsTreeItem = true;
              const status = await item.backend.mrs.status();
              this.requiredRouterVersion = status.requiredRouterVersion;
              if (status.majorUpgradeRequired) {
                addMrsTreeItem = false;
                let answer = await import_vscode33.window.showInformationMessage(
                  `This MySQL Shell version requires a new major version of the MRS metadata schema, ${String(status.requiredMetadataVersion)}. The currently deployed schema version is ${String(status.currentMetadataVersion)}. You need to downgrade the MySQL Shell version or drop and recreate the MRS metadata schema. Do you want to drop and recreate the MRS metadata schema? WARNING: All existing MRS data will be lost.`,
                  "Yes",
                  "No"
                );
                if (answer === "Yes") {
                  answer = await import_vscode33.window.showInformationMessage(
                    "Are you really sure you want to drop and recreate the MRS metadata schema? WARNING: All existing MRS data will be lost.",
                    "Drop and Recreate",
                    "No"
                  );
                  if (answer === "Drop and Recreate") {
                    await item.backend.mrs.configure(true, true);
                    addMrsTreeItem = true;
                  }
                }
              } else if (status.serviceUpgradeable) {
                addMrsTreeItem = false;
                const answer = await import_vscode33.window.showInformationMessage(
                  `This MySQL Shell version requires a new minor version of the MRS metadata schema, ${String(status.requiredMetadataVersion)}. The currently deployed schema version is ${String(status.currentMetadataVersion)}. Do you want to update the MRS metadata schema?`,
                  "Yes",
                  "No"
                );
                if (answer === "Yes") {
                  addMrsTreeItem = true;
                  const statusbarItem = import_vscode33.window.createStatusBarItem();
                  try {
                    statusbarItem.text = "$(loading~spin) Updating the MySQL REST Service Metadata Schema ...";
                    statusbarItem.show();
                    await item.backend.mrs.configure(true, false, true);
                    showMessageWithTimeout(
                      "The MySQL REST Service Metadata Schema has been updated."
                    );
                  } finally {
                    statusbarItem.hide();
                  }
                }
              }
              if (addMrsTreeItem) {
                entry.mrsEntry = {
                  parent: entry,
                  type: "mrs",
                  treeItem: new MrsTreeItem(
                    "MySQL REST Service",
                    schema,
                    item.backend,
                    item.details.id,
                    true,
                    status.serviceEnabled
                  ),
                  routers: [],
                  services: []
                };
              }
            } catch (reason) {
              void import_vscode33.window.showErrorMessage(
                `Failed to check and upgrade the MySQL REST Service Schema. Error: ${reason instanceof Error ? reason.message : String(reason)}`
              );
            }
          }
          const hideSystemSchemas = item.details.hideSystemSchemas ?? true;
          if (schema !== "mysql" && schema !== "mysql_innodb_cluster_metadata" && schema !== "mysql_rest_service_metadata" || !hideSystemSchemas) {
            entry.schemaEntries.push({
              parent: entry,
              type: "schema",
              treeItem: new SchemaMySQLTreeItem(
                schema,
                schema,
                item.backend,
                item.details.id,
                schema === entry.currentSchema,
                true
              ),
              groups: []
            });
          }
        } else {
          entry.schemaEntries.push({
            parent: entry,
            type: "schema",
            treeItem: new SchemaSqliteTreeItem(
              schema,
              schema,
              item.backend,
              item.details.id,
              schema === entry.currentSchema,
              true
            ),
            groups: []
          });
        }
      }
    } catch (error) {
      throw new Error(`Error retrieving schema list: ${error instanceof Error ? error.message : String(error)}`);
    }
  };
  /**
   * Loads a list of schemas object names (tables, views etc.).
   *
   * @param entry The tree item for which to load the children.
   *
   * @returns A promise that resolves once the schema groups have been loaded.
   */
  async loadSchemaGroupMembers(entry) {
    const item = entry.treeItem;
    const isMySQL = entry.parent.parent.treeItem.details.dbType === "MySQL";
    switch (entry.treeItem.groupType) {
      case "Routines": {
        const createItems = (type, list) => {
          for (const objectName of list) {
            if (isMySQL) {
              entry.members.push({
                parent: entry,
                type: "routine",
                treeItem: new SchemaRoutineMySQLTreeItem(
                  objectName,
                  item.schema,
                  type,
                  item.backend,
                  item.connectionId,
                  false
                )
              });
            } else {
              entry.members.push({
                parent: entry,
                type: "routine",
                treeItem: new SchemaRoutineTreeItem(
                  objectName,
                  item.schema,
                  type,
                  item.backend,
                  item.connectionId,
                  false
                )
              });
            }
          }
        };
        try {
          let names = await item.backend.getSchemaObjects(item.schema, "Routine", "function");
          createItems("function", names);
          names = await item.backend.getSchemaObjects(item.schema, "Routine", "procedure");
          createItems("procedure", names);
        } catch (error) {
          void import_vscode33.window.showErrorMessage("Error while retrieving schema objects: " + String(error));
        }
        break;
      }
      default: {
        try {
          const objectType = entry.treeItem.groupType.slice(0, -1);
          const names = await item.backend.getSchemaObjects(item.schema, objectType);
          names.forEach((objectName) => {
            switch (entry.treeItem.groupType) {
              case "Tables" /* Tables */: {
                if (isMySQL) {
                  entry.members.push({
                    parent: entry,
                    type: "table",
                    treeItem: new SchemaTableMySQLTreeItem(
                      objectName,
                      item.schema,
                      item.backend,
                      item.connectionId,
                      true
                    ),
                    groups: []
                  });
                } else {
                  entry.members.push({
                    parent: entry,
                    type: "table",
                    treeItem: new SchemaTableSqliteTreeItem(
                      objectName,
                      item.schema,
                      item.backend,
                      item.connectionId,
                      true
                    ),
                    groups: []
                  });
                }
                break;
              }
              case "Views" /* Views */: {
                if (isMySQL) {
                  entry.members.push({
                    parent: entry,
                    type: "view",
                    treeItem: new SchemaViewMySQLTreeItem(
                      objectName,
                      item.schema,
                      item.backend,
                      item.connectionId,
                      true
                    )
                  });
                } else {
                  entry.members.push({
                    parent: entry,
                    type: "view",
                    treeItem: new SchemaViewSqliteTreeItem(
                      objectName,
                      item.schema,
                      item.backend,
                      item.connectionId,
                      true
                    )
                  });
                }
                break;
              }
              case "Events" /* Events */: {
                entry.members.push({
                  parent: entry,
                  type: "event",
                  treeItem: new SchemaEventTreeItem(
                    objectName,
                    item.schema,
                    item.backend,
                    item.connectionId,
                    false
                  )
                });
                break;
              }
              default:
            }
          });
        } catch (error) {
          void import_vscode33.window.showErrorMessage("Error while retrieving schema objects: " + error);
        }
      }
    }
  }
  /**
   * Loads a list of table object names (indexes, triggers etc.).
   *
   * @param entry The data model node for which to load the children.
   *
   * @returns A promise that resolves once the table group members have been loaded.
   */
  async loadTableMembers(entry) {
    const item = entry.treeItem;
    switch (item.groupType) {
      case "Columns" /* Columns */: {
        const names = await item.backend.getTableObjects(item.schema, item.table, "Column");
        names.forEach((objectName) => {
          entry.members.push({
            parent: entry,
            type: "column",
            treeItem: new SchemaTableColumnTreeItem(
              objectName,
              item.schema,
              item.table,
              item.backend,
              item.connectionId
            )
          });
        });
        break;
      }
      case "Indexes" /* Indexes */: {
        const names = await item.backend.getTableObjects(item.schema, item.table, "Index");
        names.forEach((objectName) => {
          entry.members.push({
            parent: entry,
            type: "index",
            treeItem: new SchemaTableIndexTreeItem(
              objectName,
              item.schema,
              item.table,
              item.backend,
              item.connectionId
            )
          });
        });
        break;
      }
      case "Triggers" /* Triggers */: {
        const names = await item.backend.getTableObjects(item.schema, item.table, "Trigger");
        names.forEach((objectName) => {
          entry.members.push({
            parent: entry,
            type: "trigger",
            treeItem: new SchemaTableTriggerTreeItem(
              objectName,
              item.schema,
              item.table,
              item.backend,
              item.connectionId
            )
          });
        });
        break;
      }
      case "Foreign Keys" /* ForeignKeys */: {
        const names = await item.backend.getTableObjects(item.schema, item.table, "Foreign Key");
        names.forEach((objectName) => {
          entry.members.push({
            parent: entry,
            type: "foreignKey",
            treeItem: new SchemaTableForeignKeyTreeItem(
              objectName,
              item.schema,
              item.table,
              item.backend,
              item.connectionId
            )
          });
        });
        break;
      }
      default:
    }
  }
  /**
   * Loads the list of MRS services.
   *
   * @param entry The MRS root element.
   *
   * @returns A promise that resolves once the MRS services have been loaded.
   */
  async loadMrsServices(entry) {
    try {
      const item = entry.treeItem;
      const services = await item.backend.mrs.listServices();
      entry.services = services.map((value) => {
        let label = value.urlContextRoot;
        if (value.urlHostName) {
          label = label + ` (${value.urlHostName})`;
        }
        return {
          parent: entry,
          type: "mrsService",
          treeItem: new MrsServiceTreeItem(label, value, item.backend, item.connectionId),
          schemas: [],
          contentSets: [],
          authApps: []
        };
      });
      const routers = await item.backend.mrs.listRouters(10);
      entry.routers = routers.map((value) => {
        return {
          parent: entry,
          type: "mrsRouter",
          treeItem: new MrsRouterTreeItem(
            value.address,
            value,
            item.backend,
            item.connectionId,
            this.requiredRouterVersion !== void 0 ? compareVersionStrings(this.requiredRouterVersion, value.version) > 0 : false
          )
        };
      });
      this.#errorAlreadyDisplayed = false;
    } catch (error) {
      if (!this.#errorAlreadyDisplayed) {
        import_vscode33.window.setStatusBarMessage(`An error occurred while retrieving MRS content. Error: ${error instanceof Error ? error.message : String(error) ?? "<unknown>"}`, 1e4);
        this.#errorAlreadyDisplayed = true;
      }
      entry.services = [];
      entry.routers = [];
    }
  }
  /**
   * Loads the list of MRS content sets.
   *
   * @param entry The MRS service element.
   *
   * @returns A promise that resolves to when the MRS service elements have been loaded.
   */
  loadMrsServiceEntries = async (entry) => {
    try {
      const item = entry.treeItem;
      const schemas = await item.backend.mrs.listSchemas(item.value.id);
      entry.schemas = schemas.map((value) => {
        return {
          parent: entry,
          type: "mrsSchema",
          treeItem: new MrsSchemaTreeItem(
            `${value.requestPath} (${value.name})`,
            value,
            item.backend,
            item.connectionId
          ),
          dbObjects: []
        };
      });
      const contentSets = await item.backend.mrs.listContentSets(item.value.id);
      entry.contentSets = contentSets.map((value) => {
        return {
          parent: entry,
          type: "mrsContentSet",
          treeItem: new MrsContentSetTreeItem(`${value.requestPath}`, value, item.backend, item.connectionId),
          files: []
        };
      });
      const authApps = await item.backend.mrs.getAuthApps(item.value.id);
      entry.authApps = authApps.map((value) => {
        const name = value.name ?? "unknown";
        const vendor = value.authVendor ?? "unknown";
        return {
          parent: entry,
          type: "mrsAuthApp",
          treeItem: new MrsAuthAppTreeItem(`${name} (${vendor})`, value, item.backend, item.connectionId),
          users: []
        };
      });
      this.#errorAlreadyDisplayed = false;
    } catch (error) {
      if (!this.#errorAlreadyDisplayed) {
        import_vscode33.window.setStatusBarMessage(`An error occurred while retrieving MRS services. Error: ${error instanceof Error ? error.message : String(error) ?? "<unknown>"}`, 1e4);
        this.#errorAlreadyDisplayed = true;
      }
      entry.schemas = [];
      entry.contentSets = [];
      entry.authApps = [];
    }
  };
  /**
   * Loads the list of MRS authentication apps.
   *
   * @param entry The MRS authentication app element.
   *
   * @returns A promise that resolves to when the MRS users have been loaded.
   */
  loadMrsAuthAppUsers = async (entry) => {
    try {
      const item = entry.treeItem;
      const users = await item.backend.mrs.listUsers(void 0, item.value.id);
      entry.users = users.map((value) => {
        return {
          parent: entry,
          type: "mrsUser",
          treeItem: new MrsUserTreeItem(value.name ?? "unknown", value, item.backend, item.connectionId)
        };
      });
      this.#errorAlreadyDisplayed = false;
    } catch (error) {
      if (!this.#errorAlreadyDisplayed) {
        import_vscode33.window.setStatusBarMessage(`An error occurred while retrieving MRS users. Error: ${error instanceof Error ? error.message : String(error) ?? "<unknown>"}`, 1e4);
        this.#errorAlreadyDisplayed = true;
      }
      entry.users = [];
    }
  };
  /**
   * Loads the list of MRS content sets.
   *
   * @param entry The MRS service element.
   *
   * @returns A promise that resolves to when the MRS content set files have been loaded.
   */
  loadMrsContentSetFiles = async (entry) => {
    try {
      const item = entry.treeItem;
      const contentFiles = await item.backend.mrs.listContentFiles(item.value.id);
      entry.files = contentFiles.map((value) => {
        return {
          parent: entry,
          type: "mrsContentFile",
          treeItem: new MrsContentFileTreeItem(
            `${value.requestPath} (${formatBytes(value.size)})`,
            value,
            item.backend,
            item.connectionId
          )
        };
      });
      this.#errorAlreadyDisplayed = false;
    } catch (error) {
      if (!this.#errorAlreadyDisplayed) {
        import_vscode33.window.setStatusBarMessage(`An error occurred while retrieving MRS content files. Error: ${error instanceof Error ? error.message : String(error) ?? "<unknown>"}`, 1e4);
        this.#errorAlreadyDisplayed = true;
      }
      entry.files = [];
    }
  };
  /**
   * Loads the list of MRS db objects.
   *
   * @param entry The MRS service element.
   *
   * @returns A promise that resolves to when the MRS schema objects have been loaded.
   */
  async loadMrsDbObjects(entry) {
    const item = entry.treeItem;
    try {
      const objects = await item.backend.mrs.listDbObjects(item.value.id);
      entry.dbObjects = objects.map((value) => {
        return {
          parent: entry,
          type: "mrsDbObject",
          treeItem: new MrsDbObjectTreeItem(
            `${value.requestPath} (${value.name})`,
            value,
            item.backend,
            item.connectionId
          )
        };
      });
      this.#errorAlreadyDisplayed = false;
    } catch (error) {
      if (!this.#errorAlreadyDisplayed) {
        import_vscode33.window.setStatusBarMessage(`An error occurred while retrieving MRS db objects. Error: ${error instanceof Error ? error.message : String(error) ?? "<unknown>"}`, 1e4);
        this.#errorAlreadyDisplayed = true;
      }
      entry.dbObjects = [];
    }
  }
  refreshConnections = (data) => {
    this.refresh(data?.entry);
    return Promise.resolve(true);
  };
  /**
   * Requests sent from one of the providers.
   *
   * @param request The request to handle.
   * @param request.provider The provider that sent the request.
   * @param request.original The original request.
   *
   * @returns A promise that resolves to true if the request was handled.
   */
  proxyRequest = async (request) => {
    switch (request.original.requestType) {
      case "sqlSetCurrentSchema": {
        const response = request.original.parameter;
        const connection = this.connections.find((value) => {
          return value.treeItem.details.id === response.connectionId;
        });
        if (connection && connection.currentSchema !== response.schema) {
          connection.currentSchema = response.schema;
          return this.refreshConnections({ entry: connection });
        }
        break;
      }
      case "refreshConnections": {
        const data = request.original.parameter;
        return this.refreshConnections(data);
      }
      case "connectionAdded": {
        const response = request.original.parameter;
        let connection = this.connections.find((value) => {
          return value.treeItem.details.id === response.id;
        });
        if (!connection) {
          let treeItem;
          if (response.dbType === "MySQL" /* MySQL */) {
            treeItem = new ConnectionMySQLTreeItem(response, new ShellInterfaceSqlEditor());
          } else {
            treeItem = new ConnectionSqliteTreeItem(response, new ShellInterfaceSqlEditor());
          }
          connection = {
            id: _ConnectionsTreeDataProvider.nextId++,
            type: "connection",
            isOpen: false,
            openEditors: 0,
            currentSchema: "",
            treeItem,
            schemaEntries: []
          };
          this.connections.push(connection);
          this.refresh();
        }
        break;
      }
      case "connectionUpdated": {
        const response = request.original.parameter;
        const connection = this.connections.find((value) => {
          return value.treeItem.details.id === response.id;
        });
        if (connection) {
          let treeItem;
          if (response.dbType === "MySQL" /* MySQL */) {
            treeItem = new ConnectionMySQLTreeItem(response, new ShellInterfaceSqlEditor());
          } else {
            treeItem = new ConnectionSqliteTreeItem(response, new ShellInterfaceSqlEditor());
          }
          connection.treeItem = treeItem;
          this.refresh(connection);
        }
        break;
      }
      case "connectionRemoved": {
        const response = request.original.parameter;
        const connection = this.connections.find((value) => {
          return value.treeItem.details.id === response.id;
        });
        if (connection) {
          await connection.treeItem.backend.closeSession();
          this.connections.splice(this.connections.indexOf(connection), 1);
        }
        this.refresh();
        break;
      }
      case "editorsChanged": {
        const response = request.original.parameter;
        const connection = this.connections.find((value) => {
          return value.treeItem.details.id === response.connectionId;
        });
        if (connection) {
          if (response.opened) {
            ++connection.openEditors;
          } else {
            --connection.openEditors;
            if (connection.openEditors === 0) {
              connection.currentSchema = "";
              return this.refreshConnections({ entry: connection });
            }
          }
        }
        return Promise.resolve(true);
      }
      default:
    }
    return Promise.resolve(false);
  };
};

// src/ExtensionHost.ts
var ExtensionHost = class {
  constructor(context) {
    this.context = context;
    this.setupEnvironment();
    requisitions.register("settingsChanged", this.updateVscodeSettings);
    requisitions.register("webSessionStarted", (data) => {
      webSession.sessionId = data.sessionUuid;
      webSession.localUserMode = data.localUserMode ?? false;
      if (webSession.userName === "") {
        if (webSession.localUserMode) {
          ShellInterface.users.authenticate("LocalAdministrator", "").then((profile) => {
            if (profile) {
              void this.onAuthentication(profile);
            }
          }).catch((reason) => {
            printChannelOutput("Internal error: " + String(reason), true);
          });
        }
      } else {
        webSession.loadProfile(data.activeProfile);
        this.activeProfile = data.activeProfile;
      }
      return Promise.resolve(true);
    });
    requisitions.register("connectedToUrl", this.connectedToUrl);
    requisitions.register("proxyRequest", this.proxyRequest);
  }
  // The URL of the web session.
  url;
  // All open DB editor view providers.
  providers = [];
  lastActiveProvider;
  activeProfile;
  updatingSettings = false;
  connectionsProvider = new ConnectionsTreeDataProvider();
  dbEditorCommandHandler = new DBEditorCommandHandler(this.connectionsProvider);
  shellConsoleCommandHandler = new ShellConsoleCommandHandler();
  notebookProvider = new NotebookEditorProvider();
  mrsCommandHandler = new MRSCommandHandler();
  mdsCommandHandler = new MDSCommandHandler();
  // Tree data providers for the extension's sidebar. The connection provider is managed in the DB editor
  // command handler.
  scriptsTreeDataProvider;
  shellTasksTreeDataProvider;
  // List of shell tasks
  shellTasks = [];
  // A mapping from data type captions to data type ids.
  moduleDataCategories = /* @__PURE__ */ new Map();
  #visibleStatusbarItems = /* @__PURE__ */ new Map();
  /** @returns the currently loaded connection list. */
  get connections() {
    return this.connectionsProvider.connections;
  }
  /**
   * Closes all webview tabs and frees their providers.
   */
  closeAllTabs() {
    this.providers.forEach((provider) => {
      provider.close();
    });
    this.providers = [];
    this.dbEditorCommandHandler.clear();
    this.lastActiveProvider = void 0;
    this.shellConsoleCommandHandler.closeProviders();
  }
  async addNewShellTask(caption, shellArgs, dbConnectionId, showOutputChannel = true, responses) {
    const task = new ShellTask(caption, this.taskPromptCallback, this.taskMessageCallback);
    this.shellTasks.push(task);
    this.shellTasksTreeDataProvider.refresh();
    if (showOutputChannel) {
      taskOutputChannel.show();
    }
    await task.runTask(shellArgs, dbConnectionId, responses);
    this.shellTasksTreeDataProvider.refresh();
  }
  /**
   * Determines a connection to run SQL code with.
   *
   * @param dbType The DBType of the connection
   * @param forcePicker If true then always open the connection picker and ignore the default connection.
   *
   * @returns A promise resolving to a connection entry or undefined if no entry was found.
   */
  determineConnection = async (dbType, forcePicker) => {
    let connections = this.connectionsProvider.connections;
    let title = "Select a connection for SQL execution";
    if (!forcePicker) {
      const connectionName = import_vscode34.workspace.getConfiguration("msg.editor").get("defaultDbConnection");
      if (connectionName) {
        const connection2 = connections.find((candidate) => {
          return candidate.treeItem.details.caption === connectionName;
        });
        if (!connection2) {
          void import_vscode34.window.showErrorMessage(`The default Database Connection ${connectionName} is not available anymore.`);
        } else if (dbType && connection2.treeItem.details.dbType !== dbType) {
          void import_vscode34.window.showErrorMessage(`The default Database Connection ${connectionName} is a ${String(connection2.treeItem.details.dbType)} connection. This function requires a ${String(dbType)} connection.`);
        } else {
          return connection2;
        }
        title = "Select another connection for SQL execution";
      }
    }
    if (dbType) {
      connections = connections.filter((conn) => {
        return conn.treeItem.details.dbType === dbType;
      });
    }
    if (connections.length === 0) {
      if (dbType) {
        void import_vscode34.window.showErrorMessage(`Please create a ${String(dbType)} Database Connection first.`);
      } else {
        void import_vscode34.window.showErrorMessage("Please create a Database Connection first.");
      }
      return void 0;
    }
    const items = connections.map((connection2) => {
      return connection2.treeItem.details.caption;
    });
    const name = await import_vscode34.window.showQuickPick(items, {
      title,
      matchOnDescription: true,
      placeHolder: "Type the name of an existing DB connection"
    });
    const connection = connections.find((candidate) => {
      return candidate.treeItem.details.caption === name;
    });
    return connection;
  };
  /**
   * Sends the given request to all currently open providers. The request is executed asynchronously and in parallel.
   * This method actually handles broadcast requests from the requisition hub.
   *
   * @param sender The origin of the request, in case it came from a provider. This provider will not receive the
   *               request.
   * @param requestType The type of the request to send.
   * @param parameter The request parameters to use for the request.
   *
   * @returns A promise resolving when all requests have been sent.
   */
  broadcastRequest = async (sender, requestType, parameter) => {
    await Promise.all(this.providers.map((provider) => {
      if (sender === void 0 || provider !== sender) {
        return provider.runCommand(requestType, parameter);
      }
      return Promise.resolve();
    }));
  };
  get currentProvider() {
    if (this.lastActiveProvider) {
      return this.lastActiveProvider;
    }
    if (this.providers.length > 0) {
      return this.providers[this.providers.length - 1];
    }
    return this.newProvider;
  }
  /**
   * Creates a new connection view provider, which will open a new webview tab in the editor.
   *
   * @returns A new provider or undefined if the extension is not connected to a server.
   */
  get newProvider() {
    if (this.url) {
      const caption = this.dbEditorCommandHandler.generateNewProviderCaption();
      const provider = new DBConnectionViewProvider(this.url, this.providerDisposed, this.providerStateChanged);
      provider.caption = caption;
      this.providers.push(provider);
      return provider;
    }
    return void 0;
  }
  /**
   * Prepares all VS Code providers for first use.
   */
  setupEnvironment() {
    void NodeMessageScheduler.get;
    requisitions.setRemoteTarget(this);
    this.dbEditorCommandHandler.setup(this);
    this.shellConsoleCommandHandler.setup(this);
    this.notebookProvider.setup(this);
    this.mrsCommandHandler.setup(this);
    this.mdsCommandHandler.setup(this);
    const updateLogLevel = () => {
      const configuration = import_vscode34.workspace.getConfiguration(`msg.debugLog`);
      const level = configuration.get("level", "INFO");
      void ShellInterface.core.setLogLevel(level).catch((error) => {
        void import_vscode34.window.showErrorMessage("Error while setting log level: " + String(error));
      });
    };
    updateLogLevel();
    this.context.subscriptions.push(import_vscode34.workspace.onDidChangeConfiguration((event) => {
      if (event.affectsConfiguration("msg")) {
        updateLogLevel();
        this.updateProfileSettings();
      }
    }));
    this.shellTasksTreeDataProvider = new ShellTasksTreeDataProvider(this.shellTasks);
    this.context.subscriptions.push(import_vscode34.window.registerTreeDataProvider(
      "msg.shellTasks",
      this.shellTasksTreeDataProvider
    ));
    this.context.subscriptions.push(import_vscode34.commands.registerCommand("msg.selectProfile", async () => {
      await this.selectProfile();
    }));
    this.context.subscriptions.push(import_vscode34.commands.registerCommand(
      "msg.dumpSchemaToDisk",
      (entry) => {
        if (entry) {
          void import_vscode34.window.showOpenDialog({
            title: "Select an output folder for the dump.",
            openLabel: "Select Dump Folder",
            canSelectFiles: false,
            canSelectFolders: true,
            canSelectMany: false
          }).then((targetUri) => {
            const item = entry.treeItem;
            if (targetUri && targetUri.length === 1) {
              const shellArgs = [
                "--",
                "util",
                "dump-schemas",
                item.schema,
                "--outputUrl",
                targetUri[0].fsPath
              ];
              void this.addNewShellTask(
                `Dump Schema ${item.schema} to Disk`,
                shellArgs,
                item.connectionId
              ).then(() => {
                this.shellTasksTreeDataProvider.refresh();
              });
            }
          });
        }
      }
    ));
    this.context.subscriptions.push(import_vscode34.commands.registerCommand(
      "msg.dumpSchemaToDiskForMds",
      (entry) => {
        if (entry) {
          void import_vscode34.window.showOpenDialog({
            title: "Select an output folder for the dump.",
            openLabel: "Select Dump Folder",
            canSelectFiles: false,
            canSelectFolders: true,
            canSelectMany: false
          }).then((targetUri) => {
            const item = entry.treeItem;
            if (targetUri && targetUri.length === 1) {
              const shellArgs = [
                "--",
                "util",
                "dump-schemas",
                item.schema,
                "--outputUrl",
                targetUri[0].fsPath,
                "--ocimds",
                "true",
                "--compatibility",
                "create_invisible_pks,force_innodb,skip_invalid_accounts,strip_definers,strip_restricted_grants,strip_tablespaces"
              ];
              void this.addNewShellTask(
                `Dump Schema ${item.schema} to Disk`,
                shellArgs,
                item.connectionId
              ).then(() => {
                this.shellTasksTreeDataProvider.refresh();
              });
            }
          });
        }
      }
    ));
    this.context.subscriptions.push(import_vscode34.commands.registerCommand(
      "msg.loadDumpFromDisk",
      (entry) => {
        if (entry) {
          void import_vscode34.window.showOpenDialog({
            title: "Select a folder that contains a MySQL Shell dump.",
            openLabel: "Select Dump Folder",
            canSelectFiles: false,
            canSelectFolders: true,
            canSelectMany: false
          }).then((targetUri) => {
            if (targetUri && targetUri.length === 1) {
              const shellArgs = [
                "--",
                "util",
                "load-dump",
                targetUri[0].fsPath
              ];
              let folderName = "";
              const m3 = targetUri[0].fsPath.match(/([^/]*)\/*$/);
              if (m3 && m3.length > 1) {
                folderName = m3[1] + " ";
              }
              void this.addNewShellTask(
                `Loading Dump ${folderName}from Disk`,
                shellArgs,
                entry.treeItem.details.id
              ).then(() => {
                this.shellTasksTreeDataProvider.refresh();
                void import_vscode34.commands.executeCommand("msg.refreshConnections");
              });
            }
          });
        }
      }
    ));
  }
  async onAuthentication(profile) {
    this.activeProfile = profile;
    const categories = await ShellInterface.modules.listDataCategories();
    categories.forEach((row) => {
      this.moduleDataCategories.set(row.name, row);
    });
    await this.dbEditorCommandHandler.refreshConnectionTree();
    void import_vscode34.commands.executeCommand("msg.mds.refreshOciProfiles");
  }
  /**
   * Triggered when the user changed a VS Code setting. Updates the current profile.
   */
  updateProfileSettings() {
    if (!this.updatingSettings) {
      this.updatingSettings = true;
      const handleChildren = (children, configuration) => {
        children?.forEach((child) => {
          child.values.forEach((value) => {
            const configValue = configuration?.get(`${child.key}.${value.key}`);
            if (configValue != null) {
              Settings.set(value.id, configValue);
            }
          });
          handleChildren(child.children, configuration);
        });
      };
      const categories = settingCategories.children;
      if (categories) {
        categories.forEach((category) => {
          const configuration = import_vscode34.workspace.getConfiguration(`msg.${category.key}`);
          category.values.forEach((value) => {
            const configValue = configuration.get(value.key);
            if (configValue != null) {
              Settings.set(value.id, configValue);
            }
          });
          handleChildren(category.children, configuration);
        });
      }
      Settings.saveSettings();
      this.updatingSettings = false;
    }
  }
  /**
   * The other way around for settings. When the profile changes, change also VS code settings.
   *
   * @param entry The entry that changed or undefined when all values must be set.
   * @param entry.key The key of the value to change.
   * @param entry.value The value to set.
   *
   * @returns A promise resolving to true.
   */
  updateVscodeSettings = async (entry) => {
    if (!this.updatingSettings) {
      this.updatingSettings = true;
      if (entry) {
        const parts = entry.key.split(".");
        if (parts.length === 3) {
          const configuration = import_vscode34.workspace.getConfiguration(`msg.${parts[0]}`);
          const currentValue = configuration.get(`${parts[1]}.${parts[2]}`);
          if (currentValue !== entry.value) {
            await configuration.update(`${parts[1]}.${parts[2]}`, entry.value, import_vscode34.ConfigurationTarget.Global);
          }
        }
      } else {
        const categories = settingCategories.children;
        if (categories) {
          const updateFromChildren = async (children, configuration) => {
            if (children && configuration) {
              for await (const child of children) {
                for await (const value of child.values) {
                  const setting = Settings.get(value.id);
                  const currentValue = configuration.get(`${child.key}.${value.key}`);
                  if (setting !== currentValue) {
                    await configuration.update(
                      `${child.key}.${value.key}`,
                      setting,
                      import_vscode34.ConfigurationTarget.Global
                    );
                  }
                }
                await updateFromChildren(child.children, configuration);
              }
            }
          };
          for await (const category of categories) {
            if (category.key !== "theming") {
              const configuration = import_vscode34.workspace.getConfiguration(`msg.${category.key}`);
              for await (const value of category.values) {
                const setting = Settings.get(value.id);
                const currentValue = configuration.get(value.key);
                if (setting !== currentValue) {
                  await configuration.update(value.key, setting, import_vscode34.ConfigurationTarget.Global);
                }
              }
              await updateFromChildren(category.children, configuration);
            }
          }
        }
      }
      this.updatingSettings = false;
    }
    return true;
  };
  async selectProfile() {
    if (this.activeProfile) {
      const profiles = await ShellInterface.users.listProfiles(this.activeProfile.userId);
      const items = profiles.map((profile) => {
        return profile.name;
      });
      const name = await import_vscode34.window.showQuickPick(items, {
        title: "Activate a Profile",
        matchOnDescription: true,
        placeHolder: "Type the name of an existing profile"
      });
      if (name) {
        const row = profiles.find((candidate) => {
          return candidate.name === name;
        });
        if (row) {
          await ShellInterface.users.setCurrentProfile(row.id);
          import_vscode34.window.setStatusBarMessage("Profile set successfully", 5e3);
        }
      }
    }
  }
  taskPromptCallback = (text, isPassword) => {
    return new Promise((resolve) => {
      const match = text.match(/\[([\w\d\s/]+)\]:\s*?$/);
      if (match && match.length === 2 && match.index) {
        const buttons = match[1].split("/");
        for (let i63 = 0; i63 < buttons.length; i63++) {
          buttons[i63] = buttons[i63].charAt(0).toUpperCase() + buttons[i63].slice(1);
        }
        void import_vscode34.window.showInformationMessage(text.substring(0, match.index), ...buttons).then((value) => {
          resolve(value);
        });
      } else {
        void import_vscode34.window.showInputBox({ title: text, password: isPassword }).then((value) => {
          resolve(value);
        });
      }
    });
  };
  taskMessageCallback = (message) => {
    if (typeof message === "string") {
      taskOutputChannel.append(message);
    } else {
      taskOutputChannel.append(JSON.stringify(message));
    }
  };
  connectedToUrl = (url) => {
    this.url = url;
    this.closeAllTabs();
    return Promise.resolve(true);
  };
  providerDisposed = (provider) => {
    const index = this.providers.findIndex((candidate) => {
      return candidate === provider;
    });
    if (index > -1) {
      this.providers.splice(index, 1);
    }
    if (this.lastActiveProvider === provider) {
      this.lastActiveProvider = void 0;
    }
    this.dbEditorCommandHandler.providerClosed(provider);
  };
  providerStateChanged = (provider, active) => {
    if (active) {
      this.lastActiveProvider = provider;
      this.lastActiveProvider.reselectLastItem();
    }
    this.dbEditorCommandHandler.providerStateChanged(provider, active);
  };
  /**
   * Requests sent from one of the providers.
   *
   * @param request The request to handle.
   * @param request.provider The provider that sent the request.
   * @param request.original The original request.
   *
   * @returns A promise that resolves to true if the request was handled.
   */
  proxyRequest = (request) => {
    switch (request.original.requestType) {
      case "updateStatusbar": {
        this.updateStatusbar(request.original.parameter);
        return Promise.resolve(true);
      }
      case "connectionAdded":
      case "connectionUpdated":
      case "connectionRemoved":
      case "refreshConnections": {
        return new Promise((resolve) => {
          void requisitions.broadcastRequest(
            request.provider,
            request.original.requestType,
            request.original.parameter
          ).then(() => {
            resolve(true);
          });
        });
      }
      default:
    }
    return Promise.resolve(false);
  };
  /**
   * Creates or updates the statusbar items from the given info.
   *
   * @param info A list of statusbar info entries to create new statusbar items from or update existing ones.
   */
  updateStatusbar = (info) => {
    info.forEach((i63) => {
      if (i63.text) {
        let entry = this.#visibleStatusbarItems.get(i63.id);
        if (!entry) {
          entry = [import_vscode34.window.createStatusBarItem(), setTimeout(() => {
            entry?.[0].dispose();
            this.#visibleStatusbarItems.delete(i63.id);
          }, i63.hideAfter ?? 25e3)];
          this.#visibleStatusbarItems.set(i63.id, entry);
          entry[0].show();
        } else {
          clearTimeout(entry[1]);
          entry[1] = setTimeout(() => {
            entry?.[0].dispose();
            this.#visibleStatusbarItems.delete(i63.id);
          }, i63.hideAfter ?? 25e3);
        }
        entry[0].text = i63.text;
      } else {
        const entry = this.#visibleStatusbarItems.get(i63.id);
        if (entry) {
          entry[0].dispose();
          clearTimeout(entry[1]);
          this.#visibleStatusbarItems.delete(i63.id);
        }
      }
    });
  };
};

// src/WebviewProviders/WelcomeWebviewProvider.ts
var import_vscode35 = require("vscode");
var import_path7 = require("path");
var import_os4 = require("os");
var regedit = __toESM(require_regedit(), 1);
var getCssWebviewContent = (rootPath) => {
  return `<style>
    body {
        background-color: var(--vscode-editor-background);
    }
    #welcome {
        z-index: 2;
        display: flex;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        color: var(--vscode-editor-foreground);
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }
    #sakilaLogo {
        margin: 8px 0px 8px 0px;
        width: 160px;
        height: 160px;
        min-height: 160px;
        min-width: 160px;
        background-color: hsl(200, 65%, 40%);
        mask-image: url(${rootPath.toString()}/images/welcome/mysqlsh.svg);
        -webkit-mask-image: url(${rootPath.toString()}/images/welcome/mysqlsh.svg);
    }
    #pages .page {
        display: flex;
        height: 250px;
        width: 100%;
        max-width: 600px;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }
    .inactivePage {
        display: none !important;
    }
    h2 {
        margin-top: 15px;
        text-align: center;
        font-size: 25pt;
        font-weight: 100;
    }
    h3 {
        margin-top: 11px;
        text-align: center;
        font-size: 14pt;
        font-weight: 400;
    }
    p {
        text-align: center;
        font-size: 11pt;
        font-weight: 100;
        line-height: 13pt;
        margin-left: 30px;
        margin-right: 30px;
    }
    .pWithImg {
        text-align: left;
        font-size: 11pt;
        font-weight: 100;
        line-height: 13pt;
        margin-left: 30px;
        margin-right: 30px;
    }
    .pError {
        color: red;
        font-weight: 400;
    }
    .links {
        display: flex;
        flex-direction: row;
        justify-content: center;
        font-size: 11pt;
        font-weight: 100;
        padding-top: 10px;
        padding-bottom: 60px;
        white-space: nowrap;
    }
    .links a {
        color: var(--vscode-textLink-foreground);
        text-decoration: none;
        font-weight: 500;
        padding-left: 30px;
        padding-right: 30px;
    }
    .welcomeControls {
        display: flex;
        width: 100%;
        max-width: 600px;
        flex-direction: row;
        align-items: center;
        justify-content: center;
    }
    input[type=button] {
        margin: 8px 0px 0px 10px;
        width: 200px;
        height: 32px;
        color: var(--vscode-button-foreground);
        background-color: var(--vscode-button-background);
        border-style: none;
    }
    #cancelBtn {
        display: none;
    }
    .disabledBtn {
        color: var(--vscode-tab-inactiveForeground) !important;
        background-color: var(--vscode-tab-inactiveBackground) !important;
    }
    .CopyrightText {
        margin-top: 80px;
        font-size: 10px;
        font-weight: 100;
        color: var(--vscode-tab-unfocusedInactiveForeground);
    }
    #waitForConfirmation {
        width: 80px;
        display: block;
    }
    .pingEffect {
        display: inline-block;
        position: relative;
        width: 80px;
        height: 80px;
    }
    .pingEffect div {
        position: absolute;
        border: 4px solid var(--vscode-foreground);
        opacity: 1;
        border-radius: 50%;
        animation: pingEffect 1s cubic-bezier(0, 0.2, 0.8, 1) infinite;
    }
    .pingEffect div:nth-child(2) {
    animation-delay: -0.5s;
    }
    @keyframes pingEffect {
        0% {
            top: 36px;
            left: 36px;
            width: 0;
            height: 0;
            opacity: 1;
        }
        100% {
            top: 0px;
            left: 0px;
            width: 72px;
            height: 72px;
            opacity: 0;
        }
    }
    code {
        font-size: 10pt;
        font-weight: 400;
        line-height: 12pt;
    }
</style>
`;
};
var getRequirementsErrorWebviewContent = (requirementsError, rootPath) => {
  return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MySQL Shell Requirements Error</title>
    ${getCssWebviewContent(rootPath)}
</head>
<body>
    <div id="welcome">
        <div id="sakilaLogo"></div>
        <h2>MySQL Shell for VS Code</h2>
        <div id="pages">
            <div id="page1" class="page">
                <h3>MySQL Shell Requirements Error.</h3>
                <p>The requirements of the MySQL Shell for VS Code extension could not be met.</p>
                <p id="requirementsError" class="pError">${requirementsError}</p>
                <p>You can safely remove the extension from VS Code.<br>
                    Please feel free to file a
                    <a href="https://bugs.mysql.com/report.php?category=Shell%20VSCode%20Extension">bug report</a>.</p>
            </div>
        </div>
    </div>
</body>
</html>`;
};
var getWelcomeWebviewContent = (rootPath, showVCRuntimePrompt) => {
  const pageOffset = showVCRuntimePrompt ? 1 : 0;
  const vcRuntimePageIndex = showVCRuntimePrompt ? 2 : -100;
  const vcRuntimePage = showVCRuntimePrompt ? `
        <div id="page2" class="page inactivePage">
            <h3>Installation of MS VC++ runtime libraries.</h3>
            <p>This extension requires the MS VC++ runtime libraries.
            Please download them from the following web page and install them on your system.</p>
            <p>
                <a href="https://docs.microsoft.com/en-US/cpp/windows/latest-supported-vc-redist?view=msvc-170">
                MS Visual C++ 2019 Redistributable</a>
            </p>
            <div id="checkError" class="pError"></div>
            <h3>Click the [Check VC++ Runtime] button after completing the installation.</h3>
            <br/>
        </div>
` : ``;
  return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to MySQL Shell</title>
    ${getCssWebviewContent(rootPath)}
</head>
<body>
    <div id="welcome">
        <div id="sakilaLogo"></div>
        <h2>MySQL Shell for VS Code</h2>
        <div id="pages">
            <div id="page1" class="page">
                <h3>Welcome to MySQL Shell for VS Code.</h3>
                <p>This extension provides the powerful tool set of MySQL Shell
                    to users of Visual Studio Code.</p>
                <div class="links">
                    <a href="https://blogs.oracle.com/mysql/post/introducing-mysql-shell-for-vs-code">
                        Learn More &gt;</a>
                    <a href="#">Browse Tutorial &gt;</a>
                    <a href="#">Read Docs &gt;</a>
                </div>
                <p>Please click [Next >] to complete the installation of the
                    MySQL Shell for VS Code extension.</p>
            </div>
            ${vcRuntimePage}
            <div id="page3" class="page inactivePage">
                <h3>Installation of Certificate.</h3>
                <p>This extension needs a certificate to be installed on your local
                    user account in order to securely access the MySQL Shell.</p>
                <p class="pWithImg">
                    <img src="${rootPath.toString()}/images/welcome/trustSettingDlg-${(0, import_os4.platform)()}.png"
                        width="171px" height="87px" alt="Trust Dialog" align="left" hspace="15px"/>
                    In the next step a security dialog ${(0, import_os4.platform)() === "linux" ? "might" : "will"} be shown
                    for you to confirm the installation of the certificate.<br>
                    <br>
                    Please click [Next >] to start the installation of the
                    MySQL Shell certificate.</p>
            </div>
            <div id="page4" class="page inactivePage">
                <h3>Installation of Certificate.</h3>
                <p>Please confirm the installation of the certificate in order
                    to complete the installation of the extension.</p>
                <div id="waitForConfirmation"><div class="pingEffect"><div></div><div></div></div></div>
                <p id="certError" class="pError"></p>
            </div>
            <div id="page5" class="page inactivePage">
                <h3>Installation Completed</h3>
                <p>Thank you for installing the MySQL Shell for VS Code extension!</p>
                <p>A reload of the VS Code window is needed to be able to use the MySQL Shell.</p>
                <h3>Please click the [Reload VS Code Window] button.</h3>
            </div>
        </div>
        <form name="welcomeControls" class="welcomeControls">
            <input id="cancelBtn" alt="Cancel" type="button" value="Cancel"></input>
            <input id="nextBtn" alt="Next" type="button" value="Next >"></input>
        </form>
        <div class="CopyrightText">&copy; 2022, 2023, Oracle Corporation and/or its affiliates.</div>
    </div>
    <script>
        (function() {
            const vscode = acquireVsCodeApi();
            const pageInstallCert = 3 + ${pageOffset};
            const pageLast = 4 + ${pageOffset};
            const vcRuntimePage = ${vcRuntimePageIndex};
            const nextBtn = document.getElementById('nextBtn');
            const cancelBtn = document.getElementById('cancelBtn');
            var currentPage = 1;
            var restartWizard = false;

            function showPage(pageIndex) {
                const pagesElement = document.getElementById("pages");

                for (let i = 0; i < pagesElement.children.length; i++) {
                    pagesElement.children[i].classList.add("inactivePage");
                }

                if (pageIndex-1 < pagesElement.children.length) {
                    pagesElement.children[pageIndex-1].classList.remove("inactivePage");
                }
            }

            // Register Next button click event
            nextBtn.addEventListener('click', () => {
                // On button click, move to next page
                if (currentPage == vcRuntimePage) {
                    nextBtn.disabled = true;
                    nextBtn.classList.add("disabledBtn");
                    document.getElementById("checkError").innerHTML = "";

                    vscode.postMessage({ command: 'recheckRuntime' });
                } else {
                    currentPage += 1;
                }

                // Process handling for the new page or restart the wizard if requested
                if (restartWizard) {
                    // Go to page 1 and reset the buttons
                    restartWizard = false;
                    document.getElementById("certError").innerHTML = "";
                    nextBtn.value = "Next >";
                    cancelBtn.style.display = "none";
                    document.getElementById("waitForConfirmation").style.display = "block";
                    currentPage = 1;
                } else if (currentPage == pageInstallCert) {
                    // Try to install the cert
                    nextBtn.disabled = true;
                    nextBtn.classList.add("disabledBtn");

                    vscode.postMessage({ command: 'installCert' });
                } else if (currentPage == vcRuntimePage) {
                    nextBtn.value = "Check VC++ Runtime";
                } else if (currentPage >= pageLast) {
                    // Close the webview panel
                    vscode.postMessage({ command: 'restartVsCode' });
                    // Ensure no other page is shown
                    currentPage = pageLast + 1;
                }

                showPage(currentPage);
            });

            // Register Cancel button click event
            cancelBtn.addEventListener('click', () => {
                // Close the webview panel
                vscode.postMessage({ command: 'done' });
            });

            // Handle the message inside the webview
            window.addEventListener('message', event => {

                const message = event.data; // The JSON data our extension sent

                switch (message.command) {
                    case 'reCheckVcRuntime':
                        if (message.output.includes("true")) {
                            showPage(vcRuntimePage + 1);
                            nextBtn.value = "Next >";
                            currentPage = vcRuntimePage + 1;
                        } else {
                            const errorMessage = "VC++ runtime library installation not detected.";
                            document.getElementById("checkError").innerHTML = errorMessage;

                            showPage(vcRuntimePage);
                            currentPage = vcRuntimePage;
                        }
                        nextBtn.disabled = false;
                        nextBtn.classList.remove("disabledBtn");
                        break;

                    case 'installCertResult':
                        if (message.output.includes("true")) {
                            showPage(pageLast);

                            nextBtn.value = "Reload VS Code Window";
                            nextBtn.disabled = false;
                            nextBtn.classList.remove("disabledBtn");

                            cancelBtn.style.display = "none";
                            restartWizard = false;
                        } else if (message.output.includes("ERROR")) {
                            document.getElementById("waitForConfirmation").style.display = "none";
                            document.getElementById("certError").innerHTML = message.output;

                            nextBtn.value = "Restart Setup Wizard";
                            nextBtn.disabled = false;
                            nextBtn.classList.remove("disabledBtn");

                            cancelBtn.style.display = "block";
                            restartWizard = true;
                        }

                        break;
                }
            });
        }())
    </script>
</body>
</html>`;
};
var checkVcRuntime = () => {
  return new Promise((resolve, reject) => {
    if ((0, import_os4.platform)() === "win32") {
      regedit.promisified.list([
        "HKLM\\SOFTWARE\\WOW6432Node\\Microsoft\\VisualStudio\\14.0\\VC\\Runtimes\\X64",
        "HKLM\\SOFTWARE\\Microsoft\\VisualStudio\\14.0\\VC\\Runtimes\\X64"
      ]).then((items) => {
        let cRuntimeInstalled = false;
        for (const key in items) {
          const item = items[key];
          if (item.exists) {
            cRuntimeInstalled = true;
            break;
          }
        }
        resolve(cRuntimeInstalled);
      }).catch((reason) => {
        reject(`C++ Runtime availability could not checked: ${String(reason)}`);
      });
    } else {
      resolve(false);
    }
  });
};
var setupInitialWelcomeWebview = (context) => {
  context.subscriptions.push(import_vscode35.commands.registerCommand("msg.runWelcomeWizard", () => {
    const panel = import_vscode35.window.createWebviewPanel("mysqlShellInitialSetup", "Welcome to MySQL Shell", import_vscode35.ViewColumn.One, {
      enableScripts: true,
      retainContextWhenHidden: true,
      localResourceRoots: [import_vscode35.Uri.file((0, import_path7.join)(context.extensionPath, "images"))]
    });
    let requirementsError = "";
    const osName = (0, import_os4.platform)();
    if (osName === "darwin" || osName === "win32") {
      const rel = (0, import_os4.release)().match(/(\d*)\.(\d*)\.(\d*)/);
      const mainVersion = rel && rel.length > 1 ? parseInt(rel[1], 10) : 0;
      if (osName === "darwin" && mainVersion < 20) {
        requirementsError = "This extension requires macOS 11 Big Sur or later.";
      } else if (osName === "win32" && mainVersion < 10) {
        requirementsError = "This extension requires Windows 10 or later.";
      }
    }
    const extensionPath = panel.webview.asWebviewUri(import_vscode35.Uri.file(context.extensionPath));
    if (requirementsError) {
      panel.webview.html = getRequirementsErrorWebviewContent(requirementsError, extensionPath);
    } else {
      if (osName === "win32") {
        checkVcRuntime().then((result) => {
          panel.webview.html = getWelcomeWebviewContent(extensionPath, !result);
        }).catch((reason) => {
          printChannelOutput(String(reason), true);
          panel.webview.html = getWelcomeWebviewContent(extensionPath, false);
        });
      } else {
        panel.webview.html = getWelcomeWebviewContent(extensionPath, false);
      }
    }
    panel.webview.onDidReceiveMessage(
      (message) => {
        switch (message.command) {
          case "installCert": {
            const configuration = import_vscode35.workspace.getConfiguration(`msg.debugLog`);
            const logLevel = configuration.get("level", "INFO");
            const config = {
              rootPath: context.extensionPath,
              inDevelopment: context.extensionMode === import_vscode35.ExtensionMode.Development,
              parameters: [
                "--",
                "gui",
                "core",
                "install-shell-web-certificate",
                "--replace_existing=true"
              ],
              logLevel,
              onStdOutData: (output) => {
                printChannelOutput(output);
                if (!output.startsWith("Starting embedded MySQL Shell") && !output.includes("DEBUG")) {
                  void panel.webview.postMessage({ command: "installCertResult", output });
                }
              }
            };
            MySQLShellLauncher.runMysqlShell(config);
            return;
          }
          case "restartVsCode": {
            panel.dispose();
            void import_vscode35.commands.executeCommand("workbench.action.reloadWindow");
            return;
          }
          case "recheckRuntime": {
            checkVcRuntime().then((result) => {
              void panel.webview.postMessage({ command: "reCheckVcRuntime", output: result.toString() });
            }).catch((reason) => {
              printChannelOutput(String(reason));
            });
            return;
          }
          case "done": {
            panel.dispose();
            return;
          }
          default:
        }
      },
      void 0,
      context.subscriptions
    );
  }));
};

// src/extension.ts
var taskOutputChannel;
var statusBarItem;
var outputChannel;
var host;
var startupCompleted = false;
var restartMessage = "This will close all MySQL Shell tabs and restart the underlying process. After that a new connection will automatically be established.";
var resetMessage = "This will completely reset the MySQL Shell for VS Code extension by deleting the web certificate and user settings directory.";
var resetRestartMessage = "The MySQL Shell for VS Code extension has been reset. Please restart VS Code to initialize the extension again or press [Cancel] and remove the Extension from the Extensions View Container.";
var printChannelOutput = (content, reveal = false) => {
  outputChannel.appendLine(content);
  if (reveal) {
    outputChannel.show(true);
  }
};
var handleShellOutput = (output) => {
  if (!startupCompleted && output.includes("Sending session response...")) {
    startupCompleted = true;
  }
  if (!startupCompleted) {
    if (output.includes("Certificate is not installed.")) {
      void import_vscode36.window.showInformationMessage(
        "The MySQL Shell for VS Code extension cannot run because the web certificate is not installed. Do you want to run the Welcome Wizard to install it?",
        "Run Welcome Wizard",
        "Cancel"
      ).then((answer) => {
        if (answer !== "Cancel") {
          void import_vscode36.commands.executeCommand("msg.runWelcomeWizard");
        }
      });
    } else if (output.includes("Certificate is not correctly installed.")) {
      void import_vscode36.window.showInformationMessage(
        "The MySQL Shell for VS Code extension cannot run because the web certificate is incorrectly installed. Do you want to run the Welcome Wizard to fix it?",
        "Run Welcome Wizard",
        "Cancel"
      ).then((answer) => {
        if (answer !== "Cancel") {
          void import_vscode36.commands.executeCommand("msg.runWelcomeWizard");
        }
      });
    }
  }
  printChannelOutput(output);
};
var shellLauncher = new MySQLShellLauncher(
  handleShellOutput,
  (error) => {
    printChannelOutput(error.message, true);
  }
);
var forwardPortThroughSshSession = async (dynamicUrl) => {
  const localUri = await import_vscode36.env.asExternalUri(import_vscode36.Uri.parse(dynamicUrl.href));
  return new URL(localUri.toString().replace("%3D", "="));
};
var activate = (context) => {
  outputChannel = import_vscode36.window.createOutputChannel("MySQL Shell for VS Code");
  taskOutputChannel = import_vscode36.window.createOutputChannel("MySQL Shell - Tasks");
  statusBarItem = import_vscode36.window.createStatusBarItem(import_vscode36.StatusBarAlignment.Left);
  statusBarItem.hide();
  statusBarItem.tooltip = "MySQL Task Process";
  host = new ExtensionHost(context);
  setupInitialWelcomeWebview(context);
  context.subscriptions.push(import_vscode36.commands.registerCommand("msg.restartShell", () => {
    void import_vscode36.window.showWarningMessage(restartMessage, "Restart MySQL Shell", "Cancel").then(async (choice) => {
      if (choice === "Restart MySQL Shell") {
        host.closeAllTabs();
        MessageScheduler.get.disconnect();
        await shellLauncher.exitProcess();
        webSession.clearSessionData();
        shellLauncher.startShellAndConnect(
          context.extensionPath,
          context.extensionMode === import_vscode36.ExtensionMode.Development,
          true
        );
      }
    });
  }));
  context.subscriptions.push(import_vscode36.commands.registerCommand("msg.connectToShell", () => {
    const externalUrl = import_vscode36.workspace.getConfiguration("msg.shell").get("externalUrl");
    void import_vscode36.window.showInputBox({
      title: "Connect to a MySQL Instance",
      value: externalUrl,
      prompt: "Enter the address of a MySQL Shell instance to connect to. Leave the field empty to start and connect to a local MySQL Shell"
    }).then(async (value) => {
      host.closeAllTabs();
      MessageScheduler.get.disconnect();
      await shellLauncher.exitProcess();
      webSession.clearSessionData();
      const configuration = import_vscode36.workspace.getConfiguration(`msg.debugLog`);
      const level = configuration.get("level", "INFO");
      shellLauncher.startShellAndConnect(
        context.extensionPath,
        context.extensionMode === import_vscode36.ExtensionMode.Development,
        true,
        level,
        value
      );
    });
  }));
  context.subscriptions.push(import_vscode36.commands.registerCommand("msg.resetExtension", () => {
    void import_vscode36.window.showWarningMessage(resetMessage, "Reset Extension", "Cancel").then((choice) => {
      if (choice === "Reset Extension") {
        void context.globalState.update("MySQLShellInitialRun", "");
        const configuration = import_vscode36.workspace.getConfiguration(`msg.debugLog`);
        const logLevel = configuration.get("level", "INFO");
        const config = {
          rootPath: context.extensionPath,
          inDevelopment: context.extensionMode === import_vscode36.ExtensionMode.Development,
          parameters: [
            "--",
            "gui",
            "core",
            "remove-shell-web-certificate"
          ],
          logLevel,
          onStdOutData: (output) => {
            if (output.includes("true")) {
              const shellUserConfigDir = MySQLShellLauncher.getShellUserConfigDir(
                context.extensionMode === import_vscode36.ExtensionMode.Development
              );
              if (shellUserConfigDir.endsWith(MySQLShellLauncher.extensionShellUserConfigFolderBaseName)) {
                (0, import_fs7.rmSync)(shellUserConfigDir, { recursive: true, force: true });
              }
              void import_vscode36.window.showWarningMessage(resetRestartMessage, "Restart VS Code", "Cancel").then((choice2) => {
                if (choice2 === "Restart VS Code") {
                  void import_vscode36.commands.executeCommand("workbench.action.reloadWindow");
                }
              });
            } else if (!output.startsWith("Starting embedded MySQL Shell") && !output.includes("DEBUG") && !output.includes("LC_ALL")) {
              void import_vscode36.window.showInformationMessage(
                `The following error occurred while deleting the certificate: ${output} Cancelled reset operation.`
              );
            }
          }
        };
        MySQLShellLauncher.runMysqlShell(config);
      }
    });
  }));
  context.subscriptions.push(import_vscode36.commands.registerCommand("msg.fileBugReport", () => {
    const currentVersion2 = import_vscode36.extensions.getExtension(
      "Oracle.mysql-shell-for-vs-code"
    ).packageJSON.version || "1.0.0";
    let platformId;
    let cpuArch;
    switch ((0, import_os5.platform)()) {
      case "darwin": {
        platformId = "6";
        break;
      }
      case "win32": {
        platformId = "7";
        break;
      }
      default: {
        platformId = "5";
        break;
      }
    }
    switch ((0, import_os5.arch)()) {
      case "arm":
      case "arm64": {
        cpuArch = "3";
        break;
      }
      case "x86": {
        cpuArch = "2";
        break;
      }
      default: {
        cpuArch = "1";
        break;
      }
    }
    void import_vscode36.env.openExternal(import_vscode36.Uri.parse(`https://bugs.mysql.com/report.php?category=Shell%20VSCode%20Extension&version=${currentVersion2}&os=${platformId}&cpu_arch=${cpuArch}`));
  }));
  context.subscriptions.push(import_vscode36.commands.registerCommand("msg.hasLaunchedSuccessfully", async () => {
    await waitFor(3e3, () => {
      return startupCompleted;
    });
    return startupCompleted;
  }));
  const msgExtension = import_vscode36.extensions.getExtension("Oracle.mysql-shell-for-vs-code");
  const currentVersion = msgExtension.packageJSON.version || "1.0.0";
  const lastRunVersion = context.globalState.get("MySQLShellLastRunVersion");
  if (!lastRunVersion || lastRunVersion === "" || lastRunVersion !== currentVersion) {
    void context.globalState.update("MySQLShellLastRunVersion", currentVersion);
    if ((0, import_os5.platform)() === "darwin") {
      const shellDir = (0, import_path8.join)(context.extensionPath, "shell");
      if ((0, import_fs7.existsSync)(shellDir)) {
        void child_process2.execSync(`xattr -rc ${shellDir}`);
      }
    }
  }
  const initialRun = context.globalState.get("MySQLShellInitialRun");
  if ((!initialRun || initialRun === "") && !appParameters.testsRunning) {
    void context.globalState.update("MySQLShellInitialRun", currentVersion);
    void import_vscode36.commands.executeCommand("msg.runWelcomeWizard");
  } else {
    const useExternalUrl = import_vscode36.workspace.getConfiguration("msg.shell").get("useExternal");
    let externalUrl;
    if (useExternalUrl) {
      externalUrl = import_vscode36.workspace.getConfiguration("msg.shell").get("externalUrl");
    }
    const sshRemote = msgExtension.extensionKind === import_vscode36.ExtensionKind.Workspace && import_vscode36.env.remoteName === "ssh-remote";
    outputChannel.appendLine(`Running on a ${sshRemote ? "ssh-remote" : "local"} VS Code session.`);
    const level = import_vscode36.workspace.getConfiguration(`msg.debugLog`).get("level", "INFO");
    const enforceHttps = import_vscode36.workspace.getConfiguration(`msg.shell`).get("enforceHttps", true);
    const inDevelopment = context.extensionMode === import_vscode36.ExtensionMode.Development;
    if (sshRemote) {
      shellLauncher.startShellAndConnect(
        context.extensionPath,
        inDevelopment,
        enforceHttps,
        level,
        externalUrl,
        forwardPortThroughSshSession
      );
    } else {
      shellLauncher.startShellAndConnect(context.extensionPath, inDevelopment, enforceHttps, level, externalUrl);
    }
  }
};
var deactivate = () => {
  requisitions.unregister();
  MessageScheduler.get.disconnect();
  void shellLauncher.exitProcess();
};
var statusBarTimer;
var showStatusText = (text) => {
  clearTimeout(statusBarTimer);
  statusBarItem.text = `MySQL Shell: ${text}`;
  statusBarItem.show();
  setTimeout(() => {
    statusBarItem.hide();
  }, 5e3);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate,
  deactivate,
  printChannelOutput,
  showStatusText,
  statusBarItem,
  taskOutputChannel
});
//# sourceMappingURL=main.js.map
