(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-shape'), require('d3-selection'), require('d3-scale'), require('d3-path'), require('d3-array')) :
    typeof define === 'function' && define.amd ? define(['exports', 'd3-shape', 'd3-selection', 'd3-scale', 'd3-path', 'd3-array'], factory) :
    (global = global || self, factory(global.fc = global.fc || {}, global.d3, global.d3, global.d3, global.d3, global.d3));
}(this, function (exports, d3Shape, d3Selection, d3Scale, d3Path, d3Array) { 'use strict';

    var d3Shape__default = 'default' in d3Shape ? d3Shape['default'] : d3Shape;
    var d3Scale__default = 'default' in d3Scale ? d3Scale['default'] : d3Scale;

    // "Caution: avoid interpolating to or from the number zero when the interpolator is used to generate
    // a string (such as with attr).
    // Very small values, when stringified, may be converted to scientific notation and
    // cause a temporarily invalid attribute or style property value.
    // For example, the number 0.0000001 is converted to the string "1e-7".
    // This is particularly noticeable when interpolating opacity values.
    // To avoid scientific notation, start or end the transition at 1e-6,
    // which is the smallest value that is not stringified in exponential notation."
    // - https://github.com/mbostock/d3/wiki/Transitions#d3_interpolateNumber
    const effectivelyZero = 1e-6; // Wrapper around d3's selectAll/data data-join, which allows decoration of the result.
    // This is achieved by appending the element to the enter selection before exposing it.
    // A default transition of fade in/out is also implicitly added but can be modified.

    var dataJoin = ((element, className) => {
      element = element || 'g';

      let key = (_, i) => i;

      let explicitTransition = null;

      const dataJoin = function (container, data) {
        data = data || (d => d);

        const implicitTransition = container.selection ? container : null;

        if (implicitTransition) {
          container = container.selection();
        }

        const selected = container.selectAll((d, i, nodes) => Array.from(nodes[i].childNodes).filter(node => node.nodeType === 1)).filter(className == null ? element : `${element}.${className}`);
        let update = selected.data(data, key);
        const enter = update.enter().append(element).attr('class', className);
        let exit = update.exit(); // automatically merge in the enter selection

        update = update.merge(enter); // if transitions are enabled apply a default fade in/out transition

        const transition = implicitTransition || explicitTransition;

        if (transition) {
          update = update.transition(transition).style('opacity', 1);
          enter.style('opacity', effectivelyZero);
          exit = exit.transition(transition).style('opacity', effectivelyZero);
        }

        exit.remove();

        update.enter = () => enter;

        update.exit = () => exit;

        return update;
      };

      dataJoin.element = (...args) => {
        if (!args.length) {
          return element;
        }

        element = args[0];
        return dataJoin;
      };

      dataJoin.className = (...args) => {
        if (!args.length) {
          return className;
        }

        className = args[0];
        return dataJoin;
      };

      dataJoin.key = (...args) => {
        if (!args.length) {
          return key;
        }

        key = args[0];
        return dataJoin;
      };

      dataJoin.transition = (...args) => {
        if (!args.length) {
          return explicitTransition;
        }

        explicitTransition = args[0];
        return dataJoin;
      };

      return dataJoin;
    });

    var createReboundMethod = ((target, source, name) => {
      const method = source[name];

      if (typeof method !== 'function') {
        throw new Error(`Attempt to rebind ${name} which isn't a function on the source object`);
      }

      return (...args) => {
        var value = method.apply(source, args);
        return value === source ? target : value;
      };
    });

    var rebind = ((target, source, ...names) => {
      for (const name of names) {
        target[name] = createReboundMethod(target, source, name);
      }

      return target;
    });

    const createTransform = transforms => name => transforms.reduce((name, fn) => name && fn(name), name);

    var rebindAll = ((target, source, ...transforms) => {
      const transform = createTransform(transforms);

      for (const name of Object.keys(source)) {
        const result = transform(name);

        if (result) {
          target[result] = createReboundMethod(target, source, name);
        }
      }

      return target;
    });

    var regexify = (strsOrRegexes => strsOrRegexes.map(strOrRegex => typeof strOrRegex === 'string' ? new RegExp(`^${strOrRegex}$`) : strOrRegex));

    var exclude = ((...exclusions) => {
      exclusions = regexify(exclusions);
      return name => exclusions.every(exclusion => !exclusion.test(name)) && name;
    });

    var includeMap = (mappings => name => mappings[name]);

    var functor = (function (d) {
      return typeof d === 'function' ? d : function () {
        return d;
      };
    });

    // Checks that passed properties are 'defined', meaning that calling them with (d, i) returns non null values
    function defined() {
      var outerArguments = arguments;
      return function (d, i) {
        for (var c = 0, j = outerArguments.length; c < j; c++) {
          if (outerArguments[c](d, i) == null) {
            return false;
          }
        }

        return true;
      };
    }

    // determines the offset required along the cross scale based
    // on the series alignment
    var alignOffset = (function (align, width) {
      switch (align) {
        case 'left':
          return width / 2;

        case 'right':
          return -width / 2;

        default:
          return 0;
      }
    });

    var createBase = (function (initialValues) {
      var env = Object.assign({}, initialValues);

      var base = function base() {};

      Object.keys(env).forEach(function (key) {
        base[key] = function () {
          if (!arguments.length) {
            return env[key];
          }

          env[key] = arguments.length <= 0 ? undefined : arguments[0];
          return base;
        };
      });
      return base;
    });

    var xyBase = (function () {
      var baseValue = function baseValue() {
        return 0;
      };

      var crossValue = function crossValue(d) {
        return d.x;
      };

      var mainValue = function mainValue(d) {
        return d.y;
      };

      var align = 'center';

      var bandwidth = function bandwidth() {
        return 5;
      };

      var orient = 'vertical';
      var base = createBase({
        decorate: function decorate() {},
        defined: function defined$1(d, i) {
          return defined(baseValue, crossValue, mainValue)(d, i);
        },
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity()
      });

      base.values = function (d, i) {
        var width = bandwidth(d, i);
        var offset = alignOffset(align, width);
        var xScale = base.xScale();
        var yScale = base.yScale();

        if (orient === 'vertical') {
          var y = yScale(mainValue(d, i), i);
          var y0 = yScale(baseValue(d, i), i);
          var x = xScale(crossValue(d, i), i) + offset;
          return {
            d: d,
            x: x,
            y: y,
            y0: y0,
            width: width,
            height: y - y0,
            origin: [x, y],
            baseOrigin: [x, y0],
            transposedX: x,
            transposedY: y
          };
        } else {
          var _y = xScale(mainValue(d, i), i);

          var _y2 = xScale(baseValue(d, i), i);

          var _x = yScale(crossValue(d, i), i) + offset;

          return {
            d: d,
            x: _x,
            y: _y,
            y0: _y2,
            width: width,
            height: _y - _y2,
            origin: [_y, _x],
            baseOrigin: [_y2, _x],
            transposedX: _y,
            transposedY: _x
          };
        }
      };

      base.xValues = function () {
        return orient === 'vertical' ? [crossValue] : [baseValue, mainValue];
      };

      base.yValues = function () {
        return orient !== 'vertical' ? [crossValue] : [baseValue, mainValue];
      };

      base.baseValue = function () {
        if (!arguments.length) {
          return baseValue;
        }

        baseValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.crossValue = function () {
        if (!arguments.length) {
          return crossValue;
        }

        crossValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.mainValue = function () {
        if (!arguments.length) {
          return mainValue;
        }

        mainValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.bandwidth = function () {
        if (!arguments.length) {
          return bandwidth;
        }

        bandwidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.align = function () {
        if (!arguments.length) {
          return align;
        }

        align = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.orient = function () {
        if (!arguments.length) {
          return orient;
        }

        orient = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      return base;
    });

    var red = '#c60';
    var green = '#6c0';
    var black = '#000';
    var gray = '#ddd';
    var darkGray = '#999';
    var colors = {
      red: red,
      green: green,
      black: black,
      gray: gray,
      darkGray: darkGray
    };

    var line = (function () {
      var base = xyBase();
      var lineData = d3Shape.line().x(function (d, i) {
        return base.values(d, i).transposedX;
      }).y(function (d, i) {
        return base.values(d, i).transposedY;
      });
      var join = dataJoin('path', 'line');

      var line = function line(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        lineData.defined(base.defined());
        selection.each(function (data, index, group) {
          var path = join(d3Selection.select(group[index]), [data]);
          path.enter().attr('fill', 'none').attr('stroke', colors.black);
          path.attr('d', lineData);
          base.decorate()(path, data, index);
        });
      };

      rebindAll(line, base, exclude('baseValue', 'bandwidth', 'align'));
      rebind(line, join, 'key');
      rebind(line, lineData, 'curve');
      return line;
    });

    var line$1 = (function () {
      var base = xyBase();
      var lineData = d3Shape.line().x(function (d, i) {
        return base.values(d, i).transposedX;
      }).y(function (d, i) {
        return base.values(d, i).transposedY;
      });

      var line = function line(data) {
        var context = lineData.context();
        context.beginPath();
        lineData.defined(base.defined())(data);
        context.strokeStyle = colors.black;
        context.fillStyle = 'transparent';
        base.decorate()(context, data);
        context.fill();
        context.stroke();
        context.closePath();
      };

      rebindAll(line, base, exclude('baseValue', 'bandwidth', 'align'));
      rebind(line, lineData, 'curve', 'context');
      return line;
    });

    var bufferBuilder = (() => {
      const attributes = {};
      const uniforms = {};

      const build = (gl, program, verticesPerElement, count) => {
        Object.keys(attributes).forEach(key => {
          attributes[key](gl, program, key, verticesPerElement, count);
        });
        Object.keys(uniforms).forEach(key => {
          uniforms[key](gl, program, key);
        });
      };

      build.attribute = (...args) => {
        if (args.length === 1) {
          return attributes[args[0]];
        }

        attributes[args[0]] = args[1];
        return build;
      };

      build.uniform = (...args) => {
        if (args.length === 1) {
          return uniforms[args[0]];
        }

        uniforms[args[0]] = args[1];
        return build;
      };

      return build;
    });

    const types = {
      FLOAT: 5126
    };

    var baseAttributeBuilder = (() => {
      let buffer = null;
      let size = 1; // per vertex

      let type = types.FLOAT;
      let normalized = false;
      let stride = 0;
      let offset = 0;

      const base = (gl, program, name) => {
        if (buffer == null) {
          buffer = gl.createBuffer();
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        const location = gl.getAttribLocation(program, name);
        gl.vertexAttribPointer(location, base.size(), base.type(), base.normalized(), base.stride(), base.offset());
        gl.enableVertexAttribArray(location);
      };

      base.buffer = (...args) => {
        if (!args.length) {
          return buffer;
        }

        buffer = args[0];
        return base;
      };

      base.size = (...args) => {
        if (!args.length) {
          return size;
        }

        size = args[0];
        return base;
      };

      base.type = (...args) => {
        if (!args.length) {
          return type;
        }

        type = args[0];
        return base;
      };

      base.normalized = (...args) => {
        if (!args.length) {
          return normalized;
        }

        normalized = args[0];
        return base;
      };

      base.stride = (...args) => {
        if (!args.length) {
          return stride;
        }

        stride = args[0];
        return base;
      };

      base.offset = (...args) => {
        if (!args.length) {
          return offset;
        }

        offset = args[0];
        return base;
      };

      return base;
    });

    var projectedAttributeBuilder = (() => {
      const base = baseAttributeBuilder();

      let value = (data, element, vertex, component, index) => data[index];

      let data = null;
      let validSize = 0;

      const project = (elementCount, verticesPerElement) => {
        const components = base.size();
        const offset = base.offset();
        const projectedData = new Float32Array(offset + elementCount * verticesPerElement * components);
        let index = 0;

        for (let element = 0; element < elementCount; element++) {
          for (let vertex = 0; vertex < verticesPerElement; vertex++) {
            for (let component = 0; component < components; component++) {
              projectedData[offset + index++] = value(data, element, vertex, component, index);
            }
          }
        }

        return projectedData;
      };

      const build = (gl, program, name, verticesPerElement, count) => {
        if (validSize >= count) {
          return;
        }

        const projectedData = project(count, verticesPerElement);
        base(gl, program, name);
        gl.bindBuffer(gl.ARRAY_BUFFER, base.buffer());
        gl.bufferData(gl.ARRAY_BUFFER, projectedData, gl.DYNAMIC_DRAW);
        validSize = count;
      };

      build.value = (...args) => {
        if (!args.length) {
          return value;
        }

        value = args[0];
        validSize = 0;
        return build;
      };

      build.data = (...args) => {
        if (!args.length) {
          return data;
        }

        data = args[0];
        validSize = 0;
        return build;
      };

      rebindAll(build, base, exclude('buffer'));
      return build;
    });

    var uniformBuilder = (_data => {
      let data = _data;
      let changed = true;

      let bind = (gl, program, name) => {
        const loc = gl.getUniformLocation(program, name); // provide a way of setting which of the uniform functions to use?

        if (data instanceof Array) {
          switch (data.length) {
            case 1:
              gl.uniform1fv(loc, data);
              break;

            case 2:
              gl.uniform2fv(loc, data);
              break;

            case 3:
              gl.uniform3fv(loc, data);
              break;

            case 4:
              gl.uniform4fv(loc, data);
              break;

            default:
              throw new Error(`Uniform supports up to 4 elements. ${data.length} provided.`);
          }
        } else {
          gl.uniform1f(loc, data);
        }
      };

      const build = (gl, program, name) => {
        if (changed) {
          changed = false;
          bind(gl, program, name);
        }
      };

      build.bind = (...args) => {
        if (!args.length) {
          return bind;
        }

        bind = args[0];
        return build;
      };

      build.data = (...args) => {
        if (!args.length) {
          return data;
        }

        data = args[0];
        changed = true;
        return build;
      };

      return build;
    });

    var shaderBuilder = (base => {
      const shaderHeaders = [];
      const shaderBodies = [];

      const build = () => {
        return base(shaderHeaders.join('\n'), shaderBodies.join('\n'));
      };

      function append(array, element) {
        array.push(element);
      }

      function insert(array, element, before) {
        const beforeIndex = array.indexOf(before);
        array.splice(beforeIndex >= 0 ? beforeIndex : array.length, 0, element);
      }

      function appendIfNotExists(array, element) {
        const elementIndex = array.indexOf(element);

        if (elementIndex === -1) {
          array.push(element);
        }
      }

      build.appendHeader = header => {
        append(shaderHeaders, header);
        return build;
      };

      build.insertHeader = (header, before) => {
        insert(shaderHeaders, header, before);
        return build;
      };

      build.appendHeaderIfNotExists = header => {
        appendIfNotExists(shaderHeaders, header);
        return build;
      };

      build.appendBody = body => {
        append(shaderBodies, body);
        return build;
      };

      build.insertBody = (body, before) => {
        insert(shaderBodies, body, before);
        return build;
      };

      build.appendBodyIfNotExists = body => {
        appendIfNotExists(shaderBodies, body);
        return build;
      };

      return build;
    }); // inf is precalculated here for use in some functions (e.g. log scale calculations)

    const vertexShaderBase = (header, body) => `
precision mediump float;
float inf = 1.0 / 0.0;
${header}
void main() {
    ${body}
}`;
    const fragmentShaderBase = (header, body) => `
precision mediump float;
${header}
void main() {
    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    ${body}
}`;

    var drawModes = {
      POINTS: 0,
      LINES: 1,
      LINE_LOOP: 2,
      LINE_STRIP: 3,
      TRIANGLES: 4,
      TRIANGLE_STRIP: 5,
      TRIANGLE_FAN: 6
    };

    var programBuilder = (() => {
      let context = null;
      let program = null;
      let vertexShader = null;
      let fragmentShader = null;
      let mode = drawModes.TRIANGLES;
      let buffers = bufferBuilder();
      let verticesPerElement = 1;

      const build = count => {
        const vertexShaderSource = vertexShader();
        const fragmentShaderSource = fragmentShader();

        if (newProgram(program, vertexShaderSource, fragmentShaderSource)) {
          context.isProgram(program) && context.deleteProgram(program);
          program = createProgram(vertexShaderSource, fragmentShaderSource);
        }

        context.useProgram(program);
        buffers.uniform('uScreen', uniformBuilder([context.canvas.width, context.canvas.height]));
        buffers(context, program, verticesPerElement, count);
        context.drawArrays(mode, 0, count * verticesPerElement);
      };

      build.context = (...args) => {
        if (!args.length) {
          return context;
        }

        context = args[0];
        return build;
      };

      build.buffers = (...args) => {
        if (!args.length) {
          return buffers;
        }

        buffers = args[0];
        return build;
      };

      build.vertexShader = (...args) => {
        if (!args.length) {
          return vertexShader;
        }

        vertexShader = args[0];
        return build;
      };

      build.fragmentShader = (...args) => {
        if (!args.length) {
          return fragmentShader;
        }

        fragmentShader = args[0];
        return build;
      };

      build.mode = (...args) => {
        if (!args.length) {
          return mode;
        }

        mode = args[0];
        return build;
      };

      build.verticesPerElement = (...args) => {
        if (!args.length) {
          return verticesPerElement;
        }

        verticesPerElement = args[0];
        return build;
      };

      return build;

      function newProgram(program, vertexShader, fragmentShader) {
        if (!program) {
          return true;
        }

        const shaders = context.getAttachedShaders(program);
        const vertexShaderSource = context.getShaderSource(shaders[0]);
        const fragmentShaderSource = context.getShaderSource(shaders[1]);
        return vertexShader !== vertexShaderSource || fragmentShader !== fragmentShaderSource;
      }

      function createProgram(vertexShaderSource, fragmentShaderSource) {
        const vertexShader = loadShader(vertexShaderSource, context.VERTEX_SHADER);
        const fragmentShader = loadShader(fragmentShaderSource, context.FRAGMENT_SHADER);
        const program = context.createProgram();
        context.attachShader(program, vertexShader);
        context.attachShader(program, fragmentShader);
        context.linkProgram(program);

        if (!context.getProgramParameter(program, context.LINK_STATUS)) {
          const message = context.getProgramInfoLog(program);
          context.deleteProgram(program);
          throw new Error(`Failed to link program : ${message}
            Vertex Shader : ${vertexShaderSource}
            Fragment Shader : ${fragmentShaderSource}`);
        }

        return program;
      }

      function loadShader(source, type) {
        const shader = context.createShader(type);
        context.shaderSource(shader, source);
        context.compileShader(shader);

        if (!context.getShaderParameter(shader, context.COMPILE_STATUS)) {
          const message = context.getShaderInfoLog(shader);
          context.deleteShader(shader);
          throw new Error(`Failed to compile shader : ${message}
            Shader : ${source}`);
        }

        return shader;
      }
    });

    var glScaleBase = (() => {
      let domain = [0, 1];
      let range = [-1, 1];
      let coordinate = 0;

      const base = () => {};

      base.domain = (...args) => {
        if (!args.length) {
          return domain;
        }

        domain = args[0];
        return base;
      };

      base.range = (...args) => {
        if (!args.length) {
          return range;
        }

        range = args[0];
        return base;
      };

      base.coordinate = (...args) => {
        if (!args.length) {
          return coordinate;
        }

        coordinate = args[0];
        return base;
      };

      return base;
    });

    var glScaleLinear = (() => {
      const base = glScaleBase();

      const prefix = () => `linear${base.coordinate()}`;

      const apply = program => {
        updateProgram(program);
        const domainSize = base.domain()[1] - base.domain()[0];
        const rangeSize = base.range()[1] - base.range()[0];
        const translate = base.range()[0] * (domainSize / rangeSize) - base.domain()[0];
        const scaleFactor = rangeSize / domainSize;
        const offset = [0, 0, 0, 0];
        const scale = [1, 1, 1, 1];
        offset[base.coordinate()] = translate;
        scale[base.coordinate()] = scaleFactor;
        program.buffers().uniform(`${prefix()}Offset`, uniformBuilder(offset)).uniform(`${prefix()}Scale`, uniformBuilder(scale));
      };

      function updateProgram(program) {
        program.vertexShader().appendHeader(`uniform vec4 ${prefix()}Offset;`).appendHeader(`uniform vec4 ${prefix()}Scale;`);
        apply.scaleComponent(program, 'gl_Position');
      }

      apply.scaleComponent = (program, component) => {
        program.vertexShader().appendBody(`${component} = ${component} + ${prefix()}Offset;`).appendBody(`${component} = ${component} * ${prefix()}Scale;`);
        return apply;
      };

      rebindAll(apply, base);
      return apply;
    });

    var glScaleLog = (() => {
      const glBase = glScaleBase();
      let base = 10;

      function log(v, base) {
        return Math.log10(v) / Math.log10(base);
      }

      const prefix = () => `log${glBase.coordinate()}`;

      const apply = program => {
        updateProgram(program);
        const domainSize = log(glBase.domain()[1], base) - log(glBase.domain()[0], base);
        const rangeSize = glBase.range()[1] - glBase.range()[0];
        const scaleFactor = rangeSize / domainSize;
        const translate = glBase.range()[0] - scaleFactor * log(glBase.domain()[0], base);
        const offset = [0, 0, 0, 0];
        const scale = [0, 0, 0, 0];
        const include = [0, 0, 0, 0];
        offset[glBase.coordinate()] = translate;
        scale[glBase.coordinate()] = scaleFactor;
        include[glBase.coordinate()] = 1;
        program.buffers().uniform(`${prefix()}Offset`, uniformBuilder(offset)).uniform(`${prefix()}Scale`, uniformBuilder(scale)).uniform(`${prefix()}Include`, uniformBuilder(include)).uniform(`${prefix()}Base`, uniformBuilder(base));
      };

      function updateProgram(program) {
        program.vertexShader().appendHeader(`uniform vec4 ${prefix()}Offset;`).appendHeader(`uniform vec4 ${prefix()}Scale;`).appendHeader(`uniform vec4 ${prefix()}Include;`).appendHeader(`uniform float ${prefix()}Base;`);
        apply.scaleComponent(program, 'gl_Position');
      }

      apply.scaleComponent = (program, component) => {
        const logPart = `${prefix()}Offset + (${prefix()}Scale * clamp(log(${component}) / log(${prefix()}Base), -inf, inf))`;
        program.vertexShader().appendBody(`${component} = (${prefix()}Include * (${logPart})) + ((1.0 - ${prefix()}Include) * ${component});`);
        return apply;
      };

      apply.base = (...args) => {
        if (!args.length) {
          return base;
        }

        base = args[0];
        return apply;
      };

      rebindAll(apply, glBase);
      return apply;
    });

    var glScalePow = (() => {
      const base = glScaleBase();
      let exponent = 1;

      function pow(b, e) {
        return Math.sign(b) * Math.pow(Math.abs(b), e);
      }

      const prefix = () => `pow${base.coordinate()}`;

      const apply = program => {
        updateProgram(program);
        const domainSize = pow(base.domain()[1], exponent) - pow(base.domain()[0], exponent);
        const rangeSize = base.range()[1] - base.range()[0];
        const scaleFactor = rangeSize / domainSize;
        const translate = base.range()[0] - scaleFactor * pow(base.domain()[0], exponent);
        const offset = [0, 0, 0, 0];
        const scale = [0, 0, 0, 0];
        const include = [0, 0, 0, 0];
        offset[base.coordinate()] = translate;
        scale[base.coordinate()] = scaleFactor;
        include[base.coordinate()] = 1;
        program.buffers().uniform(`${prefix()}Offset`, uniformBuilder(offset)).uniform(`${prefix()}Scale`, uniformBuilder(scale)).uniform(`${prefix()}Include`, uniformBuilder(include)).uniform(`${prefix()}Exp`, uniformBuilder(exponent));
      };

      function updateProgram(program) {
        program.vertexShader().appendHeader(`uniform vec4 ${prefix()}Offset;`).appendHeader(`uniform vec4 ${prefix()}Scale;`).appendHeader(`uniform vec4 ${prefix()}Include;`).appendHeader(`uniform float ${prefix()}Exp;`);
        apply.scaleComponent(program, 'gl_Position');
      }

      apply.scaleComponent = (program, component) => {
        const powPart = `${prefix()}Offset + (${prefix()}Scale * sign(${component}) * pow(abs(gl_Position), vec4(${prefix()}Exp)))`;
        program.vertexShader().appendBody(`${component} = (${prefix()}Include * (${powPart})) + ((1.0 - ${prefix()}Include) * ${component});`);
        return apply;
      };

      apply.exponent = (...args) => {
        if (!args.length) {
          return exponent;
        }

        exponent = args[0];
        return apply;
      };

      rebindAll(apply, base);
      return apply;
    });

    var scaleMapper = (scale => {
      let outScale = d3Scale__default.scaleIdentity();
      let glScale = null;
      const scaleCopyString = scale.copy.toString(); // compare the stringified 'copy' function of the scale to
      // determine the scale type.

      if (scaleCopyString === d3Scale__default.scaleLinear().copy.toString()) {
        glScale = glScaleLinear().domain(scale.domain());
      } else if (scaleCopyString === d3Scale__default.scaleLog().copy.toString()) {
        glScale = glScaleLog().domain(scale.domain()).base(scale.base());
      } else if (scaleCopyString === d3Scale__default.scalePow().copy.toString()) {
        glScale = glScalePow().domain(scale.domain()).exponent(scale.exponent());
      } else if (scaleCopyString === d3Scale__default.scaleTime().copy.toString()) {
        glScale = glScaleLinear().domain(scale.domain());
      } else {
        glScale = glScaleLinear().domain(scale.range());
        outScale = scale;
      }

      return {
        scale: outScale,
        glScale: glScale
      };
    });

    const circle = {
      header: `attribute float aXValue;
             attribute float aYValue;
             attribute float aSize;
             uniform float uLineWidth;
             varying float vSize;`,
      body: `vSize = 2.0 * sqrt(aSize / 3.14159);
           gl_PointSize = vSize + uLineWidth + 1.0;
           gl_Position = vec4(aXValue, aYValue, 0, 1);`
    };
    const square = {
      header: `attribute float aXValue;
        attribute float aYValue;
        attribute float aSize;
        uniform float uLineWidth;
        varying float vSize;`,
      body: `vSize = sqrt(aSize);
        gl_PointSize = vSize + uLineWidth + 1.0;
        gl_Position = vec4(aXValue, aYValue, 0, 1);`
    };
    const triangle = {
      header: `attribute float aXValue;
        attribute float aYValue;
        attribute float aSize;
        uniform float uLineWidth;
        varying float vSize;`,
      body: `vSize = sqrt((16.0 * aSize) / (3.0 * sqrt(3.0)));
        gl_PointSize = vSize + uLineWidth + 1.0;
        gl_Position = vec4(aXValue, aYValue, 0, 1);`
    };
    const cross = {
      header: `attribute float aXValue;
        attribute float aYValue;
        attribute float aSize;
        uniform float uStrokeWidth;
        varying float vSize;
        varying float vStrokeWidthRatio;`,
      body: `vSize = 3.0 * sqrt(aSize / 5.0);
        vStrokeWidthRatio = uStrokeWidth / (vSize + uStrokeWidth + 1.0);
        gl_PointSize = vSize + uStrokeWidth + 1.0;
        gl_Position = vec4(aXValue, aYValue, 0, 1);`
    };
    const rect = {
      header: `attribute float aXValue;
        attribute float aYValue;
        attribute float aXDirection;
        attribute float aYDirection;
        attribute float aBandwidth;
        attribute float aColorIndicator;
        varying float vColorIndicator;
        uniform vec2 uScreen;
        uniform float uLineWidth;`,
      body: `vColorIndicator = aColorIndicator;
    gl_Position = vec4(aXValue, aYValue, 0, 1);`
    };
    const bar = {
      header: `attribute float aXValue;
        attribute float aYValue;
        attribute float aWidthValue;
        attribute float aDirection;`,
      body: `gl_Position = vec4(aXValue, aYValue, 0, 1);
        vec4 origin = vec4(0.0, 0.0, 0.0, 0.0);
        vec4 width = vec4(aWidthValue, 0.0, 0.0, 0.0);
        gl_Position.x += (width.x - origin.x) / 2.0 * aDirection;`
    };
    const preScaleLine = {
      header: `uniform float uLineWidth; // defines the width of the line
        uniform vec2 uScreen; // the screen space canvas size (for normalizing vectors)
        attribute vec2 aCorner; // defines which vertex in the line join we are considering
        attribute float aXValue; attribute float aYValue; // the current vertex positions
        attribute float aNextXValue; attribute float aNextYValue; // the next vertex positions
        attribute float aPrevXValue; attribute float aPrevYValue; // the previous vertex positions
        attribute float aDefined;
        varying float vDefined;`,
      body: `vDefined = aDefined;
        vec4 curr = vec4(aXValue, aYValue, 0, 1);
        gl_Position = curr;
        vec4 next = vec4(aNextXValue, aNextYValue, 0, 0);
        vec4 prev = vec4(aPrevXValue, aPrevYValue, 0, 0);`
    };
    const postScaleLine = {
      body: `if (all(equal(gl_Position.xy, prev.xy))) {
            prev.xy = gl_Position.xy + normalize(gl_Position.xy - next.xy);
        }
        if (all(equal(gl_Position.xy, next.xy))) {
            next.xy = gl_Position.xy + normalize(gl_Position.xy - prev.xy);
        }
        vec2 A = normalize(normalize(gl_Position.xy - prev.xy) * uScreen);
        vec2 B = normalize(normalize(next.xy - gl_Position.xy) * uScreen);
        vec2 tangent = normalize(A + B);
        vec2 miter = vec2(-tangent.y, tangent.x);
        vec2 normalA = vec2(-A.y, A.x);
        float miterLength = 1.0 / dot(miter, normalA);
        vec2 point = normalize(A - B);
        if (miterLength > 10.0 && sign(aCorner.x * dot(miter, point)) > 0.0) {
            gl_Position.xy = gl_Position.xy - (aCorner.x * aCorner.y * uLineWidth * normalA) / uScreen.xy;
        } else {
            gl_Position.xy = gl_Position.xy + (aCorner.x * miter * uLineWidth * miterLength) / uScreen.xy;
        }`
    };
    const errorBar = {
      header: `attribute float aXValue;
        attribute float aHighValue;
        attribute float aLowValue;
        attribute float aBandwidth;
        attribute vec3 aCorner;
        uniform vec2 uScreen;
        uniform float uLineWidth;`,
      body: `
        float isLow = (aCorner.y + 1.0) / 2.0;
        float yValue = isLow * aLowValue + (1.0 - isLow) * aHighValue;

        float isEdgeCorner = abs(aCorner.x);
        float lineWidthXDirection = (1.0 - isEdgeCorner) * aCorner.z;
        float lineWidthYDirection = isEdgeCorner * aCorner.z;
        
        gl_Position = vec4(aXValue, yValue, 0, 1);
        
        float xModifier = ((uLineWidth * lineWidthXDirection) + (aBandwidth * aCorner.x));
        float yModifier = (uLineWidth * lineWidthYDirection);
    `
    };
    const area = {
      header: `attribute float aXValue;
        attribute float aYValue;
        attribute float aXPrevValue;
        attribute float aYPrevValue;
        attribute float aY0Value;
        attribute float aY0PrevValue;
        attribute vec3 aCorner;
        attribute float aDefined;
        varying float vDefined;
        
        float when_lt(float a, float b) {
            return max(sign(b - a), 0.0);
        }
        
        float and(float a, float b) {
            return a * b;
        }`,
      body: `vDefined = aDefined;
        gl_Position = vec4(0, 0, 0, 1);

        float hasIntercepted = when_lt((aYValue - aY0Value) * (aYPrevValue - aY0PrevValue), 0.0);
        float useIntercept = and(aCorner.z, hasIntercepted);
        
        float yGradient = (aYValue - aYPrevValue) / (aXValue - aXPrevValue);
        float yConstant = aYValue - (yGradient * aXValue);

        float y0Gradient = (aY0Value - aY0PrevValue) / (aXValue - aXPrevValue);
        float y0Constant = aY0Value - (y0Gradient * aXValue);

        float denominator = (yGradient - y0Gradient) + step(abs(yGradient - y0Gradient), 0.0);
        float interceptXValue = (y0Constant - yConstant) / denominator;
        float interceptYValue = (yGradient * interceptXValue) + yConstant;

        gl_Position = vec4(interceptXValue * useIntercept, interceptYValue * useIntercept, 0, 1);
        
        gl_Position.x += (1.0 - useIntercept) * ((aCorner.x * aXValue) + ((1.0 - aCorner.x) * aXPrevValue));
        gl_Position.y += (1.0 - useIntercept) * (1.0 - aCorner.y) * ((aCorner.x * aYValue) + ((1.0 - aCorner.x) * aYPrevValue));
        gl_Position.y += (1.0 - useIntercept) * aCorner.y * ((aCorner.x * aY0Value) + ((1.0 - aCorner.x) * aY0PrevValue));`
    };
    const boxPlot = {
      header: `attribute float aXValue;
        attribute float aYValue;
        attribute float aXDirection;
        attribute float aYDirection;
        attribute float aBandwidth;
        uniform vec2 uScreen;
        uniform float uLineWidth;`,
      body: `gl_Position = vec4(aXValue, aYValue, 0, 1);`
    };

    const circle$1 = {
      header: `varying float vSize;`,
      body: `float distance = length(2.0 * gl_PointCoord - 1.0);
    if (distance > 1.0) {
        discard;
        return;
    }`
    };
    const square$1 = {
      header: `varying float vSize;`,
      body: `vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;
        float distance = max(abs(pointCoordTransform.x), abs(pointCoordTransform.y));`
    };
    const triangle$1 = {
      header: `varying float vSize;`,
      body: `vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;
    float topEdgesDistance = abs(pointCoordTransform.x) - ((pointCoordTransform.y - 0.6) / sqrt(3.0));
    float bottomEdgeDistance = pointCoordTransform.y + 0.5;
    float distance = max(topEdgesDistance, bottomEdgeDistance);
    if (distance > 1.0) {
        discard;
    }`
    };
    const cross$1 = {
      header: `varying float vSize;
            varying float vStrokeWidthRatio;`,
      body: `vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;
    float innerCornerDistance = min(abs(pointCoordTransform.x), abs(pointCoordTransform.y)) + 0.66 - vStrokeWidthRatio;
    float outerEdgeDistance = max(abs(pointCoordTransform.x), abs(pointCoordTransform.y));
    float distance = max(innerCornerDistance, outerEdgeDistance);
    if (distance > 1.0) {
        discard;
    }`
    };
    const rect$1 = {
      header: `varying float vColorIndicator;`,
      body: `gl_FragColor = vec4(0.4, 0.8, 0, 1);
    if (vColorIndicator < 0.0) {
        gl_FragColor = vec4(0.8, 0.4, 0, 1);
    }`
    };
    const area$1 = {
      header: `varying float vDefined;`,
      body: `if (vDefined < 0.5) {
            discard;
        }
        gl_FragColor = vec4(0.86, 0.86, 0.86, 1);`
    };
    const line$2 = {
      header: `varying float vDefined;`,
      body: `if (vDefined < 0.5) {
        discard;
    }`
    };

    var circlePointShader = (() => {
      const vertexShader = shaderBuilder(vertexShaderBase);
      const fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(circle.header).appendBody(circle.body);
      fragmentShader.appendHeader(circle$1.header).appendBody(circle$1.body);
      return {
        vertex: () => vertexShader,
        fragment: () => fragmentShader
      };
    });

    var squarePointShader = (() => {
      const vertexShader = shaderBuilder(vertexShaderBase);
      const fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(square.header).appendBody(square.body);
      fragmentShader.appendHeader(square$1.header).appendBody(square$1.body);
      return {
        vertex: () => vertexShader,
        fragment: () => fragmentShader
      };
    });

    var trianglePointShader = (() => {
      const vertexShader = shaderBuilder(vertexShaderBase);
      const fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(triangle.header).appendBody(triangle.body);
      fragmentShader.appendHeader(triangle$1.header).appendBody(triangle$1.body);
      return {
        vertex: () => vertexShader,
        fragment: () => fragmentShader
      };
    });

    var crossPointShader = (() => {
      const vertexShader = shaderBuilder(vertexShaderBase);
      const fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(cross.header).appendBody(cross.body);
      fragmentShader.appendHeader(cross$1.header).appendBody(cross$1.body);
      return {
        vertex: () => vertexShader,
        fragment: () => fragmentShader
      };
    });

    var symbolMapper = (symbol => {
      switch (symbol) {
        case d3Shape__default.symbolCircle:
          return circlePointShader();

        case d3Shape__default.symbolSquare:
          return squarePointShader();

        case d3Shape__default.symbolTriangle:
          return trianglePointShader();

        case d3Shape__default.symbolCross:
          return crossPointShader();

        default:
          throw new Error(`Unrecognised symbol: ${symbol}`);
      }
    });

    var lineWidthShader = (() => {
      let width = 1;

      const lineWidth = program => {
        program.buffers().uniform('uLineWidth', uniformBuilder(width));
      };

      lineWidth.lineWidth = (...args) => {
        if (!args.length) {
          return width;
        }

        width = args[0];
        return lineWidth;
      };

      return lineWidth;
    });

    var glPoint = (() => {
      let xScale = glScaleBase();
      let yScale = glScaleBase();
      let type = circlePointShader();

      let decorate = () => {};

      const xValueAttribute = projectedAttributeBuilder().value((data, element) => data[element]);
      const yValueAttribute = projectedAttributeBuilder().value((data, element) => data[element]);
      const sizeAttribute = projectedAttributeBuilder().value((data, element) => data[element]);
      const program = programBuilder().mode(drawModes.POINTS);
      program.buffers().attribute('aXValue', xValueAttribute).attribute('aYValue', yValueAttribute).attribute('aSize', sizeAttribute);

      const draw = numElements => {
        program.vertexShader(type.vertex()).fragmentShader(type.fragment());
        xScale.coordinate(0);
        xScale(program);
        yScale.coordinate(1);
        yScale(program);
        decorate(program);
        program(numElements);
      };

      draw.xValues = data => {
        xValueAttribute.data(data);
        return draw;
      };

      draw.yValues = data => {
        yValueAttribute.data(data);
        return draw;
      };

      draw.sizes = data => {
        sizeAttribute.data(data);
        return draw;
      };

      draw.decorate = (...args) => {
        if (!args.length) {
          return decorate;
        }

        decorate = args[0];
        return draw;
      };

      draw.xScale = (...args) => {
        if (!args.length) {
          return xScale;
        }

        xScale = args[0];
        return draw;
      };

      draw.yScale = (...args) => {
        if (!args.length) {
          return yScale;
        }

        yScale = args[0];
        return draw;
      };

      draw.type = (...args) => {
        if (!args.length) {
          return type;
        }

        type = args[0];
        return draw;
      };

      rebind(draw, program, 'context');
      return draw;
    });

    var lineShader = (() => {
      const vertexShader = shaderBuilder(vertexShaderBase);
      const fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(preScaleLine.header).appendBody(preScaleLine.body);
      fragmentShader.appendHeader(line$2.header).appendBody(line$2.body);
      return {
        vertex: () => vertexShader,
        fragment: () => fragmentShader
      };
    });

    var glLine = (() => {
      let xScale = glScaleBase();
      let yScale = glScaleBase();

      let decorate = () => {};

      const lineWidth = lineWidthShader();
      const xValueAttribute = projectedAttributeBuilder().value((data, element) => data[element]);
      const xNextValueAttribute = projectedAttributeBuilder().value((data, element) => data[Math.min(element + 1, data.length - 1)]);
      const xPreviousValueAttribute = projectedAttributeBuilder().value((data, element) => data[Math.max(element - 1, 0)]);
      const yValueAttribute = projectedAttributeBuilder().value((data, element) => data[element]);
      const yNextValueAttribute = projectedAttributeBuilder().value((data, element) => data[Math.min(element + 1, data.length - 1)]);
      const yPreviousValueAttribute = projectedAttributeBuilder().value((data, element) => data[Math.max(element - 1, 0)]);
      const cornerAttribute = projectedAttributeBuilder().size(2).data([[-1, -1], [1, -1], [-1, 1], [1, 1]]).value((data, element, vertex, component) => data[vertex][component]);
      const definedAttribute = projectedAttributeBuilder().value((data, element, vertex, component) => {
        const value = data[element];

        if (vertex <= 1) {
          const previousValue = element === 0 ? value : data[element - 1];
          return value ? previousValue : value;
        } else {
          const nextValue = element === data.length - 1 ? value : data[element + 1];
          return value ? nextValue : value;
        }
      });
      const program = programBuilder().mode(drawModes.TRIANGLE_STRIP).verticesPerElement(4);
      program.buffers().attribute('aXValue', xValueAttribute).attribute('aNextXValue', xNextValueAttribute).attribute('aPrevXValue', xPreviousValueAttribute).attribute('aYValue', yValueAttribute).attribute('aNextYValue', yNextValueAttribute).attribute('aPrevYValue', yPreviousValueAttribute).attribute('aCorner', cornerAttribute).attribute('aDefined', definedAttribute);

      const draw = numElements => {
        const shaderBuilder = lineShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale.coordinate(0);
        xScale(program);
        yScale.coordinate(1);
        yScale(program);
        xScale.scaleComponent(program, 'next');
        yScale.scaleComponent(program, 'next');
        xScale.scaleComponent(program, 'prev');
        yScale.scaleComponent(program, 'prev');
        program.vertexShader().appendBody(postScaleLine.body);
        lineWidth(program);
        decorate(program);
        program(numElements);
      };

      draw.xValues = data => {
        xValueAttribute.data(data);
        xNextValueAttribute.data(data);
        xPreviousValueAttribute.data(data);
        return draw;
      };

      draw.yValues = data => {
        yValueAttribute.data(data);
        yNextValueAttribute.data(data);
        yPreviousValueAttribute.data(data);
        return draw;
      };

      draw.defined = data => {
        definedAttribute.data(data);
        return draw;
      };

      draw.decorate = (...args) => {
        if (!args.length) {
          return decorate;
        }

        decorate = args[0];
        return draw;
      };

      draw.xScale = (...args) => {
        if (!args.length) {
          return xScale;
        }

        xScale = args[0];
        return draw;
      };

      draw.yScale = (...args) => {
        if (!args.length) {
          return yScale;
        }

        yScale = args[0];
        return draw;
      };

      rebind(draw, program, 'context');
      rebind(draw, lineWidth, 'lineWidth');
      return draw;
    });

    var rectShader = (() => {
      const vertexShader = shaderBuilder(vertexShaderBase);
      const fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(rect.header).appendBody(rect.body);
      fragmentShader.appendHeader(rect$1.header).appendBody(rect$1.body);
      return {
        vertex: () => vertexShader,
        fragment: () => fragmentShader
      };
    });

    var glOhlc = (() => {
      const program = programBuilder().verticesPerElement(18);
      let xScale = glScaleBase();
      let yScale = glScaleBase();
      const lineWidth = lineWidthShader();

      let decorate = () => {};

      const xValueAttribute = projectedAttributeBuilder().value((data, element) => data[element]);
      const yValueAttribute = projectedAttributeBuilder().data({
        open: null,
        high: null,
        low: null,
        close: null
      }).value((data, element, vertex) => {
        if ([6, 7, 8, 9, 10, 11].includes(vertex)) {
          return data.open[element];
        }

        if ([2, 4, 5].includes(vertex)) {
          return data.high[element];
        }

        if ([0, 1, 3].includes(vertex)) {
          return data.low[element];
        }

        if ([12, 13, 14, 15, 16, 17].includes(vertex)) {
          return data.close[element];
        }

        throw new Error(`Invalid vertex ${vertex}`);
      });
      const xDirectionAttribute = projectedAttributeBuilder().data([1, -1, -1, 1, 1, -1, 0, 0, -1, 0, -1, -1, 0, 0, 1, 0, 1, 1]).value((data, element, vertex) => data[vertex]);
      const yDirectionAttribute = projectedAttributeBuilder().data([0, 0, 0, 0, 0, 0, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 1]).value((data, element, vertex) => data[vertex]);
      const bandwidthAttribute = projectedAttributeBuilder().value((data, element, vertex) => {
        if ([8, 10, 11, 14, 16, 17].includes(vertex)) {
          const value = data[element];
          return [8, 10, 11].includes(vertex) ? -value : value;
        }

        return 0;
      });
      const colorIndicatorAttribute = projectedAttributeBuilder().value((data, element, vertex) => {
        const openVal = data.open[element];
        const closeVal = data.close[element];
        return openVal < closeVal ? 1 : -1;
      });

      const draw = numElements => {
        const shaderBuilder = rectShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment()).mode(drawModes.TRIANGLES);
        program.buffers().attribute('aXValue', xValueAttribute).attribute('aYValue', yValueAttribute).attribute('aXDirection', xDirectionAttribute).attribute('aYDirection', yDirectionAttribute).attribute('aBandwidth', bandwidthAttribute).attribute('aColorIndicator', colorIndicatorAttribute);
        xScale.coordinate(0);
        xScale(program);
        yScale.coordinate(1);
        yScale(program);
        lineWidth(program);
        program.vertexShader().appendBody(`
        gl_Position.x += ((uLineWidth * aXDirection / 2.0) + (aBandwidth / 2.0)) / uScreen.x;
        gl_Position.y += (uLineWidth * aYDirection / 2.0) / uScreen.y;
      `);
        decorate(program);
        program(numElements);
      };

      draw.xValues = data => {
        xValueAttribute.data(data);
        return draw;
      };

      draw.openValues = data => {
        const existing = yValueAttribute.data();
        const updated = { ...existing,
          open: data
        };
        yValueAttribute.data(updated);
        colorIndicatorAttribute.data(updated);
        return draw;
      };

      draw.highValues = data => {
        const existing = yValueAttribute.data();
        const updated = { ...existing,
          high: data
        };
        yValueAttribute.data(updated);
        colorIndicatorAttribute.data(updated);
        return draw;
      };

      draw.lowValues = data => {
        const existing = yValueAttribute.data();
        const updated = { ...existing,
          low: data
        };
        yValueAttribute.data(updated);
        colorIndicatorAttribute.data(updated);
        return draw;
      };

      draw.closeValues = data => {
        const existing = yValueAttribute.data();
        const updated = { ...existing,
          close: data
        };
        yValueAttribute.data(updated);
        colorIndicatorAttribute.data(updated);
        return draw;
      };

      draw.bandwidth = data => {
        bandwidthAttribute.data(data);
        return draw;
      };

      draw.decorate = (...args) => {
        if (!args.length) {
          return decorate;
        }

        decorate = args[0];
        return draw;
      };

      draw.xScale = (...args) => {
        if (!args.length) {
          return xScale;
        }

        xScale = args[0];
        return draw;
      };

      draw.yScale = (...args) => {
        if (!args.length) {
          return yScale;
        }

        yScale = args[0];
        return draw;
      };

      rebind(draw, program, 'context');
      rebind(draw, lineWidth, 'lineWidth');
      return draw;
    });

    var barShader = (() => {
      const vertexShader = shaderBuilder(vertexShaderBase);
      const fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(bar.header).appendBody(bar.body);
      return {
        vertex: () => vertexShader,
        fragment: () => fragmentShader
      };
    });

    //     .-------------.------------.
    // (x-w/2, y1)    (x, y1)   (x+w/2, y1)
    //     |     \                    |
    //     |        \                 |
    //     |           \              |
    //     |              \           |
    //     |                 \        |
    //     |                    \     |
    //     |                       \  |
    //     L                        R
    //     .-------------.------------.
    // (x-w/2, y0)     (x, y0)   (x+w/2, y0)
    // Drawing order
    // Triangle L, L, R. (bottom)
    //  -> L.
    //  -> L.
    //  -> R.
    // Triangle L, R, R. (top)
    //  -> L.
    //  -> R.
    //  -> R.

    var glBar = (() => {
      const program = programBuilder().verticesPerElement(6);
      let xScale = null;
      let yScale = null;

      let decorate = () => {};

      const xValueAttribute = projectedAttributeBuilder().value((data, element) => data[element]);
      const yValueAttribute = projectedAttributeBuilder().data([null, null]).value((data, element, vertex) => {
        const array = [1, 2, 4].includes(vertex) ? 0 : 1;
        return data[array][element];
      });
      const widthValueAttribute = projectedAttributeBuilder().value((data, element) => data[element]);
      const directionAttribute = projectedAttributeBuilder().size(2).data([-1, -1, 1, -1, 1, 1]).value((data, element, vertex) => data[vertex]);

      const draw = numElements => {
        const shader = barShader();
        program.vertexShader(shader.vertex()).fragmentShader(shader.fragment()).mode(drawModes.TRIANGLES);
        program.buffers().attribute('aXValue', xValueAttribute).attribute('aYValue', yValueAttribute).attribute('aWidthValue', widthValueAttribute).attribute('aDirection', directionAttribute);
        xScale.coordinate(0);
        xScale(program);
        yScale.coordinate(1);
        yScale(program);
        xScale.scaleComponent(program, 'origin');
        xScale.scaleComponent(program, 'width');
        decorate(program);
        program(numElements);
      };

      draw.xScale = (...args) => {
        if (!args.length) {
          return xScale;
        }

        xScale = args[0];
        return draw;
      };

      draw.yScale = (...args) => {
        if (!args.length) {
          return yScale;
        }

        yScale = args[0];
        return draw;
      };

      draw.decorate = (...args) => {
        if (!args.length) {
          return decorate;
        }

        decorate = args[0];
        return draw;
      };

      draw.xValues = data => {
        xValueAttribute.data(data);
        return draw;
      };

      draw.y0Values = data => {
        yValueAttribute.data([data, yValueAttribute.data()[1]]);
        return draw;
      };

      draw.yValues = data => {
        yValueAttribute.data([yValueAttribute.data()[0], data]);
        return draw;
      };

      draw.widths = data => {
        widthValueAttribute.data(data);
        return draw;
      };

      rebind(draw, program, 'context');
      return draw;
    });

    var errorBarShader = (() => {
      const vertexShader = shaderBuilder(vertexShaderBase);
      const fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(errorBar.header).appendBody(errorBar.body);
      return {
        vertex: () => vertexShader,
        fragment: () => fragmentShader
      };
    });

    var glErrorBar = (() => {
      const program = programBuilder().verticesPerElement(18);
      let xScale = glScaleBase();
      let yScale = glScaleBase();

      const lineWidth = lineWidthShader();
      const xValueAttribute = projectedAttributeBuilder().value((data, element) => data[element]);
      const highValueAttribute = projectedAttributeBuilder().value((data, element) => data[element]);
      const lowValueAttribute = projectedAttributeBuilder().value((data, element) => data[element]);
      const bandwidthAttribute = projectedAttributeBuilder().value((data, element) => data[element]);
      /*
       * x-y coordinate to locate the "corners" of the element (ie errorbar). The `z` coordinate locates the corner relative to the line (this takes line width into account).
       * X: -1: LEFT, 0: MIDDLE, 1: RIGHT
       * Y: -1: HIGH, 1: LOW
       * Z: Follows X or Y convention, depending on the orientation of the line that the vertex is part of.
       */

      const cornerAttribute = projectedAttributeBuilder().size(3).data([[0, 1, 1], [0, 1, -1], [0, -1, -1], [0, 1, 1], [0, -1, 1], [0, -1, -1], [1, -1, 1], [1, -1, -1], [-1, -1, -1], [1, -1, 1], [-1, -1, 1], [-1, -1, -1], [-1, 1, -1], [-1, 1, 1], [1, 1, 1], [-1, 1, -1], [1, 1, -1], [1, 1, 1]]).value((data, element, vertex, component) => data[vertex][component]);

      const draw = numElements => {
        const shader = errorBarShader();
        program.vertexShader(shader.vertex()).fragmentShader(shader.fragment()).mode(drawModes.TRIANGLES);
        program.buffers().attribute('aXValue', xValueAttribute).attribute('aHighValue', highValueAttribute).attribute('aLowValue', lowValueAttribute).attribute('aBandwidth', bandwidthAttribute).attribute('aCorner', cornerAttribute);
        xScale.coordinate(0);
        xScale(program);
        yScale.coordinate(1);
        yScale(program);
        lineWidth(program);
        program.vertexShader().appendBody(`
                gl_Position.x += xModifier / uScreen.x;
                gl_Position.y += yModifier / uScreen.y;
            `);
        program(numElements);
      };

      draw.xValues = data => {
        xValueAttribute.data(data);
        return draw;
      };

      draw.highValues = data => {
        highValueAttribute.data(data);
        return draw;
      };

      draw.lowValues = data => {
        lowValueAttribute.data(data);
        return draw;
      };

      draw.bandwidth = data => {
        bandwidthAttribute.data(data);
        return draw;
      };

      draw.xScale = (...args) => {
        if (!args.length) {
          return xScale;
        }

        xScale = args[0];
        return draw;
      };

      draw.yScale = (...args) => {
        if (!args.length) {
          return yScale;
        }

        yScale = args[0];
        return draw;
      };

      rebind(draw, program, 'context');
      rebind(draw, lineWidth, 'lineWidth');
      return draw;
    });

    var areaShader = (() => {
      const vertexShader = shaderBuilder(vertexShaderBase);
      const fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(area.header).appendBody(area.body);
      fragmentShader.appendHeader(area$1.header).appendBody(area$1.body);
      return {
        vertex: () => vertexShader,
        fragment: () => fragmentShader
      };
    });

    var glArea = (() => {
      let xScale = glScaleBase();
      let yScale = glScaleBase();

      let decorate = () => {};

      const xValueAttribute = projectedAttributeBuilder().value((data, element) => data[Math.min(element + 1, data.length - 1)]);
      const xPreviousValueAttribute = projectedAttributeBuilder().value((data, element) => data[element]);
      const yValueAttribute = projectedAttributeBuilder().value((data, element) => data[Math.min(element + 1, data.length - 1)]);
      const yPreviousValueAttribute = projectedAttributeBuilder().value((data, element) => data[element]);
      const y0ValueAttribute = projectedAttributeBuilder().value((data, element) => data[Math.min(element + 1, data.length - 1)]);
      const y0PreviousValueAttribute = projectedAttributeBuilder().value((data, element) => data[element]);
      const cornerAttribute = projectedAttributeBuilder().size(3).data([[0, 0, 0], [0, 1, 0], [1, 1, 1], [0, 0, 1], [1, 0, 0], [1, 1, 0]]).value((data, element, vertex, component) => data[vertex][component]);
      const definedAttribute = projectedAttributeBuilder().value((data, element, vertex, component) => {
        const value = data[element];
        const nextValue = element === data.length - 1 ? 0 : data[element + 1];
        return value ? nextValue : value;
      });
      const program = programBuilder().mode(drawModes.TRIANGLES).verticesPerElement(6);
      program.buffers().attribute('aXValue', xValueAttribute).attribute('aXPrevValue', xPreviousValueAttribute).attribute('aYValue', yValueAttribute).attribute('aYPrevValue', yPreviousValueAttribute).attribute('aY0Value', y0ValueAttribute).attribute('aY0PrevValue', y0PreviousValueAttribute).attribute('aCorner', cornerAttribute).attribute('aDefined', definedAttribute);

      const draw = numElements => {
        const shaderBuilder = areaShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale.coordinate(0);
        xScale(program);
        yScale.coordinate(1);
        yScale(program);
        decorate(program);
        program(numElements - 1);
      };

      draw.xValues = data => {
        xValueAttribute.data(data);
        xPreviousValueAttribute.data(data);
        return draw;
      };

      draw.yValues = data => {
        yValueAttribute.data(data);
        yPreviousValueAttribute.data(data);
        return draw;
      };

      draw.y0Values = data => {
        y0ValueAttribute.data(data);
        y0PreviousValueAttribute.data(data);
        return draw;
      };

      draw.defined = data => {
        definedAttribute.data(data);
        return draw;
      };

      draw.decorate = (...args) => {
        if (!args.length) {
          return decorate;
        }

        decorate = args[0];
        return draw;
      };

      draw.xScale = (...args) => {
        if (!args.length) {
          return xScale;
        }

        xScale = args[0];
        return draw;
      };

      draw.yScale = (...args) => {
        if (!args.length) {
          return yScale;
        }

        yScale = args[0];
        return draw;
      };

      rebind(draw, program, 'context');
      return draw;
    });

    var glCandlestick = (() => {
      const program = programBuilder().verticesPerElement(12);
      let xScale = glScaleBase();
      let yScale = glScaleBase();
      const lineWidth = lineWidthShader();

      let decorate = () => {};

      const xValueAttribute = projectedAttributeBuilder().value((data, element) => data[element]);
      const yValueAttribute = projectedAttributeBuilder().data({
        open: null,
        high: null,
        low: null,
        close: null
      }).value((data, element, vertex) => {
        if ([6, 7, 9].includes(vertex)) {
          return data.open[element];
        }

        if ([2, 4, 5].includes(vertex)) {
          return data.high[element];
        }

        if ([0, 1, 3].includes(vertex)) {
          return data.low[element];
        }

        if ([8, 10, 11].includes(vertex)) {
          return data.close[element];
        }

        return 0;
      });
      const xDirectionAttribute = projectedAttributeBuilder().data([1, -1, -1, 1, 1, -1, 1, -1, -1, 1, 1, -1]).value((data, element, vertex) => data[vertex]);
      const yDirectionAttribute = projectedAttributeBuilder().value((data, element, vertex) => {
        const openVal = data.open[element];
        const closeVal = data.close[element];

        if ([6, 7, 8, 9, 10, 11].includes(vertex)) {
          const openValMin = Math.min(openVal, closeVal) === openVal;

          if ([6, 7, 9].includes(vertex)) {
            return openValMin ? -1 : 1;
          } else {
            return openValMin ? 1 : -1;
          }
        }

        return 0;
      });
      const bandwidthAttribute = projectedAttributeBuilder().value((data, element, vertex) => {
        if (vertex >= 6 && vertex <= 11) {
          const value = data[element];
          return [6, 9, 10].includes(vertex) ? value : -value;
        }

        return 0;
      });
      const colorIndicatorAttribute = projectedAttributeBuilder().value((data, element, vertex) => {
        const openVal = data.open[element];
        const closeVal = data.close[element];
        return openVal < closeVal ? 1 : -1;
      });

      const draw = numElements => {
        const shaderBuilder = rectShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment()).mode(drawModes.TRIANGLES);
        program.buffers().attribute('aXValue', xValueAttribute).attribute('aYValue', yValueAttribute).attribute('aXDirection', xDirectionAttribute).attribute('aYDirection', yDirectionAttribute).attribute('aBandwidth', bandwidthAttribute).attribute('aColorIndicator', colorIndicatorAttribute);
        xScale.coordinate(0);
        xScale(program);
        yScale.coordinate(1);
        yScale(program);
        lineWidth(program);
        program.vertexShader().appendBody(`
        gl_Position.x += ((uLineWidth * aXDirection / 2.0) + (aBandwidth / 2.0)) / uScreen.x;
        gl_Position.y += (uLineWidth * aYDirection / 2.0) / uScreen.y;
      `);
        decorate(program);
        program(numElements);
      };

      draw.xValues = data => {
        xValueAttribute.data(data);
        return draw;
      };

      draw.openValues = data => {
        const existing = yValueAttribute.data();
        const updated = { ...existing,
          open: data
        };
        yValueAttribute.data(updated);
        yDirectionAttribute.data(updated);
        colorIndicatorAttribute.data(updated);
        return draw;
      };

      draw.highValues = data => {
        const existing = yValueAttribute.data();
        const updated = { ...existing,
          high: data
        };
        yValueAttribute.data(updated);
        yDirectionAttribute.data(updated);
        colorIndicatorAttribute.data(updated);
        return draw;
      };

      draw.lowValues = data => {
        const existing = yValueAttribute.data();
        const updated = { ...existing,
          low: data
        };
        yValueAttribute.data(updated);
        yDirectionAttribute.data(updated);
        colorIndicatorAttribute.data(updated);
        return draw;
      };

      draw.closeValues = data => {
        const existing = yValueAttribute.data();
        const updated = { ...existing,
          close: data
        };
        yValueAttribute.data(updated);
        yDirectionAttribute.data(updated);
        colorIndicatorAttribute.data(updated);
        return draw;
      };

      draw.bandwidth = data => {
        bandwidthAttribute.data(data);
        return draw;
      };

      draw.decorate = (...args) => {
        if (!args.length) {
          return decorate;
        }

        decorate = args[0];
        return draw;
      };

      draw.xScale = (...args) => {
        if (!args.length) {
          return xScale;
        }

        xScale = args[0];
        return draw;
      };

      draw.yScale = (...args) => {
        if (!args.length) {
          return yScale;
        }

        yScale = args[0];
        return draw;
      };

      rebind(draw, program, 'context');
      rebind(draw, lineWidth, 'lineWidth');
      return draw;
    });

    var boxPlotShader = (() => {
      const vertexShader = shaderBuilder(vertexShaderBase);
      const fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(boxPlot.header).appendBody(boxPlot.body);
      return {
        vertex: () => vertexShader,
        fragment: () => fragmentShader
      };
    });

    //            .------.------.
    //                   |
    //                   |
    //                   |
    //    L2                       R2
    //     .-------------.------------.
    //     |                          |
    //     |                          |
    //     |                          |
    //     L2                       R2
    //     .-------------.------------.
    //     |                          |
    //     |                          |
    //     |                          |
    //    L2                       R2
    //     .-------------.------------.
    //                   |
    //                   |
    //                   |
    //           L1          R1
    //            .------.------.
    // Line drawing order
    // L1 -> R1
    //  -> 
    // L2 -> R2
    // L2 -> R2
    // L2 -> R2
    // L2 -> L2
    // R2 -> R2
    //  -> 
    // L1 -> R1

    var glBoxPlot = (() => {
      const verticesPerElement = 54;
      const program = programBuilder().verticesPerElement(verticesPerElement);
      let xScale = glScaleBase();
      let yScale = glScaleBase();

      const lineWidth = lineWidthShader();
      const xValueAttribute = projectedAttributeBuilder().value((data, element) => data[element]);
      const yValueAttribute = projectedAttributeBuilder().data({
        median: null,
        upperQuartile: null,
        lowerQuartile: null,
        high: null,
        low: null
      }).value((data, element, vertex) => {
        if ([18, 19, 20, 21, 22, 23].includes(vertex)) {
          return data.median[element];
        }

        if ([8, 10, 11, 12, 13, 14, 15, 16, 17, 30, 31, 33, 36, 37, 39].includes(vertex)) {
          return data.upperQuartile[element];
        }

        if ([24, 25, 26, 27, 28, 29, 32, 34, 35, 38, 40, 41, 42, 43, 45].includes(vertex)) {
          return data.lowerQuartile[element];
        }

        if ([0, 1, 2, 3, 4, 5, 6, 7, 9].includes(vertex)) {
          return data.high[element];
        }

        if ([44, 46, 47, 48, 49, 50, 51, 52, 53].includes(vertex)) {
          return data.low[element];
        }

        return 0;
      });
      const xDirectionAttribute = projectedAttributeBuilder().data([0, 0, 0, 0, 0, 0, -1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 1, -1, 1, 1, -1, -1, 1, -1, 1, 1, -1, -1, 1, 0, 0, 0, 0, 0, 0]).value((data, element, vertex) => data[vertex]);
      const yDirectionAttribute = projectedAttributeBuilder().data([1, 1, -1, 1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1]).value((data, element, vertex) => data[vertex]);
      const bandwidthAttribute = projectedAttributeBuilder().data({
        bandwidth: null,
        capWidth: null
      }).value((data, element, vertex) => {
        if (vertex <= 5 || vertex >= 48) {
          const value = data.capWidth[element];
          return [0, 3, 4, 48, 51, 52].includes(vertex) ? -value : value;
        }

        if (vertex > 11 && vertex < 42) {
          const value = data.bandwidth[element];
          return [12, 15, 16, 18, 21, 22, 24, 27, 28, 30, 31, 32, 33, 34, 35].includes(vertex) ? -value : value;
        }

        return 0;
      });

      const draw = numElements => {
        const shader = boxPlotShader();
        program.vertexShader(shader.vertex()).fragmentShader(shader.fragment()).mode(drawModes.TRIANGLES);
        program.buffers().attribute('aXValue', xValueAttribute).attribute('aYValue', yValueAttribute).attribute('aXDirection', xDirectionAttribute).attribute('aYDirection', yDirectionAttribute).attribute('aBandwidth', bandwidthAttribute);
        xScale.coordinate(0);
        xScale(program);
        yScale.coordinate(1);
        yScale(program);
        lineWidth(program);
        program.vertexShader().appendBody(`
                gl_Position.x += ((uLineWidth * aXDirection) + aBandwidth) / uScreen.x;
                gl_Position.y += (uLineWidth * aYDirection) / uScreen.y;
            `);
        program(numElements);
      };

      draw.xValues = data => {
        xValueAttribute.data(data);
        return draw;
      };

      draw.medianValues = data => {
        const existing = yValueAttribute.data();
        yValueAttribute.data({ ...existing,
          median: data
        });
        return draw;
      };

      draw.upperQuartileValues = data => {
        const existing = yValueAttribute.data();
        yValueAttribute.data({ ...existing,
          upperQuartile: data
        });
        return draw;
      };

      draw.lowerQuartileValues = data => {
        const existing = yValueAttribute.data();
        yValueAttribute.data({ ...existing,
          lowerQuartile: data
        });
        return draw;
      };

      draw.highValues = data => {
        const existing = yValueAttribute.data();
        yValueAttribute.data({ ...existing,
          high: data
        });
        return draw;
      };

      draw.lowValues = data => {
        const existing = yValueAttribute.data();
        yValueAttribute.data({ ...existing,
          low: data
        });
        return draw;
      };

      draw.bandwidth = data => {
        const existing = bandwidthAttribute.data();
        bandwidthAttribute.data({ ...existing,
          bandwidth: data
        });
        return draw;
      };

      draw.capWidth = data => {
        const existing = bandwidthAttribute.data();
        bandwidthAttribute.data({ ...existing,
          capWidth: data
        });
        return draw;
      };

      draw.xScale = (...args) => {
        if (!args.length) {
          return xScale;
        }

        xScale = args[0];
        return draw;
      };

      draw.yScale = (...args) => {
        if (!args.length) {
          return yScale;
        }

        yScale = args[0];
        return draw;
      };

      rebind(draw, program, 'context');
      rebind(draw, lineWidth, 'lineWidth');
      return draw;
    });

    var line$3 = (function () {
      var base = xyBase();
      var draw = glLine();

      var line = function line(data) {
        var xScale = scaleMapper(base.xScale());
        var yScale = scaleMapper(base.yScale());
        var accessor = getAccessors();
        var x = new Float32Array(data.length);
        var y = new Float32Array(data.length);
        var defined = new Float32Array(data.length);
        data.forEach(function (d, i) {
          x[i] = xScale.scale(accessor.x(d, i));
          y[i] = yScale.scale(accessor.y(d, i));
          defined[i] = accessor.defined(d, i);
        });
        draw.xValues(x).yValues(y).defined(defined).xScale(xScale.glScale).yScale(yScale.glScale).decorate(function (program) {
          base.decorate()(program, data, 0);
        });
        draw(data.length);
      };

      function getAccessors() {
        if (base.orient() === 'vertical') {
          return {
            x: base.crossValue(),
            y: base.mainValue(),
            defined: base.defined()
          };
        } else {
          return {
            x: base.mainValue(),
            y: base.crossValue(),
            defined: base.defined()
          };
        }
      }

      rebindAll(line, base, exclude('baseValue', 'bandwidth', 'align'));
      rebind(line, draw, 'context', 'lineWidth');
      return line;
    });

    var point = (function () {
      var symbol = d3Shape.symbol();
      var base = xyBase();
      var join = dataJoin('g', 'point');

      var containerTransform = function containerTransform(origin) {
        return 'translate(' + origin[0] + ', ' + origin[1] + ')';
      };

      var point = function point(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        selection.each(function (data, index, group) {
          var filteredData = data.filter(base.defined());
          var g = join(d3Selection.select(group[index]), filteredData);
          g.enter().attr('transform', function (d, i) {
            return containerTransform(base.values(d, i).origin);
          }).attr('fill', colors.gray).attr('stroke', colors.black).append('path');
          g.attr('transform', function (d, i) {
            return containerTransform(base.values(d, i).origin);
          }).select('path').attr('d', symbol);
          base.decorate()(g, data, index);
        });
      };

      rebindAll(point, base, exclude('baseValue', 'bandwidth', 'align'));
      rebind(point, join, 'key');
      rebind(point, symbol, 'type', 'size');
      return point;
    });

    var point$1 = (function () {
      var symbol = d3Shape.symbol();
      var base = xyBase();

      var point = function point(data) {
        var filteredData = data.filter(base.defined());
        var context = symbol.context();
        filteredData.forEach(function (d, i) {
          context.save();
          var values = base.values(d, i);
          context.translate(values.origin[0], values.origin[1]);
          context.beginPath();
          symbol(d, i);
          context.strokeStyle = colors.black;
          context.fillStyle = colors.gray;
          base.decorate()(context, d, i);
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      rebindAll(point, base, exclude('baseValue', 'bandwidth', 'align'));
      rebind(point, symbol, 'size', 'type', 'context');
      return point;
    });

    var point$2 = (function () {
      var base = xyBase();
      var size = 64;
      var type = d3Shape__default.symbolCircle;
      var draw = glPoint();

      var point = function point(data) {
        var filteredData = data.filter(base.defined());
        var xScale = scaleMapper(base.xScale());
        var yScale = scaleMapper(base.yScale());
        var symbolType = symbolMapper(type);
        var accessor = getAccessors();
        var xValues = new Float32Array(filteredData.length);
        var yValues = new Float32Array(filteredData.length);
        var sizes = new Float32Array(filteredData.length);
        filteredData.forEach(function (d, i) {
          var sizeFn = typeof size === 'function' ? size : function () {
            return size;
          };
          xValues[i] = xScale.scale(accessor.x(d, i));
          yValues[i] = yScale.scale(accessor.y(d, i));
          sizes[i] = sizeFn(d);
        });
        draw.xValues(xValues).yValues(yValues).sizes(sizes).xScale(xScale.glScale).yScale(yScale.glScale).type(symbolType).decorate(function (program) {
          return base.decorate()(program, filteredData, 0);
        });
        draw(filteredData.length);
      };

      function getAccessors() {
        if (base.orient() === 'vertical') {
          return {
            x: base.crossValue(),
            y: base.mainValue()
          };
        } else {
          return {
            x: base.mainValue(),
            y: base.crossValue()
          };
        }
      }

      point.size = function () {
        if (!arguments.length) {
          return size;
        }

        size = arguments.length <= 0 ? undefined : arguments[0];
        return point;
      };

      point.type = function () {
        if (!arguments.length) {
          return type;
        }

        type = arguments.length <= 0 ? undefined : arguments[0];
        return point;
      };

      rebindAll(point, base, exclude('baseValue', 'bandwidth', 'align'));
      rebind(point, draw, 'context');
      return point;
    });

    var functor$1 = (v => typeof v === 'function' ? v : () => v);

    // OHLC has a fixed width, whilst the x, open, high, low and close positions are
    // obtained from each point via the supplied accessor functions.

    var shapeOhlc = (() => {
      let context = null;

      let x = d => d.date;

      let open = d => d.open;

      let high = d => d.high;

      let low = d => d.low;

      let close = d => d.close;

      let orient = 'vertical';
      let width = functor$1(3);

      const ohlc = function (data) {
        const drawingContext = context || d3Path.path();
        data.forEach(function (d, i) {
          const xValue = x(d, i);
          const yOpen = open(d, i);
          const yHigh = high(d, i);
          const yLow = low(d, i);
          const yClose = close(d, i);
          const halfWidth = width(d, i) / 2;

          if (orient === 'vertical') {
            drawingContext.moveTo(xValue, yLow);
            drawingContext.lineTo(xValue, yHigh);
            drawingContext.moveTo(xValue, yOpen);
            drawingContext.lineTo(xValue - halfWidth, yOpen);
            drawingContext.moveTo(xValue, yClose);
            drawingContext.lineTo(xValue + halfWidth, yClose);
          } else {
            drawingContext.moveTo(yLow, xValue);
            drawingContext.lineTo(yHigh, xValue);
            drawingContext.moveTo(yOpen, xValue);
            drawingContext.lineTo(yOpen, xValue + halfWidth);
            drawingContext.moveTo(yClose, xValue);
            drawingContext.lineTo(yClose, xValue - halfWidth);
          }
        });
        return context ? null : drawingContext.toString();
      };

      ohlc.context = (...args) => {
        if (!args.length) {
          return context;
        }

        context = args[0];
        return ohlc;
      };

      ohlc.x = (...args) => {
        if (!args.length) {
          return x;
        }

        x = functor$1(args[0]);
        return ohlc;
      };

      ohlc.open = (...args) => {
        if (!args.length) {
          return open;
        }

        open = functor$1(args[0]);
        return ohlc;
      };

      ohlc.high = (...args) => {
        if (!args.length) {
          return high;
        }

        high = functor$1(args[0]);
        return ohlc;
      };

      ohlc.low = (...args) => {
        if (!args.length) {
          return low;
        }

        low = functor$1(args[0]);
        return ohlc;
      };

      ohlc.close = (...args) => {
        if (!args.length) {
          return close;
        }

        close = functor$1(args[0]);
        return ohlc;
      };

      ohlc.width = (...args) => {
        if (!args.length) {
          return width;
        }

        width = functor$1(args[0]);
        return ohlc;
      };

      ohlc.orient = (...args) => {
        if (!args.length) {
          return orient;
        }

        orient = args[0];
        return ohlc;
      };

      return ohlc;
    });

    // bar has a fixed width, whilst the x, y and height are obtained from each data
    // point via the supplied accessor functions.

    var shapeBar = (() => {
      let context = null;

      let x = d => d.x;

      let y = d => d.y;

      let horizontalAlign = 'center';
      let verticalAlign = 'center';

      let height = d => d.height;

      let width = functor$1(3);

      const bar = function (data, index) {
        const drawingContext = context || d3Path.path();
        data.forEach(function (d, i) {
          const xValue = x.call(this, d, index || i);
          const yValue = y.call(this, d, index || i);
          const barHeight = height.call(this, d, index || i);
          const barWidth = width.call(this, d, index || i);
          let horizontalOffset;

          switch (horizontalAlign) {
            case 'left':
              horizontalOffset = barWidth;
              break;

            case 'right':
              horizontalOffset = 0;
              break;

            case 'center':
              horizontalOffset = barWidth / 2;
              break;

            default:
              throw new Error('Invalid horizontal alignment ' + horizontalAlign);
          }

          let verticalOffset;

          switch (verticalAlign) {
            case 'bottom':
              verticalOffset = -barHeight;
              break;

            case 'top':
              verticalOffset = 0;
              break;

            case 'center':
              verticalOffset = barHeight / 2;
              break;

            default:
              throw new Error('Invalid vertical alignment ' + verticalAlign);
          }

          drawingContext.rect(xValue - horizontalOffset, yValue - verticalOffset, barWidth, barHeight);
        }, this);
        return context ? null : drawingContext.toString();
      };

      bar.context = (...args) => {
        if (!args.length) {
          return context;
        }

        context = args[0];
        return bar;
      };

      bar.x = (...args) => {
        if (!args.length) {
          return x;
        }

        x = functor$1(args[0]);
        return bar;
      };

      bar.y = (...args) => {
        if (!args.length) {
          return y;
        }

        y = functor$1(args[0]);
        return bar;
      };

      bar.width = (...args) => {
        if (!args.length) {
          return width;
        }

        width = functor$1(args[0]);
        return bar;
      };

      bar.horizontalAlign = (...args) => {
        if (!args.length) {
          return horizontalAlign;
        }

        horizontalAlign = args[0];
        return bar;
      };

      bar.height = (...args) => {
        if (!args.length) {
          return height;
        }

        height = functor$1(args[0]);
        return bar;
      };

      bar.verticalAlign = (...args) => {
        if (!args.length) {
          return verticalAlign;
        }

        verticalAlign = args[0];
        return bar;
      };

      return bar;
    });

    // candlestick has a fixed width, whilst the x, open, high, low and close positions are
    // obtained from each point via the supplied accessor functions.

    var shapeCandlestick = (() => {
      let context = null;

      let x = d => d.date;

      let open = d => d.open;

      let high = d => d.high;

      let low = d => d.low;

      let close = d => d.close;

      let width = functor$1(3);

      const candlestick = function (data) {
        const drawingContext = context || d3Path.path();
        data.forEach(function (d, i) {
          const xValue = x(d, i);
          const yOpen = open(d, i);
          const yHigh = high(d, i);
          const yLow = low(d, i);
          const yClose = close(d, i);
          const barWidth = width(d, i);
          const halfBarWidth = barWidth / 2; // Body

          drawingContext.rect(xValue - halfBarWidth, yOpen, barWidth, yClose - yOpen); // High wick
          // // Move to the max price of close or open; draw the high wick
          // N.B. Math.min() is used as we're dealing with pixel values,
          // the lower the pixel value, the higher the price!

          drawingContext.moveTo(xValue, Math.min(yClose, yOpen));
          drawingContext.lineTo(xValue, yHigh); // Low wick
          // // Move to the min price of close or open; draw the low wick
          // N.B. Math.max() is used as we're dealing with pixel values,
          // the higher the pixel value, the lower the price!

          drawingContext.moveTo(xValue, Math.max(yClose, yOpen));
          drawingContext.lineTo(xValue, yLow);
        });
        return context ? null : drawingContext.toString();
      };

      candlestick.context = (...args) => {
        if (!args.length) {
          return context;
        }

        context = args[0];
        return candlestick;
      };

      candlestick.x = (...args) => {
        if (!args.length) {
          return x;
        }

        x = functor$1(args[0]);
        return candlestick;
      };

      candlestick.open = (...args) => {
        if (!args.length) {
          return open;
        }

        open = functor$1(args[0]);
        return candlestick;
      };

      candlestick.high = (...args) => {
        if (!args.length) {
          return high;
        }

        high = functor$1(args[0]);
        return candlestick;
      };

      candlestick.low = (...args) => {
        if (!args.length) {
          return low;
        }

        low = functor$1(args[0]);
        return candlestick;
      };

      candlestick.close = (...args) => {
        if (!args.length) {
          return close;
        }

        close = functor$1(args[0]);
        return candlestick;
      };

      candlestick.width = (...args) => {
        if (!args.length) {
          return width;
        }

        width = functor$1(args[0]);
        return candlestick;
      };

      return candlestick;
    });

    var shapeBoxPlot = (() => {
      let context = null;

      let value = d => d.value;

      let median = d => d.median;

      let upperQuartile = d => d.upperQuartile;

      let lowerQuartile = d => d.lowerQuartile;

      let high = d => d.high;

      let low = d => d.low;

      let orient = 'vertical';
      let width = functor$1(5);
      let cap = functor$1(0.5);

      const boxPlot = function (data) {
        const drawingContext = context || d3Path.path();
        data.forEach(function (d, i) {
          // naming convention is for vertical orientation
          const _value = value(d, i);

          const _width = width(d, i);

          const halfWidth = _width / 2;

          const capWidth = _width * cap(d, i);

          const halfCapWidth = capWidth / 2;

          const _high = high(d, i);

          const _upperQuartile = upperQuartile(d, i);

          const _median = median(d, i);

          const _lowerQuartile = lowerQuartile(d, i);

          const _low = low(d, i);

          const upperQuartileToLowerQuartile = _lowerQuartile - _upperQuartile;

          if (orient === 'vertical') {
            // Upper whisker
            drawingContext.moveTo(_value - halfCapWidth, _high);
            drawingContext.lineTo(_value + halfCapWidth, _high);
            drawingContext.moveTo(_value, _high);
            drawingContext.lineTo(_value, _upperQuartile); // Box

            drawingContext.rect(_value - halfWidth, _upperQuartile, _width, upperQuartileToLowerQuartile);
            drawingContext.moveTo(_value - halfWidth, _median); // Median line

            drawingContext.lineTo(_value + halfWidth, _median); // Lower whisker

            drawingContext.moveTo(_value, _lowerQuartile);
            drawingContext.lineTo(_value, _low);
            drawingContext.moveTo(_value - halfCapWidth, _low);
            drawingContext.lineTo(_value + halfCapWidth, _low);
          } else {
            // Lower whisker
            drawingContext.moveTo(_low, _value - halfCapWidth);
            drawingContext.lineTo(_low, _value + halfCapWidth);
            drawingContext.moveTo(_low, _value);
            drawingContext.lineTo(_lowerQuartile, _value); // Box

            drawingContext.rect(_lowerQuartile, _value - halfWidth, -upperQuartileToLowerQuartile, _width);
            drawingContext.moveTo(_median, _value - halfWidth);
            drawingContext.lineTo(_median, _value + halfWidth); // Upper whisker

            drawingContext.moveTo(_upperQuartile, _value);
            drawingContext.lineTo(_high, _value);
            drawingContext.moveTo(_high, _value - halfCapWidth);
            drawingContext.lineTo(_high, _value + halfCapWidth);
          }
        });
        return context ? null : drawingContext.toString();
      };

      boxPlot.context = (...args) => {
        if (!args.length) {
          return context;
        }

        context = args[0];
        return boxPlot;
      };

      boxPlot.value = (...args) => {
        if (!args.length) {
          return value;
        }

        value = functor$1(args[0]);
        return boxPlot;
      };

      boxPlot.median = (...args) => {
        if (!args.length) {
          return median;
        }

        median = functor$1(args[0]);
        return boxPlot;
      };

      boxPlot.upperQuartile = (...args) => {
        if (!args.length) {
          return upperQuartile;
        }

        upperQuartile = functor$1(args[0]);
        return boxPlot;
      };

      boxPlot.lowerQuartile = (...args) => {
        if (!args.length) {
          return lowerQuartile;
        }

        lowerQuartile = functor$1(args[0]);
        return boxPlot;
      };

      boxPlot.high = (...args) => {
        if (!args.length) {
          return high;
        }

        high = functor$1(args[0]);
        return boxPlot;
      };

      boxPlot.low = (...args) => {
        if (!args.length) {
          return low;
        }

        low = functor$1(args[0]);
        return boxPlot;
      };

      boxPlot.width = (...args) => {
        if (!args.length) {
          return width;
        }

        width = functor$1(args[0]);
        return boxPlot;
      };

      boxPlot.orient = (...args) => {
        if (!args.length) {
          return orient;
        }

        orient = args[0];
        return boxPlot;
      };

      boxPlot.cap = (...args) => {
        if (!args.length) {
          return cap;
        }

        cap = functor$1(args[0]);
        return boxPlot;
      };

      return boxPlot;
    });

    var shapeErrorBar = (() => {
      let context = null;

      let value = d => d.x;

      let high = d => d.high;

      let low = d => d.low;

      let orient = 'vertical';
      let width = functor$1(5);

      const errorBar = function (data) {
        const drawingContext = context || d3Path.path();
        data.forEach(function (d, i) {
          // naming convention is for vertical orientation
          const _value = value(d, i);

          const _width = width(d, i);

          const halfWidth = _width / 2;

          const _high = high(d, i);

          const _low = low(d, i);

          if (orient === 'vertical') {
            drawingContext.moveTo(_value - halfWidth, _high);
            drawingContext.lineTo(_value + halfWidth, _high);
            drawingContext.moveTo(_value, _high);
            drawingContext.lineTo(_value, _low);
            drawingContext.moveTo(_value - halfWidth, _low);
            drawingContext.lineTo(_value + halfWidth, _low);
          } else {
            drawingContext.moveTo(_low, _value - halfWidth);
            drawingContext.lineTo(_low, _value + halfWidth);
            drawingContext.moveTo(_low, _value);
            drawingContext.lineTo(_high, _value);
            drawingContext.moveTo(_high, _value - halfWidth);
            drawingContext.lineTo(_high, _value + halfWidth);
          }
        });
        return context ? null : drawingContext.toString();
      };

      errorBar.context = (...args) => {
        if (!args.length) {
          return context;
        }

        context = args[0];
        return errorBar;
      };

      errorBar.value = (...args) => {
        if (!args.length) {
          return value;
        }

        value = functor$1(args[0]);
        return errorBar;
      };

      errorBar.high = (...args) => {
        if (!args.length) {
          return high;
        }

        high = functor$1(args[0]);
        return errorBar;
      };

      errorBar.low = (...args) => {
        if (!args.length) {
          return low;
        }

        low = functor$1(args[0]);
        return errorBar;
      };

      errorBar.width = (...args) => {
        if (!args.length) {
          return width;
        }

        width = functor$1(args[0]);
        return errorBar;
      };

      errorBar.orient = (...args) => {
        if (!args.length) {
          return orient;
        }

        orient = args[0];
        return errorBar;
      };

      return errorBar;
    });

    var bar$1 = (function () {
      var pathGenerator = shapeBar().x(0).y(0);
      var base = xyBase();
      var join = dataJoin('g', 'bar');

      var valueAxisDimension = function valueAxisDimension(generator) {
        return base.orient() === 'vertical' ? generator.height : generator.width;
      };

      var crossAxisDimension = function crossAxisDimension(generator) {
        return base.orient() === 'vertical' ? generator.width : generator.height;
      };

      var translation = function translation(origin) {
        return 'translate(' + origin[0] + ', ' + origin[1] + ')';
      };

      var bar = function bar(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        selection.each(function (data, index, group) {
          var orient = base.orient();

          if (orient !== 'vertical' && orient !== 'horizontal') {
            throw new Error('The bar series does not support an orientation of ' + orient);
          }

          var filteredData = data.filter(base.defined());
          var projectedData = filteredData.map(base.values);
          pathGenerator.width(0).height(0);

          if (base.orient() === 'vertical') {
            pathGenerator.verticalAlign('top');
            pathGenerator.horizontalAlign('center');
          } else {
            pathGenerator.horizontalAlign('right');
            pathGenerator.verticalAlign('center');
          }

          var g = join(d3Selection.select(group[index]), filteredData); // within the enter selection the pathGenerator creates a zero
          // height bar on the baseline. As a result, when used with a transition the bar grows
          // from y0 to y1 (y)

          g.enter().attr('transform', function (_, i) {
            return translation(projectedData[i].baseOrigin);
          }).attr('class', 'bar ' + base.orient()).attr('fill', colors.darkGray).append('path').attr('d', function (d, i) {
            crossAxisDimension(pathGenerator)(projectedData[i].width);
            return pathGenerator([d]);
          }); // the container translation sets the origin to the 'tip'
          // of each bar as per the decorate pattern

          g.attr('transform', function (_, i) {
            return translation(projectedData[i].origin);
          }).select('path').attr('d', function (d, i) {
            crossAxisDimension(pathGenerator)(projectedData[i].width);
            valueAxisDimension(pathGenerator)(-projectedData[i].height);
            return pathGenerator([d]);
          });
          base.decorate()(g, filteredData, index);
        });
      };

      rebindAll(bar, base);
      rebind(bar, join, 'key');
      return bar;
    });

    var bar$2 = (function () {
      var base = xyBase();
      var pathGenerator = shapeBar().x(0).y(0);

      var valueAxisDimension = function valueAxisDimension(generator) {
        return base.orient() === 'vertical' ? generator.height : generator.width;
      };

      var crossAxisDimension = function crossAxisDimension(generator) {
        return base.orient() === 'vertical' ? generator.width : generator.height;
      };

      var bar = function bar(data) {
        var context = pathGenerator.context();
        var filteredData = data.filter(base.defined());
        var projectedData = filteredData.map(base.values);

        if (base.orient() === 'vertical') {
          pathGenerator.verticalAlign('top');
          pathGenerator.horizontalAlign('center');
        } else {
          pathGenerator.horizontalAlign('right');
          pathGenerator.verticalAlign('center');
        }

        projectedData.forEach(function (datum, i) {
          context.save();
          context.beginPath();
          context.translate(datum.origin[0], datum.origin[1]);
          valueAxisDimension(pathGenerator)(-datum.height);
          crossAxisDimension(pathGenerator)(datum.width);
          pathGenerator([datum]);
          context.fillStyle = colors.darkGray;
          context.strokeStyle = 'transparent';
          base.decorate()(context, datum.d, i);
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      rebindAll(bar, base);
      rebind(bar, pathGenerator, 'context');
      return bar;
    });

    var bar$3 = (function () {
      var base = xyBase();
      var draw = glBar();

      var bar = function bar(data) {
        var filteredData = data.filter(base.defined());
        var xScale = scaleMapper(base.xScale());
        var yScale = scaleMapper(base.yScale());
        var xValues = new Float32Array(filteredData.length);
        var y0Values = new Float32Array(filteredData.length);
        var yValues = new Float32Array(filteredData.length);
        var widths = new Float32Array(filteredData.length);
        filteredData.forEach(function (d, i) {
          xValues[i] = xScale.scale(base.crossValue()(d, i));
          y0Values[i] = yScale.scale(base.baseValue()(d, i));
          yValues[i] = yScale.scale(base.mainValue()(d, i));
          widths[i] = yScale.scale(base.bandwidth()(d, i));
        });
        draw.xValues(xValues).y0Values(y0Values).yValues(yValues).widths(widths).xScale(xScale.glScale).yScale(yScale.glScale).decorate(function (program) {
          base.decorate()(program, filteredData, 0);
        });
        draw(filteredData.length);
      };

      rebindAll(bar, base, exclude('align'));
      rebind(bar, draw, 'context');
      return bar;
    });

    var errorBarBase = (function () {
      var highValue = function highValue(d) {
        return d.high;
      };

      var lowValue = function lowValue(d) {
        return d.low;
      };

      var crossValue = function crossValue(d) {
        return d.cross;
      };

      var orient = 'vertical';
      var align = 'center';

      var bandwidth = function bandwidth() {
        return 5;
      };

      var base = createBase({
        decorate: function decorate() {},
        defined: function defined$1(d, i) {
          return defined(lowValue, highValue, crossValue)(d, i);
        },
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity()
      });

      base.values = function (d, i) {
        var width = bandwidth(d, i);
        var offset = alignOffset(align, width);
        var xScale = base.xScale();
        var yScale = base.yScale();

        if (orient === 'vertical') {
          var y = yScale(highValue(d, i));
          return {
            origin: [xScale(crossValue(d, i)) + offset, y],
            high: 0,
            low: yScale(lowValue(d, i)) - y,
            width: width
          };
        } else {
          var x = xScale(lowValue(d, i));
          return {
            origin: [x, yScale(crossValue(d, i)) + offset],
            high: xScale(highValue(d, i)) - x,
            low: 0,
            width: width
          };
        }
      };

      base.xValues = function () {
        return orient === 'vertical' ? [crossValue] : [highValue, lowValue];
      };

      base.yValues = function () {
        return orient !== 'vertical' ? [crossValue] : [highValue, lowValue];
      };

      base.orient = function () {
        if (!arguments.length) {
          return orient;
        }

        orient = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.lowValue = function () {
        if (!arguments.length) {
          return lowValue;
        }

        lowValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.highValue = function () {
        if (!arguments.length) {
          return highValue;
        }

        highValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.crossValue = function () {
        if (!arguments.length) {
          return crossValue;
        }

        crossValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.bandwidth = function () {
        if (!arguments.length) {
          return bandwidth;
        }

        bandwidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.align = function () {
        if (!arguments.length) {
          return align;
        }

        align = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      return base;
    });

    var errorBar$1 = (function () {
      var base = errorBarBase();
      var join = dataJoin('g', 'error-bar');
      var pathGenerator = shapeErrorBar().value(0);

      var propagateTransition = function propagateTransition(maybeTransition) {
        return function (selection) {
          return maybeTransition.selection ? selection.transition(maybeTransition) : selection;
        };
      };

      var containerTranslation = function containerTranslation(values) {
        return 'translate(' + values.origin[0] + ', ' + values.origin[1] + ')';
      };

      var errorBar = function errorBar(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        var transitionPropagator = propagateTransition(selection);
        selection.each(function (data, index, group) {
          var filteredData = data.filter(base.defined());
          var projectedData = filteredData.map(base.values);
          var g = join(d3Selection.select(group[index]), filteredData);
          g.enter().attr('stroke', colors.black).attr('fill', colors.gray).attr('transform', function (d, i) {
            return containerTranslation(base.values(d, i)) + ' scale(1e-6, 1)';
          }).append('path');
          pathGenerator.orient(base.orient());
          g.each(function (d, i, g) {
            var values = projectedData[i];
            pathGenerator.high(values.high).low(values.low).width(values.width);
            transitionPropagator(d3Selection.select(g[i])).attr('transform', containerTranslation(values) + ' scale(1)').select('path').attr('d', pathGenerator([d]));
          });
          base.decorate()(g, data, index);
        });
      };

      rebindAll(errorBar, base);
      rebind(errorBar, join, 'key');
      return errorBar;
    });

    var errorBar$2 = (function () {
      var base = errorBarBase();
      var pathGenerator = shapeErrorBar().value(0);

      var errorBar = function errorBar(data) {
        var filteredData = data.filter(base.defined());
        var context = pathGenerator.context();
        pathGenerator.orient(base.orient());
        filteredData.forEach(function (d, i) {
          context.save();
          var values = base.values(d, i);
          context.translate(values.origin[0], values.origin[1]);
          context.beginPath();
          pathGenerator.high(values.high).width(values.width).low(values.low)([d]);
          context.strokeStyle = colors.black;
          context.fillStyle = colors.gray;
          base.decorate()(context, d, i);
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      rebindAll(errorBar, base);
      rebind(errorBar, pathGenerator, 'context');
      return errorBar;
    });

    var errorBar$3 = (function () {
      var base = errorBarBase();
      var draw = glErrorBar();

      var errorBar = function errorBar(data) {
        var filteredData = data.filter(base.defined());
        var xScale = scaleMapper(base.xScale());
        var yScale = scaleMapper(base.yScale());
        var xValues = new Float32Array(filteredData.length);
        var high = new Float32Array(filteredData.length);
        var low = new Float32Array(filteredData.length);
        var bandwidth = new Float32Array(filteredData.length);
        filteredData.forEach(function (d, i) {
          xValues[i] = xScale.scale(base.crossValue()(d, i));
          high[i] = yScale.scale(base.highValue()(d, i));
          low[i] = yScale.scale(base.lowValue()(d, i));
          bandwidth[i] = base.bandwidth()(d, i);
        });
        draw.xValues(xValues).highValues(high).lowValues(low).bandwidth(bandwidth).xScale(xScale.glScale).yScale(yScale.glScale);
        draw(filteredData.length);
      };

      rebindAll(errorBar, base, exclude('align'));
      rebind(errorBar, draw, 'context', 'lineWidth');
      return errorBar;
    });

    var area$2 = (function () {
      var base = xyBase();
      var areaData = d3Shape.area();
      var join = dataJoin('path', 'area');

      var area = function area(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        areaData.defined(base.defined());
        selection.each(function (data, index, group) {
          var projectedData = data.map(base.values);
          areaData.x(function (_, i) {
            return projectedData[i].transposedX;
          }).y(function (_, i) {
            return projectedData[i].transposedY;
          });
          var valueComponent = base.orient() === 'vertical' ? 'y' : 'x';
          areaData[valueComponent + '0'](function (_, i) {
            return projectedData[i].y0;
          });
          areaData[valueComponent + '1'](function (_, i) {
            return projectedData[i].y;
          });
          var path = join(d3Selection.select(group[index]), [data]);
          path.enter().attr('fill', colors.gray);
          path.attr('d', areaData);
          base.decorate()(path, data, index);
        });
      };

      rebindAll(area, base, exclude('bandwidth', 'align'));
      rebind(area, join, 'key');
      rebind(area, areaData, 'curve');
      return area;
    });

    var area$3 = (function () {
      var base = xyBase();
      var areaData = d3Shape.area();

      var area = function area(data) {
        var context = areaData.context();
        areaData.defined(base.defined());
        var projectedData = data.map(base.values);
        areaData.x(function (_, i) {
          return projectedData[i].transposedX;
        }).y(function (_, i) {
          return projectedData[i].transposedY;
        });
        var valueComponent = base.orient() === 'vertical' ? 'y' : 'x';
        areaData[valueComponent + '0'](function (_, i) {
          return projectedData[i].y0;
        });
        areaData[valueComponent + '1'](function (_, i) {
          return projectedData[i].y;
        });
        context.beginPath();
        areaData(data);
        context.fillStyle = colors.gray;
        context.strokeStyle = 'transparent';
        base.decorate()(context, data);
        context.fill();
        context.stroke();
        context.closePath();
      };

      rebindAll(area, base, exclude('bandwidth', 'align'));
      rebind(area, areaData, 'curve', 'context');
      return area;
    });

    var area$4 = (function () {
      var base = xyBase();
      var draw = glArea();

      var area = function area(data) {
        var xScale = scaleMapper(base.xScale());
        var yScale = scaleMapper(base.yScale());
        var xValues = new Float32Array(data.length);
        var yValues = new Float32Array(data.length);
        var y0Values = new Float32Array(data.length);
        var defined = new Float32Array(data.length);
        data.forEach(function (d, i) {
          xValues[i] = xScale.scale(base.crossValue()(d, i));
          yValues[i] = yScale.scale(base.mainValue()(d, i));
          y0Values[i] = yScale.scale(base.baseValue()(d, i));
          defined[i] = base.defined()(d, i);
        });
        draw.xValues(xValues).yValues(yValues).y0Values(y0Values).defined(defined).xScale(xScale.glScale).yScale(yScale.glScale).decorate(function (program) {
          return base.decorate()(program, data, 0);
        });
        draw(data.length);
      };

      rebindAll(area, base, exclude('bandwidth', 'align'));
      rebind(area, draw, 'context');
      return area;
    });

    var ohlcBase = (function () {
      var base;

      var crossValue = function crossValue(d) {
        return d.date;
      };

      var openValue = function openValue(d) {
        return d.open;
      };

      var highValue = function highValue(d) {
        return d.high;
      };

      var lowValue = function lowValue(d) {
        return d.low;
      };

      var closeValue = function closeValue(d) {
        return d.close;
      };

      var bandwidth = function bandwidth() {
        return 5;
      };

      var align = 'center';

      var crossValueScaled = function crossValueScaled(d, i) {
        return base.xScale()(crossValue(d, i));
      };

      base = createBase({
        decorate: function decorate() {},
        defined: function defined$1(d, i) {
          return defined(crossValue, openValue, lowValue, highValue, closeValue)(d, i);
        },
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity()
      });

      base.values = function (d, i) {
        var closeRaw = closeValue(d, i);
        var openRaw = openValue(d, i);
        var width = bandwidth(d, i);
        var offset = alignOffset(align, width);
        var direction = '';

        if (closeRaw > openRaw) {
          direction = 'up';
        } else if (closeRaw < openRaw) {
          direction = 'down';
        }

        return {
          cross: crossValueScaled(d, i) + offset,
          open: base.yScale()(openRaw),
          high: base.yScale()(highValue(d, i)),
          low: base.yScale()(lowValue(d, i)),
          close: base.yScale()(closeRaw),
          width: width,
          direction: direction
        };
      };

      base.xValues = function () {
        return [crossValue];
      };

      base.yValues = function () {
        return [openValue, highValue, lowValue, closeValue];
      };

      base.crossValue = function () {
        if (!arguments.length) {
          return crossValue;
        }

        crossValue = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.openValue = function () {
        if (!arguments.length) {
          return openValue;
        }

        openValue = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.highValue = function () {
        if (!arguments.length) {
          return highValue;
        }

        highValue = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.lowValue = function () {
        if (!arguments.length) {
          return lowValue;
        }

        lowValue = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.yValue = base.closeValue = function () {
        if (!arguments.length) {
          return closeValue;
        }

        closeValue = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.bandwidth = function () {
        if (!arguments.length) {
          return bandwidth;
        }

        bandwidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.align = function () {
        if (!arguments.length) {
          return align;
        }

        align = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      return base;
    });

    var ohlcBase$1 = (function (pathGenerator, seriesName) {
      var base = ohlcBase();
      var join = dataJoin('g', seriesName);

      var containerTranslation = function containerTranslation(values) {
        return 'translate(' + values.cross + ', ' + values.high + ')';
      };

      var propagateTransition = function propagateTransition(maybeTransition) {
        return function (selection) {
          return maybeTransition.selection ? selection.transition(maybeTransition) : selection;
        };
      };

      var candlestick = function candlestick(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        var transitionPropagator = propagateTransition(selection);
        selection.each(function (data, index, group) {
          var filteredData = data.filter(base.defined());
          var g = join(d3Selection.select(group[index]), filteredData);
          g.enter().attr('transform', function (d, i) {
            return containerTranslation(base.values(d, i)) + ' scale(1e-6, 1)';
          }).append('path');
          g.each(function (d, i, g) {
            var values = base.values(d, i);
            var color = values.direction === 'up' ? colors.green : colors.red;
            var singleCandlestick = transitionPropagator(d3Selection.select(g[i])).attr('class', seriesName + ' ' + values.direction).attr('stroke', color).attr('fill', color).attr('transform', function () {
              return containerTranslation(values) + ' scale(1)';
            });
            pathGenerator.x(0).width(values.width).open(function () {
              return values.open - values.high;
            }).high(0).low(function () {
              return values.low - values.high;
            }).close(function () {
              return values.close - values.high;
            });
            singleCandlestick.select('path').attr('d', pathGenerator([d]));
          });
          base.decorate()(g, data, index);
        });
      };

      rebind(candlestick, join, 'key');
      rebindAll(candlestick, base);
      return candlestick;
    });

    var candlestick = (function () {
      return ohlcBase$1(shapeCandlestick(), 'candlestick');
    });

    var ohlcBase$2 = (function (pathGenerator) {
      var base = ohlcBase();

      var candlestick = function candlestick(data) {
        var filteredData = data.filter(base.defined());
        var context = pathGenerator.context();
        filteredData.forEach(function (d, i) {
          context.save();
          var values = base.values(d, i);
          context.translate(values.cross, values.high);
          context.beginPath();
          pathGenerator.x(0).open(function () {
            return values.open - values.high;
          }).width(values.width).high(0).low(function () {
            return values.low - values.high;
          }).close(function () {
            return values.close - values.high;
          })([d]);
          var color = values.direction === 'up' ? colors.green : colors.red;
          context.strokeStyle = color;
          context.fillStyle = color;
          base.decorate()(context, d, i);
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      rebind(candlestick, pathGenerator, 'context');
      rebindAll(candlestick, base);
      return candlestick;
    });

    var candlestick$1 = (function () {
      return ohlcBase$2(shapeCandlestick());
    });

    var ohlcBase$3 = (function (pathGenerator) {
      var base = ohlcBase();

      var candlestick = function candlestick(data) {
        var filteredData = data.filter(base.defined());
        var xScale = scaleMapper(base.xScale());
        var yScale = scaleMapper(base.yScale());
        var xValues = new Float32Array(filteredData.length);
        var open = new Float32Array(filteredData.length);
        var high = new Float32Array(filteredData.length);
        var low = new Float32Array(filteredData.length);
        var close = new Float32Array(filteredData.length);
        var bandwidths = new Float32Array(filteredData.length);
        filteredData.forEach(function (d, i) {
          xValues[i] = xScale.scale(base.crossValue()(d, i));
          open[i] = yScale.scale(base.openValue()(d, i));
          high[i] = yScale.scale(base.highValue()(d, i));
          low[i] = yScale.scale(base.lowValue()(d, i));
          close[i] = yScale.scale(base.closeValue()(d, i));
          bandwidths[i] = base.bandwidth()(d, i);
        });
        pathGenerator.xValues(xValues).openValues(open).highValues(high).lowValues(low).closeValues(close).bandwidth(bandwidths).xScale(xScale.glScale).yScale(yScale.glScale).decorate(function (program) {
          return base.decorate()(program, filteredData, 0);
        });
        pathGenerator(filteredData.length);
      };

      rebindAll(candlestick, base, exclude('align'));
      rebind(candlestick, pathGenerator, 'context', 'lineWidth');
      return candlestick;
    });

    var candlestick$2 = (function () {
      return ohlcBase$3(glCandlestick());
    });

    var boxPlotBase = (function () {
      var upperQuartileValue = function upperQuartileValue(d) {
        return d.upperQuartile;
      };

      var lowerQuartileValue = function lowerQuartileValue(d) {
        return d.lowerQuartile;
      };

      var highValue = function highValue(d) {
        return d.high;
      };

      var lowValue = function lowValue(d) {
        return d.low;
      };

      var crossValue = function crossValue(d) {
        return d.value;
      };

      var medianValue = function medianValue(d) {
        return d.median;
      };

      var orient = 'vertical';
      var align = 'center';

      var bandwidth = function bandwidth() {
        return 5;
      };

      var base = createBase({
        decorate: function decorate() {},
        defined: function defined$1(d, i) {
          return defined(lowValue, highValue, lowerQuartileValue, upperQuartileValue, crossValue, medianValue)(d, i);
        },
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity()
      });

      base.values = function (d, i) {
        var width = bandwidth(d, i);
        var offset = alignOffset(align, width);
        var xScale = base.xScale();
        var yScale = base.yScale();

        if (orient === 'vertical') {
          var y = yScale(highValue(d, i));
          return {
            origin: [xScale(crossValue(d, i)) + offset, y],
            high: 0,
            upperQuartile: yScale(upperQuartileValue(d, i)) - y,
            median: yScale(medianValue(d, i)) - y,
            lowerQuartile: yScale(lowerQuartileValue(d, i)) - y,
            low: yScale(lowValue(d, i)) - y,
            width: width
          };
        } else {
          var x = xScale(lowValue(d, i));
          return {
            origin: [x, yScale(crossValue(d, i)) + offset],
            high: xScale(highValue(d, i)) - x,
            upperQuartile: xScale(upperQuartileValue(d, i)) - x,
            median: xScale(medianValue(d, i)) - x,
            lowerQuartile: xScale(lowerQuartileValue(d, i)) - x,
            low: 0,
            width: width
          };
        }
      };

      base.xValues = function () {
        return orient === 'vertical' ? [crossValue] : [upperQuartileValue, lowerQuartileValue, highValue, lowValue, medianValue];
      };

      base.yValues = function () {
        return orient !== 'vertical' ? [crossValue] : [upperQuartileValue, lowerQuartileValue, highValue, lowValue, medianValue];
      };

      base.orient = function () {
        if (!arguments.length) {
          return orient;
        }

        orient = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.lowerQuartileValue = function () {
        if (!arguments.length) {
          return lowerQuartileValue;
        }

        lowerQuartileValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.upperQuartileValue = function () {
        if (!arguments.length) {
          return upperQuartileValue;
        }

        upperQuartileValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.lowValue = function () {
        if (!arguments.length) {
          return lowValue;
        }

        lowValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.highValue = function () {
        if (!arguments.length) {
          return highValue;
        }

        highValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.crossValue = function () {
        if (!arguments.length) {
          return crossValue;
        }

        crossValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.medianValue = function () {
        if (!arguments.length) {
          return medianValue;
        }

        medianValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.bandwidth = function () {
        if (!arguments.length) {
          return bandwidth;
        }

        bandwidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.align = function () {
        if (!arguments.length) {
          return align;
        }

        align = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      return base;
    });

    var boxPlot$1 = (function () {
      var base = boxPlotBase();
      var join = dataJoin('g', 'box-plot');
      var pathGenerator = shapeBoxPlot().value(0);

      var propagateTransition = function propagateTransition(maybeTransition) {
        return function (selection) {
          return maybeTransition.selection ? selection.transition(maybeTransition) : selection;
        };
      };

      var containerTranslation = function containerTranslation(values) {
        return 'translate(' + values.origin[0] + ', ' + values.origin[1] + ')';
      };

      var boxPlot = function boxPlot(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        var transitionPropagator = propagateTransition(selection);
        selection.each(function (data, index, group) {
          var filteredData = data.filter(base.defined());
          var g = join(d3Selection.select(group[index]), filteredData);
          g.enter().attr('stroke', colors.black).attr('fill', colors.gray).attr('transform', function (d, i) {
            return containerTranslation(base.values(d, i)) + ' scale(1e-6, 1)';
          }).append('path');
          pathGenerator.orient(base.orient());
          g.each(function (d, i, g) {
            var values = base.values(d, i);
            pathGenerator.median(values.median).upperQuartile(values.upperQuartile).lowerQuartile(values.lowerQuartile).width(values.width).high(values.high).low(values.low);
            transitionPropagator(d3Selection.select(g[i])).attr('transform', containerTranslation(values)).select('path').attr('d', pathGenerator([d]));
          });
          base.decorate()(g, data, index);
        });
      };

      rebindAll(boxPlot, base);
      rebind(boxPlot, join, 'key');
      rebind(boxPlot, pathGenerator, 'cap');
      return boxPlot;
    });

    var boxPlot$2 = (function () {
      var base = boxPlotBase();
      var pathGenerator = shapeBoxPlot().value(0);

      var boxPlot = function boxPlot(data) {
        var filteredData = data.filter(base.defined());
        var context = pathGenerator.context();
        pathGenerator.orient(base.orient());
        filteredData.forEach(function (d, i) {
          context.save();
          var values = base.values(d, i);
          context.translate(values.origin[0], values.origin[1]);
          context.beginPath();
          pathGenerator.median(values.median).upperQuartile(values.upperQuartile).lowerQuartile(values.lowerQuartile).high(values.high).width(values.width).low(values.low)([d]);
          context.fillStyle = colors.gray;
          context.strokeStyle = colors.black;
          base.decorate()(context, d, i);
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      rebindAll(boxPlot, base);
      rebind(boxPlot, pathGenerator, 'cap', 'context');
      return boxPlot;
    });

    var boxPlot$3 = (function () {
      var base = boxPlotBase();
      var cap = functor(0.5);
      var draw = glBoxPlot();

      var boxPlot = function boxPlot(data) {
        var filteredData = data.filter(base.defined());
        var xScale = scaleMapper(base.xScale());
        var yScale = scaleMapper(base.yScale());
        var xValues = new Float32Array(filteredData.length);
        var medianValues = new Float32Array(filteredData.length);
        var upperQuartileValues = new Float32Array(filteredData.length);
        var lowerQuartileValues = new Float32Array(filteredData.length);
        var highValues = new Float32Array(filteredData.length);
        var lowValues = new Float32Array(filteredData.length);
        var bandwidth = new Float32Array(filteredData.length);
        var capWidth = new Float32Array(filteredData.length);
        filteredData.forEach(function (d, i) {
          xValues[i] = xScale.scale(base.crossValue()(d, i));
          medianValues[i] = yScale.scale(base.medianValue()(d, i));
          upperQuartileValues[i] = yScale.scale(base.upperQuartileValue()(d, i));
          lowerQuartileValues[i] = xScale.scale(base.lowerQuartileValue()(d, i));
          highValues[i] = yScale.scale(base.highValue()(d, i));
          lowValues[i] = yScale.scale(base.lowValue()(d, i));
          bandwidth[i] = base.bandwidth()(d, i);
          capWidth[i] = bandwidth[i] * cap(d, i);
        });
        draw.xValues(xValues).medianValues(medianValues).upperQuartileValues(upperQuartileValues).lowerQuartileValues(lowerQuartileValues).highValues(highValues).lowValues(lowValues).bandwidth(bandwidth).capWidth(capWidth).xScale(xScale.glScale).yScale(yScale.glScale);
        draw(filteredData.length);
      };

      boxPlot.cap = function () {
        if (!arguments.length) {
          return cap;
        }

        cap = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return boxPlot;
      };

      rebindAll(boxPlot, base, exclude('align'));
      rebind(boxPlot, draw, 'context', 'lineWidth');
      return boxPlot;
    });

    var ohlc = (function () {
      return ohlcBase$1(shapeOhlc(), 'ohlc');
    });

    var ohlc$1 = (function () {
      return ohlcBase$2(shapeOhlc());
    });

    var ohlc$2 = (function () {
      return ohlcBase$3(glOhlc());
    });

    var multiBase = (function () {
      var series = [];

      var mapping = function mapping(d) {
        return d;
      };

      var key = function key(_, i) {
        return i;
      };

      var multi = createBase({
        decorate: function decorate() {},
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity()
      });

      multi.xValues = function () {
        return series.map(function (s) {
          return s.xValues();
        }).reduce(function (a, b) {
          return a.concat(b);
        });
      };

      multi.yValues = function () {
        return series.map(function (s) {
          return s.yValues();
        }).reduce(function (a, b) {
          return a.concat(b);
        });
      };

      multi.mapping = function () {
        if (!arguments.length) {
          return mapping;
        }

        mapping = arguments.length <= 0 ? undefined : arguments[0];
        return multi;
      };

      multi.key = function () {
        if (!arguments.length) {
          return key;
        }

        key = arguments.length <= 0 ? undefined : arguments[0];
        return multi;
      };

      multi.series = function () {
        if (!arguments.length) {
          return series;
        }

        series = arguments.length <= 0 ? undefined : arguments[0];
        return multi;
      };

      return multi;
    });

    var multiSeries = (function () {
      var base = multiBase();
      var innerJoin = dataJoin('g');
      var join = dataJoin('g', 'multi');

      var multi = function multi(selection) {
        if (selection.selection) {
          join.transition(selection);
          innerJoin.transition(selection);
        }

        var mapping = base.mapping();
        var series = base.series();
        var xScale = base.xScale();
        var yScale = base.yScale();
        selection.each(function (data, index, group) {
          var container = join(d3Selection.select(group[index]), series); // iterate over the containers, 'call'-ing the series for each

          container.each(function (dataSeries, seriesIndex, seriesGroup) {
            dataSeries.xScale(xScale).yScale(yScale);
            var seriesData = mapping(data, seriesIndex, series);
            var innerContainer = innerJoin(d3Selection.select(seriesGroup[seriesIndex]), [seriesData]);
            innerContainer.call(dataSeries);
          });
          var unwrappedSelection = container.selection ? container.selection() : container;
          unwrappedSelection.order();
          base.decorate()(container, data, index);
        });
      };

      rebindAll(multi, base);
      rebind(multi, join, 'key');
      return multi;
    });

    var multiSeries$1 = (function () {
      var context = null;
      var base = multiBase();

      var multi = function multi(data) {
        var mapping = base.mapping();
        var series = base.series();
        var xScale = base.xScale();
        var yScale = base.yScale();
        series.forEach(function (dataSeries, index) {
          var seriesData = mapping(data, index, series);
          dataSeries.context(context).xScale(xScale).yScale(yScale);
          var adaptedDecorate;

          if (dataSeries.decorate) {
            adaptedDecorate = dataSeries.decorate();
            dataSeries.decorate(function (c, d, i) {
              base.decorate()(c, data, index);
              adaptedDecorate(c, d, i);
            });
          } else {
            base.decorate()(context, data, index);
          }

          dataSeries(seriesData);

          if (adaptedDecorate) {
            dataSeries.decorate(adaptedDecorate);
          }
        });
      };

      multi.context = function () {
        if (!arguments.length) {
          return context;
        }

        context = arguments.length <= 0 ? undefined : arguments[0];
        return multi;
      };

      rebindAll(multi, base);
      return multi;
    });

    var groupedBase = (function (series) {
      var bandwidth = function bandwidth() {
        return 50;
      };

      var align = 'center'; // the offset scale is used to offset each of the series within a group

      var offsetScale = d3Scale.scaleBand();
      var grouped = createBase({
        decorate: function decorate() {},
        xScale: d3Scale.scaleLinear(),
        yScale: d3Scale.scaleLinear()
      }); // the bandwidth for the grouped series can be a function of datum / index. As a result
      // the offset scale required to cluster the 'sub' series is also dependent on datum / index.
      // This function computes the offset scale for a specific datum / index of the grouped series

      grouped.offsetScaleForDatum = function (data, d, i) {
        var width = bandwidth(d, i);
        var offset = alignOffset(align, width);
        var halfWidth = width / 2;
        return offsetScale.domain(d3Array.range(0, data.length)).range([-halfWidth + offset, halfWidth + offset]);
      };

      grouped.bandwidth = function () {
        if (!arguments.length) {
          return bandwidth;
        }

        bandwidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return grouped;
      };

      grouped.align = function () {
        if (!arguments.length) {
          return align;
        }

        align = arguments.length <= 0 ? undefined : arguments[0];
        return grouped;
      };

      rebindAll(grouped, offsetScale, includeMap({
        'paddingInner': 'paddingOuter'
      }));
      return grouped;
    });

    var grouped = (function (series) {
      var base = groupedBase();
      var join = dataJoin('g', 'grouped');

      var grouped = function grouped(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        selection.each(function (data, index, group) {
          var g = join(d3Selection.select(group[index]), data);
          g.enter().append('g');
          g.select('g').each(function (_, index, group) {
            var container = d3Selection.select(group[index]); // create a composite scale that applies the required offset

            var isVertical = series.orient() !== 'horizontal';

            var compositeScale = function compositeScale(d, i) {
              var offset = base.offsetScaleForDatum(data, d, i);
              var baseScale = isVertical ? base.xScale() : base.yScale();
              return baseScale(d) + offset(index) + offset.bandwidth() / 2;
            };

            if (isVertical) {
              series.xScale(compositeScale);
              series.yScale(base.yScale());
            } else {
              series.yScale(compositeScale);
              series.xScale(base.xScale());
            } // if the sub-series has a bandwidth, set this from the offset scale


            if (series.bandwidth) {
              series.bandwidth(function (d, i) {
                return base.offsetScaleForDatum(data, d, i).bandwidth();
              });
            } // adapt the decorate function to give each series the correct index


            series.decorate(function (s, d) {
              return base.decorate()(s, d, index);
            });
            container.call(series);
          });
        });
      };

      rebindAll(grouped, series, exclude('decorate', 'xScale', 'yScale'));
      rebindAll(grouped, base, exclude('offsetScaleForDatum'));
      return grouped;
    });

    function grouped$1 (series) {
      var base = groupedBase();

      var grouped = function grouped(data) {
        data.forEach(function (seriesData, index) {
          // create a composite scale that applies the required offset
          var isVertical = series.orient() !== 'horizontal';

          var compositeScale = function compositeScale(d, i) {
            var offset = base.offsetScaleForDatum(data, d, i);
            var baseScale = isVertical ? base.xScale() : base.yScale();
            return baseScale(d) + offset(index) + offset.bandwidth() / 2;
          };

          if (isVertical) {
            series.xScale(compositeScale);
            series.yScale(base.yScale());
          } else {
            series.yScale(compositeScale);
            series.xScale(base.xScale());
          } // if the sub-series has a bandwidth, set this from the offset scale


          if (series.bandwidth) {
            series.bandwidth(function (d, i) {
              return base.offsetScaleForDatum(data, d, i).bandwidth();
            });
          } // adapt the decorate function to give each series the correct index


          series.decorate(function (c, d) {
            return base.decorate()(c, d, index);
          });
          series(seriesData);
        });
      };

      rebindAll(grouped, series, exclude('decorate', 'xScale', 'yScale'));
      rebindAll(grouped, base, exclude('offsetScaleForDatum'));
      return grouped;
    }

    var repeat = (function () {
      var orient = 'vertical';
      var series = line();
      var multi = multiSeries();

      var repeat = function repeat(selection) {
        return selection.each(function (data, index, group) {
          if (orient === 'vertical') {
            multi.series(data[0].map(function (_) {
              return series;
            })).mapping(function (data, index) {
              return data.map(function (d) {
                return d[index];
              });
            });
          } else {
            multi.series(data.map(function (_) {
              return series;
            })).mapping(function (data, index) {
              return data[index];
            });
          }

          d3Selection.select(group[index]).call(multi);
        });
      };

      repeat.series = function () {
        if (!arguments.length) {
          return series;
        }

        series = arguments.length <= 0 ? undefined : arguments[0];
        return repeat;
      };

      repeat.orient = function () {
        if (!arguments.length) {
          return orient;
        }

        orient = arguments.length <= 0 ? undefined : arguments[0];
        return repeat;
      };

      rebindAll(repeat, multi, exclude('series', 'mapping'));
      return repeat;
    });

    var repeat$1 = (function () {
      var orient = 'vertical';
      var series = line$1();
      var multi = multiSeries$1();

      var repeat = function repeat(data) {
        if (orient === 'vertical') {
          multi.series(data[0].map(function (_) {
            return series;
          })).mapping(function (data, index) {
            return data.map(function (d) {
              return d[index];
            });
          });
        } else {
          multi.series(data.map(function (_) {
            return series;
          })).mapping(function (data, index) {
            return data[index];
          });
        }

        multi(data);
      };

      repeat.series = function () {
        if (!arguments.length) {
          return series;
        }

        series = arguments.length <= 0 ? undefined : arguments[0];
        return repeat;
      };

      repeat.orient = function () {
        if (!arguments.length) {
          return orient;
        }

        orient = arguments.length <= 0 ? undefined : arguments[0];
        return repeat;
      };

      rebindAll(repeat, multi, exclude('series', 'mapping'));
      return repeat;
    });

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

        return arr2;
      }
    }

    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }

    var sortUnique = function sortUnique(arr) {
      return arr.sort(d3Array.ascending).filter(function (value, index, self) {
        return self.indexOf(value, index + 1) === -1;
      });
    };

    var autoBandwidth = (function (adaptee) {
      var widthFraction = 0.75; // computes the bandwidth as a fraction of the smallest distance between the datapoints

      var computeBandwidth = function computeBandwidth(screenValues) {
        // return some default value if there are not enough datapoints to compute the width
        if (screenValues.length <= 1) {
          return 10;
        }

        screenValues = sortUnique(screenValues); // compute the distance between neighbouring items

        var neighbourDistances = d3Array.pairs(screenValues).map(function (tuple) {
          return Math.abs(tuple[0] - tuple[1]);
        });
        var minDistance = d3Array.min(neighbourDistances);
        return widthFraction * minDistance;
      };

      var determineBandwith = function determineBandwith(crossScale, data, accessor) {
        // if the cross-scale has a bandwidth function, i.e. it is a scaleBand, use
        // this to determine the width
        if (crossScale.bandwidth) {
          return crossScale.bandwidth();
        } else {
          var _ref;

          // grouped series expect a nested array, which is flattened out
          var flattenedData = Array.isArray(data) ? (_ref = []).concat.apply(_ref, _toConsumableArray(data)) : data; // obtain an array of points along the crossValue axis, mapped to screen coordinates.

          var crossValuePoints = flattenedData.filter(adaptee.defined()).map(accessor()).map(crossScale);
          var width = computeBandwidth(crossValuePoints);
          return width;
        }
      };

      var autoBandwidth = function autoBandwidth(arg) {
        var computeWidth = function computeWidth(data) {
          if (adaptee.xBandwidth && adaptee.yBandwidth) {
            adaptee.xBandwidth(determineBandwith(adaptee.xScale(), data, adaptee.xValue));
            adaptee.yBandwidth(determineBandwith(adaptee.yScale(), data, adaptee.yValue));
          } else {
            // if the series has an orient property, use this to determine the cross-scale, otherwise
            // assume it is the x-scale
            var crossScale = adaptee.orient && adaptee.orient() === 'horizontal' ? adaptee.yScale() : adaptee.xScale();
            adaptee.bandwidth(determineBandwith(crossScale, data, adaptee.crossValue));
          }
        };

        if (arg instanceof d3Selection.selection) {
          arg.each(function (data, index, group) {
            computeWidth(data);
            adaptee(d3Selection.select(group[index]));
          });
        } else {
          computeWidth(arg);
          adaptee(arg);
        }
      };

      rebindAll(autoBandwidth, adaptee);

      autoBandwidth.widthFraction = function () {
        if (!arguments.length) {
          return widthFraction;
        }

        widthFraction = arguments.length <= 0 ? undefined : arguments[0];
        return autoBandwidth;
      };

      return autoBandwidth;
    });

    var heatmapBase = (function () {
      var xValue = function xValue(d) {
        return d.x;
      };

      var yValue = function yValue(d) {
        return d.y;
      };

      var colorValue = function colorValue(d) {
        return d.color;
      };

      var yBandwidth = function yBandwidth() {
        return 5;
      };

      var xBandwidth = function xBandwidth() {
        return 5;
      };

      var colorInterpolate = d3Scale.interpolateViridis;
      var heatmap = createBase({
        decorate: function decorate() {},
        defined: function defined$1(d, i) {
          return defined(xValue, yValue, colorValue)(d, i);
        },
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity()
      });
      heatmap.pathGenerator = shapeBar().x(0).y(0);

      heatmap.colorScale = function (data) {
        var colorValues = data.map(colorValue); // a scale that maps the color values onto a unit range, [0, 1]

        return d3Scale.scaleLinear().domain([d3Array.min(colorValues), d3Array.max(colorValues)]);
      };

      heatmap.values = function (d, i) {
        return {
          x: heatmap.xScale()(xValue(d, i)),
          y: heatmap.yScale()(yValue(d, i)),
          colorValue: colorValue(d, i),
          width: xBandwidth(d, i),
          height: yBandwidth(d, i)
        };
      };

      heatmap.xValues = function () {
        return [xValue];
      };

      heatmap.yValues = function () {
        return [yValue];
      };

      heatmap.xValue = function () {
        if (!arguments.length) {
          return xValue;
        }

        xValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return heatmap;
      };

      heatmap.yValue = function () {
        if (!arguments.length) {
          return yValue;
        }

        yValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return heatmap;
      };

      heatmap.colorValue = function () {
        if (!arguments.length) {
          return colorValue;
        }

        colorValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return heatmap;
      };

      heatmap.colorInterpolate = function () {
        if (!arguments.length) {
          return colorInterpolate;
        }

        colorInterpolate = arguments.length <= 0 ? undefined : arguments[0];
        return heatmap;
      };

      heatmap.xBandwidth = function () {
        if (!arguments.length) {
          return xBandwidth;
        }

        xBandwidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return heatmap;
      };

      heatmap.yBandwidth = function () {
        if (!arguments.length) {
          return yBandwidth;
        }

        yBandwidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return heatmap;
      };

      rebindAll(heatmap, heatmap.pathGenerator, includeMap({
        'horizontalAlign': 'xAlign',
        'verticalAlign': 'yAlign'
      }));
      return heatmap;
    });

    var heatmap = (function () {
      var base = heatmapBase();
      var join = dataJoin('g', 'box');

      var containerTransform = function containerTransform(values) {
        return 'translate(' + values.x + ', ' + values.y + ')';
      };

      var heatmap = function heatmap(selection) {
        selection.each(function (data, index, group) {
          var filteredData = data.filter(base.defined());
          var colorValue = base.colorValue();
          var colorInterpolate = base.colorInterpolate();
          var colorScale = base.colorScale(filteredData);
          var g = join(d3Selection.select(group[index]), filteredData);
          g.enter().append('path').attr('stroke', 'transparent');
          g.attr('transform', function (d, i) {
            return containerTransform(base.values(d, i));
          }).select('path').attr('d', function (d, i) {
            return base.pathGenerator.width(base.values(d, i).width).height(base.values(d, i).height)([d]);
          }).attr('fill', function (d, i) {
            return colorInterpolate(colorScale(colorValue(d, i)));
          });
          base.decorate()(g, data, index);
        });
      };

      rebindAll(heatmap, base);
      return heatmap;
    });

    var heatmap$1 = (function () {
      var base = heatmapBase();

      var heatmap = function heatmap(data) {
        var filteredData = data.filter(base.defined());
        var colorInterpolate = base.colorInterpolate();
        var colorScale = base.colorScale(filteredData);
        var context = base.pathGenerator.context();
        filteredData.forEach(function (d, i) {
          context.save();
          context.beginPath();
          var values = base.values(d, i);
          context.translate(values.x, values.y);
          context.fillStyle = colorInterpolate(colorScale(values.colorValue));
          context.strokeStyle = 'transparent';
          base.pathGenerator.height(values.height).width(values.width)([d]);
          base.decorate()(context, d, i);
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      rebind(heatmap, base.pathGenerator, 'context');
      rebindAll(heatmap, base);
      return heatmap;
    });

    exports.autoBandwidth = autoBandwidth;
    exports.seriesCanvasArea = area$3;
    exports.seriesCanvasBar = bar$2;
    exports.seriesCanvasBoxPlot = boxPlot$2;
    exports.seriesCanvasCandlestick = candlestick$1;
    exports.seriesCanvasErrorBar = errorBar$2;
    exports.seriesCanvasGrouped = grouped$1;
    exports.seriesCanvasHeatmap = heatmap$1;
    exports.seriesCanvasLine = line$1;
    exports.seriesCanvasMulti = multiSeries$1;
    exports.seriesCanvasOhlc = ohlc$1;
    exports.seriesCanvasPoint = point$1;
    exports.seriesCanvasRepeat = repeat$1;
    exports.seriesSvgArea = area$2;
    exports.seriesSvgBar = bar$1;
    exports.seriesSvgBoxPlot = boxPlot$1;
    exports.seriesSvgCandlestick = candlestick;
    exports.seriesSvgErrorBar = errorBar$1;
    exports.seriesSvgGrouped = grouped;
    exports.seriesSvgHeatmap = heatmap;
    exports.seriesSvgLine = line;
    exports.seriesSvgMulti = multiSeries;
    exports.seriesSvgOhlc = ohlc;
    exports.seriesSvgPoint = point;
    exports.seriesSvgRepeat = repeat;
    exports.seriesWebglArea = area$4;
    exports.seriesWebglBar = bar$3;
    exports.seriesWebglBoxPlot = boxPlot$3;
    exports.seriesWebglCandlestick = candlestick$2;
    exports.seriesWebglErrorBar = errorBar$3;
    exports.seriesWebglLine = line$3;
    exports.seriesWebglMulti = multiSeries$1;
    exports.seriesWebglOhlc = ohlc$2;
    exports.seriesWebglPoint = point$2;
    exports.seriesWebglRepeat = repeat$1;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
