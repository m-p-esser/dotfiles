"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const compressor_1 = require("./compressor");
const decompressor_1 = require("./decompressor");
function isNode() {
    if (typeof process === 'object') {
        if (typeof process.versions === 'object') {
            if (typeof process.versions.node !== 'undefined') {
                return true;
            }
        }
    }
    return false;
}
function isUint8Array(object) {
    return object instanceof Uint8Array && (!isNode() || !Buffer.isBuffer(object));
}
function isArrayBuffer(object) {
    return object instanceof ArrayBuffer;
}
function isBuffer(object) {
    if (!isNode()) {
        return false;
    }
    return Buffer.isBuffer(object);
}
const TYPE_ERROR_MSG = 'Argument compressed must be type of ArrayBuffer, Buffer, or Uint8Array';
function uncompress(compressed) {
    if (!isUint8Array(compressed) && !isArrayBuffer(compressed) && !isBuffer(compressed)) {
        throw new TypeError(TYPE_ERROR_MSG);
    }
    let uint8Mode = false;
    let arrayBufferMode = false;
    let buffer;
    if (isUint8Array(compressed)) {
        uint8Mode = true;
        buffer = Buffer.from(compressed.buffer, compressed.byteOffset, compressed.byteLength);
    }
    else if (isArrayBuffer(compressed)) {
        arrayBufferMode = true;
        buffer = Buffer.from(compressed);
    }
    else {
        buffer = compressed;
    }
    const length = decompressor_1.readUncompressedLength(buffer);
    if (length === -1)
        throw new Error('Invalid Snappy bitstream');
    const target = Buffer.alloc(length);
    if (!decompressor_1.uncompressToBuffer(buffer, target)) {
        throw new Error('Invalid Snappy bitstream');
    }
    if (uint8Mode) {
        return new Uint8Array(target.buffer);
    }
    else if (arrayBufferMode) {
        return target.buffer;
    }
    else {
        return target;
    }
}
exports.uncompress = uncompress;
function compress(uncompressed) {
    if (!isUint8Array(uncompressed) && !isArrayBuffer(uncompressed) && !isBuffer(uncompressed)) {
        throw new TypeError(TYPE_ERROR_MSG);
    }
    let uint8Mode = false;
    let arrayBufferMode = false;
    let buffer;
    if (isUint8Array(uncompressed)) {
        uint8Mode = true;
        buffer = Buffer.from(uncompressed.buffer, uncompressed.byteOffset, uncompressed.byteLength);
    }
    else if (isArrayBuffer(uncompressed)) {
        arrayBufferMode = true;
        buffer = Buffer.from(uncompressed);
    }
    else {
        buffer = uncompressed;
    }
    const maxLength = compressor_1.maxCompressedLength(buffer);
    const target = Buffer.alloc(maxLength);
    const length = compressor_1.compressToBuffer(buffer, target);
    const array = target.buffer.slice(0, length);
    if (uint8Mode) {
        return new Uint8Array(array);
    }
    else if (arrayBufferMode) {
        return array;
    }
    else {
        return Buffer.from(array);
    }
}
exports.compress = compress;
//# sourceMappingURL=index.js.map