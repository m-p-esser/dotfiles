"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Util = require("./util");
const zlib = require("zlib");
const snappyjs = require("./snappy");
let brotli;
let lzo;
let lz4js;
exports.PARQUET_COMPRESSION_METHODS = {
    UNCOMPRESSED: {
        deflate: deflate_identity,
        inflate: inflate_identity
    },
    GZIP: {
        deflate: deflate_gzip,
        inflate: inflate_gzip
    },
    SNAPPY: {
        deflate: deflate_snappy,
        inflate: inflate_snappy
    },
    LZO: {
        deflate: deflate_lzo,
        inflate: inflate_lzo
    },
    BROTLI: {
        deflate: deflate_brotli,
        inflate: inflate_brotli
    },
    LZ4: {
        deflate: deflate_lz4,
        inflate: inflate_lz4
    }
};
/**
 * Deflate a value using compression method `method`
 */
function deflate(method, value) {
    if (!(method in exports.PARQUET_COMPRESSION_METHODS)) {
        throw new Error('invalid compression method: ' + method);
    }
    return exports.PARQUET_COMPRESSION_METHODS[method].deflate(value);
}
exports.deflate = deflate;
function deflate_identity(value) {
    return value;
}
function deflate_gzip(value) {
    return zlib.gzipSync(value);
}
function deflate_snappy(value) {
    return snappyjs.compress(value);
}
function deflate_lzo(value) {
    lzo = lzo || Util.load('lzo');
    return lzo.compress(value);
}
function deflate_brotli(value) {
    brotli = brotli || Util.load('brotli');
    const result = brotli.compress(value, {
        mode: 0,
        quality: 8,
        lgwin: 22
    });
    return result ? Buffer.from(result) : Buffer.alloc(0);
}
function deflate_lz4(value) {
    lz4js = lz4js || Util.load('lz4js');
    try {
        // let result = Buffer.alloc(lz4js.encodeBound(value.length));
        // const compressedSize = lz4.encodeBlock(value, result);
        // // remove unnecessary bytes
        // result = result.slice(0, compressedSize);
        // return result;
        return Buffer.from(lz4js.compress(value));
    }
    catch (err) {
        throw err;
    }
}
/**
 * Inflate a value using compression method `method`
 */
function inflate(method, value, size) {
    if (!(method in exports.PARQUET_COMPRESSION_METHODS)) {
        throw new Error('invalid compression method: ' + method);
    }
    return exports.PARQUET_COMPRESSION_METHODS[method].inflate(value, size);
}
exports.inflate = inflate;
function inflate_identity(value) {
    return value;
}
function inflate_gzip(value) {
    return zlib.gunzipSync(value);
}
function inflate_snappy(value) {
    return snappyjs.uncompress(value);
}
function inflate_lzo(value, size) {
    lzo = lzo || Util.load('lzo');
    return lzo.decompress(value, size);
}
function inflate_lz4(value, size) {
    lz4js = lz4js || Util.load('lz4js');
    try {
        // let result = Buffer.alloc(size);
        // const uncompressedSize = lz4js.decodeBlock(value, result);
        // // remove unnecessary bytes
        // result = result.slice(0, uncompressedSize);
        // return result;
        return Buffer.from(lz4js.decompress(value, size));
    }
    catch (err) {
        throw err;
    }
}
function inflate_brotli(value) {
    brotli = brotli || Util.load('brotli');
    if (!value.length) {
        return Buffer.alloc(0);
    }
    return Buffer.from(brotli.decompress(value));
}
//# sourceMappingURL=compression.js.map