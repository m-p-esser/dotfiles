/*! For license information please see extension.js.LICENSE.txt */
(() => {
 var __webpack_modules__ = {
  71044: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    RestError: () => RestError,
    bearerTokenAuthenticationPolicy: () => bearerTokenAuthenticationPolicy,
    bearerTokenAuthenticationPolicyName: () => bearerTokenAuthenticationPolicyName,
    createDefaultHttpClient: () => createDefaultHttpClient,
    createEmptyPipeline: () => createEmptyPipeline,
    createHttpHeaders: () => createHttpHeaders,
    createPipelineFromOptions: () => createPipelineFromOptions,
    createPipelineRequest: () => createPipelineRequest,
    decompressResponsePolicy: () => decompressResponsePolicy,
    decompressResponsePolicyName: () => decompressResponsePolicyName,
    defaultRetryPolicy: () => defaultRetryPolicy,
    exponentialRetryPolicy: () => exponentialRetryPolicy,
    exponentialRetryPolicyName: () => exponentialRetryPolicyName,
    formDataPolicy: () => formDataPolicy,
    formDataPolicyName: () => formDataPolicyName,
    getDefaultProxySettings: () => getDefaultProxySettings,
    isRestError: () => isRestError,
    logPolicy: () => logPolicy,
    logPolicyName: () => logPolicyName,
    ndJsonPolicy: () => ndJsonPolicy,
    ndJsonPolicyName: () => ndJsonPolicyName,
    proxyPolicy: () => proxyPolicy,
    proxyPolicyName: () => proxyPolicyName,
    redirectPolicy: () => redirectPolicy,
    redirectPolicyName: () => redirectPolicyName,
    retryPolicy: () => retryPolicy,
    setClientRequestIdPolicy: () => setClientRequestIdPolicy,
    setClientRequestIdPolicyName: () => setClientRequestIdPolicyName,
    systemErrorRetryPolicy: () => systemErrorRetryPolicy,
    systemErrorRetryPolicyName: () => systemErrorRetryPolicyName,
    throttlingRetryPolicy: () => throttlingRetryPolicy,
    throttlingRetryPolicyName: () => throttlingRetryPolicyName,
    tlsPolicy: () => tlsPolicy,
    tlsPolicyName: () => tlsPolicyName,
    tracingPolicy: () => tracingPolicy,
    tracingPolicyName: () => tracingPolicyName,
    userAgentPolicy: () => userAgentPolicy,
    userAgentPolicyName: () => userAgentPolicyName
   });
   const ValidPhaseNames = new Set([ "Deserialize", "Serialize", "Retry", "Sign" ]);
   class HttpPipeline {
    constructor(policies) {
     var _a;
     this._policies = [], this._policies = null !== (_a = null == policies ? void 0 : policies.slice(0)) && void 0 !== _a ? _a : [], 
     this._orderedPolicies = void 0;
    }
    addPolicy(policy, options = {}) {
     if (options.phase && options.afterPhase) throw new Error("Policies inside a phase cannot specify afterPhase.");
     if (options.phase && !ValidPhaseNames.has(options.phase)) throw new Error(`Invalid phase name: ${options.phase}`);
     if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
     this._policies.push({
      policy,
      options
     }), this._orderedPolicies = void 0;
    }
    removePolicy(options) {
     const removedPolicies = [];
     return this._policies = this._policies.filter((policyDescriptor => !(options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) || (removedPolicies.push(policyDescriptor.policy), 
     !1))), this._orderedPolicies = void 0, removedPolicies;
    }
    sendRequest(httpClient, request) {
     return this.getOrderedPolicies().reduceRight(((next, policy) => req => policy.sendRequest(req, next)), (req => httpClient.sendRequest(req)))(request);
    }
    getOrderedPolicies() {
     return this._orderedPolicies || (this._orderedPolicies = this.orderPolicies()), 
     this._orderedPolicies;
    }
    clone() {
     return new HttpPipeline(this._policies);
    }
    static create() {
     return new HttpPipeline;
    }
    orderPolicies() {
     const result = [], policyMap = new Map;
     function createPhase(name) {
      return {
       name,
       policies: new Set,
       hasRun: !1,
       hasAfterPolicies: !1
      };
     }
     const serializePhase = createPhase("Serialize"), noPhase = createPhase("None"), deserializePhase = createPhase("Deserialize"), retryPhase = createPhase("Retry"), signPhase = createPhase("Sign"), orderedPhases = [ serializePhase, noPhase, deserializePhase, retryPhase, signPhase ];
     function getPhase(phase) {
      return "Retry" === phase ? retryPhase : "Serialize" === phase ? serializePhase : "Deserialize" === phase ? deserializePhase : "Sign" === phase ? signPhase : noPhase;
     }
     for (const descriptor of this._policies) {
      const policy = descriptor.policy, options = descriptor.options, policyName = policy.name;
      if (policyMap.has(policyName)) throw new Error("Duplicate policy names not allowed in pipeline");
      const node = {
       policy,
       dependsOn: new Set,
       dependants: new Set
      };
      options.afterPhase && (node.afterPhase = getPhase(options.afterPhase), node.afterPhase.hasAfterPolicies = !0), 
      policyMap.set(policyName, node);
      getPhase(options.phase).policies.add(node);
     }
     for (const descriptor of this._policies) {
      const {policy, options} = descriptor, policyName = policy.name, node = policyMap.get(policyName);
      if (!node) throw new Error(`Missing node for policy ${policyName}`);
      if (options.afterPolicies) for (const afterPolicyName of options.afterPolicies) {
       const afterNode = policyMap.get(afterPolicyName);
       afterNode && (node.dependsOn.add(afterNode), afterNode.dependants.add(node));
      }
      if (options.beforePolicies) for (const beforePolicyName of options.beforePolicies) {
       const beforeNode = policyMap.get(beforePolicyName);
       beforeNode && (beforeNode.dependsOn.add(node), node.dependants.add(beforeNode));
      }
     }
     function walkPhase(phase) {
      phase.hasRun = !0;
      for (const node of phase.policies) if ((!node.afterPhase || node.afterPhase.hasRun && !node.afterPhase.policies.size) && 0 === node.dependsOn.size) {
       result.push(node.policy);
       for (const dependant of node.dependants) dependant.dependsOn.delete(node);
       policyMap.delete(node.policy.name), phase.policies.delete(node);
      }
     }
     function walkPhases() {
      for (const phase of orderedPhases) {
       if (walkPhase(phase), phase.policies.size > 0 && phase !== noPhase) return void (noPhase.hasRun || walkPhase(noPhase));
       phase.hasAfterPolicies && walkPhase(noPhase);
      }
     }
     let iteration = 0;
     for (;policyMap.size > 0; ) {
      iteration++;
      const initialResultLength = result.length;
      if (walkPhases(), result.length <= initialResultLength && iteration > 1) throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
     }
     return result;
    }
   }
   function createEmptyPipeline() {
    return HttpPipeline.create();
   }
   var external_os_ = __webpack_require__(22037), external_util_ = __webpack_require__(73837), external_util_default = __webpack_require__.n(external_util_);
   const debugEnvVariable = "undefined" != typeof process && process.env && process.env.DEBUG || void 0;
   let enabledString, enabledNamespaces = [], skippedNamespaces = [];
   const debuggers = [];
   debugEnvVariable && enable(debugEnvVariable);
   const debugObj = Object.assign((namespace => createDebugger(namespace)), {
    enable,
    enabled,
    disable: function() {
     const result = enabledString || "";
     return enable(""), result;
    },
    log: function(message, ...args) {
     process.stderr.write(`${external_util_default().format(message, ...args)}${external_os_.EOL}`);
    }
   });
   function enable(namespaces) {
    enabledString = namespaces, enabledNamespaces = [], skippedNamespaces = [];
    const wildcard = /\*/g, namespaceList = namespaces.split(",").map((ns => ns.trim().replace(wildcard, ".*?")));
    for (const ns of namespaceList) ns.startsWith("-") ? skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`)) : enabledNamespaces.push(new RegExp(`^${ns}$`));
    for (const instance of debuggers) instance.enabled = enabled(instance.namespace);
   }
   function enabled(namespace) {
    if (namespace.endsWith("*")) return !0;
    for (const skipped of skippedNamespaces) if (skipped.test(namespace)) return !1;
    for (const enabledNamespace of enabledNamespaces) if (enabledNamespace.test(namespace)) return !0;
    return !1;
   }
   function createDebugger(namespace) {
    const newDebugger = Object.assign((function(...args) {
     if (!newDebugger.enabled) return;
     args.length > 0 && (args[0] = `${namespace} ${args[0]}`);
     newDebugger.log(...args);
    }), {
     enabled: enabled(namespace),
     destroy,
     log: debugObj.log,
     namespace,
     extend
    });
    return debuggers.push(newDebugger), newDebugger;
   }
   function destroy() {
    const index = debuggers.indexOf(this);
    return index >= 0 && (debuggers.splice(index, 1), !0);
   }
   function extend(namespace) {
    const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
    return newDebugger.log = this.log, newDebugger;
   }
   const debug = debugObj, registeredLoggers = new Set, logLevelFromEnv = "undefined" != typeof process && process.env && process.env.AZURE_LOG_LEVEL || void 0;
   let azureLogLevel;
   const AzureLogger = debug("azure");
   AzureLogger.log = (...args) => {
    debug.log(...args);
   };
   const AZURE_LOG_LEVELS = [ "verbose", "info", "warning", "error" ];
   logLevelFromEnv && (isAzureLogLevel(logLevelFromEnv) ? function(level) {
    if (level && !isAzureLogLevel(level)) throw new Error(`Unknown log level '${level}'. Acceptable values: ${AZURE_LOG_LEVELS.join(",")}`);
    azureLogLevel = level;
    const enabledNamespaces = [];
    for (const logger of registeredLoggers) shouldEnable(logger) && enabledNamespaces.push(logger.namespace);
    debug.enable(enabledNamespaces.join(","));
   }(logLevelFromEnv) : console.error(`AZURE_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${AZURE_LOG_LEVELS.join(", ")}.`));
   const levelMap = {
    verbose: 400,
    info: 300,
    warning: 200,
    error: 100
   };
   function createClientLogger(namespace) {
    const clientRootLogger = AzureLogger.extend(namespace);
    return patchLogMethod(AzureLogger, clientRootLogger), {
     error: createLogger(clientRootLogger, "error"),
     warning: createLogger(clientRootLogger, "warning"),
     info: createLogger(clientRootLogger, "info"),
     verbose: createLogger(clientRootLogger, "verbose")
    };
   }
   function patchLogMethod(parent, child) {
    child.log = (...args) => {
     parent.log(...args);
    };
   }
   function createLogger(parent, level) {
    const logger = Object.assign(parent.extend(level), {
     level
    });
    if (patchLogMethod(parent, logger), shouldEnable(logger)) {
     const enabledNamespaces = debug.disable();
     debug.enable(enabledNamespaces + "," + logger.namespace);
    }
    return registeredLoggers.add(logger), logger;
   }
   function shouldEnable(logger) {
    return Boolean(azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]);
   }
   function isAzureLogLevel(logLevel) {
    return AZURE_LOG_LEVELS.includes(logLevel);
   }
   const log_logger = createClientLogger("core-rest-pipeline");
   function isObject(input) {
    return !("object" != typeof input || null === input || Array.isArray(input) || input instanceof RegExp || input instanceof Date);
   }
   const defaultAllowedHeaderNames = [ "x-ms-client-request-id", "x-ms-return-client-request-id", "x-ms-useragent", "x-ms-correlation-request-id", "x-ms-request-id", "client-request-id", "ms-cv", "return-client-request-id", "traceparent", "Access-Control-Allow-Credentials", "Access-Control-Allow-Headers", "Access-Control-Allow-Methods", "Access-Control-Allow-Origin", "Access-Control-Expose-Headers", "Access-Control-Max-Age", "Access-Control-Request-Headers", "Access-Control-Request-Method", "Origin", "Accept", "Accept-Encoding", "Cache-Control", "Connection", "Content-Length", "Content-Type", "Date", "ETag", "Expires", "If-Match", "If-Modified-Since", "If-None-Match", "If-Unmodified-Since", "Last-Modified", "Pragma", "Request-Id", "Retry-After", "Server", "Transfer-Encoding", "User-Agent", "WWW-Authenticate" ], defaultAllowedQueryParameters = [ "api-version" ];
   class Sanitizer {
    constructor({additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = []} = {}) {
     allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames), allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters), 
     this.allowedHeaderNames = new Set(allowedHeaderNames.map((n => n.toLowerCase()))), 
     this.allowedQueryParameters = new Set(allowedQueryParameters.map((p => p.toLowerCase())));
    }
    sanitize(obj) {
     const seen = new Set;
     return JSON.stringify(obj, ((key, value) => {
      if (value instanceof Error) return Object.assign(Object.assign({}, value), {
       name: value.name,
       message: value.message
      });
      if ("headers" === key) return this.sanitizeHeaders(value);
      if ("url" === key) return this.sanitizeUrl(value);
      if ("query" === key) return this.sanitizeQuery(value);
      if ("body" !== key && "response" !== key && "operationSpec" !== key) {
       if (Array.isArray(value) || isObject(value)) {
        if (seen.has(value)) return "[Circular]";
        seen.add(value);
       }
       return value;
      }
     }), 2);
    }
    sanitizeHeaders(obj) {
     const sanitized = {};
     for (const key of Object.keys(obj)) this.allowedHeaderNames.has(key.toLowerCase()) ? sanitized[key] = obj[key] : sanitized[key] = "REDACTED";
     return sanitized;
    }
    sanitizeQuery(value) {
     if ("object" != typeof value || null === value) return value;
     const sanitized = {};
     for (const k of Object.keys(value)) this.allowedQueryParameters.has(k.toLowerCase()) ? sanitized[k] = value[k] : sanitized[k] = "REDACTED";
     return sanitized;
    }
    sanitizeUrl(value) {
     if ("string" != typeof value || null === value) return value;
     const url = new URL(value);
     if (!url.search) return value;
     for (const [key] of url.searchParams) this.allowedQueryParameters.has(key.toLowerCase()) || url.searchParams.set(key, "REDACTED");
     return url.toString();
    }
   }
   const logPolicyName = "logPolicy";
   function logPolicy(options = {}) {
    var _a;
    const logger = null !== (_a = options.logger) && void 0 !== _a ? _a : log_logger.info, sanitizer = new Sanitizer({
     additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
     additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
    });
    return {
     name: logPolicyName,
     async sendRequest(request, next) {
      if (!logger.enabled) return next(request);
      logger(`Request: ${sanitizer.sanitize(request)}`);
      const response = await next(request);
      return logger(`Response status code: ${response.status}`), logger(`Headers: ${sanitizer.sanitize(response.headers)}`), 
      response;
     }
    };
   }
   const redirectPolicyName = "redirectPolicy", allowedRedirect = [ "GET", "HEAD" ];
   function redirectPolicy(options = {}) {
    const {maxRetries = 20} = options;
    return {
     name: redirectPolicyName,
     async sendRequest(request, next) {
      const response = await next(request);
      return handleRedirect(next, response, maxRetries);
     }
    };
   }
   async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
    const {request, status, headers} = response, locationHeader = headers.get("location");
    if (locationHeader && (300 === status || 301 === status && allowedRedirect.includes(request.method) || 302 === status && allowedRedirect.includes(request.method) || 303 === status && "POST" === request.method || 307 === status) && currentRetries < maxRetries) {
     const url = new URL(locationHeader, request.url);
     request.url = url.toString(), 303 === status && (request.method = "GET", request.headers.delete("Content-Length"), 
     delete request.body), request.headers.delete("Authorization");
     const res = await next(request);
     return handleRedirect(next, res, maxRetries, currentRetries + 1);
    }
    return response;
   }
   const SDK_VERSION = "1.10.1", DEFAULT_RETRY_POLICY_COUNT = 3;
   function getUserAgentValue(prefix) {
    const runtimeInfo = new Map;
    var map;
    runtimeInfo.set("core-rest-pipeline", SDK_VERSION), (map = runtimeInfo).set("Node", process.version), 
    map.set("OS", `(${external_os_.arch()}-${external_os_.type()}-${external_os_.release()})`);
    const defaultAgent = function(telemetryInfo) {
     const parts = [];
     for (const [key, value] of telemetryInfo) {
      const token = value ? `${key}/${value}` : key;
      parts.push(token);
     }
     return parts.join(" ");
    }(runtimeInfo);
    return prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
   }
   const UserAgentHeaderName = "User-Agent", userAgentPolicyName = "userAgentPolicy";
   function userAgentPolicy(options = {}) {
    const userAgentValue = getUserAgentValue(options.userAgentPrefix);
    return {
     name: userAgentPolicyName,
     sendRequest: async (request, next) => (request.headers.has(UserAgentHeaderName) || request.headers.set(UserAgentHeaderName, userAgentValue), 
     next(request))
    };
   }
   const decompressResponsePolicyName = "decompressResponsePolicy";
   function decompressResponsePolicy() {
    return {
     name: decompressResponsePolicyName,
     sendRequest: async (request, next) => ("HEAD" !== request.method && request.headers.set("Accept-Encoding", "gzip,deflate"), 
     next(request))
    };
   }
   const listenersMap = new WeakMap, abortedMap = new WeakMap;
   class AbortSignal {
    constructor() {
     this.onabort = null, listenersMap.set(this, []), abortedMap.set(this, !1);
    }
    get aborted() {
     if (!abortedMap.has(this)) throw new TypeError("Expected `this` to be an instance of AbortSignal.");
     return abortedMap.get(this);
    }
    static get none() {
     return new AbortSignal;
    }
    addEventListener(_type, listener) {
     if (!listenersMap.has(this)) throw new TypeError("Expected `this` to be an instance of AbortSignal.");
     listenersMap.get(this).push(listener);
    }
    removeEventListener(_type, listener) {
     if (!listenersMap.has(this)) throw new TypeError("Expected `this` to be an instance of AbortSignal.");
     const listeners = listenersMap.get(this), index = listeners.indexOf(listener);
     index > -1 && listeners.splice(index, 1);
    }
    dispatchEvent(_event) {
     throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
    }
   }
   function abortSignal(signal) {
    if (signal.aborted) return;
    signal.onabort && signal.onabort.call(signal);
    const listeners = listenersMap.get(signal);
    listeners && listeners.slice().forEach((listener => {
     listener.call(signal, {
      type: "abort"
     });
    })), abortedMap.set(signal, !0);
   }
   class AbortError extends Error {
    constructor(message) {
     super(message), this.name = "AbortError";
    }
   }
   class AbortController {
    constructor(parentSignals) {
     if (this._signal = new AbortSignal, parentSignals) {
      Array.isArray(parentSignals) || (parentSignals = arguments);
      for (const parentSignal of parentSignals) parentSignal.aborted ? this.abort() : parentSignal.addEventListener("abort", (() => {
       this.abort();
      }));
     }
    }
    get signal() {
     return this._signal;
    }
    abort() {
     abortSignal(this._signal);
    }
    static timeout(ms) {
     const signal = new AbortSignal, timer = setTimeout(abortSignal, ms, signal);
     return "function" == typeof timer.unref && timer.unref(), signal;
    }
   }
   const StandardAbortMessage = "The operation was aborted.";
   function delay(delayInMs, value, options) {
    return new Promise(((resolve, reject) => {
     let timer, onAborted;
     const rejectOnAbort = () => reject(new AbortError((null == options ? void 0 : options.abortErrorMsg) ? null == options ? void 0 : options.abortErrorMsg : StandardAbortMessage)), removeListeners = () => {
      (null == options ? void 0 : options.abortSignal) && onAborted && options.abortSignal.removeEventListener("abort", onAborted);
     };
     if (onAborted = () => (timer && clearTimeout(timer), removeListeners(), rejectOnAbort()), 
     (null == options ? void 0 : options.abortSignal) && options.abortSignal.aborted) return rejectOnAbort();
     timer = setTimeout((() => {
      removeListeners(), resolve(value);
     }), delayInMs), (null == options ? void 0 : options.abortSignal) && options.abortSignal.addEventListener("abort", onAborted);
    }));
   }
   function parseHeaderValueAsNumber(response, headerName) {
    const value = response.headers.get(headerName);
    if (!value) return;
    const valueAsNum = Number(value);
    return Number.isNaN(valueAsNum) ? void 0 : valueAsNum;
   }
   const RetryAfterHeader = "Retry-After", AllRetryAfterHeaders = [ "retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader ];
   function getRetryAfterInMs(response) {
    if (response && [ 429, 503 ].includes(response.status)) try {
     for (const header of AllRetryAfterHeaders) {
      const retryAfterValue = parseHeaderValueAsNumber(response, header);
      if (0 === retryAfterValue || retryAfterValue) {
       return retryAfterValue * (header === RetryAfterHeader ? 1e3 : 1);
      }
     }
     const retryAfterHeader = response.headers.get(RetryAfterHeader);
     if (!retryAfterHeader) return;
     const diff = Date.parse(retryAfterHeader) - Date.now();
     return Number.isFinite(diff) ? Math.max(0, diff) : void 0;
    } catch (e) {
     return;
    }
   }
   function throttlingRetryStrategy() {
    return {
     name: "throttlingRetryStrategy",
     retry({response}) {
      const retryAfterInMs = getRetryAfterInMs(response);
      return Number.isFinite(retryAfterInMs) ? {
       retryAfterInMs
      } : {
       skipStrategy: !0
      };
     }
    };
   }
   const DEFAULT_CLIENT_RETRY_INTERVAL = 1e3, DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 64e3;
   function exponentialRetryStrategy(options = {}) {
    var _a, _b;
    const retryInterval = null !== (_a = options.retryDelayInMs) && void 0 !== _a ? _a : DEFAULT_CLIENT_RETRY_INTERVAL, maxRetryInterval = null !== (_b = options.maxRetryDelayInMs) && void 0 !== _b ? _b : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
    let retryAfterInMs = retryInterval;
    return {
     name: "exponentialRetryStrategy",
     retry({retryCount, response, responseError}) {
      const matchedSystemError = function(err) {
       if (!err) return !1;
       return "ETIMEDOUT" === err.code || "ESOCKETTIMEDOUT" === err.code || "ECONNREFUSED" === err.code || "ECONNRESET" === err.code || "ENOENT" === err.code;
      }(responseError), ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors, isExponential = function(response) {
       return Boolean(response && void 0 !== response.status && (response.status >= 500 || 408 === response.status) && 501 !== response.status && 505 !== response.status);
      }(response), ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes, unknownResponse = response && (function(response) {
       return Number.isFinite(getRetryAfterInMs(response));
      }(response) || !isExponential);
      if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) return {
       skipStrategy: !0
      };
      if (responseError && !matchedSystemError && !isExponential) return {
       errorToThrow: responseError
      };
      const exponentialDelay = retryAfterInMs * Math.pow(2, retryCount), clampedExponentialDelay = Math.min(maxRetryInterval, exponentialDelay);
      var min, max;
      return retryAfterInMs = clampedExponentialDelay / 2 + (min = 0, max = clampedExponentialDelay / 2, 
      min = Math.ceil(min), max = Math.floor(max), Math.floor(Math.random() * (max - min + 1)) + min), 
      {
       retryAfterInMs
      };
     }
    };
   }
   const retryPolicyLogger = createClientLogger("core-rest-pipeline retryPolicy"), retryPolicyName = "retryPolicy";
   function retryPolicy(strategies, options = {
    maxRetries: DEFAULT_RETRY_POLICY_COUNT
   }) {
    const logger = options.logger || retryPolicyLogger;
    return {
     name: retryPolicyName,
     async sendRequest(request, next) {
      var _a, _b;
      let response, responseError, retryCount = -1;
      retryRequest: for (;;) {
       retryCount += 1, response = void 0, responseError = void 0;
       try {
        logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId), 
        response = await next(request), logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);
       } catch (e) {
        if (logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId), 
        responseError = e, !e || "RestError" !== responseError.name) throw e;
        response = responseError.response;
       }
       if (null === (_a = request.abortSignal) || void 0 === _a ? void 0 : _a.aborted) {
        logger.error(`Retry ${retryCount}: Request aborted.`);
        throw new AbortError;
       }
       if (retryCount >= (null !== (_b = options.maxRetries) && void 0 !== _b ? _b : DEFAULT_RETRY_POLICY_COUNT)) {
        if (logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`), 
        responseError) throw responseError;
        if (response) return response;
        throw new Error("Maximum retries reached with no response or error to throw");
       }
       logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
       strategiesLoop: for (const strategy of strategies) {
        const strategyLogger = strategy.logger || retryPolicyLogger;
        strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
        const modifiers = strategy.retry({
         retryCount,
         response,
         responseError
        });
        if (modifiers.skipStrategy) {
         strategyLogger.info(`Retry ${retryCount}: Skipped.`);
         continue strategiesLoop;
        }
        const {errorToThrow, retryAfterInMs, redirectTo} = modifiers;
        if (errorToThrow) throw strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow), 
        errorToThrow;
        if (retryAfterInMs || 0 === retryAfterInMs) {
         strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`), 
         await delay(retryAfterInMs, void 0, {
          abortSignal: request.abortSignal
         });
         continue retryRequest;
        }
        if (redirectTo) {
         strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`), 
         request.url = redirectTo;
         continue retryRequest;
        }
       }
       if (responseError) throw logger.info("None of the retry strategies could work with the received error. Throwing it."), 
       responseError;
       if (response) return logger.info("None of the retry strategies could work with the received response. Returning it."), 
       response;
      }
     }
    };
   }
   const defaultRetryPolicyName = "defaultRetryPolicy";
   function defaultRetryPolicy(options = {}) {
    var _a;
    return {
     name: defaultRetryPolicyName,
     sendRequest: retryPolicy([ throttlingRetryStrategy(), exponentialRetryStrategy(options) ], {
      maxRetries: null !== (_a = options.maxRetries) && void 0 !== _a ? _a : DEFAULT_RETRY_POLICY_COUNT
     }).sendRequest
    };
   }
   var form_data = __webpack_require__(46882), form_data_default = __webpack_require__.n(form_data);
   const formDataPolicyName = "formDataPolicy";
   function formDataPolicy() {
    return {
     name: formDataPolicyName,
     async sendRequest(request, next) {
      if (request.formData) {
       const contentType = request.headers.get("Content-Type");
       contentType && -1 !== contentType.indexOf("application/x-www-form-urlencoded") ? (request.body = function(formData) {
        const urlSearchParams = new URLSearchParams;
        for (const [key, value] of Object.entries(formData)) if (Array.isArray(value)) for (const subValue of value) urlSearchParams.append(key, subValue.toString()); else urlSearchParams.append(key, value.toString());
        return urlSearchParams.toString();
       }(request.formData), request.formData = void 0) : await async function(formData, request) {
        const requestForm = new (form_data_default());
        for (const formKey of Object.keys(formData)) {
         const formValue = formData[formKey];
         if (Array.isArray(formValue)) for (const subValue of formValue) requestForm.append(formKey, subValue); else requestForm.append(formKey, formValue);
        }
        request.body = requestForm, request.formData = void 0;
        const contentType = request.headers.get("Content-Type");
        contentType && -1 !== contentType.indexOf("multipart/form-data") && request.headers.set("Content-Type", `multipart/form-data; boundary=${requestForm.getBoundary()}`);
        try {
         const contentLength = await new Promise(((resolve, reject) => {
          requestForm.getLength(((err, length) => {
           err ? reject(err) : resolve(length);
          }));
         }));
         request.headers.set("Content-Length", contentLength);
        } catch (e) {}
       }(request.formData, request);
      }
      return next(request);
     }
    };
   }
   var _a;
   const isNode = "undefined" != typeof process && Boolean(process.version) && Boolean(null === (_a = process.versions) || void 0 === _a ? void 0 : _a.node);
   var dist = __webpack_require__(26018), http_proxy_agent_dist = __webpack_require__(74476);
   const HTTPS_PROXY = "HTTPS_PROXY", HTTP_PROXY = "HTTP_PROXY", ALL_PROXY = "ALL_PROXY", NO_PROXY = "NO_PROXY", proxyPolicyName = "proxyPolicy", globalNoProxyList = [];
   let noProxyListLoaded = !1;
   const globalBypassedMap = new Map;
   function getEnvironmentValue(name) {
    return process.env[name] ? process.env[name] : process.env[name.toLowerCase()] ? process.env[name.toLowerCase()] : void 0;
   }
   function getDefaultProxySettings(proxyUrl) {
    if (!proxyUrl && !(proxyUrl = function() {
     if (!process) return;
     const httpsProxy = getEnvironmentValue(HTTPS_PROXY), allProxy = getEnvironmentValue(ALL_PROXY), httpProxy = getEnvironmentValue(HTTP_PROXY);
     return httpsProxy || allProxy || httpProxy;
    }())) return;
    const parsedUrl = new URL(proxyUrl);
    return {
     host: (parsedUrl.protocol ? parsedUrl.protocol + "//" : "") + parsedUrl.hostname,
     port: Number.parseInt(parsedUrl.port || "80"),
     username: parsedUrl.username,
     password: parsedUrl.password
    };
   }
   function getProxyAgentOptions(proxySettings, {headers, tlsSettings}) {
    let parsedProxyUrl;
    try {
     parsedProxyUrl = new URL(proxySettings.host);
    } catch (_error) {
     throw new Error(`Expecting a valid host string in proxy settings, but found "${proxySettings.host}".`);
    }
    tlsSettings && log_logger.warning("TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.");
    const proxyAgentOptions = {
     hostname: parsedProxyUrl.hostname,
     port: proxySettings.port,
     protocol: parsedProxyUrl.protocol,
     headers: headers.toJSON()
    };
    return proxySettings.username && proxySettings.password ? proxyAgentOptions.auth = `${proxySettings.username}:${proxySettings.password}` : proxySettings.username && (proxyAgentOptions.auth = `${proxySettings.username}`), 
    proxyAgentOptions;
   }
   function proxyPolicy(proxySettings = getDefaultProxySettings(), options) {
    noProxyListLoaded || globalNoProxyList.push(...function() {
     const noProxy = getEnvironmentValue(NO_PROXY);
     return noProxyListLoaded = !0, noProxy ? noProxy.split(",").map((item => item.trim())).filter((item => item.length)) : [];
    }());
    const cachedAgents = {};
    return {
     name: proxyPolicyName,
     async sendRequest(request, next) {
      var _a;
      return request.proxySettings || function(uri, noProxyList, bypassedMap) {
       if (0 === noProxyList.length) return !1;
       const host = new URL(uri).hostname;
       if (null == bypassedMap ? void 0 : bypassedMap.has(host)) return bypassedMap.get(host);
       let isBypassedFlag = !1;
       for (const pattern of noProxyList) "." === pattern[0] ? (host.endsWith(pattern) || host.length === pattern.length - 1 && host === pattern.slice(1)) && (isBypassedFlag = !0) : host === pattern && (isBypassedFlag = !0);
       return null == bypassedMap || bypassedMap.set(host, isBypassedFlag), isBypassedFlag;
      }(request.url, null !== (_a = null == options ? void 0 : options.customNoProxyList) && void 0 !== _a ? _a : globalNoProxyList, (null == options ? void 0 : options.customNoProxyList) ? void 0 : globalBypassedMap) || (request.proxySettings = proxySettings), 
      request.proxySettings && function(request, cachedAgents) {
       if (request.agent) return;
       const isInsecure = "https:" !== new URL(request.url).protocol, proxySettings = request.proxySettings;
       if (proxySettings) if (isInsecure) {
        if (!cachedAgents.httpProxyAgent) {
         const proxyAgentOptions = getProxyAgentOptions(proxySettings, request);
         cachedAgents.httpProxyAgent = new http_proxy_agent_dist.HttpProxyAgent(proxyAgentOptions);
        }
        request.agent = cachedAgents.httpProxyAgent;
       } else {
        if (!cachedAgents.httpsProxyAgent) {
         const proxyAgentOptions = getProxyAgentOptions(proxySettings, request);
         cachedAgents.httpsProxyAgent = new dist.HttpsProxyAgent(proxyAgentOptions);
        }
        request.agent = cachedAgents.httpsProxyAgent;
       }
      }(request, cachedAgents), next(request);
     }
    };
   }
   const setClientRequestIdPolicyName = "setClientRequestIdPolicy";
   function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
    return {
     name: setClientRequestIdPolicyName,
     sendRequest: async (request, next) => (request.headers.has(requestIdHeaderName) || request.headers.set(requestIdHeaderName, request.requestId), 
     next(request))
    };
   }
   const tlsPolicyName = "tlsPolicy";
   function tlsPolicy(tlsSettings) {
    return {
     name: tlsPolicyName,
     sendRequest: async (req, next) => (req.tlsSettings || (req.tlsSettings = tlsSettings), 
     next(req))
    };
   }
   const knownContextKeys = {
    span: Symbol.for("@azure/core-tracing span"),
    namespace: Symbol.for("@azure/core-tracing namespace")
   };
   function createTracingContext(options = {}) {
    let context = new TracingContextImpl(options.parentContext);
    return options.span && (context = context.setValue(knownContextKeys.span, options.span)), 
    options.namespace && (context = context.setValue(knownContextKeys.namespace, options.namespace)), 
    context;
   }
   class TracingContextImpl {
    constructor(initialContext) {
     this._contextMap = initialContext instanceof TracingContextImpl ? new Map(initialContext._contextMap) : new Map;
    }
    setValue(key, value) {
     const newContext = new TracingContextImpl(this);
     return newContext._contextMap.set(key, value), newContext;
    }
    getValue(key) {
     return this._contextMap.get(key);
    }
    deleteValue(key) {
     const newContext = new TracingContextImpl(this);
     return newContext._contextMap.delete(key), newContext;
    }
   }
   let instrumenterImplementation;
   function getInstrumenter() {
    return instrumenterImplementation || (instrumenterImplementation = {
     createRequestHeaders: () => ({}),
     parseTraceparentHeader: () => {},
     startSpan: (_name, spanOptions) => ({
      span: {
       end: () => {},
       isRecording: () => !1,
       recordException: () => {},
       setAttribute: () => {},
       setStatus: () => {}
      },
      tracingContext: createTracingContext({
       parentContext: spanOptions.tracingContext
      })
     }),
     withContext: (_context, callback, ...callbackArgs) => callback(...callbackArgs)
    }), instrumenterImplementation;
   }
   function isError(e) {
    if (isObject(e)) {
     const hasName = "string" == typeof e.name, hasMessage = "string" == typeof e.message;
     return hasName && hasMessage;
    }
    return !1;
   }
   function getErrorMessage(e) {
    if (isError(e)) return e.message;
    {
     let stringified;
     try {
      stringified = "object" == typeof e && e ? JSON.stringify(e) : String(e);
     } catch (err) {
      stringified = "[unable to stringify input]";
     }
     return `Unknown error ${stringified}`;
    }
   }
   const custom = external_util_.inspect.custom, errorSanitizer = new Sanitizer;
   class RestError extends Error {
    constructor(message, options = {}) {
     super(message), this.name = "RestError", this.code = options.code, this.statusCode = options.statusCode, 
     this.request = options.request, this.response = options.response, Object.setPrototypeOf(this, RestError.prototype);
    }
    [custom]() {
     return `RestError: ${this.message} \n ${errorSanitizer.sanitize(this)}`;
    }
   }
   function isRestError(e) {
    return e instanceof RestError || isError(e) && "RestError" === e.name;
   }
   RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR", RestError.PARSE_ERROR = "PARSE_ERROR";
   const tracingPolicyName = "tracingPolicy";
   function tracingPolicy(options = {}) {
    const userAgent = getUserAgentValue(options.userAgentPrefix), tracingClient = function() {
     try {
      return function(options) {
       const {namespace, packageName, packageVersion} = options;
       function startSpan(name, operationOptions, spanOptions) {
        var _a;
        const startSpanResult = getInstrumenter().startSpan(name, Object.assign(Object.assign({}, spanOptions), {
         packageName,
         packageVersion,
         tracingContext: null === (_a = null == operationOptions ? void 0 : operationOptions.tracingOptions) || void 0 === _a ? void 0 : _a.tracingContext
        }));
        let tracingContext = startSpanResult.tracingContext;
        const span = startSpanResult.span;
        return tracingContext.getValue(knownContextKeys.namespace) || (tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace)), 
        span.setAttribute("az.namespace", tracingContext.getValue(knownContextKeys.namespace)), 
        {
         span,
         updatedOptions: Object.assign({}, operationOptions, {
          tracingOptions: Object.assign(Object.assign({}, null == operationOptions ? void 0 : operationOptions.tracingOptions), {
           tracingContext
          })
         })
        };
       }
       function withContext(context, callback, ...callbackArgs) {
        return getInstrumenter().withContext(context, callback, ...callbackArgs);
       }
       return {
        startSpan,
        withSpan: async function(name, operationOptions, callback, spanOptions) {
         const {span, updatedOptions} = startSpan(name, operationOptions, spanOptions);
         try {
          const result = await withContext(updatedOptions.tracingOptions.tracingContext, (() => Promise.resolve(callback(updatedOptions, span))));
          return span.setStatus({
           status: "success"
          }), result;
         } catch (err) {
          throw span.setStatus({
           status: "error",
           error: err
          }), err;
         } finally {
          span.end();
         }
        },
        withContext,
        parseTraceparentHeader: function(traceparentHeader) {
         return getInstrumenter().parseTraceparentHeader(traceparentHeader);
        },
        createRequestHeaders: function(tracingContext) {
         return getInstrumenter().createRequestHeaders(tracingContext);
        }
       };
      }({
       namespace: "",
       packageName: "@azure/core-rest-pipeline",
       packageVersion: SDK_VERSION
      });
     } catch (e) {
      return void log_logger.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);
     }
    }();
    return {
     name: tracingPolicyName,
     async sendRequest(request, next) {
      var _a, _b;
      if (!tracingClient || !(null === (_a = request.tracingOptions) || void 0 === _a ? void 0 : _a.tracingContext)) return next(request);
      const {span, tracingContext} = null !== (_b = function(tracingClient, request, userAgent) {
       try {
        const {span, updatedOptions} = tracingClient.startSpan(`HTTP ${request.method}`, {
         tracingOptions: request.tracingOptions
        }, {
         spanKind: "client",
         spanAttributes: {
          "http.method": request.method,
          "http.url": request.url,
          requestId: request.requestId
         }
        });
        if (!span.isRecording()) return void span.end();
        userAgent && span.setAttribute("http.user_agent", userAgent);
        const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
        for (const [key, value] of Object.entries(headers)) request.headers.set(key, value);
        return {
         span,
         tracingContext: updatedOptions.tracingOptions.tracingContext
        };
       } catch (e) {
        return void log_logger.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);
       }
      }(tracingClient, request, userAgent)) && void 0 !== _b ? _b : {};
      if (!span || !tracingContext) return next(request);
      try {
       const response = await tracingClient.withContext(tracingContext, next, request);
       return function(span, response) {
        try {
         span.setAttribute("http.status_code", response.status);
         const serviceRequestId = response.headers.get("x-ms-request-id");
         serviceRequestId && span.setAttribute("serviceRequestId", serviceRequestId), span.setStatus({
          status: "success"
         }), span.end();
        } catch (e) {
         log_logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
        }
       }(span, response), response;
      } catch (err) {
       throw function(span, error) {
        try {
         span.setStatus({
          status: "error",
          error: isError(error) ? error : void 0
         }), isRestError(error) && error.statusCode && span.setAttribute("http.status_code", error.statusCode), 
         span.end();
        } catch (e) {
         log_logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
        }
       }(span, err), err;
      }
     }
    };
   }
   function createPipelineFromOptions(options) {
    const pipeline = createEmptyPipeline();
    return isNode && (options.tlsOptions && pipeline.addPolicy(tlsPolicy(options.tlsOptions)), 
    pipeline.addPolicy(proxyPolicy(options.proxyOptions)), pipeline.addPolicy(decompressResponsePolicy())), 
    pipeline.addPolicy(formDataPolicy()), pipeline.addPolicy(userAgentPolicy(options.userAgentOptions)), 
    pipeline.addPolicy(setClientRequestIdPolicy()), pipeline.addPolicy(defaultRetryPolicy(options.retryOptions), {
     phase: "Retry"
    }), pipeline.addPolicy(tracingPolicy(options.userAgentOptions), {
     afterPhase: "Retry"
    }), isNode && pipeline.addPolicy(redirectPolicy(options.redirectOptions), {
     afterPhase: "Retry"
    }), pipeline.addPolicy(logPolicy(options.loggingOptions), {
     afterPhase: "Sign"
    }), pipeline;
   }
   var external_http_ = __webpack_require__(13685), external_https_ = __webpack_require__(95687), external_zlib_ = __webpack_require__(59796), external_stream_ = __webpack_require__(12781);
   function normalizeName(name) {
    return name.toLowerCase();
   }
   class HttpHeadersImpl {
    constructor(rawHeaders) {
     if (this._headersMap = new Map, rawHeaders) for (const headerName of Object.keys(rawHeaders)) this.set(headerName, rawHeaders[headerName]);
    }
    set(name, value) {
     this._headersMap.set(normalizeName(name), {
      name,
      value: String(value)
     });
    }
    get(name) {
     var _a;
     return null === (_a = this._headersMap.get(normalizeName(name))) || void 0 === _a ? void 0 : _a.value;
    }
    has(name) {
     return this._headersMap.has(normalizeName(name));
    }
    delete(name) {
     this._headersMap.delete(normalizeName(name));
    }
    toJSON(options = {}) {
     const result = {};
     if (options.preserveCase) for (const entry of this._headersMap.values()) result[entry.name] = entry.value; else for (const [normalizedName, entry] of this._headersMap) result[normalizedName] = entry.value;
     return result;
    }
    toString() {
     return JSON.stringify(this.toJSON({
      preserveCase: !0
     }));
    }
    [Symbol.iterator]() {
     return function*(map) {
      for (const entry of map.values()) yield [ entry.name, entry.value ];
     }(this._headersMap);
    }
   }
   function createHttpHeaders(rawHeaders) {
    return new HttpHeadersImpl(rawHeaders);
   }
   const DEFAULT_TLS_SETTINGS = {};
   function isReadableStream(body) {
    return body && "function" == typeof body.pipe;
   }
   function isStreamComplete(stream) {
    return new Promise((resolve => {
     stream.on("close", resolve), stream.on("end", resolve), stream.on("error", resolve);
    }));
   }
   function isArrayBuffer(body) {
    return body && "number" == typeof body.byteLength;
   }
   class ReportTransform extends external_stream_.Transform {
    constructor(progressCallback) {
     super(), this.loadedBytes = 0, this.progressCallback = progressCallback;
    }
    _transform(chunk, _encoding, callback) {
     this.push(chunk), this.loadedBytes += chunk.length;
     try {
      this.progressCallback({
       loadedBytes: this.loadedBytes
      }), callback();
     } catch (e) {
      callback(e);
     }
    }
   }
   class NodeHttpClient {
    constructor() {
     this.cachedHttpsAgents = new WeakMap;
    }
    async sendRequest(request) {
     var _a, _b, _c;
     const abortController = new AbortController;
     let abortListener;
     if (request.abortSignal) {
      if (request.abortSignal.aborted) throw new AbortError("The operation was aborted.");
      abortListener = event => {
       "abort" === event.type && abortController.abort();
      }, request.abortSignal.addEventListener("abort", abortListener);
     }
     request.timeout > 0 && setTimeout((() => {
      abortController.abort();
     }), request.timeout);
     const acceptEncoding = request.headers.get("Accept-Encoding"), shouldDecompress = (null == acceptEncoding ? void 0 : acceptEncoding.includes("gzip")) || (null == acceptEncoding ? void 0 : acceptEncoding.includes("deflate"));
     let responseStream, body = "function" == typeof request.body ? request.body() : request.body;
     if (body && !request.headers.has("Content-Length")) {
      const bodyLength = function(body) {
       return body ? Buffer.isBuffer(body) ? body.length : isReadableStream(body) ? null : isArrayBuffer(body) ? body.byteLength : "string" == typeof body ? Buffer.from(body).length : null : 0;
      }(body);
      null !== bodyLength && request.headers.set("Content-Length", bodyLength);
     }
     try {
      if (body && request.onUploadProgress) {
       const onUploadProgress = request.onUploadProgress, uploadReportStream = new ReportTransform(onUploadProgress);
       uploadReportStream.on("error", (e => {
        log_logger.error("Error in upload progress", e);
       })), isReadableStream(body) ? body.pipe(uploadReportStream) : uploadReportStream.end(body), 
       body = uploadReportStream;
      }
      const res = await this.makeRequest(request, abortController, body), headers = function(res) {
       const headers = createHttpHeaders();
       for (const header of Object.keys(res.headers)) {
        const value = res.headers[header];
        Array.isArray(value) ? value.length > 0 && headers.set(header, value[0]) : value && headers.set(header, value);
       }
       return headers;
      }(res), response = {
       status: null !== (_a = res.statusCode) && void 0 !== _a ? _a : 0,
       headers,
       request
      };
      if ("HEAD" === request.method) return res.resume(), response;
      responseStream = shouldDecompress ? function(stream, headers) {
       const contentEncoding = headers.get("Content-Encoding");
       if ("gzip" === contentEncoding) {
        const unzip = external_zlib_.createGunzip();
        return stream.pipe(unzip), unzip;
       }
       if ("deflate" === contentEncoding) {
        const inflate = external_zlib_.createInflate();
        return stream.pipe(inflate), inflate;
       }
       return stream;
      }(res, headers) : res;
      const onDownloadProgress = request.onDownloadProgress;
      if (onDownloadProgress) {
       const downloadReportStream = new ReportTransform(onDownloadProgress);
       downloadReportStream.on("error", (e => {
        log_logger.error("Error in download progress", e);
       })), responseStream.pipe(downloadReportStream), responseStream = downloadReportStream;
      }
      return (null === (_b = request.streamResponseStatusCodes) || void 0 === _b ? void 0 : _b.has(Number.POSITIVE_INFINITY)) || (null === (_c = request.streamResponseStatusCodes) || void 0 === _c ? void 0 : _c.has(response.status)) ? response.readableStreamBody = responseStream : response.bodyAsText = await (stream = responseStream, 
      new Promise(((resolve, reject) => {
       const buffer = [];
       stream.on("data", (chunk => {
        Buffer.isBuffer(chunk) ? buffer.push(chunk) : buffer.push(Buffer.from(chunk));
       })), stream.on("end", (() => {
        resolve(Buffer.concat(buffer).toString("utf8"));
       })), stream.on("error", (e => {
        e && "AbortError" === (null == e ? void 0 : e.name) ? reject(e) : reject(new RestError(`Error reading response as text: ${e.message}`, {
         code: RestError.PARSE_ERROR
        }));
       }));
      }))), response;
     } finally {
      if (request.abortSignal && abortListener) {
       let uploadStreamDone = Promise.resolve();
       isReadableStream(body) && (uploadStreamDone = isStreamComplete(body));
       let downloadStreamDone = Promise.resolve();
       isReadableStream(responseStream) && (downloadStreamDone = isStreamComplete(responseStream)), 
       Promise.all([ uploadStreamDone, downloadStreamDone ]).then((() => {
        var _a;
        abortListener && (null === (_a = request.abortSignal) || void 0 === _a || _a.removeEventListener("abort", abortListener));
       })).catch((e => {
        log_logger.warning("Error when cleaning up abortListener on httpRequest", e);
       }));
      }
     }
     var stream;
    }
    makeRequest(request, abortController, body) {
     var _a;
     const url = new URL(request.url), isInsecure = "https:" !== url.protocol;
     if (isInsecure && !request.allowInsecureConnection) throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
     const options = {
      agent: null !== (_a = request.agent) && void 0 !== _a ? _a : this.getOrCreateAgent(request, isInsecure),
      hostname: url.hostname,
      path: `${url.pathname}${url.search}`,
      port: url.port,
      method: request.method,
      headers: request.headers.toJSON({
       preserveCase: !0
      })
     };
     return new Promise(((resolve, reject) => {
      const req = isInsecure ? external_http_.request(options, resolve) : external_https_.request(options, resolve);
      req.once("error", (err => {
       var _a;
       reject(new RestError(err.message, {
        code: null !== (_a = err.code) && void 0 !== _a ? _a : RestError.REQUEST_SEND_ERROR,
        request
       }));
      })), abortController.signal.addEventListener("abort", (() => {
       const abortError = new AbortError("The operation was aborted.");
       req.destroy(abortError), reject(abortError);
      })), body && isReadableStream(body) ? body.pipe(req) : body ? "string" == typeof body || Buffer.isBuffer(body) ? req.end(body) : isArrayBuffer(body) ? req.end(ArrayBuffer.isView(body) ? Buffer.from(body.buffer) : Buffer.from(body)) : (log_logger.error("Unrecognized body type", body), 
      reject(new RestError("Unrecognized body type"))) : req.end();
     }));
    }
    getOrCreateAgent(request, isInsecure) {
     var _a;
     const disableKeepAlive = request.disableKeepAlive;
     if (isInsecure) return disableKeepAlive ? external_http_.globalAgent : (this.cachedHttpAgent || (this.cachedHttpAgent = new external_http_.Agent({
      keepAlive: !0
     })), this.cachedHttpAgent);
     {
      if (disableKeepAlive && !request.tlsSettings) return external_https_.globalAgent;
      const tlsSettings = null !== (_a = request.tlsSettings) && void 0 !== _a ? _a : DEFAULT_TLS_SETTINGS;
      let agent = this.cachedHttpsAgents.get(tlsSettings);
      return agent && agent.options.keepAlive === !disableKeepAlive || (log_logger.info("No cached TLS Agent exist, creating a new Agent"), 
      agent = new external_https_.Agent(Object.assign({
       keepAlive: !disableKeepAlive
      }, tlsSettings)), this.cachedHttpsAgents.set(tlsSettings, agent)), agent;
     }
    }
   }
   function createDefaultHttpClient() {
    return new NodeHttpClient;
   }
   var external_crypto_ = __webpack_require__(6113), external_crypto_default = __webpack_require__.n(external_crypto_);
   const rnds8Pool = new Uint8Array(256);
   let poolPtr = rnds8Pool.length;
   function rng() {
    return poolPtr > rnds8Pool.length - 16 && (external_crypto_default().randomFillSync(rnds8Pool), 
    poolPtr = 0), rnds8Pool.slice(poolPtr, poolPtr += 16);
   }
   const regex = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
   const esm_node_validate = function(uuid) {
    return "string" == typeof uuid && regex.test(uuid);
   }, byteToHex = [];
   for (let i = 0; i < 256; ++i) byteToHex.push((i + 256).toString(16).substr(1));
   const esm_node_stringify = function(arr, offset = 0) {
    const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!esm_node_validate(uuid)) throw TypeError("Stringified UUID is invalid");
    return uuid;
   };
   const esm_node_v4 = function(options, buf, offset) {
    const rnds = (options = options || {}).random || (options.rng || rng)();
    if (rnds[6] = 15 & rnds[6] | 64, rnds[8] = 63 & rnds[8] | 128, buf) {
     offset = offset || 0;
     for (let i = 0; i < 16; ++i) buf[offset + i] = rnds[i];
     return buf;
    }
    return esm_node_stringify(rnds);
   };
   class PipelineRequestImpl {
    constructor(options) {
     var _a, _b, _c, _d, _e, _f, _g;
     this.url = options.url, this.body = options.body, this.headers = null !== (_a = options.headers) && void 0 !== _a ? _a : createHttpHeaders(), 
     this.method = null !== (_b = options.method) && void 0 !== _b ? _b : "GET", this.timeout = null !== (_c = options.timeout) && void 0 !== _c ? _c : 0, 
     this.formData = options.formData, this.disableKeepAlive = null !== (_d = options.disableKeepAlive) && void 0 !== _d && _d, 
     this.proxySettings = options.proxySettings, this.streamResponseStatusCodes = options.streamResponseStatusCodes, 
     this.withCredentials = null !== (_e = options.withCredentials) && void 0 !== _e && _e, 
     this.abortSignal = options.abortSignal, this.tracingOptions = options.tracingOptions, 
     this.onUploadProgress = options.onUploadProgress, this.onDownloadProgress = options.onDownloadProgress, 
     this.requestId = options.requestId || esm_node_v4(), this.allowInsecureConnection = null !== (_f = options.allowInsecureConnection) && void 0 !== _f && _f, 
     this.enableBrowserStreams = null !== (_g = options.enableBrowserStreams) && void 0 !== _g && _g;
    }
   }
   function createPipelineRequest(options) {
    return new PipelineRequestImpl(options);
   }
   const exponentialRetryPolicyName = "exponentialRetryPolicy";
   function exponentialRetryPolicy(options = {}) {
    var _a;
    return retryPolicy([ exponentialRetryStrategy(Object.assign(Object.assign({}, options), {
     ignoreSystemErrors: !0
    })) ], {
     maxRetries: null !== (_a = options.maxRetries) && void 0 !== _a ? _a : DEFAULT_RETRY_POLICY_COUNT
    });
   }
   const systemErrorRetryPolicyName = "systemErrorRetryPolicy";
   function systemErrorRetryPolicy(options = {}) {
    var _a;
    return {
     name: systemErrorRetryPolicyName,
     sendRequest: retryPolicy([ exponentialRetryStrategy(Object.assign(Object.assign({}, options), {
      ignoreHttpStatusCodes: !0
     })) ], {
      maxRetries: null !== (_a = options.maxRetries) && void 0 !== _a ? _a : DEFAULT_RETRY_POLICY_COUNT
     }).sendRequest
    };
   }
   const throttlingRetryPolicyName = "throttlingRetryPolicy";
   function throttlingRetryPolicy(options = {}) {
    var _a;
    return {
     name: throttlingRetryPolicyName,
     sendRequest: retryPolicy([ throttlingRetryStrategy() ], {
      maxRetries: null !== (_a = options.maxRetries) && void 0 !== _a ? _a : DEFAULT_RETRY_POLICY_COUNT
     }).sendRequest
    };
   }
   const DEFAULT_CYCLER_OPTIONS = {
    forcedRefreshWindowInMs: 1e3,
    retryIntervalInMs: 3e3,
    refreshWindowInMs: 12e4
   };
   function createTokenCycler(credential, tokenCyclerOptions) {
    let tenantId, refreshWorker = null, token = null;
    const options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions), cycler = {
     get isRefreshing() {
      return null !== refreshWorker;
     },
     get shouldRefresh() {
      var _a;
      return !cycler.isRefreshing && (null !== (_a = null == token ? void 0 : token.expiresOnTimestamp) && void 0 !== _a ? _a : 0) - options.refreshWindowInMs < Date.now();
     },
     get mustRefresh() {
      return null === token || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
     }
    };
    function refresh(scopes, getTokenOptions) {
     var _a;
     if (!cycler.isRefreshing) {
      refreshWorker = async function(getAccessToken, retryIntervalInMs, refreshTimeout) {
       async function tryGetAccessToken() {
        if (!(Date.now() < refreshTimeout)) {
         const finalToken = await getAccessToken();
         if (null === finalToken) throw new Error("Failed to refresh access token.");
         return finalToken;
        }
        try {
         return await getAccessToken();
        } catch (_a) {
         return null;
        }
       }
       let token = await tryGetAccessToken();
       for (;null === token; ) await delay(retryIntervalInMs), token = await tryGetAccessToken();
       return token;
      }((() => credential.getToken(scopes, getTokenOptions)), options.retryIntervalInMs, null !== (_a = null == token ? void 0 : token.expiresOnTimestamp) && void 0 !== _a ? _a : Date.now()).then((_token => (refreshWorker = null, 
      token = _token, tenantId = getTokenOptions.tenantId, token))).catch((reason => {
       throw refreshWorker = null, token = null, tenantId = void 0, reason;
      }));
     }
     return refreshWorker;
    }
    return async (scopes, tokenOptions) => tenantId !== tokenOptions.tenantId || Boolean(tokenOptions.claims) || cycler.mustRefresh ? refresh(scopes, tokenOptions) : (cycler.shouldRefresh && refresh(scopes, tokenOptions), 
    token);
   }
   const bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
   async function defaultAuthorizeRequest(options) {
    const {scopes, getAccessToken, request} = options, getTokenOptions = {
     abortSignal: request.abortSignal,
     tracingOptions: request.tracingOptions
    }, accessToken = await getAccessToken(scopes, getTokenOptions);
    accessToken && options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
   }
   function bearerTokenAuthenticationPolicy(options) {
    var _a;
    const {credential, scopes, challengeCallbacks} = options, logger = options.logger || log_logger, callbacks = Object.assign({
     authorizeRequest: null !== (_a = null == challengeCallbacks ? void 0 : challengeCallbacks.authorizeRequest) && void 0 !== _a ? _a : defaultAuthorizeRequest,
     authorizeRequestOnChallenge: null == challengeCallbacks ? void 0 : challengeCallbacks.authorizeRequestOnChallenge
    }, challengeCallbacks), getAccessToken = credential ? createTokenCycler(credential) : () => Promise.resolve(null);
    return {
     name: bearerTokenAuthenticationPolicyName,
     async sendRequest(request, next) {
      if (!request.url.toLowerCase().startsWith("https://")) throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
      let response, error;
      await callbacks.authorizeRequest({
       scopes: Array.isArray(scopes) ? scopes : [ scopes ],
       request,
       getAccessToken,
       logger
      });
      try {
       response = await next(request);
      } catch (err) {
       error = err, response = err.response;
      }
      if (callbacks.authorizeRequestOnChallenge && 401 === (null == response ? void 0 : response.status) && function(response) {
       const challenge = response.headers.get("WWW-Authenticate");
       if (401 === response.status && challenge) return challenge;
      }(response)) {
       if (await callbacks.authorizeRequestOnChallenge({
        scopes: Array.isArray(scopes) ? scopes : [ scopes ],
        request,
        response,
        getAccessToken,
        logger
       })) return next(request);
      }
      if (error) throw error;
      return response;
     }
    };
   }
   const ndJsonPolicyName = "ndJsonPolicy";
   function ndJsonPolicy() {
    return {
     name: ndJsonPolicyName,
     async sendRequest(request, next) {
      if ("string" == typeof request.body && request.body.startsWith("[")) {
       const body = JSON.parse(request.body);
       Array.isArray(body) && (request.body = body.map((item => JSON.stringify(item) + "\n")).join(""));
      }
      return next(request);
     }
    };
   }
  },
  65521: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.default = function(emitter, name, {signal} = {}) {
    return new Promise(((resolve, reject) => {
     function cleanup() {
      null == signal || signal.removeEventListener("abort", cleanup), emitter.removeListener(name, onEvent), 
      emitter.removeListener("error", onError);
     }
     function onEvent(...args) {
      cleanup(), resolve(args);
     }
     function onError(err) {
      cleanup(), reject(err);
     }
     null == signal || signal.addEventListener("abort", cleanup), emitter.on(name, onEvent), 
     emitter.on("error", onError);
    }));
   };
  },
  88192: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }, __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
     default: mod
    };
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   const net_1 = __importDefault(__webpack_require__(41808)), tls_1 = __importDefault(__webpack_require__(24404)), url_1 = __importDefault(__webpack_require__(57310)), debug_1 = __importDefault(__webpack_require__(15158)), once_1 = __importDefault(__webpack_require__(65521)), agent_base_1 = __webpack_require__(88054), debug = (0, 
   debug_1.default)("http-proxy-agent");
   class HttpProxyAgent extends agent_base_1.Agent {
    constructor(_opts) {
     let opts;
     if (opts = "string" == typeof _opts ? url_1.default.parse(_opts) : _opts, !opts) throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
     debug("Creating new HttpProxyAgent instance: %o", opts), super(opts);
     const proxy = Object.assign({}, opts);
     var protocol;
     this.secureProxy = opts.secureProxy || "string" == typeof (protocol = proxy.protocol) && /^https:?$/i.test(protocol), 
     proxy.host = proxy.hostname || proxy.host, "string" == typeof proxy.port && (proxy.port = parseInt(proxy.port, 10)), 
     !proxy.port && proxy.host && (proxy.port = this.secureProxy ? 443 : 80), proxy.host && proxy.path && (delete proxy.path, 
     delete proxy.pathname), this.proxy = proxy;
    }
    callback(req, opts) {
     return __awaiter(this, void 0, void 0, (function*() {
      const {proxy, secureProxy} = this, parsed = url_1.default.parse(req.path);
      let socket;
      if (parsed.protocol || (parsed.protocol = "http:"), parsed.hostname || (parsed.hostname = opts.hostname || opts.host || null), 
      null == parsed.port && (opts.port, 1) && (parsed.port = String(opts.port)), "80" === parsed.port && (parsed.port = ""), 
      req.path = url_1.default.format(parsed), proxy.auth && req.setHeader("Proxy-Authorization", `Basic ${Buffer.from(proxy.auth).toString("base64")}`), 
      secureProxy ? (debug("Creating `tls.Socket`: %o", proxy), socket = tls_1.default.connect(proxy)) : (debug("Creating `net.Socket`: %o", proxy), 
      socket = net_1.default.connect(proxy)), req._header) {
       let first, endOfHeaders;
       debug("Regenerating stored HTTP header string for request"), req._header = null, 
       req._implicitHeader(), req.output && req.output.length > 0 ? (debug("Patching connection write() output buffer with updated header"), 
       first = req.output[0], endOfHeaders = first.indexOf("\r\n\r\n") + 4, req.output[0] = req._header + first.substring(endOfHeaders), 
       debug("Output buffer: %o", req.output)) : req.outputData && req.outputData.length > 0 && (debug("Patching connection write() output buffer with updated header"), 
       first = req.outputData[0].data, endOfHeaders = first.indexOf("\r\n\r\n") + 4, req.outputData[0].data = req._header + first.substring(endOfHeaders), 
       debug("Output buffer: %o", req.outputData[0].data));
      }
      return yield (0, once_1.default)(socket, "connect"), socket;
     }));
    }
   }
   exports.default = HttpProxyAgent;
  },
  74476: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   const agent_1 = (this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
     default: mod
    };
   })(__webpack_require__(88192));
   function createHttpProxyAgent(opts) {
    return new agent_1.default(opts);
   }
   !function(createHttpProxyAgent) {
    createHttpProxyAgent.HttpProxyAgent = agent_1.default, createHttpProxyAgent.prototype = agent_1.default.prototype;
   }(createHttpProxyAgent || (createHttpProxyAgent = {})), module.exports = createHttpProxyAgent;
  },
  67164: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    AppInsightsCore: () => src_AppInsightsCore,
    BaseCore: () => src_BaseCore,
    BaseTelemetryPlugin: () => BaseTelemetryPlugin.i,
    CoreUtils: () => Utils.Tr,
    DiagnosticLogger: () => DiagnosticLogger.AQ,
    ESPromise: () => src_ESPromise,
    ESPromiseScheduler: () => src_ESPromiseScheduler,
    EventHelper: () => CoreUtils.zB,
    EventLatency: () => EventLatency,
    EventPersistence: () => EventPersistence,
    EventPropertyType: () => EventPropertyType,
    EventsDiscardedReason: () => EventsDiscardedReason.h,
    FullVersionString: () => Utils.vs,
    InternalAppInsightsCore: () => AppInsightsCore,
    InternalBaseCore: () => BaseCore,
    LoggingSeverity: () => LoggingSeverity,
    MinChannelPriorty: () => MinChannelPriorty,
    NotificationManager: () => NotificationManager,
    PerfEvent: () => PerfManager.zn,
    PerfManager: () => PerfManager.Jk,
    ProcessTelemetryContext: () => ProcessTelemetryContext.Vi,
    TraceLevel: () => TraceLevel,
    Undefined: () => Constants.jA,
    Utils: () => Utils.cQ,
    ValueKind: () => ValueKind,
    ValueSanitizer: () => ValueSanitizer,
    Version: () => Utils.Gf,
    _ExtendedInternalMessageId: () => _ExtendedInternalMessageId,
    _InternalLogMessage: () => DiagnosticLogger.lQ,
    _InternalMessageId: () => _InternalMessageId,
    __getRegisteredEvents: () => EventHelpers.um,
    _logInternalMessage: () => DiagnosticLogger.L4,
    _throwInternal: () => DiagnosticLogger.kP,
    _warnToConsole: () => DiagnosticLogger.jV,
    addEventHandler: () => EventHelpers.Ib,
    addEventListeners: () => EventHelpers.yw,
    addPageHideEventListener: () => EventHelpers.TJ,
    addPageShowEventListener: () => EventHelpers.nD,
    addPageUnloadEventListener: () => EventHelpers.c9,
    areCookiesSupported: () => CookieMgr.p7,
    arrForEach: () => HelperFuncs.tO,
    arrIndexOf: () => HelperFuncs.UA,
    arrMap: () => HelperFuncs.Mr,
    arrReduce: () => HelperFuncs.Xz,
    attachEvent: () => EventHelpers.pZ,
    cookieAvailable: () => CookieMgr.p7,
    createCookieMgr: () => CookieMgr.Nz,
    createEnumStyle: () => EnumHelperFuncs.By,
    createGuid: () => Utils.cm,
    createProcessTelemetryContext: () => ProcessTelemetryContext.CD,
    createTraceParent: () => W3cTraceParent.SU,
    createUniqueNamespace: () => DataCacheHelper.J,
    createUnloadHandlerContainer: () => UnloadHandlerContainer.Y,
    dateNow: () => HelperFuncs.m6,
    deleteCookie: () => Utils.kT,
    detachEvent: () => EventHelpers.pD,
    disableCookies: () => Utils.oF,
    disallowsSameSiteNone: () => CookieMgr.UY,
    doPerf: () => PerfManager.Lm,
    dumpObj: () => EnvUtils.eU,
    eventOff: () => EventHelpers.QY,
    eventOn: () => EventHelpers.XO,
    extend: () => Utils.l7,
    findW3cTraceParent: () => W3cTraceParent.lq,
    formatTraceParent: () => W3cTraceParent.aR,
    generateW3CId: () => CoreUtils.DO,
    getCommonSchemaMetaData: () => Utils.Vv,
    getConsole: () => EnvUtils.dr,
    getCookie: () => Utils.ej,
    getCookieValue: () => Utils.Do,
    getCrypto: () => EnvUtils.MX,
    getDocument: () => EnvUtils.Me,
    getExceptionName: () => HelperFuncs.jj,
    getFieldValueType: () => Utils.Sy,
    getGlobal: () => Helpers.Rd,
    getGlobalInst: () => EnvUtils.a8,
    getHistory: () => EnvUtils.s1,
    getIEVersion: () => EnvUtils.sA,
    getISOString: () => HelperFuncs.Y6,
    getJSON: () => EnvUtils.xA,
    getLocation: () => EnvUtils.k$,
    getMsCrypto: () => EnvUtils.gz,
    getNavigator: () => EnvUtils.jW,
    getPerformance: () => EnvUtils.r,
    getSetValue: () => HelperFuncs.qK,
    getTenantId: () => Utils.jM,
    getTime: () => Utils.hK,
    getWindow: () => EnvUtils.Jj,
    hasDocument: () => EnvUtils.Nv,
    hasHistory: () => EnvUtils.fE,
    hasJSON: () => EnvUtils.nS,
    hasNavigator: () => EnvUtils.d6,
    hasOwnProperty: () => HelperFuncs.nr,
    hasWindow: () => EnvUtils.Ym,
    isArray: () => HelperFuncs.kJ,
    isArrayValid: () => Utils.JT,
    isBeaconsSupported: () => EnvUtils.MF,
    isBoolean: () => HelperFuncs.jn,
    isChromium: () => Utils.mJ,
    isDate: () => HelperFuncs.J_,
    isDocumentObjectAvailable: () => Utils.x9,
    isError: () => HelperFuncs.VZ,
    isFetchSupported: () => EnvUtils.JO,
    isFunction: () => HelperFuncs.mf,
    isIE: () => EnvUtils.w1,
    isLatency: () => Utils.r7,
    isNotTruthy: () => HelperFuncs.F,
    isNullOrUndefined: () => HelperFuncs.le,
    isNumber: () => HelperFuncs.hj,
    isObject: () => HelperFuncs.Kn,
    isReactNative: () => EnvUtils.b$,
    isSampledFlag: () => W3cTraceParent.Pn,
    isString: () => HelperFuncs.HD,
    isTruthy: () => HelperFuncs.fQ,
    isTypeof: () => HelperFuncs.Ym,
    isUint8ArrayAvailable: () => Utils.IZ,
    isUndefined: () => HelperFuncs.o8,
    isValidSpanId: () => W3cTraceParent.Lc,
    isValidTraceId: () => W3cTraceParent.jN,
    isValidTraceParent: () => W3cTraceParent.J6,
    isValueAssigned: () => Utils.Sn,
    isValueKind: () => Utils.oS,
    isWindowObjectAvailable: () => Utils.dH,
    isXhrSupported: () => EnvUtils.Z3,
    mergeEvtNamespace: () => EventHelpers.jU,
    newGuid: () => CoreUtils.GW,
    newId: () => RandomHelper.pZ,
    normalizeJsName: () => HelperFuncs.Gf,
    objCreate: () => Helpers.pu,
    objDefineAccessors: () => HelperFuncs.l_,
    objForEachKey: () => HelperFuncs.rW,
    objFreeze: () => HelperFuncs.FL,
    objKeys: () => HelperFuncs.FY,
    objSeal: () => HelperFuncs.Xi,
    openXhr: () => Utils.ot,
    optimizeObject: () => HelperFuncs.Ax,
    parseTraceParent: () => W3cTraceParent.j_,
    perfNow: () => CoreUtils.Jj,
    proxyAssign: () => HelperFuncs.cf,
    proxyFunctionAs: () => HelperFuncs.Oi,
    proxyFunctions: () => HelperFuncs.Vb,
    random32: () => RandomHelper._l,
    randomValue: () => RandomHelper.az,
    removeEventHandler: () => EventHelpers.C1,
    removeEventListeners: () => EventHelpers.nJ,
    removePageHideEventListener: () => EventHelpers.C9,
    removePageShowEventListener: () => EventHelpers.Yl,
    removePageUnloadEventListener: () => EventHelpers.JA,
    safeGetCookieMgr: () => CookieMgr.JP,
    safeGetLogger: () => DiagnosticLogger.vH,
    sanitizeProperty: () => Utils.yj,
    setCookie: () => Utils.d8,
    setEnableEnvMocks: () => EnvUtils.dI,
    setProcessTelemetryTimings: () => Utils.if,
    setValue: () => HelperFuncs.sO,
    strContains: () => HelperFuncs._Q,
    strEndsWith: () => HelperFuncs.Id,
    strFunction: () => Constants.cb,
    strObject: () => Constants.fK,
    strPrototype: () => Constants.hB,
    strStartsWith: () => HelperFuncs.xe,
    strTrim: () => HelperFuncs.nd,
    strUndefined: () => Constants.jA,
    throwError: () => HelperFuncs._y,
    toISOString: () => HelperFuncs.Y6,
    useXDomainRequest: () => EnvUtils.cp
   });
   var _a, TsLibShims = __webpack_require__(27421), EnumHelperFuncs = __webpack_require__(50951), HelperFuncs = __webpack_require__(24869), LoggingSeverity = (0, 
   EnumHelperFuncs.By)({
    CRITICAL: 1,
    WARNING: 2
   }), _InternalMessageId = (0, EnumHelperFuncs.By)(((_a = {}).BrowserDoesNotSupportLocalStorage = 0, 
   _a.BrowserCannotReadLocalStorage = 1, _a.BrowserCannotReadSessionStorage = 2, _a.BrowserCannotWriteLocalStorage = 3, 
   _a.BrowserCannotWriteSessionStorage = 4, _a.BrowserFailedRemovalFromLocalStorage = 5, 
   _a.BrowserFailedRemovalFromSessionStorage = 6, _a.CannotSendEmptyTelemetry = 7, 
   _a.ClientPerformanceMathError = 8, _a.ErrorParsingAISessionCookie = 9, _a.ErrorPVCalc = 10, 
   _a.ExceptionWhileLoggingError = 11, _a.FailedAddingTelemetryToBuffer = 12, _a.FailedMonitorAjaxAbort = 13, 
   _a.FailedMonitorAjaxDur = 14, _a.FailedMonitorAjaxOpen = 15, _a.FailedMonitorAjaxRSC = 16, 
   _a.FailedMonitorAjaxSend = 17, _a.FailedMonitorAjaxGetCorrelationHeader = 18, _a.FailedToAddHandlerForOnBeforeUnload = 19, 
   _a.FailedToSendQueuedTelemetry = 20, _a.FailedToReportDataLoss = 21, _a.FlushFailed = 22, 
   _a.MessageLimitPerPVExceeded = 23, _a.MissingRequiredFieldSpecification = 24, _a.NavigationTimingNotSupported = 25, 
   _a.OnError = 26, _a.SessionRenewalDateIsZero = 27, _a.SenderNotInitialized = 28, 
   _a.StartTrackEventFailed = 29, _a.StopTrackEventFailed = 30, _a.StartTrackFailed = 31, 
   _a.StopTrackFailed = 32, _a.TelemetrySampledAndNotSent = 33, _a.TrackEventFailed = 34, 
   _a.TrackExceptionFailed = 35, _a.TrackMetricFailed = 36, _a.TrackPVFailed = 37, 
   _a.TrackPVFailedCalc = 38, _a.TrackTraceFailed = 39, _a.TransmissionFailed = 40, 
   _a.FailedToSetStorageBuffer = 41, _a.FailedToRestoreStorageBuffer = 42, _a.InvalidBackendResponse = 43, 
   _a.FailedToFixDepricatedValues = 44, _a.InvalidDurationValue = 45, _a.TelemetryEnvelopeInvalid = 46, 
   _a.CreateEnvelopeError = 47, _a.CannotSerializeObject = 48, _a.CannotSerializeObjectNonSerializable = 49, 
   _a.CircularReferenceDetected = 50, _a.ClearAuthContextFailed = 51, _a.ExceptionTruncated = 52, 
   _a.IllegalCharsInName = 53, _a.ItemNotInArray = 54, _a.MaxAjaxPerPVExceeded = 55, 
   _a.MessageTruncated = 56, _a.NameTooLong = 57, _a.SampleRateOutOfRange = 58, _a.SetAuthContextFailed = 59, 
   _a.SetAuthContextFailedAccountName = 60, _a.StringValueTooLong = 61, _a.StartCalledMoreThanOnce = 62, 
   _a.StopCalledWithoutStart = 63, _a.TelemetryInitializerFailed = 64, _a.TrackArgumentsNotSpecified = 65, 
   _a.UrlTooLong = 66, _a.SessionStorageBufferFull = 67, _a.CannotAccessCookie = 68, 
   _a.IdTooLong = 69, _a.InvalidEvent = 70, _a.FailedMonitorAjaxSetRequestHeader = 71, 
   _a.SendBrowserInfoOnUserInit = 72, _a.PluginException = 73, _a.NotificationException = 74, 
   _a.SnippetScriptLoadFailure = 99, _a.InvalidInstrumentationKey = 100, _a.CannotParseAiBlobValue = 101, 
   _a.InvalidContentBlob = 102, _a.TrackPageActionEventFailed = 103, _a.FailedAddingCustomDefinedRequestContext = 104, 
   _a.InMemoryStorageBufferFull = 105, _a.InstrumentationKeyDeprecation = 106, _a)), ValueKind = (0, 
   EnumHelperFuncs.By)({
    NotSet: 0,
    Pii_DistinguishedName: 1,
    Pii_GenericData: 2,
    Pii_IPV4Address: 3,
    Pii_IPv6Address: 4,
    Pii_MailSubject: 5,
    Pii_PhoneNumber: 6,
    Pii_QueryString: 7,
    Pii_SipAddress: 8,
    Pii_SmtpAddress: 9,
    Pii_Identity: 10,
    Pii_Uri: 11,
    Pii_Fqdn: 12,
    Pii_IPV4AddressLegacy: 13,
    CustomerContent_GenericContent: 32
   }), EventLatency = (0, EnumHelperFuncs.By)({
    Normal: 1,
    CostDeferred: 2,
    RealTime: 3,
    Immediate: 4
   }), EventPropertyType = (0, EnumHelperFuncs.By)({
    Unspecified: 0,
    String: 1,
    Int32: 2,
    UInt32: 3,
    Int64: 4,
    UInt64: 5,
    Double: 6,
    Bool: 7,
    Guid: 8,
    DateTime: 9
   }), EventPersistence = (0, EnumHelperFuncs.By)({
    Normal: 1,
    Critical: 2
   }), TraceLevel = (0, EnumHelperFuncs.By)({
    NONE: 0,
    ERROR: 1,
    WARNING: 2,
    INFORMATION: 3
   }), _ExtendedInternalMessageId = (0, HelperFuncs.FL)((0, TsLibShims.uc)((0, TsLibShims.uc)({}, _InternalMessageId), (0, 
   EnumHelperFuncs.By)({
    AuthHandShakeError: 501,
    AuthRedirectFail: 502,
    BrowserCannotReadLocalStorage: 503,
    BrowserCannotWriteLocalStorage: 504,
    BrowserDoesNotSupportLocalStorage: 505,
    CannotParseBiBlobValue: 506,
    CannotParseDataAttribute: 507,
    CVPluginNotAvailable: 508,
    DroppedEvent: 509,
    ErrorParsingAISessionCookie: 510,
    ErrorProvidedChannels: 511,
    FailedToGetCookies: 512,
    FailedToInitializeCorrelationVector: 513,
    FailedToInitializeSDK: 514,
    InvalidContentBlob: 515,
    InvalidCorrelationValue: 516,
    SessionRenewalDateIsZero: 517,
    SendPostOnCompleteFailure: 518,
    PostResponseHandler: 519,
    SDKNotInitialized: 520
   }))), dynamicproto_js = __webpack_require__(29141), DiagnosticLogger = __webpack_require__(29339), PerfManager = __webpack_require__(81782), EnvUtils = __webpack_require__(49251), _DynamicConstants = __webpack_require__(98145), Helpers = __webpack_require__(30175), InternalConstants = __webpack_require__(96335), ProcessTelemetryContext = __webpack_require__(31030), TelemetryHelpers = __webpack_require__(69031), ChannelControllerPriority = 500, ChannelValidationMessage = "Channel has invalid priority - ";
   function _addChannelQueue(channelQueue, queue, core) {
    queue && (0, HelperFuncs.kJ)(queue) && queue[_DynamicConstants.R5] > 0 && (queue = queue.sort((function(a, b) {
     return a[InternalConstants.yi] - b[InternalConstants.yi];
    })), (0, HelperFuncs.tO)(queue, (function(queueItem) {
     queueItem[InternalConstants.yi] < ChannelControllerPriority && (0, HelperFuncs._y)(ChannelValidationMessage + queueItem[_DynamicConstants.pZ]);
    })), channelQueue[_DynamicConstants.MW]({
     queue: (0, HelperFuncs.FL)(queue),
     chain: (0, ProcessTelemetryContext.jV)(queue, core[_DynamicConstants.TC], core)
    }));
   }
   var CookieMgr = __webpack_require__(88140), DataCacheHelper = __webpack_require__(87624), DbgExtensionUtils = __webpack_require__(28341), BaseTelemetryPlugin = __webpack_require__(87951), TelemetryInitializerPlugin = function(_super) {
    function TelemetryInitializerPlugin() {
     var _id, _initializers, _this = _super.call(this) || this;
     function _initDefaults() {
      _id = 0, _initializers = [];
     }
     return _this.identifier = "TelemetryInitializerPlugin", _this.priority = 199, _initDefaults(), 
     (0, dynamicproto_js.Z)(TelemetryInitializerPlugin, _this, (function(_self, _base) {
      _self.addTelemetryInitializer = function(telemetryInitializer) {
       var theInitializer = {
        id: _id++,
        fn: telemetryInitializer
       };
       return _initializers[_DynamicConstants.MW](theInitializer), {
        remove: function() {
         (0, HelperFuncs.tO)(_initializers, (function(initializer, idx) {
          if (initializer.id === theInitializer.id) return _initializers[_DynamicConstants.cb](idx, 1), 
          -1;
         }));
        }
       };
      }, _self[InternalConstants.hL] = function(item, itemCtx) {
       for (var doNotSendItem = !1, telemetryInitializersCount = _initializers[_DynamicConstants.R5], i = 0; i < telemetryInitializersCount; ++i) {
        var telemetryInitializer = _initializers[i];
        if (telemetryInitializer) try {
         if (!1 === telemetryInitializer.fn[_DynamicConstants.ZV](null, [ item ])) {
          doNotSendItem = !0;
          break;
         }
        } catch (e) {
         (0, DiagnosticLogger.kP)(itemCtx[_DynamicConstants.mc](), 1, 64, "One of telemetry initializers failed, telemetry item will not be sent: " + (0, 
         HelperFuncs.jj)(e), {
          exception: (0, EnvUtils.eU)(e)
         }, !0);
        }
       }
       doNotSendItem || _self[_DynamicConstants.uL](item, itemCtx);
      }, _self[_DynamicConstants.F3] = function() {
       _initDefaults();
      };
     })), _this;
    }
    return (0, TsLibShims.ne)(TelemetryInitializerPlugin, _super), TelemetryInitializerPlugin.__ieDyn = 1, 
    TelemetryInitializerPlugin;
   }(BaseTelemetryPlugin.i), UnloadHandlerContainer = __webpack_require__(38593), defaultInitConfig = {
    loggingLevelConsole: 1
   };
   function _createPerfManager(core, notificationMgr) {
    return new PerfManager.Jk(notificationMgr);
   }
   function _isPluginPresent(thePlugin, plugins) {
    var exists = !1;
    return (0, HelperFuncs.tO)(plugins, (function(plugin) {
     if (plugin === thePlugin) return exists = !0, -1;
    })), exists;
   }
   var BaseCore = function() {
    function BaseCore() {
     var _config, _isInitialized, _eventQueue, _notificationManager, _perfManager, _cfgPerfManager, _cookieManager, _pluginChain, _configExtensions, _coreExtensions, _channelControl, _channelConfig, _channelQueue, _isUnloading, _telemetryInitializerPlugin, _internalLogsEventName, _evtNamespace, _unloadHandlers, _debugListener, _traceCtx, _internalLogPoller = 0, _forceStopInternalLogPoller = !1;
     (0, dynamicproto_js.Z)(BaseCore, this, (function(_self) {
      function _startInternalLogTimer(alwaysStart) {
       if (!_internalLogPoller && !_forceStopInternalLogPoller && (alwaysStart || _self[_DynamicConstants.eZ] && _self[_DynamicConstants.eZ].queue[_DynamicConstants.R5] > 0)) {
        var interval = (0, HelperFuncs.v4)(_config.diagnosticLogInterval);
        interval && interval > 0 || (interval = 1e4), _internalLogPoller = setInterval((function() {
         clearInterval(_internalLogPoller), _internalLogPoller = 0, _flushInternalLogs();
        }), interval);
       }
       return _internalLogPoller;
      }
      function _initDefaults() {
       _isInitialized = !1, _config = (0, HelperFuncs.mm)(!0, {}, defaultInitConfig), _self[_DynamicConstants.TC] = _config, 
       _self[_DynamicConstants.eZ] = new DiagnosticLogger.AQ(_config), _self[_DynamicConstants.iC] = [], 
       _telemetryInitializerPlugin = new TelemetryInitializerPlugin, _eventQueue = [], 
       _notificationManager = null, _perfManager = null, _cfgPerfManager = null, _cookieManager = null, 
       _pluginChain = null, _coreExtensions = null, _configExtensions = [], _channelControl = null, 
       _channelConfig = null, _channelQueue = null, _isUnloading = !1, _internalLogsEventName = null, 
       _evtNamespace = (0, DataCacheHelper.J)("AIBaseCore", !0), _unloadHandlers = (0, 
       UnloadHandlerContainer.Y)(), _traceCtx = null;
      }
      function _createTelCtx() {
       var theCtx = (0, ProcessTelemetryContext.CD)(_getPluginChain(), _config, _self);
       return theCtx[_DynamicConstants.Fc](_startInternalLogTimer), theCtx;
      }
      function _initPluginChain(updateState) {
       var theExtensions = function(logger, channelPriority, allExtensions) {
        var _a, coreExtensions = [], extPriorities = {};
        return (0, HelperFuncs.tO)(allExtensions, (function(ext) {
         ((0, HelperFuncs.le)(ext) || (0, HelperFuncs.le)(ext[_DynamicConstants.VL])) && (0, 
         HelperFuncs._y)("Plugins must provide initialize method");
         var extPriority = ext[InternalConstants.yi], identifier = ext[_DynamicConstants.pZ];
         ext && extPriority && ((0, HelperFuncs.le)(extPriorities[extPriority]) ? extPriorities[extPriority] = identifier : (0, 
         DiagnosticLogger.jV)(logger, "Two extensions have same priority #" + extPriority + " - " + extPriorities[extPriority] + ", " + identifier)), 
         (!extPriority || extPriority < channelPriority) && coreExtensions[_DynamicConstants.MW](ext);
        })), (_a = {
         all: allExtensions
        })[InternalConstants.oV] = coreExtensions, _a;
       }(_self[_DynamicConstants.eZ], ChannelControllerPriority, _configExtensions);
       _coreExtensions = theExtensions[InternalConstants.oV], _pluginChain = null;
       var allExtensions = theExtensions.all;
       if (_channelQueue = (0, HelperFuncs.FL)(function(channels, extensions, core) {
        var channelQueue = [];
        if (channels && (0, HelperFuncs.tO)(channels, (function(queue) {
         return _addChannelQueue(channelQueue, queue, core);
        })), extensions) {
         var extensionQueue_1 = [];
         (0, HelperFuncs.tO)(extensions, (function(plugin) {
          plugin[InternalConstants.yi] > ChannelControllerPriority && extensionQueue_1[_DynamicConstants.MW](plugin);
         })), _addChannelQueue(channelQueue, extensionQueue_1, core);
        }
        return channelQueue;
       }(_channelConfig, allExtensions, _self)), _channelControl) {
        var idx = (0, HelperFuncs.UA)(allExtensions, _channelControl);
        -1 !== idx && allExtensions[_DynamicConstants.cb](idx, 1), -1 !== (idx = (0, HelperFuncs.UA)(_coreExtensions, _channelControl)) && _coreExtensions[_DynamicConstants.cb](idx, 1), 
        _channelControl._setQueue(_channelQueue);
       } else _channelControl = function(channelQueue, core) {
        function _getTelCtx() {
         return (0, ProcessTelemetryContext.CD)(null, core[_DynamicConstants.TC], core, null);
        }
        function _processChannelQueue(theChannels, itemCtx, processFn, onComplete) {
         var waiting = theChannels ? theChannels[_DynamicConstants.R5] + 1 : 1;
         function _runChainOnComplete() {
          0 == --waiting && (onComplete && onComplete(), onComplete = null);
         }
         waiting > 0 && (0, HelperFuncs.tO)(theChannels, (function(channels) {
          if (channels && channels.queue[_DynamicConstants.R5] > 0) {
           var channelChain = channels.chain, chainCtx = itemCtx[_DynamicConstants.zV](channelChain);
           chainCtx[_DynamicConstants.Fc](_runChainOnComplete), processFn(chainCtx);
          } else waiting--;
         })), _runChainOnComplete();
        }
        var isInitialized = !1, channelController = {
         identifier: "ChannelControllerPlugin",
         priority: ChannelControllerPriority,
         initialize: function(config, core, extensions, pluginChain) {
          isInitialized = !0, (0, HelperFuncs.tO)(channelQueue, (function(channels) {
           channels && channels.queue[_DynamicConstants.R5] > 0 && (0, TelemetryHelpers.bP)((0, 
           ProcessTelemetryContext.CD)(channels.chain, config, core), extensions);
          }));
         },
         isInitialized: function() {
          return isInitialized;
         },
         processTelemetry: function(item, itemCtx) {
          _processChannelQueue(channelQueue, itemCtx || _getTelCtx(), (function(chainCtx) {
           chainCtx[_DynamicConstants.uL](item);
          }), (function() {
           itemCtx[_DynamicConstants.uL](item);
          }));
         },
         update: function(updateCtx, updateState) {
          var theUpdateState = updateState || {
           reason: 0
          };
          return _processChannelQueue(channelQueue, updateCtx, (function(chainCtx) {
           chainCtx[_DynamicConstants.uL](theUpdateState);
          }), (function() {
           updateCtx[_DynamicConstants.uL](theUpdateState);
          })), !0;
         },
         pause: function() {
          _processChannelQueue(channelQueue, _getTelCtx(), (function(chainCtx) {
           chainCtx.iterate((function(plugin) {
            plugin.pause && plugin.pause();
           }));
          }), null);
         },
         resume: function() {
          _processChannelQueue(channelQueue, _getTelCtx(), (function(chainCtx) {
           chainCtx.iterate((function(plugin) {
            plugin.resume && plugin.resume();
           }));
          }), null);
         },
         teardown: function(unloadCtx, unloadState) {
          var theUnloadState = unloadState || {
           reason: 0,
           isAsync: !1
          };
          return _processChannelQueue(channelQueue, unloadCtx, (function(chainCtx) {
           chainCtx[_DynamicConstants.uL](theUnloadState);
          }), (function() {
           unloadCtx[_DynamicConstants.uL](theUnloadState), isInitialized = !1;
          })), !0;
         },
         getChannel: function(pluginIdentifier) {
          var thePlugin = null;
          return channelQueue && channelQueue[_DynamicConstants.R5] > 0 && (0, HelperFuncs.tO)(channelQueue, (function(channels) {
           if (channels && channels.queue[_DynamicConstants.R5] > 0 && ((0, HelperFuncs.tO)(channels.queue, (function(ext) {
            if (ext[_DynamicConstants.pZ] === pluginIdentifier) return thePlugin = ext, -1;
           })), thePlugin)) return -1;
          })), thePlugin;
         },
         flush: function(isAsync, callBack, sendReason, cbTimeout) {
          var waiting = 1, doneIterating = !1, cbTimer = null;
          function doCallback() {
           waiting--, doneIterating && 0 === waiting && (cbTimer && (clearTimeout(cbTimer), 
           cbTimer = null), callBack && callBack(doneIterating), callBack = null);
          }
          return cbTimeout = cbTimeout || 5e3, _processChannelQueue(channelQueue, _getTelCtx(), (function(chainCtx) {
           chainCtx.iterate((function(plugin) {
            if (plugin[_DynamicConstants.kL]) {
             waiting++;
             var handled_1 = !1;
             plugin[_DynamicConstants.kL](isAsync, (function() {
              handled_1 = !0, doCallback();
             }), sendReason) || handled_1 || (isAsync && null == cbTimer ? cbTimer = setTimeout((function() {
              cbTimer = null, doCallback();
             }), cbTimeout) : doCallback());
            }
           }));
          }), (function() {
           doneIterating = !0, doCallback();
          })), !0;
         },
         _setQueue: function(queue) {
          channelQueue = queue;
         }
        };
        return channelController;
       }(_channelQueue, _self);
       allExtensions[_DynamicConstants.MW](_channelControl), _coreExtensions[_DynamicConstants.MW](_channelControl), 
       _self[_DynamicConstants.iC] = (0, TelemetryHelpers.AA)(allExtensions), _channelControl[_DynamicConstants.VL](_config, _self, allExtensions);
       var initCtx = _createTelCtx();
       (0, TelemetryHelpers.bP)(initCtx, allExtensions), _self[_DynamicConstants.iC] = (0, 
       HelperFuncs.FL)((0, TelemetryHelpers.AA)(_coreExtensions || [])).slice(), updateState && function(updateState) {
        var updateCtx = (0, ProcessTelemetryContext.xy)(_getPluginChain(), _self);
        updateCtx[_DynamicConstants.Fc](_startInternalLogTimer), _self._updateHook && !0 === _self._updateHook(updateCtx, updateState) || updateCtx[_DynamicConstants.uL](updateState);
       }(updateState);
      }
      function _getPlugin(pluginIdentifier) {
       var _a, theExt = null, thePlugin = null;
       return (0, HelperFuncs.tO)(_self[_DynamicConstants.iC], (function(ext) {
        if (ext[_DynamicConstants.pZ] === pluginIdentifier && ext !== _channelControl && ext !== _telemetryInitializerPlugin) return thePlugin = ext, 
        -1;
       })), !thePlugin && _channelControl && (thePlugin = _channelControl.getChannel(pluginIdentifier)), 
       thePlugin && ((_a = {
        plugin: thePlugin
       })[_DynamicConstants.$h] = function(enabled) {
        (0, TelemetryHelpers.OY)(thePlugin)[InternalConstants.mE] = !enabled;
       }, _a.isEnabled = function() {
        var pluginState = (0, TelemetryHelpers.OY)(thePlugin);
        return !pluginState[_DynamicConstants.fi] && !pluginState[InternalConstants.mE];
       }, _a.remove = function(isAsync, removeCb) {
        var _a;
        void 0 === isAsync && (isAsync = !0);
        var pluginsToRemove = [ thePlugin ], unloadState = ((_a = {
         reason: 1
        })[_DynamicConstants.d] = isAsync, _a);
        _removePlugins(pluginsToRemove, unloadState, (function(removed) {
         removed && _initPluginChain({
          reason: 32,
          removed: pluginsToRemove
         }), removeCb && removeCb(removed);
        }));
       }, theExt = _a), theExt;
      }
      function _getPluginChain() {
       if (!_pluginChain) {
        var extensions = (_coreExtensions || []).slice();
        -1 === (0, HelperFuncs.UA)(extensions, _telemetryInitializerPlugin) && extensions[_DynamicConstants.MW](_telemetryInitializerPlugin), 
        _pluginChain = (0, ProcessTelemetryContext.jV)((0, TelemetryHelpers.AA)(extensions), _config, _self);
       }
       return _pluginChain;
      }
      function _removePlugins(thePlugins, unloadState, removeComplete) {
       if (thePlugins && thePlugins[_DynamicConstants.R5] > 0) {
        var unloadChain = (0, ProcessTelemetryContext.jV)(thePlugins, _config, _self), unloadCtx = (0, 
        ProcessTelemetryContext.Bt)(unloadChain, _self);
        unloadCtx[_DynamicConstants.Fc]((function() {
         var removed = !1, newConfigExtensions = [];
         (0, HelperFuncs.tO)(_configExtensions, (function(plugin, idx) {
          _isPluginPresent(plugin, thePlugins) ? removed = !0 : newConfigExtensions[_DynamicConstants.MW](plugin);
         })), _configExtensions = newConfigExtensions;
         var newChannelConfig = [];
         _channelConfig && ((0, HelperFuncs.tO)(_channelConfig, (function(queue, idx) {
          var newQueue = [];
          (0, HelperFuncs.tO)(queue, (function(channel) {
           _isPluginPresent(channel, thePlugins) ? removed = !0 : newQueue[_DynamicConstants.MW](channel);
          })), newChannelConfig[_DynamicConstants.MW](newQueue);
         })), _channelConfig = newChannelConfig), removeComplete && removeComplete(removed), 
         _startInternalLogTimer();
        })), unloadCtx[_DynamicConstants.uL](unloadState);
       } else removeComplete(!1);
      }
      function _flushInternalLogs() {
       if (_self[_DynamicConstants.eZ] && _self[_DynamicConstants.eZ].queue) {
        var queue = _self[_DynamicConstants.eZ].queue.slice(0);
        _self[_DynamicConstants.eZ].queue[_DynamicConstants.R5] = 0, (0, HelperFuncs.tO)(queue, (function(logMessage) {
         var _a, item = ((_a = {})[_DynamicConstants.I] = _internalLogsEventName || "InternalMessageId: " + logMessage[_DynamicConstants.Gc], 
         _a.iKey = (0, HelperFuncs.v4)(_config[_DynamicConstants.p$]), _a.time = (0, HelperFuncs.Y6)(new Date), 
         _a.baseType = DiagnosticLogger.lQ.dataType, _a.baseData = {
          message: logMessage[_DynamicConstants.gU]
         }, _a);
         _self.track(item);
        }));
       }
      }
      function _flushChannels(isAsync, callBack, sendReason, cbTimeout) {
       return _channelControl ? _channelControl[_DynamicConstants.kL](isAsync, callBack, sendReason || 6, cbTimeout) : (callBack && callBack(!1), 
       !0);
      }
      function _logOrThrowError(message) {
       var logger = _self[_DynamicConstants.eZ];
       logger ? ((0, DiagnosticLogger.kP)(logger, 2, 73, message), _startInternalLogTimer()) : (0, 
       HelperFuncs._y)(message);
      }
      _initDefaults(), _self[_DynamicConstants.yl] = function() {
       return _isInitialized;
      }, _self[_DynamicConstants.VL] = function(config, extensions, logger, notificationManager) {
       _isUnloading && (0, HelperFuncs._y)("SDK is still unloading..."), _self[_DynamicConstants.yl]() && (0, 
       HelperFuncs._y)("Core should not be initialized more than once"), _config = config || {}, 
       _self[_DynamicConstants.TC] = _config, (0, HelperFuncs.le)(config[_DynamicConstants.p$]) && (0, 
       HelperFuncs._y)("Please provide instrumentation key"), _notificationManager = notificationManager, 
       _self._notificationManager = notificationManager, function() {
        var disableDbgExt = (0, HelperFuncs.v4)(_config.disableDbgExt);
        !0 === disableDbgExt && _debugListener && (_notificationManager[_DynamicConstants.n7](_debugListener), 
        _debugListener = null);
        _notificationManager && !_debugListener && !0 !== disableDbgExt && (_debugListener = (0, 
        DbgExtensionUtils.p)(_config), _notificationManager[_DynamicConstants.g](_debugListener));
       }(), function() {
        var enablePerfMgr = (0, HelperFuncs.v4)(_config.enablePerfMgr);
        !enablePerfMgr && _cfgPerfManager && (_cfgPerfManager = null);
        enablePerfMgr && (0, HelperFuncs.qK)(_config, InternalConstants.DN, _createPerfManager);
       }(), (0, HelperFuncs.qK)(_config, InternalConstants.Zh, {}).NotificationManager = _notificationManager, 
       logger && (_self[_DynamicConstants.eZ] = logger);
       var cfgExtensions = (0, HelperFuncs.qK)(_config, InternalConstants.js, []);
       (_configExtensions = [])[_DynamicConstants.MW].apply(_configExtensions, (0, TsLibShims.$h)((0, 
       TsLibShims.$h)([], extensions, !1), cfgExtensions, !1)), _channelConfig = (0, HelperFuncs.qK)(_config, InternalConstants.Z, []), 
       _initPluginChain(null), _channelQueue && 0 !== _channelQueue[_DynamicConstants.R5] || (0, 
       HelperFuncs._y)("No " + InternalConstants.Z + " available"), _isInitialized = !0, 
       _self.releaseQueue();
      }, _self.getTransmissionControls = function() {
       var controls = [];
       return _channelQueue && (0, HelperFuncs.tO)(_channelQueue, (function(channels) {
        controls[_DynamicConstants.MW](channels.queue);
       })), (0, HelperFuncs.FL)(controls);
      }, _self.track = function(telemetryItem) {
       telemetryItem.iKey = telemetryItem.iKey || _config[_DynamicConstants.p$], telemetryItem[_DynamicConstants.Z_] = telemetryItem[_DynamicConstants.Z_] || (0, 
       HelperFuncs.Y6)(new Date), telemetryItem.ver = telemetryItem.ver || "4.0", !_isUnloading && _self[_DynamicConstants.yl]() ? _createTelCtx()[_DynamicConstants.uL](telemetryItem) : _eventQueue[_DynamicConstants.MW](telemetryItem);
      }, _self[_DynamicConstants.SD] = _createTelCtx, _self[_DynamicConstants.tb] = function() {
       return _notificationManager || (_notificationManager = function() {
        var _a;
        return (0, Helpers.pu)(((_a = {})[_DynamicConstants.g] = function(listener) {}, 
        _a[_DynamicConstants.n7] = function(listener) {}, _a[InternalConstants.uC] = function(events) {}, 
        _a[InternalConstants.$F] = function(events, reason) {}, _a[InternalConstants.f_] = function(sendReason, isAsync) {}, 
        _a));
       }(), _self._notificationManager = _notificationManager), _notificationManager;
      }, _self[_DynamicConstants.g] = function(listener) {
       _notificationManager && _notificationManager[_DynamicConstants.g](listener);
      }, _self[_DynamicConstants.n7] = function(listener) {
       _notificationManager && _notificationManager[_DynamicConstants.n7](listener);
      }, _self.getCookieMgr = function() {
       return _cookieManager || (_cookieManager = (0, CookieMgr.Nz)(_config, _self[_DynamicConstants.eZ])), 
       _cookieManager;
      }, _self.setCookieMgr = function(cookieMgr) {
       _cookieManager = cookieMgr;
      }, _self[InternalConstants.kl] = function() {
       if (!_perfManager && !_cfgPerfManager && (0, HelperFuncs.v4)(_config.enablePerfMgr)) {
        var createPerfMgr = (0, HelperFuncs.v4)(_config[InternalConstants.DN]);
        (0, HelperFuncs.mf)(createPerfMgr) && (_cfgPerfManager = createPerfMgr(_self, _self[_DynamicConstants.tb]()));
       }
       return _perfManager || _cfgPerfManager || (0, PerfManager.j5)();
      }, _self.setPerfMgr = function(perfMgr) {
       _perfManager = perfMgr;
      }, _self.eventCnt = function() {
       return _eventQueue[_DynamicConstants.R5];
      }, _self.releaseQueue = function() {
       if (_isInitialized && _eventQueue[_DynamicConstants.R5] > 0) {
        var eventQueue = _eventQueue;
        _eventQueue = [], (0, HelperFuncs.tO)(eventQueue, (function(event) {
         _createTelCtx()[_DynamicConstants.uL](event);
        }));
       }
      }, _self.pollInternalLogs = function(eventName) {
       return _internalLogsEventName = eventName || null, _forceStopInternalLogPoller = !1, 
       _internalLogPoller && (clearInterval(_internalLogPoller), _internalLogPoller = null), 
       _startInternalLogTimer(!0);
      }, _self[_DynamicConstants.LS] = function() {
       _forceStopInternalLogPoller = !0, _internalLogPoller && (clearInterval(_internalLogPoller), 
       _internalLogPoller = 0, _flushInternalLogs());
      }, (0, HelperFuncs.Vb)(_self, (function() {
       return _telemetryInitializerPlugin;
      }), [ "addTelemetryInitializer" ]), _self.unload = function(isAsync, unloadComplete, cbTimeout) {
       var _a;
       void 0 === isAsync && (isAsync = !0), _isInitialized || (0, HelperFuncs._y)("SDK is not initialized"), 
       _isUnloading && (0, HelperFuncs._y)("SDK is still unloading...");
       var unloadState = ((_a = {
        reason: 50
       })[_DynamicConstants.d] = isAsync, _a.flushComplete = !1, _a), processUnloadCtx = (0, 
       ProcessTelemetryContext.Bt)(_getPluginChain(), _self);
       function _doUnload(flushComplete) {
        unloadState.flushComplete = flushComplete, _isUnloading = !0, _unloadHandlers.run(processUnloadCtx, unloadState), 
        _self[_DynamicConstants.LS](), processUnloadCtx[_DynamicConstants.uL](unloadState);
       }
       processUnloadCtx[_DynamicConstants.Fc]((function() {
        _initDefaults(), unloadComplete && unloadComplete(unloadState);
       }), _self), _flushInternalLogs(), _flushChannels(isAsync, _doUnload, 6, cbTimeout) || _doUnload(!1);
      }, _self[_DynamicConstants.TO] = _getPlugin, _self.addPlugin = function(plugin, replaceExisting, isAsync, addCb) {
       if (!plugin) return addCb && addCb(!1), void _logOrThrowError("Plugins must provide initialize method");
       var existingPlugin = _getPlugin(plugin[_DynamicConstants.pZ]);
       if (existingPlugin && !replaceExisting) return addCb && addCb(!1), void _logOrThrowError("Plugin [" + plugin[_DynamicConstants.pZ] + "] is already loaded!");
       var updateState = {
        reason: 16
       };
       function _addPlugin(removed) {
        _configExtensions[_DynamicConstants.MW](plugin), updateState.added = [ plugin ], 
        _initPluginChain(updateState), addCb && addCb(!0);
       }
       if (existingPlugin) {
        var removedPlugins_1 = [ existingPlugin.plugin ];
        _removePlugins(removedPlugins_1, {
         reason: 2,
         isAsync: !!isAsync
        }, (function(removed) {
         removed ? (updateState.removed = removedPlugins_1, updateState.reason |= 32, _addPlugin()) : addCb && addCb(!1);
        }));
       } else _addPlugin();
      }, _self.evtNamespace = function() {
       return _evtNamespace;
      }, _self[_DynamicConstants.kL] = _flushChannels, _self.getTraceCtx = function(createNew) {
       return _traceCtx || (_traceCtx = (0, TelemetryHelpers.Yn)()), _traceCtx;
      }, _self.setTraceCtx = function(traceCtx) {
       _traceCtx = traceCtx || null;
      }, (0, HelperFuncs.Oi)(_self, "addUnloadCb", (function() {
       return _unloadHandlers;
      }), "add");
     }));
    }
    return BaseCore.__ieDyn = 1, BaseCore;
   }();
   function _runListeners(listeners, name, isAsync, callback) {
    (0, HelperFuncs.tO)(listeners, (function(listener) {
     if (listener && listener[name]) if (isAsync) setTimeout((function() {
      return callback(listener);
     }), 0); else try {
      callback(listener);
     } catch (e) {}
    }));
   }
   var NotificationManager = function() {
    function NotificationManager(config) {
     this.listeners = [];
     var perfEvtsSendAll = !!(config || {}).perfEvtsSendAll;
     (0, dynamicproto_js.Z)(NotificationManager, this, (function(_self) {
      _self[_DynamicConstants.g] = function(listener) {
       _self.listeners[_DynamicConstants.MW](listener);
      }, _self[_DynamicConstants.n7] = function(listener) {
       for (var index = (0, HelperFuncs.UA)(_self[_DynamicConstants.dE], listener); index > -1; ) _self.listeners[_DynamicConstants.cb](index, 1), 
       index = (0, HelperFuncs.UA)(_self[_DynamicConstants.dE], listener);
      }, _self[InternalConstants.uC] = function(events) {
       _runListeners(_self[_DynamicConstants.dE], InternalConstants.uC, !0, (function(listener) {
        listener[InternalConstants.uC](events);
       }));
      }, _self[InternalConstants.$F] = function(events, reason) {
       _runListeners(_self[_DynamicConstants.dE], InternalConstants.$F, !0, (function(listener) {
        listener[InternalConstants.$F](events, reason);
       }));
      }, _self[InternalConstants.f_] = function(sendReason, isAsync) {
       _runListeners(_self[_DynamicConstants.dE], InternalConstants.f_, isAsync, (function(listener) {
        listener[InternalConstants.f_](sendReason, isAsync);
       }));
      }, _self[InternalConstants.C$] = function(perfEvent) {
       perfEvent && (!perfEvtsSendAll && perfEvent[_DynamicConstants.PL]() || _runListeners(_self[_DynamicConstants.dE], InternalConstants.C$, !1, (function(listener) {
        perfEvent[_DynamicConstants.d] ? setTimeout((function() {
         return listener[InternalConstants.C$](perfEvent);
        }), 0) : listener[InternalConstants.C$](perfEvent);
       })));
      };
     }));
    }
    return NotificationManager.__ieDyn = 1, NotificationManager;
   }(), AppInsightsCore = function(_super) {
    function AppInsightsCore() {
     var _this = _super.call(this) || this;
     return (0, dynamicproto_js.Z)(AppInsightsCore, _this, (function(_self, _base) {
      function _notifyInvalidEvent(telemetryItem) {
       var manager = _self[_DynamicConstants.tb]();
       manager && manager[InternalConstants.$F]([ telemetryItem ], 2);
      }
      _self[_DynamicConstants.VL] = function(config, extensions, logger, notificationManager) {
       _base[_DynamicConstants.VL](config, extensions, logger || new DiagnosticLogger.AQ(config), notificationManager || new NotificationManager(config));
      }, _self.track = function(telemetryItem) {
       (0, PerfManager.Lm)(_self[InternalConstants.kl](), (function() {
        return "AppInsightsCore:track";
       }), (function() {
        null === telemetryItem && (_notifyInvalidEvent(telemetryItem), (0, HelperFuncs._y)("Invalid telemetry item")), 
        function(telemetryItem) {
         (0, HelperFuncs.le)(telemetryItem[_DynamicConstants.I]) && (_notifyInvalidEvent(telemetryItem), 
         (0, HelperFuncs._y)("telemetry name required"));
        }(telemetryItem), _base.track(telemetryItem);
       }), (function() {
        return {
         item: telemetryItem
        };
       }), !telemetryItem.sync);
      };
     })), _this;
    }
    return (0, TsLibShims.ne)(AppInsightsCore, _super), AppInsightsCore.__ieDyn = 1, 
    AppInsightsCore;
   }(BaseCore), src_InternalConstants = __webpack_require__(51539), Utils = __webpack_require__(65705), AppInsightsCore_AppInsightsCore = function(_super) {
    function AppInsightsCore() {
     var _this = _super.call(this) || this;
     return _this.pluginVersionStringArr = [], (0, dynamicproto_js.Z)(AppInsightsCore, _this, (function(_self, _base) {
      _self.logger && _self.logger.queue || (_self.logger = new DiagnosticLogger.AQ({
       loggingLevelConsole: 1
      })), _self.initialize = function(config, extensions, logger, notificationManager) {
       (0, PerfManager.Lm)(_self, (function() {
        return "AppInsightsCore.initialize";
       }), (function() {
        var _pluginVersionStringArr = _self.pluginVersionStringArr;
        if (config) {
         config.endpointUrl || (config.endpointUrl = src_InternalConstants.YT);
         var propertyStorageOverride = config.propertyStorageOverride;
         !propertyStorageOverride || propertyStorageOverride.getProperty && propertyStorageOverride.setProperty || (0, 
         HelperFuncs._y)("Invalid property storage override passed."), config.channels && (0, 
         HelperFuncs.tO)(config.channels, (function(channels) {
          channels && (0, HelperFuncs.tO)(channels, (function(channel) {
           if (channel.identifier && channel.version) {
            var ver = channel.identifier + "=" + channel.version;
            _pluginVersionStringArr.push(ver);
           }
          }));
         }));
        }
        _self.getWParam = function() {
         return "undefined" != typeof document || config.enableWParam ? 0 : -1;
        }, extensions && (0, HelperFuncs.tO)(extensions, (function(ext) {
         if (ext && ext.identifier && ext.version) {
          var ver = ext.identifier + "=" + ext.version;
          _pluginVersionStringArr.push(ver);
         }
        })), _self.pluginVersionString = _pluginVersionStringArr.join(";"), _self.pluginVersionStringArr = _pluginVersionStringArr;
        try {
         _base.initialize(config, extensions, logger, notificationManager), _self.pollInternalLogs("InternalLog");
        } catch (e) {
         var logger_1 = _self.logger, message = (0, EnvUtils.eU)(e);
         -1 !== message.indexOf("channels") && (message += "\n - Channels must be provided through config.channels only!"), 
         (0, DiagnosticLogger.kP)(logger_1, 1, 514, "SDK Initialization Failed - no telemetry will be sent: " + message);
        }
       }), (function() {
        return {
         config,
         extensions,
         logger,
         notificationManager
        };
       }));
      }, _self.track = function(item) {
       (0, PerfManager.Lm)(_self, (function() {
        return "AppInsightsCore.track";
       }), (function() {
        var telemetryItem = item;
        if (telemetryItem) {
         telemetryItem.timings = telemetryItem.timings || {}, telemetryItem.timings.trackStart = (0, 
         Utils.hK)(), (0, Utils.r7)(telemetryItem.latency) || (telemetryItem.latency = 1);
         var itemExt = telemetryItem.ext = telemetryItem.ext || {};
         itemExt.sdk = itemExt.sdk || {}, itemExt.sdk.ver = Utils.vs;
         var baseData = telemetryItem.baseData = telemetryItem.baseData || {};
         baseData[src_InternalConstants.o6] = baseData[src_InternalConstants.o6] || {};
         var itemProperties = baseData[src_InternalConstants.o6];
         itemProperties[src_InternalConstants.p8] = itemProperties[src_InternalConstants.p8] || _self.pluginVersionString || src_InternalConstants.qS;
        }
        _base.track(telemetryItem);
       }), (function() {
        return {
         item
        };
       }), !item.sync);
      };
     })), _this;
    }
    return (0, TsLibShims.ne)(AppInsightsCore, _super), AppInsightsCore.__ieDyn = 1, 
    AppInsightsCore;
   }(AppInsightsCore);
   const src_AppInsightsCore = AppInsightsCore_AppInsightsCore;
   var BaseCore_BaseCore = function(_super) {
    function BaseCore() {
     var _this = _super.call(this) || this;
     return (0, dynamicproto_js.Z)(BaseCore, _this, (function(_self, _base) {
      _self.initialize = function(config, extensions, logger, notificationManager) {
       config && !config.endpointUrl && (config.endpointUrl = src_InternalConstants.YT), 
       _self.getWParam = function() {
        return Utils.x9 || config.enableWParam ? 0 : -1;
       };
       try {
        _base.initialize(config, extensions, logger, notificationManager);
       } catch (e) {
        (0, DiagnosticLogger.kP)(_self.logger, 1, 514, "Initialization Failed: " + (0, EnvUtils.eU)(e) + "\n - Note: Channels must be provided through config.channels only");
       }
      }, _self.track = function(item) {
       var telemetryItem = item;
       if (telemetryItem) {
        var ext = telemetryItem.ext = telemetryItem.ext || {};
        ext.sdk = ext.sdk || {}, ext.sdk.ver = Utils.vs;
       }
       _base.track(telemetryItem);
      };
     })), _this;
    }
    return (0, TsLibShims.ne)(BaseCore, _super), BaseCore.__ieDyn = 1, BaseCore;
   }(BaseCore);
   const src_BaseCore = BaseCore_BaseCore;
   var _isFunction = HelperFuncs.mf;
   function _createPromiseAllOnResolvedFunction(values, index, resolvedCallback) {
    return function(value) {
     values[index] = value, resolvedCallback();
    };
   }
   const src_ESPromise = function() {
    function ESPromise(resolverFunc) {
     var _state = 0, _settledValue = null, _queue = [];
     function _processQueue() {
      if (_queue.length > 0) {
       var pending_1 = _queue.slice();
       _queue = [], setTimeout((function() {
        for (var i = 0, len = pending_1.length; i < len; ++i) try {
         pending_1[i]();
        } catch (e) {}
       }), 0);
      }
     }
     function _resolve(value) {
      0 === _state && (_settledValue = value, _state = 1, _processQueue());
     }
     function _reject(reason) {
      0 === _state && (_settledValue = reason, _state = 2, _processQueue());
     }
     (0, dynamicproto_js.Z)(ESPromise, this, (function(_this) {
      _this.then = function(onResolved, onRejected) {
       return new ESPromise((function(resolve, reject) {
        !function(onResolved, onRejected, resolve, reject) {
         _queue.push((function() {
          var value;
          try {
           (value = 1 === _state ? _isFunction(onResolved) ? onResolved(_settledValue) : _settledValue : _isFunction(onRejected) ? onRejected(_settledValue) : _settledValue) instanceof ESPromise ? value.then(resolve, reject) : 2 !== _state || _isFunction(onRejected) ? resolve(value) : reject(value);
          } catch (error) {
           return void reject(error);
          }
         })), 0 !== _state && _processQueue();
        }(onResolved, onRejected, resolve, reject);
       }));
      }, _this.catch = function(onRejected) {
       return _this.then(null, onRejected);
      };
     })), function() {
      if (!_isFunction(resolverFunc)) throw new TypeError("ESPromise: resolvedFunc argument is not a Function");
      try {
       resolverFunc(_resolve, _reject);
      } catch (error) {
       _reject(error);
      }
     }();
    }
    return ESPromise.resolve = function(value) {
     return value instanceof ESPromise ? value : value && _isFunction(value.then) ? new ESPromise((function(resolve, reject) {
      try {
       value.then(resolve, reject);
      } catch (error) {
       reject(error);
      }
     })) : new ESPromise((function(resolve) {
      resolve(value);
     }));
    }, ESPromise.reject = function(reason) {
     return new ESPromise((function(resolve, reject) {
      reject(reason);
     }));
    }, ESPromise.all = function(iterable) {
     if (iterable && iterable.length) return new ESPromise((function(resolve, reject) {
      try {
       for (var values_1 = [], pending_2 = 0, lp = 0; lp < iterable.length; lp++) {
        var item = iterable[lp];
        item && _isFunction(item.then) ? (pending_2++, item.then(_createPromiseAllOnResolvedFunction(values_1, lp, (function() {
         0 == --pending_2 && resolve(values_1);
        })), reject)) : values_1[lp] = item;
       }
       0 === pending_2 && setTimeout((function() {
        resolve(values_1);
       }), 0);
      } catch (error) {
       reject(error);
      }
     }));
    }, ESPromise.race = function(iterable) {
     return new ESPromise((function(resolve, reject) {
      if (iterable && iterable.length) try {
       for (var _loop_1 = function(lp) {
        var item = iterable[lp];
        item && _isFunction(item.then) ? item.then(resolve, reject) : setTimeout((function() {
         resolve(item);
        }), 0);
       }, lp = 0; lp < iterable.length; lp++) _loop_1(lp);
      } catch (error) {
       reject(error);
      }
     }));
    }, ESPromise;
   }();
   var _schedulerId = 0, _running = [], _waiting = [], _timedOut = [];
   function _getTime() {
    return (new Date).getTime();
   }
   const src_ESPromiseScheduler = function() {
    function ESPromiseScheduler(name, diagLog) {
     var _promiseId = 0, _scheduledName = (name || "<unnamed>") + "." + _schedulerId;
     function _debugLog(message) {
      var global = (0, Helpers.Rd)();
      global && global.QUnit && console && console.log("ESPromiseScheduler[" + _scheduledName + "] " + message);
     }
     function _warnLog(message) {
      (0, DiagnosticLogger.jV)(diagLog, "ESPromiseScheduler[" + _scheduledName + "] " + message);
     }
     _schedulerId++, (0, dynamicproto_js.Z)(ESPromiseScheduler, this, (function(_this) {
      var _lastEvent = null, _eventCount = 0;
      function _removeQueuedEvent(queue, eventId) {
       for (var lp = 0; lp < queue.length; lp++) if (queue[lp].id === eventId) return queue.splice(lp, 1)[0];
       return null;
      }
      _this.scheduleEvent = function(startEventAction, eventName, timeout) {
       var uniqueId = _scheduledName + "." + _eventCount;
       _eventCount++, eventName && (uniqueId += "-(" + eventName + ")");
       var uniqueEventId = uniqueId + "{" + _promiseId + "}";
       _promiseId++;
       var eventDetails, waitForEvent, waitEvent, newScheduledEvent = {
        evt: null,
        tm: _getTime(),
        id: uniqueEventId,
        isRunning: !1,
        isAborted: !1
       };
       return newScheduledEvent.evt = _lastEvent ? (eventDetails = newScheduledEvent, waitForEvent = _lastEvent, 
       waitEvent = new src_ESPromise((function(waitResolve, waitReject) {
        var runTime = _getTime() - waitForEvent.tm, prevId = waitForEvent.id;
        _debugLog("[" + uniqueId + "] is waiting for [" + prevId + ":" + runTime + " ms] to complete before starting -- [" + _waiting.length + "] waiting and [" + _running.length + "] running"), 
        eventDetails.abort = function(message) {
         eventDetails.abort = null, _removeQueuedEvent(_waiting, uniqueId), eventDetails.isAborted = !0, 
         waitReject(new Error(message));
        }, waitForEvent.evt.then((function(value) {
         _removeQueuedEvent(_waiting, uniqueId), _startWaitingEvent(eventDetails).then(waitResolve, waitReject);
        }), (function(reason) {
         _removeQueuedEvent(_waiting, uniqueId), _startWaitingEvent(eventDetails).then(waitResolve, waitReject);
        }));
       })), _waiting.push(eventDetails), waitEvent) : _startWaitingEvent(newScheduledEvent), 
       (_lastEvent = newScheduledEvent).evt._schId = uniqueEventId, newScheduledEvent.evt;
       function _abortAndRemoveOldEvents(eventQueue) {
        for (var now = _getTime(), expired = now - 6e5, len = eventQueue.length, lp = 0; lp < len; ) {
         var evt = eventQueue[lp];
         if (evt && evt.tm < expired) {
          var message = null;
          evt.abort ? (message = "Aborting [" + evt.id + "] due to Excessive runtime (" + (now - evt.tm) + " ms)", 
          evt.abort(message)) : message = "Removing [" + evt.id + "] due to Excessive runtime (" + (now - evt.tm) + " ms)", 
          _warnLog(message), eventQueue.splice(lp, 1), len--;
         } else lp++;
        }
       }
       function _cleanup(eventId, completed) {
        var toQueue = !1, removed = _removeQueuedEvent(_running, eventId);
        if (removed || (removed = _removeQueuedEvent(_timedOut, eventId), toQueue = !0), 
        removed) {
         removed.to && (clearTimeout(removed.to), removed.to = null);
         var tm = _getTime() - removed.tm;
         completed ? toQueue ? _warnLog("Timed out event [" + eventId + "] finally complete -- " + tm + " ms") : _debugLog("Promise [" + eventId + "] Complete -- " + tm + " ms") : (_timedOut.push(removed), 
         _warnLog("Event [" + eventId + "] Timed out and removed -- " + tm + " ms"));
        } else _debugLog("Failed to remove [" + eventId + "] from running queue");
        _lastEvent && _lastEvent.id === eventId && (_lastEvent = null), _abortAndRemoveOldEvents(_running), 
        _abortAndRemoveOldEvents(_waiting), _abortAndRemoveOldEvents(_timedOut);
       }
       function _removeScheduledEvent(eventId, callback) {
        return function(value) {
         return _cleanup(eventId, !0), callback && callback(value), value;
        };
       }
       function _waitForFinalResult(eventId, startResult, schEventResolve, schEventReject) {
        startResult.then((function(value) {
         return value instanceof src_ESPromise ? (_debugLog("Event [" + eventId + "] returned a promise -- waiting"), 
         _waitForFinalResult(eventId, value, schEventResolve, schEventReject), value) : _removeScheduledEvent(eventId, schEventResolve)(value);
        }), _removeScheduledEvent(eventId, schEventReject));
       }
       function _createScheduledEvent(eventDetails, startEvent) {
        var eventId = eventDetails.id;
        return new src_ESPromise((function(schEventResolve, schEventReject) {
         _debugLog("Event [" + eventId + "] Starting -- waited for " + (eventDetails.wTm || "--") + " ms"), 
         eventDetails.isRunning = !0, eventDetails.abort = function(message) {
          eventDetails.abort = null, eventDetails.isAborted = !0, _cleanup(eventId, !1), schEventReject(new Error(message));
         };
         var startResult = startEvent(eventId);
         startResult instanceof src_ESPromise ? (timeout && (eventDetails.to = setTimeout((function() {
          _cleanup(eventId, !1), schEventReject(new Error("Timed out after [" + timeout + "] ms"));
         }), timeout)), _waitForFinalResult(eventId, startResult, (function(theResult) {
          _debugLog("Event [" + eventId + "] Resolving after " + (_getTime() - eventDetails.tm) + " ms"), 
          schEventResolve(theResult);
         }), schEventReject)) : (_debugLog("Promise [" + eventId + "] Auto completed as the start action did not return a promise"), 
         schEventResolve());
        }));
       }
       function _startWaitingEvent(eventDetails) {
        var now = _getTime();
        return eventDetails.wTm = now - eventDetails.tm, eventDetails.tm = now, eventDetails.isAborted ? src_ESPromise.reject(new Error("[" + uniqueId + "] was aborted")) : (_running.push(eventDetails), 
        _createScheduledEvent(eventDetails, startEventAction));
       }
      };
     }));
    }
    return ESPromiseScheduler.incomplete = function() {
     return _running;
    }, ESPromiseScheduler.waitingToStart = function() {
     return _waiting;
    }, ESPromiseScheduler;
   }();
   var ValueSanitizer = function() {
    function ValueSanitizer(fieldSanitizerProvider) {
     var _self = this, _sanitizerMap = {}, _sanitizers = [], _fieldSanitizers = [];
     function _getFieldSanitizer(path, name) {
      var result, fieldLookup = _sanitizerMap[path];
      if (fieldLookup && (result = fieldLookup[name]), !result && null !== result) {
       if ((0, HelperFuncs.HD)(path) && (0, HelperFuncs.HD)(name)) if (_fieldSanitizers.length > 0) {
        for (var lp = 0; lp < _fieldSanitizers.length; lp++) if (_fieldSanitizers[lp].handleField(path, name)) {
         result = {
          canHandle: !0,
          fieldHandler: _fieldSanitizers[lp]
         };
         break;
        }
       } else 0 === _sanitizers.length && (result = {
        canHandle: !0
       });
       if (!result && null !== result) {
        result = null;
        for (lp = 0; lp < _sanitizers.length; lp++) if (_sanitizers[lp].handleField(path, name)) {
         result = {
          canHandle: !0,
          handler: _sanitizers[lp],
          fieldHandler: null
         };
         break;
        }
       }
       fieldLookup || (fieldLookup = _sanitizerMap[path] = {}), fieldLookup[name] = result;
      }
      return result;
     }
     function _handleProperty(mapValue, path, name, fieldType, property, stringifyObjects) {
      if (mapValue.handler) return mapValue.handler.property(path, name, property, stringifyObjects);
      if (!(0, HelperFuncs.le)(property.kind)) {
       if (4096 == (4096 & fieldType) || !(0, Utils.oS)(property.kind)) return null;
       property.value = property.value.toString();
      }
      return _callFieldSanitizer(mapValue.fieldHandler, path, name, fieldType, property);
     }
     function _convertToProperty(path, name, value) {
      return (0, Utils.Sn)(value) ? {
       value
      } : null;
     }
     function _callFieldSanitizer(fieldProvider, path, name, theType, property) {
      if (property && fieldProvider) {
       var sanitizer = fieldProvider.getSanitizer(path, name, theType, property.kind, property.propertyType);
       if (sanitizer) if (4 === theType) {
        var newValue_1 = {}, propValue = property.value;
        (0, HelperFuncs.rW)(propValue, (function(propKey, theValue) {
         var newPath = path + "." + name;
         if ((0, Utils.Sn)(theValue)) {
          var newProp = _convertToProperty(0, 0, theValue);
          (newProp = _callFieldSanitizer(fieldProvider, newPath, propKey, (0, Utils.Sy)(theValue), newProp)) && (newValue_1[propKey] = newProp.value);
         }
        })), property.value = newValue_1;
       } else {
        var details = {
         path,
         name,
         type: theType,
         prop: property,
         sanitizer: _self
        };
        property = sanitizer.call(_self, details);
       }
      }
      return property;
     }
     fieldSanitizerProvider && _fieldSanitizers.push(fieldSanitizerProvider), _self.addSanitizer = function(newSanitizer) {
      newSanitizer && (_sanitizers.push(newSanitizer), _sanitizerMap = {});
     }, _self.addFieldSanitizer = function(fieldSanitizer) {
      fieldSanitizer && (_fieldSanitizers.push(fieldSanitizer), _sanitizerMap = {});
     }, _self.handleField = function(path, name) {
      var mapValue = _getFieldSanitizer(path, name);
      return !!mapValue && mapValue.canHandle;
     }, _self.value = function(path, name, value, stringifyObjects) {
      var mapValue = _getFieldSanitizer(path, name);
      if (mapValue && mapValue.canHandle) {
       if (!mapValue || !mapValue.canHandle) return null;
       if (mapValue.handler) return mapValue.handler.value(path, name, value, stringifyObjects);
       if (!(0, HelperFuncs.HD)(name) || (0, HelperFuncs.le)(value) || value === src_InternalConstants.qS) return null;
       var property = null, fieldType = (0, Utils.Sy)(value);
       if (8192 == (8192 & fieldType)) {
        var subType = -8193 & fieldType;
        if (property = value, !(0, Utils.Sn)(property.value) || 1 !== subType && 2 !== subType && 3 !== subType && 4096 != (4096 & subType)) return null;
       } else 1 === fieldType || 2 === fieldType || 3 === fieldType || 4096 == (4096 & fieldType) ? property = _convertToProperty(path, name, value) : 4 === fieldType && (property = _convertToProperty(path, name, stringifyObjects ? JSON.stringify(value) : value));
       if (property) return _handleProperty(mapValue, path, name, fieldType, property, stringifyObjects);
      }
      return null;
     }, _self.property = function(path, name, property, stringifyObjects) {
      var mapValue = _getFieldSanitizer(path, name);
      if (!mapValue || !mapValue.canHandle) return null;
      if (!(0, HelperFuncs.HD)(name) || (0, HelperFuncs.le)(property) || !(0, Utils.Sn)(property.value)) return null;
      var fieldType = (0, Utils.Sy)(property.value);
      return 0 === fieldType ? null : _handleProperty(mapValue, path, name, fieldType, property, stringifyObjects);
     };
    }
    return ValueSanitizer.getFieldType = Utils.Sy, ValueSanitizer;
   }(), MinChannelPriorty = 100, EventsDiscardedReason = __webpack_require__(28452), CoreUtils = __webpack_require__(28956), EventHelpers = __webpack_require__(47954), RandomHelper = __webpack_require__(19406), Constants = __webpack_require__(1550), W3cTraceParent = __webpack_require__(56207);
  },
  51539: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    YT: () => STR_DEFAULT_ENDPOINT_URL,
    o6: () => STR_PROPERTIES,
    p8: () => STR_VERSION,
    qS: () => STR_EMPTY
   });
   var STR_EMPTY = "", STR_DEFAULT_ENDPOINT_URL = "https://browser.events.data.microsoft.com/OneCollector/1.0/", STR_VERSION = "version", STR_PROPERTIES = "properties";
  },
  65705: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Do: () => getCookieValue,
    Gf: () => Version,
    IZ: () => isUint8ArrayAvailable,
    JT: () => isArrayValid,
    Sn: () => isValueAssigned,
    Sy: () => getFieldValueType,
    Tr: () => CoreUtils,
    Vv: () => getCommonSchemaMetaData,
    cQ: () => Utils,
    cm: () => createGuid,
    d8: () => setCookie,
    dH: () => isWindowObjectAvailable,
    ej: () => getCookie,
    hK: () => getTime,
    if: () => setProcessTelemetryTimings,
    jM: () => getTenantId,
    kT: () => deleteCookie,
    l7: () => extend,
    mJ: () => isChromium,
    oF: () => disableCookies,
    oS: () => isValueKind,
    ot: () => openXhr,
    r7: () => isLatency,
    vs: () => FullVersionString,
    x9: () => isDocumentObjectAvailable,
    yj: () => sanitizeProperty
   });
   var _a, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49251), _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24869), _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(88140), _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(28956), _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1550), _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(47954), _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(19406), _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(30175), _InternalConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51539), Version = "3.2.13", FullVersionString = "1DS-Web-JS-" + Version, strDisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation", strWithCredentials = "withCredentials", strTimeout = "timeout", _fieldTypeEventPropMap = ((_a = {})[0] = 0, 
   _a[2] = 6, _a[1] = 1, _a[3] = 7, _a[4098] = 6, _a[4097] = 1, _a[4099] = 7, _a), uInt8ArraySupported = null, isDocumentObjectAvailable = Boolean((0, 
   _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.Me)()), isWindowObjectAvailable = Boolean((0, 
   _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.Jj)());
   function isValueAssigned(value) {
    return !(value === _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.qS || (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.le)(value));
   }
   function getTenantId(apiKey) {
    if (apiKey) {
     var indexTenantId = apiKey.indexOf("-");
     if (indexTenantId > -1) return apiKey.substring(0, indexTenantId);
    }
    return _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.qS;
   }
   function isUint8ArrayAvailable() {
    return null === uInt8ArraySupported && (uInt8ArraySupported = !(0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.o8)(Uint8Array) && !function() {
     var nav = (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.jW)();
     if (!(0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.o8)(nav) && nav.userAgent) {
      var ua = nav.userAgent.toLowerCase();
      if ((ua.indexOf("safari") >= 0 || ua.indexOf("firefox") >= 0) && ua.indexOf("chrome") < 0) return !0;
     }
     return !1;
    }() && !(0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.b$)()), 
    uInt8ArraySupported;
   }
   function isLatency(value) {
    return !!(value && (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.hj)(value) && value >= 1 && value <= 4);
   }
   function sanitizeProperty(name, property, stringifyObjects) {
    if (!property && !isValueAssigned(property) || "string" != typeof name) return null;
    var propType = typeof property;
    if ("string" === propType || "number" === propType || "boolean" === propType || (0, 
    _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.kJ)(property)) property = {
     value: property
    }; else if ("object" !== propType || _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__.CY.call(property, "value")) {
     if ((0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.le)(property.value) || property.value === _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.qS || !(0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.HD)(property.value) && !(0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.hj)(property.value) && !(0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.jn)(property.value) && !(0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.kJ)(property.value)) return null;
    } else property = {
     value: stringifyObjects ? JSON.stringify(property) : property
    };
    if ((0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.kJ)(property.value) && !isArrayValid(property.value)) return null;
    if (!(0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.le)(property.kind)) {
     if ((0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.kJ)(property.value) || !isValueKind(property.kind)) return null;
     property.value = property.value.toString();
    }
    return property;
   }
   function getCommonSchemaMetaData(value, kind, type) {
    var encodedTypeValue = -1;
    if (!(0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.o8)(value)) if (kind > 0 && (32 === kind ? encodedTypeValue = 8192 : kind <= 13 && (encodedTypeValue = kind << 5)), 
    function(value) {
     if (value >= 0 && value <= 9) return !0;
     return !1;
    }(type)) -1 === encodedTypeValue && (encodedTypeValue = 0), encodedTypeValue |= type; else {
     var propType = _fieldTypeEventPropMap[getFieldValueType(value)] || -1;
     -1 !== encodedTypeValue && -1 !== propType ? encodedTypeValue |= propType : 6 === propType && (encodedTypeValue = propType);
    }
    return encodedTypeValue;
   }
   function disableCookies() {
    (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.JP)(null).setEnabled(!1);
   }
   function setCookie(name, value, days) {
    (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.p7)(null) && (0, 
    _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.JP)(null).set(name, value, 86400 * days, null, "/");
   }
   function deleteCookie(name) {
    (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.p7)(null) && (0, 
    _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.JP)(null).del(name);
   }
   function getCookie(name) {
    return (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.p7)(null) ? getCookieValue((0, 
    _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.JP)(null), name) : _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.qS;
   }
   function getCookieValue(cookieMgr, name, decode) {
    var cookieValue;
    return void 0 === decode && (decode = !0), cookieMgr && (cookieValue = cookieMgr.get(name), 
    decode && cookieValue && decodeURIComponent && (cookieValue = decodeURIComponent(cookieValue))), 
    cookieValue || _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.qS;
   }
   function createGuid(style) {
    void 0 === style && (style = "D");
    var theGuid = (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__.GW)();
    return "B" === style ? theGuid = "{" + theGuid + "}" : "P" === style ? theGuid = "(" + theGuid + ")" : "N" === style && (theGuid = theGuid.replace(/-/g, _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.qS)), 
    theGuid;
   }
   function extend(obj, obj2, obj3, obj4, obj5) {
    var extended = {}, deep = !1, i = 0, length = arguments.length, theArgs = arguments;
    for ("[object Boolean]" === Object[_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__.hB].toString.call(theArgs[0]) && (deep = theArgs[0], 
    i++); i < length; i++) {
     obj = theArgs[i];
     (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.rW)(obj, (function(prop, value) {
      deep && value && (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.Kn)(value) ? (0, 
      _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.kJ)(value) ? (extended[prop] = extended[prop] || [], 
      (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.tO)(value, (function(arrayValue, arrayIndex) {
       arrayValue && (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.Kn)(arrayValue) ? extended[prop][arrayIndex] = extend(!0, extended[prop][arrayIndex], arrayValue) : extended[prop][arrayIndex] = arrayValue;
      }))) : extended[prop] = extend(!0, extended[prop], value) : extended[prop] = value;
     }));
    }
    return extended;
   }
   var getTime = _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__.Jj;
   function isValueKind(value) {
    return 0 === value || value > 0 && value <= 13 || 32 === value;
   }
   function isArrayValid(value) {
    return value.length > 0;
   }
   function setProcessTelemetryTimings(event, identifier) {
    var evt = event;
    evt.timings = evt.timings || {}, evt.timings.processTelemetryStart = evt.timings.processTelemetryStart || {}, 
    evt.timings.processTelemetryStart[identifier] = getTime();
   }
   function getFieldValueType(value) {
    var theType = 0;
    if (null != value) {
     var objType = typeof value;
     "string" === objType ? theType = 1 : "number" === objType ? theType = 2 : "boolean" === objType ? theType = 3 : objType === _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__.fK && (theType = 4, 
     (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.kJ)(value) ? (theType = 4096, 
     value.length > 0 && (theType |= getFieldValueType(value[0]))) : _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__.CY.call(value, "value") && (theType = 8192 | getFieldValueType(value.value)));
    }
    return theType;
   }
   var Utils = {
    Version,
    FullVersionString,
    strUndefined: _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__.jA,
    strObject: _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__.fK,
    Undefined: _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__.jA,
    arrForEach: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.tO,
    arrIndexOf: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.UA,
    arrMap: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.Mr,
    arrReduce: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.Xz,
    objKeys: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.FY,
    toISOString: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.Y6,
    isReactNative: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.b$,
    isString: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.HD,
    isNumber: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.hj,
    isBoolean: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.jn,
    isFunction: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.mf,
    isArray: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.kJ,
    isObject: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.Kn,
    strTrim: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.nd,
    isDocumentObjectAvailable,
    isWindowObjectAvailable,
    isValueAssigned,
    getTenantId,
    isBeaconsSupported: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.MF,
    isUint8ArrayAvailable,
    isLatency,
    sanitizeProperty,
    getISOString: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.Y6,
    useXDomainRequest: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.cp,
    getCommonSchemaMetaData,
    cookieAvailable: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.p7,
    disallowsSameSiteNone: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.UY,
    setCookie,
    deleteCookie,
    getCookie,
    createGuid,
    extend,
    getTime,
    isValueKind,
    isArrayValid,
    objDefineAccessors: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.l_,
    addPageUnloadEventListener: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__.c9,
    setProcessTelemetryTimings,
    addEventHandler: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__.Ib,
    getFieldValueType,
    strEndsWith: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.Id,
    objForEachKey: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.rW
   }, CoreUtils = {
    _canUseCookies: void 0,
    isTypeof: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.Ym,
    isUndefined: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.o8,
    isNullOrUndefined: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.le,
    hasOwnProperty: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.nr,
    isFunction: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.mf,
    isObject: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.Kn,
    isDate: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.J_,
    isArray: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.kJ,
    isError: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.VZ,
    isString: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.HD,
    isNumber: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.hj,
    isBoolean: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.jn,
    toISOString: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.Y6,
    arrForEach: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.tO,
    arrIndexOf: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.UA,
    arrMap: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.Mr,
    arrReduce: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.Xz,
    strTrim: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.nd,
    objCreate: _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_7__.pu,
    objKeys: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.FY,
    objDefineAccessors: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.l_,
    addEventHandler: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__.Ib,
    dateNow: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.m6,
    isIE: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.w1,
    disableCookies,
    newGuid: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__.GW,
    perfNow: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__.Jj,
    newId: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_8__.pZ,
    randomValue: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_8__.az,
    random32: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_8__._l,
    mwcRandomSeed: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_8__.CN,
    mwcRandom32: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_8__.F6,
    generateW3CId: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__.DO
   };
   function isChromium() {
    return !!(0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.a8)("chrome");
   }
   function openXhr(method, urlString, withCredentials, disabled, isSync, timeout) {
    function _wrapSetXhrProp(xhr, prop, value) {
     try {
      xhr[prop] = value;
     } catch (e) {}
    }
    void 0 === disabled && (disabled = !1), void 0 === isSync && (isSync = !1);
    var xhr = new XMLHttpRequest;
    return disabled && _wrapSetXhrProp(xhr, strDisabledPropertyName, disabled), withCredentials && _wrapSetXhrProp(xhr, strWithCredentials, withCredentials), 
    xhr.open(method, urlString, !isSync), withCredentials && _wrapSetXhrProp(xhr, strWithCredentials, withCredentials), 
    !isSync && timeout && _wrapSetXhrProp(xhr, strTimeout, timeout), xhr;
   }
  },
  71488: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    BE_PROFILE: () => BE_PROFILE,
    NRT_PROFILE: () => NRT_PROFILE,
    PostChannel: () => src_PostChannel,
    RT_PROFILE: () => RT_PROFILE
   });
   var TsLibShims = __webpack_require__(27421), dynamicproto_js = __webpack_require__(29141), PerfManager = __webpack_require__(81782), EventHelpers = __webpack_require__(47954), DataCacheHelper = __webpack_require__(87624), Utils = __webpack_require__(65705), HelperFuncs = __webpack_require__(24869), EnvUtils = __webpack_require__(49251), EventsDiscardedReason = __webpack_require__(28452), DiagnosticLogger = __webpack_require__(29339), BaseTelemetryPlugin = __webpack_require__(87951), RT_PROFILE = "REAL_TIME", NRT_PROFILE = "NEAR_REAL_TIME", BE_PROFILE = "BEST_EFFORT", STR_MSFPC = "msfpc";
   function _getEventMsfpc(theEvent) {
    var intWeb = (theEvent.ext || {}).intweb;
    return intWeb && (0, Utils.Sn)(intWeb[STR_MSFPC]) ? intWeb[STR_MSFPC] : null;
   }
   function _getMsfpc(theEvents) {
    for (var msfpc = null, lp = 0; null === msfpc && lp < theEvents.length; lp++) msfpc = _getEventMsfpc(theEvents[lp]);
    return msfpc;
   }
   var EventBatch = function() {
    function EventBatch(iKey, addEvents) {
     var events = addEvents ? [].concat(addEvents) : [], _msfpc = _getMsfpc(events);
     this.iKey = function() {
      return iKey;
     }, this.Msfpc = function() {
      return _msfpc || "";
     }, this.count = function() {
      return events.length;
     }, this.events = function() {
      return events;
     }, this.addEvent = function(theEvent) {
      return !!theEvent && (events.push(theEvent), _msfpc || (_msfpc = _getEventMsfpc(theEvent)), 
      !0);
     }, this.split = function(fromEvent, numEvents) {
      var theEvents;
      if (fromEvent < events.length) {
       var cnt = events.length - fromEvent;
       (0, HelperFuncs.le)(numEvents) || (cnt = numEvents < cnt ? numEvents : cnt), theEvents = events.splice(fromEvent, cnt), 
       _msfpc = _getMsfpc(events);
      }
      return new EventBatch(iKey, theEvents);
     };
    }
    return EventBatch.create = function(iKey, theEvents) {
     return new EventBatch(iKey, theEvents);
    }, EventBatch;
   }();
   const src_ClockSkewManager = function() {
    function ClockSkewManager() {
     var _allowRequestSending = !0, _shouldAddClockSkewHeaders = !0, _isFirstRequest = !0, _clockSkewHeaderValue = "use-collector-delta", _clockSkewSet = !1;
     (0, dynamicproto_js.Z)(ClockSkewManager, this, (function(_self) {
      _self.allowRequestSending = function() {
       return _allowRequestSending;
      }, _self.firstRequestSent = function() {
       _isFirstRequest && (_isFirstRequest = !1, _clockSkewSet || (_allowRequestSending = !1));
      }, _self.shouldAddClockSkewHeaders = function() {
       return _shouldAddClockSkewHeaders;
      }, _self.getClockSkewHeaderValue = function() {
       return _clockSkewHeaderValue;
      }, _self.setClockSkew = function(timeDeltaInMillis) {
       _clockSkewSet || (timeDeltaInMillis ? (_clockSkewHeaderValue = timeDeltaInMillis, 
       _shouldAddClockSkewHeaders = !0, _clockSkewSet = !0) : _shouldAddClockSkewHeaders = !1, 
       _allowRequestSending = !0);
      };
     }));
    }
    return ClockSkewManager.__ieDyn = 1, ClockSkewManager;
   }();
   const src_KillSwitch = function() {
    function KillSwitch() {
     var _killedTokenDictionary = {};
     (0, dynamicproto_js.Z)(KillSwitch, this, (function(_self) {
      _self.setKillSwitchTenants = function(killTokens, killDuration) {
       if (killTokens && killDuration) try {
        var killedTokens = (values = killTokens.split(","), result = [], values && (0, HelperFuncs.tO)(values, (function(value) {
         result.push((0, HelperFuncs.nd)(value));
        })), result);
        if ("this-request-only" === killDuration) return killedTokens;
        for (var durationMs = 1e3 * parseInt(killDuration, 10), i = 0; i < killedTokens.length; ++i) _killedTokenDictionary[killedTokens[i]] = (0, 
        HelperFuncs.m6)() + durationMs;
       } catch (ex) {
        return [];
       }
       var values, result;
       return [];
      }, _self.isTenantKilled = function(tenantToken) {
       var killDictionary = _killedTokenDictionary, name = (0, HelperFuncs.nd)(tenantToken);
       return void 0 !== killDictionary[name] && killDictionary[name] > (0, HelperFuncs.m6)() || (delete killDictionary[name], 
       !1);
      };
     }));
    }
    return KillSwitch.__ieDyn = 1, KillSwitch;
   }();
   var Constants = __webpack_require__(1550);
   function retryPolicyGetMillisToBackoffForRetry(retriesSoFar) {
    var waitDuration, randomBackoff = Math.floor(1200 * Math.random()) + 2400;
    return waitDuration = Math.pow(2, retriesSoFar) * randomBackoff, Math.min(waitDuration, 6e5);
   }
   var _a, MaxBeaconRecordSize = Math.min(2e6, 65e3), f = "f", rCheckDot = /\./, Serializer = function() {
    function Serializer(perfManager, valueSanitizer, stringifyObjects, enableCompoundKey) {
     var _checkForCompoundkey = !!enableCompoundKey, _theSanitizer = valueSanitizer, _isReservedCache = {};
     (0, dynamicproto_js.Z)(Serializer, this, (function(_self) {
      function _processPathKeys(srcObj, target, thePath, checkReserved, metadataPathKeys, metadataCallback, processSubKeys) {
       (0, HelperFuncs.rW)(srcObj, (function(key, srcValue) {
        var prop = null;
        if (srcValue || (0, Utils.Sn)(srcValue)) {
         var path = thePath, name_1 = key, theMetaPathKeys = metadataPathKeys, destObj = target;
         if (_checkForCompoundkey && !checkReserved && rCheckDot.test(key)) {
          var subKeys = key.split("."), keyLen = subKeys.length;
          if (keyLen > 1) {
           theMetaPathKeys && (theMetaPathKeys = theMetaPathKeys.slice());
           for (var lp = 0; lp < keyLen - 1; lp++) {
            var subKey = subKeys[lp];
            destObj = destObj[subKey] = destObj[subKey] || {}, path += "." + subKey, theMetaPathKeys && theMetaPathKeys.push(subKey);
           }
           name_1 = subKeys[keyLen - 1];
          }
         }
         var isReserved = checkReserved && function(path, name) {
          var result = _isReservedCache[path];
          return void 0 === result && (path.length >= 7 && (result = (0, HelperFuncs.xe)(path, "ext.metadata") || (0, 
          HelperFuncs.xe)(path, "ext.web")), _isReservedCache[path] = result), result;
         }(path);
         if (prop = !isReserved && _theSanitizer && _theSanitizer.handleField(path, name_1) ? _theSanitizer.value(path, name_1, srcValue, stringifyObjects) : (0, 
         Utils.yj)(name_1, srcValue, stringifyObjects)) {
          var newValue = prop.value;
          if (destObj[name_1] = newValue, metadataCallback && metadataCallback(theMetaPathKeys, name_1, prop), 
          processSubKeys && "object" == typeof newValue && !(0, HelperFuncs.kJ)(newValue)) {
           var newPath = theMetaPathKeys;
           newPath && (newPath = newPath.slice()).push(name_1), _processPathKeys(srcValue, newValue, path + "." + name_1, checkReserved, newPath, metadataCallback, processSubKeys);
          }
         }
        }
       }));
      }
      _self.createPayload = function(retryCnt, isTeardown, isSync, isReducedPayload, sendReason, sendType) {
       return {
        apiKeys: [],
        payloadBlob: "",
        overflow: null,
        sizeExceed: [],
        failedEvts: [],
        batches: [],
        numEvents: 0,
        retryCnt,
        isTeardown,
        isSync,
        isBeacon: isReducedPayload,
        sendType,
        sendReason
       };
      }, _self.appendPayload = function(payload, theBatch, maxEventsPerBatch) {
       var canAddEvents = payload && theBatch && !payload.overflow;
       return canAddEvents && (0, PerfManager.Lm)(perfManager, (function() {
        return "Serializer:appendPayload";
       }), (function() {
        for (var theEvents = theBatch.events(), payloadBlob = payload.payloadBlob, payloadEvents = payload.numEvents, eventsAdded = !1, sizeExceeded = [], failedEvts = [], isBeaconPayload = payload.isBeacon, requestMaxSize = isBeaconPayload ? 65e3 : 3984588, recordMaxSize = isBeaconPayload ? MaxBeaconRecordSize : 2e6, lp = 0, joinCount = 0; lp < theEvents.length; ) {
         var theEvent = theEvents[lp];
         if (theEvent) {
          if (payloadEvents >= maxEventsPerBatch) {
           payload.overflow = theBatch.split(lp);
           break;
          }
          var eventBlob = _self.getEventBlob(theEvent);
          if (eventBlob && eventBlob.length <= recordMaxSize) {
           var blobLength = eventBlob.length;
           if (payloadBlob.length + blobLength > requestMaxSize) {
            payload.overflow = theBatch.split(lp);
            break;
           }
           payloadBlob && (payloadBlob += "\n"), payloadBlob += eventBlob, ++joinCount > 20 && (payloadBlob.substr(0, 1), 
           joinCount = 0), eventsAdded = !0, payloadEvents++;
          } else eventBlob ? sizeExceeded.push(theEvent) : failedEvts.push(theEvent), theEvents.splice(lp, 1), 
          lp--;
         }
         lp++;
        }
        if (sizeExceeded && sizeExceeded.length > 0 && payload.sizeExceed.push(EventBatch.create(theBatch.iKey(), sizeExceeded)), 
        failedEvts && failedEvts.length > 0 && payload.failedEvts.push(EventBatch.create(theBatch.iKey(), failedEvts)), 
        eventsAdded) {
         payload.batches.push(theBatch), payload.payloadBlob = payloadBlob, payload.numEvents = payloadEvents;
         var apiKey = theBatch.iKey();
         -1 === (0, HelperFuncs.UA)(payload.apiKeys, apiKey) && payload.apiKeys.push(apiKey);
        }
       }), (function() {
        return {
         payload,
         theBatch: {
          iKey: theBatch.iKey(),
          evts: theBatch.events()
         },
         max: maxEventsPerBatch
        };
       })), canAddEvents;
      }, _self.getEventBlob = function(eventData) {
       try {
        return (0, PerfManager.Lm)(perfManager, (function() {
         return "Serializer.getEventBlob";
        }), (function() {
         var serializedEvent = {};
         serializedEvent.name = eventData.name, serializedEvent.time = eventData.time, serializedEvent.ver = eventData.ver, 
         serializedEvent.iKey = "o:" + (0, Utils.jM)(eventData.iKey);
         var serializedExt = {}, eventExt = eventData.ext;
         eventExt && (serializedEvent.ext = serializedExt, (0, HelperFuncs.rW)(eventExt, (function(key, value) {
          _processPathKeys(value, serializedExt[key] = {}, "ext." + key, !0, null, null, !0);
         })));
         var serializedData = serializedEvent.data = {};
         serializedData.baseType = eventData.baseType;
         var serializedBaseData = serializedData.baseData = {};
         return _processPathKeys(eventData.baseData, serializedBaseData, "baseData", !1, [ "baseData" ], (function(pathKeys, name, value) {
          _addJSONPropertyMetaData(serializedExt, pathKeys, name, value);
         }), true), _processPathKeys(eventData.data, serializedData, "data", !1, [], (function(pathKeys, name, value) {
          _addJSONPropertyMetaData(serializedExt, pathKeys, name, value);
         }), true), JSON.stringify(serializedEvent);
        }), (function() {
         return {
          item: eventData
         };
        }));
       } catch (e) {
        return null;
       }
      };
     }));
    }
    return Serializer.__ieDyn = 1, Serializer;
   }();
   function _addJSONPropertyMetaData(json, propKeys, name, propertyValue) {
    if (propertyValue && json) {
     var encodedTypeValue = (0, Utils.Vv)(propertyValue.value, propertyValue.kind, propertyValue.propertyType);
     if (encodedTypeValue > -1) {
      var metaData = json.metadata;
      metaData || (metaData = json.metadata = {
       f: {}
      });
      var metaTarget = metaData[f];
      if (metaTarget || (metaTarget = metaData[f] = {}), propKeys) for (var lp = 0; lp < propKeys.length; lp++) {
       var key = propKeys[lp];
       metaTarget[key] || (metaTarget[key] = {
        f: {}
       });
       var newTarget = metaTarget[key][f];
       newTarget || (newTarget = metaTarget[key][f] = {}), metaTarget = newTarget;
      }
      metaTarget = metaTarget[name] = {}, (0, HelperFuncs.kJ)(propertyValue.value) ? metaTarget.a = {
       t: encodedTypeValue
      } : metaTarget.t = encodedTypeValue;
     }
    }
   }
   var _eventActionMap = ((_a = {})[1] = "requeue", _a[100] = "requeue", _a[200] = "sent", 
   _a[8004] = "drop", _a[8003] = "drop", _a), _collectorQsHeaders = {}, _collectorHeaderToQs = {};
   function _addCollectorHeaderQsMapping(qsName, headerName, allowQs) {
    _collectorQsHeaders[qsName] = headerName, !1 !== allowQs && (_collectorHeaderToQs[headerName] = qsName);
   }
   function _getResponseText(xhr) {
    try {
     return xhr.responseText;
    } catch (e) {}
    return "";
   }
   function _hasHeader(headers, header) {
    var hasHeader = !1;
    if (headers && header) {
     var keys = (0, HelperFuncs.FY)(headers);
     if (keys && keys.length > 0) for (var lowerHeader = header.toLowerCase(), lp = 0; lp < keys.length; lp++) {
      var value = keys[lp];
      if (value && (0, HelperFuncs.nr)(header, value) && value.toLowerCase() === lowerHeader) {
       hasHeader = !0;
       break;
      }
     }
    }
    return hasHeader;
   }
   function _addRequestDetails(details, name, value, useHeaders) {
    name && value && value.length > 0 && (useHeaders && _collectorQsHeaders[name] ? (details.hdrs[_collectorQsHeaders[name]] = value, 
    details.useHdrs = !0) : details.url += "&" + name + "=" + value);
   }
   function _prependTransports(theTransports, newTransports) {
    return newTransports && ((0, HelperFuncs.hj)(newTransports) ? theTransports = [ newTransports ].concat(theTransports) : (0, 
    HelperFuncs.kJ)(newTransports) && (theTransports = newTransports.concat(theTransports))), 
    theTransports;
   }
   _addCollectorHeaderQsMapping("AuthMsaDeviceTicket", "AuthMsaDeviceTicket", !1), 
   _addCollectorHeaderQsMapping("client-version", "client-version"), _addCollectorHeaderQsMapping("client-id", "Client-Id"), 
   _addCollectorHeaderQsMapping("apikey", "apikey"), _addCollectorHeaderQsMapping("time-delta-to-apply-millis", "time-delta-to-apply-millis"), 
   _addCollectorHeaderQsMapping("upload-time", "upload-time"), _addCollectorHeaderQsMapping("AuthXToken", "AuthXToken");
   var HttpManager = function() {
    function HttpManager(maxEventsPerBatch, maxConnections, maxRequestRetriesBeforeBackoff, actions, timeoutOverride) {
     this._responseHandlers = [];
     var _postManager, _logger, _sendInterfaces, _core, _cookieMgr, _xhrTimeout, _disableXhrSync, _disableFetchKeepAlive, _canHaveReducedPayload, _addNoResponse, _urlString = "?cors=true&" + "content-type".toLowerCase() + "=application/x-json-stream", _killSwitch = new src_KillSwitch, _paused = !1, _clockSkewManager = new src_ClockSkewManager, _useBeacons = !1, _outstandingRequests = 0, _customHttpInterface = !0, _queryStringParameters = [], _headers = {}, _batchQueue = [], _serializer = null, _enableEventTimings = !1, _isUnloading = !1, _useHeaders = !1;
     (0, dynamicproto_js.Z)(HttpManager, this, (function(_self) {
      var _sendCredentials = !0;
      function _getSenderInterface(transports, syncSupport) {
       for (var transportType = 0, sendPostFunc = null, lp = 0; null == sendPostFunc && lp < transports.length; ) 1 === (transportType = transports[lp]) ? (0, 
       EnvUtils.cp)() ? sendPostFunc = _xdrSendPost : (0, EnvUtils.Z3)() && (sendPostFunc = _xhrSendPost) : 2 === transportType && (0, 
       EnvUtils.JO)(syncSupport) && (!syncSupport || syncSupport && !_disableFetchKeepAlive) ? sendPostFunc = _fetchSendPost : _useBeacons && 3 === transportType && (0, 
       EnvUtils.MF)() && (sendPostFunc = _beaconSendPost), lp++;
       return sendPostFunc ? {
        _transport: transportType,
        _isSync: syncSupport,
        sendPOST: sendPostFunc
       } : null;
      }
      function _xdrSendPost(payload, oncomplete, sync) {
       var xdr = new XDomainRequest;
       xdr.open("POST", payload.urlString), payload.timeout && (xdr.timeout = payload.timeout), 
       xdr.onload = function() {
        var response = _getResponseText(xdr);
        _doOnComplete(oncomplete, 200, {}, response), _handleCollectorResponse(response);
       }, xdr.onerror = function() {
        _doOnComplete(oncomplete, 400, {});
       }, xdr.ontimeout = function() {
        _doOnComplete(oncomplete, 500, {});
       }, xdr.onprogress = function() {}, sync ? xdr.send(payload.data) : timeoutOverride.set((function() {
        xdr.send(payload.data);
       }), 0);
      }
      function _fetchSendPost(payload, oncomplete, sync) {
       var _a, theUrl = payload.urlString, ignoreResponse = !1, responseHandled = !1, requestInit = ((_a = {
        body: payload.data,
        method: "POST"
       }).Microsoft_ApplicationInsights_BypassAjaxInstrumentation = !0, _a);
       sync && (requestInit.keepalive = !0, 2 === payload._sendReason && (ignoreResponse = !0, 
       _addNoResponse && (theUrl += "&NoResponseBody=true"))), _sendCredentials && (requestInit.credentials = "include"), 
       payload.headers && (0, HelperFuncs.FY)(payload.headers).length > 0 && (requestInit.headers = payload.headers), 
       fetch(theUrl, requestInit).then((function(response) {
        var headerMap = {}, responseText = "", headers = response.headers;
        headers && headers.forEach((function(value, name) {
         headerMap[name] = value;
        })), response.body && response.text().then((function(text) {
         responseText = text;
        })), responseHandled || (responseHandled = !0, _doOnComplete(oncomplete, response.status, headerMap, responseText), 
        _handleCollectorResponse(responseText));
       })).catch((function(error) {
        responseHandled || (responseHandled = !0, _doOnComplete(oncomplete, 0, {}));
       })), ignoreResponse && !responseHandled && (responseHandled = !0, _doOnComplete(oncomplete, 200, {})), 
       !responseHandled && payload.timeout > 0 && timeoutOverride.set((function() {
        responseHandled || (responseHandled = !0, _doOnComplete(oncomplete, 500, {}));
       }), payload.timeout);
      }
      function _xhrSendPost(payload, oncomplete, sync) {
       var theUrl = payload.urlString;
       function _appendHeader(theHeaders, xhr, name) {
        if (!theHeaders[name] && xhr && xhr.getResponseHeader) {
         var value = xhr.getResponseHeader(name);
         value && (theHeaders[name] = (0, HelperFuncs.nd)(value));
        }
        return theHeaders;
       }
       function _getAllResponseHeaders(xhr) {
        var theHeaders = {};
        return xhr.getAllResponseHeaders ? theHeaders = function(headersString) {
         var headers = {};
         if ((0, HelperFuncs.HD)(headersString)) {
          var headersArray = (0, HelperFuncs.nd)(headersString).split(/[\r\n]+/);
          (0, HelperFuncs.tO)(headersArray, (function(headerEntry) {
           if (headerEntry) {
            var idx = headerEntry.indexOf(": ");
            if (-1 !== idx) {
             var header = (0, HelperFuncs.nd)(headerEntry.substring(0, idx)).toLowerCase(), value = (0, 
             HelperFuncs.nd)(headerEntry.substring(idx + 1));
             headers[header] = value;
            } else headers[(0, HelperFuncs.nd)(headerEntry)] = 1;
           }
          }));
         }
         return headers;
        }(xhr.getAllResponseHeaders()) : (theHeaders = _appendHeader(theHeaders, xhr, "time-delta-millis"), 
        theHeaders = _appendHeader(theHeaders, xhr, "kill-duration"), theHeaders = _appendHeader(theHeaders, xhr, "kill-duration-seconds")), 
        theHeaders;
       }
       function xhrComplete(xhr, responseTxt) {
        _doOnComplete(oncomplete, xhr.status, _getAllResponseHeaders(xhr), responseTxt);
       }
       sync && payload.disableXhrSync && (sync = !1);
       var xhrRequest = (0, Utils.ot)("POST", theUrl, _sendCredentials, !0, sync, payload.timeout);
       (0, HelperFuncs.rW)(payload.headers, (function(name, value) {
        xhrRequest.setRequestHeader(name, value);
       })), xhrRequest.onload = function() {
        var response = _getResponseText(xhrRequest);
        xhrComplete(xhrRequest, response), _handleCollectorResponse(response);
       }, xhrRequest.onerror = function() {
        xhrComplete(xhrRequest);
       }, xhrRequest.ontimeout = function() {
        xhrComplete(xhrRequest);
       }, xhrRequest.send(payload.data);
      }
      function _doOnComplete(oncomplete, status, headers, response) {
       try {
        oncomplete(status, headers, response);
       } catch (e) {
        (0, DiagnosticLogger.kP)(_logger, 2, 518, (0, EnvUtils.eU)(e));
       }
      }
      function _beaconSendPost(payload, oncomplete, sync) {
       var status = 200, thePayload = payload._thePayload, theUrl = payload.urlString + (_addNoResponse ? "&NoResponseBody=true" : "");
       try {
        var nav_1 = (0, EnvUtils.jW)();
        if (!nav_1.sendBeacon(theUrl, payload.data)) if (thePayload) {
         var droppedBatches_1 = [];
         (0, HelperFuncs.tO)(thePayload.batches, (function(theBatch) {
          if (droppedBatches_1 && theBatch && theBatch.count() > 0) {
           for (var theEvents = theBatch.events(), lp = 0; lp < theEvents.length; lp++) if (!nav_1.sendBeacon(theUrl, _serializer.getEventBlob(theEvents[lp]))) {
            droppedBatches_1.push(theBatch.split(lp));
            break;
           }
          } else droppedBatches_1.push(theBatch.split(0));
         })), _sendBatchesNotification(droppedBatches_1, 8003, thePayload.sendType, !0);
        } else status = 0;
       } catch (ex) {
        (0, DiagnosticLogger.jV)(_logger, "Failed to send telemetry using sendBeacon API. Ex:" + (0, 
        EnvUtils.eU)(ex)), status = 0;
       } finally {
        _doOnComplete(oncomplete, status, {}, "");
       }
      }
      function _isBeaconPayload(sendType) {
       return 2 === sendType || 3 === sendType;
      }
      function _adjustSendType(sendType) {
       return _isUnloading && _isBeaconPayload(sendType) && (sendType = 2), sendType;
      }
      function _hasIdleConnection() {
       return !_paused && _outstandingRequests < maxConnections;
      }
      function _clearQueue() {
       var theQueue = _batchQueue;
       return _batchQueue = [], theQueue;
      }
      function _canSendPayload(theBatches, sendType, retryCnt) {
       var result = !1;
       return theBatches && theBatches.length > 0 && !_paused && _sendInterfaces[sendType] && _serializer && (result = 0 !== sendType || _hasIdleConnection() && (retryCnt > 0 || _clockSkewManager.allowRequestSending())), 
       result;
      }
      function _createDebugBatches(theBatches) {
       var values = {};
       return theBatches && (0, HelperFuncs.tO)(theBatches, (function(theBatch, idx) {
        values[idx] = {
         iKey: theBatch.iKey(),
         evts: theBatch.events()
        };
       })), values;
      }
      function _sendBatches(theBatches, retryCount, isTeardown, sendType, sendReason) {
       if (theBatches && 0 !== theBatches.length) if (_paused) _sendBatchesNotification(theBatches, 1, sendType); else {
        sendType = _adjustSendType(sendType);
        try {
         var orgBatches_1 = theBatches, isSynchronous_1 = 0 !== sendType;
         (0, PerfManager.Lm)(_core, (function() {
          return "HttpManager:_sendBatches";
         }), (function(perfEvt) {
          perfEvt && (theBatches = theBatches.slice(0));
          for (var droppedBatches = [], thePayload = null, serializationStart = (0, Utils.hK)(), sendInterface = _sendInterfaces[sendType] || (isSynchronous_1 ? _sendInterfaces[1] : _sendInterfaces[0]), sendTransport = sendInterface && sendInterface._transport, isReducedPayload = _canHaveReducedPayload && (_isUnloading || _isBeaconPayload(sendType) || 3 === sendTransport || sendInterface._isSync && 2 === sendTransport); _canSendPayload(theBatches, sendType, retryCount); ) {
           var theBatch = theBatches.shift();
           theBatch && theBatch.count() > 0 && (_killSwitch.isTenantKilled(theBatch.iKey()) ? droppedBatches.push(theBatch) : (thePayload = thePayload || _serializer.createPayload(retryCount, isTeardown, isSynchronous_1, isReducedPayload, sendReason, sendType), 
           _serializer.appendPayload(thePayload, theBatch, maxEventsPerBatch) ? null !== thePayload.overflow && (theBatches = [ thePayload.overflow ].concat(theBatches), 
           thePayload.overflow = null, _doPayloadSend(thePayload, serializationStart, (0, Utils.hK)(), sendReason), 
           serializationStart = (0, Utils.hK)(), thePayload = null) : (_doPayloadSend(thePayload, serializationStart, (0, 
           Utils.hK)(), sendReason), serializationStart = (0, Utils.hK)(), theBatches = [ theBatch ].concat(theBatches), 
           thePayload = null)));
          }
          thePayload && _doPayloadSend(thePayload, serializationStart, (0, Utils.hK)(), sendReason), 
          theBatches.length > 0 && (_batchQueue = theBatches.concat(_batchQueue)), _sendBatchesNotification(droppedBatches, 8004, sendType);
         }), (function() {
          return {
           batches: _createDebugBatches(orgBatches_1),
           retryCount,
           isTeardown,
           isSynchronous: isSynchronous_1,
           sendReason,
           useSendBeacon: _isBeaconPayload(sendType),
           sendType
          };
         }), !isSynchronous_1);
        } catch (ex) {
         (0, DiagnosticLogger.kP)(_logger, 2, 48, "Unexpected Exception sending batch: " + (0, 
         EnvUtils.eU)(ex));
        }
       }
      }
      function _buildRequestDetails(thePayload, useHeaders) {
       var requestDetails = {
        url: _urlString,
        hdrs: {},
        useHdrs: !1
       };
       useHeaders ? (requestDetails.hdrs = (0, Utils.l7)(requestDetails.hdrs, _headers), 
       requestDetails.useHdrs = (0, HelperFuncs.FY)(requestDetails.hdrs).length > 0) : (0, 
       HelperFuncs.rW)(_headers, (function(name, value) {
        _collectorHeaderToQs[name] ? _addRequestDetails(requestDetails, _collectorHeaderToQs[name], value, !1) : (requestDetails.hdrs[name] = value, 
        requestDetails.useHdrs = !0);
       })), _addRequestDetails(requestDetails, "client-id", "NO_AUTH", useHeaders), _addRequestDetails(requestDetails, "client-version", Utils.vs, useHeaders);
       var apiQsKeys = "";
       (0, HelperFuncs.tO)(thePayload.apiKeys, (function(apiKey) {
        apiQsKeys.length > 0 && (apiQsKeys += ","), apiQsKeys += apiKey;
       })), _addRequestDetails(requestDetails, "apikey", apiQsKeys, useHeaders), _addRequestDetails(requestDetails, "upload-time", (0, 
       HelperFuncs.m6)().toString(), useHeaders);
       var msfpc = function(thePayload) {
        for (var lp = 0; lp < thePayload.batches.length; lp++) {
         var msfpc = thePayload.batches[lp].Msfpc();
         if (msfpc) return encodeURIComponent(msfpc);
        }
        return "";
       }(thePayload);
       if ((0, Utils.Sn)(msfpc) && (requestDetails.url += "&ext.intweb.msfpc=" + msfpc), 
       _clockSkewManager.shouldAddClockSkewHeaders() && _addRequestDetails(requestDetails, "time-delta-to-apply-millis", _clockSkewManager.getClockSkewHeaderValue(), useHeaders), 
       _core.getWParam) {
        var wParam = _core.getWParam();
        wParam >= 0 && (requestDetails.url += "&w=" + wParam);
       }
       for (var i = 0; i < _queryStringParameters.length; i++) requestDetails.url += "&" + _queryStringParameters[i].name + "=" + _queryStringParameters[i].value;
       return requestDetails;
      }
      function _setTimingValue(timings, name, value) {
       timings[name] = timings[name] || {}, timings[name][_postManager.identifier] = value;
      }
      function _doPayloadSend(thePayload, serializationStart, serializationCompleted, sendReason) {
       if (thePayload && thePayload.payloadBlob && thePayload.payloadBlob.length > 0) {
        var useSendHook_1 = !!_self.sendHook, sendInterface_1 = _sendInterfaces[thePayload.sendType];
        !_isBeaconPayload(thePayload.sendType) && thePayload.isBeacon && 2 === thePayload.sendReason && (sendInterface_1 = _sendInterfaces[2] || _sendInterfaces[3] || sendInterface_1);
        var useHeaders_1 = _useHeaders;
        (thePayload.isBeacon || 3 === sendInterface_1._transport) && (useHeaders_1 = !1);
        var requestDetails_1 = _buildRequestDetails(thePayload, useHeaders_1);
        useHeaders_1 = useHeaders_1 || requestDetails_1.useHdrs;
        var sendEventStart_1 = (0, Utils.hK)();
        (0, PerfManager.Lm)(_core, (function() {
         return "HttpManager:_doPayloadSend";
        }), (function() {
         for (var batchLp = 0; batchLp < thePayload.batches.length; batchLp++) for (var theEvents = thePayload.batches[batchLp].events(), evtLp = 0; evtLp < theEvents.length; evtLp++) {
          var telemetryItem = theEvents[evtLp];
          if (_enableEventTimings) {
           var timings = telemetryItem.timings = telemetryItem.timings || {};
           _setTimingValue(timings, "sendEventStart", sendEventStart_1), _setTimingValue(timings, "serializationStart", serializationStart), 
           _setTimingValue(timings, "serializationCompleted", serializationCompleted);
          }
          telemetryItem.sendAttempt > 0 ? telemetryItem.sendAttempt++ : telemetryItem.sendAttempt = 1;
         }
         _sendBatchesNotification(thePayload.batches, 1e3 + (sendReason || 0), thePayload.sendType, !0);
         var orgPayloadData = {
          data: thePayload.payloadBlob,
          urlString: requestDetails_1.url,
          headers: requestDetails_1.hdrs,
          _thePayload: thePayload,
          _sendReason: sendReason,
          timeout: _xhrTimeout,
          disableXhrSync: _disableXhrSync,
          disableFetchKeepAlive: _disableFetchKeepAlive
         };
         useHeaders_1 && (_hasHeader(orgPayloadData.headers, "cache-control") || (orgPayloadData.headers["cache-control"] = "no-cache, no-store"), 
         _hasHeader(orgPayloadData.headers, "content-type") || (orgPayloadData.headers["content-type"] = "application/x-json-stream"));
         var sender = null;
         sendInterface_1 && (sender = function(payload) {
          _clockSkewManager.firstRequestSent();
          var onComplete = function(status, headers) {
           !function(status, headers, thePayload, sendReason) {
            var reason = 9e3, droppedBatches = null, isRetrying = !1, backOffTrans = !1;
            try {
             var shouldRetry = !0;
             if (typeof status !== Constants.jA) {
              if (headers) {
               _clockSkewManager.setClockSkew(headers["time-delta-millis"]);
               var killDuration = headers["kill-duration"] || headers["kill-duration-seconds"];
               (0, HelperFuncs.tO)(_killSwitch.setKillSwitchTenants(headers["kill-tokens"], killDuration), (function(killToken) {
                (0, HelperFuncs.tO)(thePayload.batches, (function(theBatch) {
                 if (theBatch.iKey() === killToken) {
                  droppedBatches = droppedBatches || [];
                  var removedEvents = theBatch.split(0);
                  thePayload.numEvents -= removedEvents.count(), droppedBatches.push(removedEvents);
                 }
                }));
               }));
              }
              if (200 == status || 204 == status) return void (reason = 200);
              ((httpStatusCode = status) >= 300 && httpStatusCode < 500 && 408 != httpStatusCode && 429 != httpStatusCode || 501 == httpStatusCode || 505 == httpStatusCode || thePayload.numEvents <= 0) && (shouldRetry = !1), 
              reason = 9e3 + status % 1e3;
             }
             if (shouldRetry) {
              reason = 100;
              var retryCount_1 = thePayload.retryCnt;
              0 === thePayload.sendType && (retryCount_1 < maxRequestRetriesBeforeBackoff ? (isRetrying = !0, 
              _doAction((function() {
               0 === thePayload.sendType && _outstandingRequests--, _sendBatches(thePayload.batches, retryCount_1 + 1, thePayload.isTeardown, _isUnloading ? 2 : thePayload.sendType, 5);
              }), _isUnloading, retryPolicyGetMillisToBackoffForRetry(retryCount_1))) : (backOffTrans = !0, 
              _isUnloading && (reason = 8001)));
             }
            } finally {
             isRetrying || (_clockSkewManager.setClockSkew(), function(thePayload, batchReason, sendReason, backOffTrans) {
              try {
               backOffTrans && _postManager._backOffTransmission(), 200 === batchReason && (backOffTrans || thePayload.isSync || _postManager._clearBackOff(), 
               function(theBatches) {
                if (_enableEventTimings) {
                 var sendEventCompleted_1 = (0, Utils.hK)();
                 (0, HelperFuncs.tO)(theBatches, (function(theBatch) {
                  theBatch && theBatch.count() > 0 && function(theEvents, sendEventCompleted) {
                   _enableEventTimings && (0, HelperFuncs.tO)(theEvents, (function(theEvent) {
                    _setTimingValue(theEvent.timings = theEvent.timings || {}, "sendEventCompleted", sendEventCompleted);
                   }));
                  }(theBatch.events(), sendEventCompleted_1);
                 }));
                }
               }(thePayload.batches)), _sendBatchesNotification(thePayload.batches, batchReason, thePayload.sendType, !0);
              } finally {
               0 === thePayload.sendType && (_outstandingRequests--, 5 !== sendReason && _self.sendQueuedRequests(thePayload.sendType, sendReason));
              }
             }(thePayload, reason, sendReason, backOffTrans)), _sendBatchesNotification(droppedBatches, 8004, thePayload.sendType);
            }
            var httpStatusCode;
           }(status, headers, thePayload, sendReason);
          }, isSync = thePayload.isTeardown || thePayload.isSync;
          try {
           sendInterface_1.sendPOST(payload, onComplete, isSync), _self.sendListener && _self.sendListener(orgPayloadData, payload, isSync, thePayload.isBeacon);
          } catch (ex) {
           (0, DiagnosticLogger.jV)(_logger, "Unexpected exception sending payload. Ex:" + (0, 
           EnvUtils.eU)(ex)), _doOnComplete(onComplete, 0, {});
          }
         }), (0, PerfManager.Lm)(_core, (function() {
          return "HttpManager:_doPayloadSend.sender";
         }), (function() {
          if (sender) if (0 === thePayload.sendType && _outstandingRequests++, useSendHook_1 && !thePayload.isBeacon && 3 !== sendInterface_1._transport) {
           var hookData_1 = {
            data: orgPayloadData.data,
            urlString: orgPayloadData.urlString,
            headers: (0, Utils.l7)({}, orgPayloadData.headers),
            timeout: orgPayloadData.timeout,
            disableXhrSync: orgPayloadData.disableXhrSync,
            disableFetchKeepAlive: orgPayloadData.disableFetchKeepAlive
           }, senderCalled_1 = !1;
           (0, PerfManager.Lm)(_core, (function() {
            return "HttpManager:_doPayloadSend.sendHook";
           }), (function() {
            try {
             _self.sendHook(hookData_1, (function(payload) {
              senderCalled_1 = !0, _customHttpInterface || payload._thePayload || (payload._thePayload = payload._thePayload || orgPayloadData._thePayload, 
              payload._sendReason = payload._sendReason || orgPayloadData._sendReason), sender(payload);
             }), thePayload.isSync || thePayload.isTeardown);
            } catch (ex) {
             senderCalled_1 || sender(orgPayloadData);
            }
           }));
          } else sender(orgPayloadData);
         }));
        }), (function() {
         return {
          thePayload,
          serializationStart,
          serializationCompleted,
          sendReason
         };
        }), thePayload.isSync);
       }
       thePayload.sizeExceed && thePayload.sizeExceed.length > 0 && _sendBatchesNotification(thePayload.sizeExceed, 8003, thePayload.sendType), 
       thePayload.failedEvts && thePayload.failedEvts.length > 0 && _sendBatchesNotification(thePayload.failedEvts, 8002, thePayload.sendType);
      }
      function _doAction(cb, isSync, interval) {
       isSync ? cb() : timeoutOverride.set(cb, interval);
      }
      function _handleCollectorResponse(responseText) {
       var responseHandlers = _self._responseHandlers;
       try {
        for (var i = 0; i < responseHandlers.length; i++) try {
         responseHandlers[i](responseText);
        } catch (e) {
         (0, DiagnosticLogger.kP)(_logger, 1, 519, "Response handler failed: " + e);
        }
        if (responseText) {
         var response = JSON.parse(responseText);
         (0, Utils.Sn)(response.webResult) && (0, Utils.Sn)(response.webResult[STR_MSFPC]) && _cookieMgr.set("MSFPC", response.webResult[STR_MSFPC], 31536e3);
        }
       } catch (ex) {}
      }
      function _sendBatchesNotification(theBatches, batchReason, sendType, sendSync) {
       if (theBatches && theBatches.length > 0 && actions) {
        var theAction_1 = actions[function(reason) {
         var action = _eventActionMap[reason];
         (0, Utils.Sn)(action) || (action = "oth", reason >= 9e3 && reason <= 9999 ? action = "rspFail" : reason >= 8e3 && reason <= 8999 ? action = "drop" : reason >= 1e3 && reason <= 1999 && (action = "send"));
         return action;
        }(batchReason)];
        if (theAction_1) {
         var isSyncRequest_1 = 0 !== sendType;
         (0, PerfManager.Lm)(_core, (function() {
          return "HttpManager:_sendBatchesNotification";
         }), (function() {
          _doAction((function() {
           try {
            theAction_1.call(actions, theBatches, batchReason, isSyncRequest_1, sendType);
           } catch (e) {
            (0, DiagnosticLogger.kP)(_logger, 1, 74, "send request notification failed: " + e);
           }
          }), sendSync || isSyncRequest_1, 0);
         }), (function() {
          return {
           batches: _createDebugBatches(theBatches),
           reason: batchReason,
           isSync: isSyncRequest_1,
           sendSync,
           sendType
          };
         }), !isSyncRequest_1);
        }
       }
      }
      _self.initialize = function(endpointUrl, core, postChannel, httpInterface, channelConfig) {
       var _a;
       channelConfig || (channelConfig = {}), _urlString = endpointUrl + _urlString, _useHeaders = !!(0, 
       HelperFuncs.o8)(channelConfig.avoidOptions) || !channelConfig.avoidOptions, _core = core, 
       _cookieMgr = core.getCookieMgr(), _enableEventTimings = !_core.config.disableEventTimings;
       var enableCompoundKey = !!_core.config.enableCompoundKey;
       _logger = (_postManager = postChannel).diagLog();
       var valueSanitizer = channelConfig.valueSanitizer, stringifyObjects = channelConfig.stringifyObjects;
       (0, HelperFuncs.o8)(channelConfig.enableCompoundKey) || (enableCompoundKey = !!channelConfig.enableCompoundKey), 
       _xhrTimeout = channelConfig.xhrTimeout, _disableXhrSync = !!channelConfig.disableXhrSync, 
       _disableFetchKeepAlive = !!channelConfig.disableFetchKeepAlive, _addNoResponse = !1 !== channelConfig.addNoResponse, 
       _useBeacons = !(0, EnvUtils.b$)(), _serializer = new Serializer(_core, valueSanitizer, stringifyObjects, enableCompoundKey), 
       (0, HelperFuncs.le)(channelConfig.useSendBeacon) || (_useBeacons = !!channelConfig.useSendBeacon);
       var syncHttpInterface = httpInterface, beaconHttpInterface = channelConfig.alwaysUseXhrOverride ? httpInterface : null, fetchSyncHttpInterface = channelConfig.alwaysUseXhrOverride ? httpInterface : null, beaconUnloadTransports = [ 3, 2 ];
       if (!httpInterface) {
        _customHttpInterface = !1;
        var location_1 = (0, EnvUtils.k$)();
        location_1 && location_1.protocol && "file:" === location_1.protocol.toLowerCase() && (_sendCredentials = !1);
        var theTransports = [];
        (0, EnvUtils.b$)() ? (theTransports = [ 2, 1 ], beaconUnloadTransports = [ 2, 1, 3 ]) : theTransports = [ 1, 2, 3 ], 
        (httpInterface = _getSenderInterface(theTransports = _prependTransports(theTransports, channelConfig.transports), !1)) || (0, 
        DiagnosticLogger.jV)(_logger, "No available transport to send events"), syncHttpInterface = _getSenderInterface(theTransports, !0);
       }
       beaconHttpInterface || (beaconHttpInterface = _getSenderInterface(beaconUnloadTransports = _prependTransports(beaconUnloadTransports, channelConfig.unloadTransports), !0)), 
       _canHaveReducedPayload = !_customHttpInterface && (_useBeacons && (0, EnvUtils.MF)() || !_disableFetchKeepAlive && (0, 
       EnvUtils.JO)(!0)), (_a = {})[0] = httpInterface, _a[1] = syncHttpInterface || _getSenderInterface([ 1, 2, 3 ], !0), 
       _a[2] = beaconHttpInterface || syncHttpInterface || _getSenderInterface([ 1 ], !0), 
       _a[3] = fetchSyncHttpInterface || _getSenderInterface([ 2, 3 ], !0) || syncHttpInterface || _getSenderInterface([ 1 ], !0), 
       _sendInterfaces = _a;
      }, _self._getDbgPlgTargets = function() {
       return [ _sendInterfaces[0], _killSwitch, _serializer, _sendInterfaces ];
      }, _self.addQueryStringParameter = function(name, value) {
       for (var i = 0; i < _queryStringParameters.length; i++) if (_queryStringParameters[i].name === name) return void (_queryStringParameters[i].value = value);
       _queryStringParameters.push({
        name,
        value
       });
      }, _self.addHeader = function(name, value) {
       _headers[name] = value;
      }, _self.canSendRequest = function() {
       return _hasIdleConnection() && _clockSkewManager.allowRequestSending();
      }, _self.sendQueuedRequests = function(sendType, sendReason) {
       (0, HelperFuncs.o8)(sendType) && (sendType = 0), _isUnloading && (sendType = _adjustSendType(sendType), 
       sendReason = 2), _canSendPayload(_batchQueue, sendType, 0) && _sendBatches(_clearQueue(), 0, !1, sendType, sendReason || 0);
      }, _self.isCompletelyIdle = function() {
       return !_paused && 0 === _outstandingRequests && 0 === _batchQueue.length;
      }, _self.setUnloading = function(value) {
       _isUnloading = value;
      }, _self.addBatch = function(theBatch) {
       if (theBatch && theBatch.count() > 0) {
        if (_killSwitch.isTenantKilled(theBatch.iKey())) return !1;
        _batchQueue.push(theBatch);
       }
       return !0;
      }, _self.teardown = function() {
       _batchQueue.length > 0 && _sendBatches(_clearQueue(), 0, !0, 2, 2);
      }, _self.pause = function() {
       _paused = !0;
      }, _self.resume = function() {
       _paused = !1, _self.sendQueuedRequests(0, 4);
      }, _self.sendSynchronousBatch = function(batch, sendType, sendReason) {
       batch && batch.count() > 0 && ((0, HelperFuncs.le)(sendType) && (sendType = 1), 
       _isUnloading && (sendType = _adjustSendType(sendType), sendReason = 2), _sendBatches([ batch ], 0, !1, sendType, sendReason || 0));
      };
     }));
    }
    return HttpManager.__ieDyn = 1, HttpManager;
   }();
   function defaultSetTimeout(callback, ms) {
    for (var args = [], _i = 2; _i < arguments.length; _i++) args[_i - 2] = arguments[_i];
    return setTimeout(callback, ms, args);
   }
   function defaultClearTimeout(timeoutId) {
    clearTimeout(timeoutId);
   }
   function createTimeoutWrapper(argSetTimeout, argClearTimeout) {
    return {
     set: argSetTimeout || defaultSetTimeout,
     clear: argClearTimeout || defaultClearTimeout
    };
   }
   const src_PostChannel = function(_super) {
    function PostChannel() {
     var _config, _this = _super.call(this) || this;
     _this.identifier = "PostChannel", _this.priority = 1011, _this.version = "3.2.13";
     var _xhrOverride, _httpManager, _autoFlushEventsLimit, _autoFlushBatchLimit, _delayedBatchReason, _evtNamespace, _timeoutWrapper, _isTeardownCalled = !1, _flushCallbackQueue = [], _flushCallbackTimerId = null, _paused = !1, _immediateQueueSize = 0, _immediateQueueSizeLimit = 500, _queueSize = 0, _queueSizeLimit = 1e4, _profiles = {}, _currentProfile = RT_PROFILE, _scheduledTimerId = null, _immediateTimerId = null, _currentBackoffCount = 0, _timerCount = 0, _batchQueues = {}, _delayedBatchSendLatency = -1, _optimizeObject = !0, _isPageUnloadTriggered = !1, _maxEventSendAttempts = 6, _maxUnloadEventSendAttempts = 2;
     return (0, dynamicproto_js.Z)(PostChannel, _this, (function(_self, _base) {
      function _handleUnloadEvents(evt) {
       "beforeunload" !== (evt || (0, EnvUtils.Jj)().event).type && (_isPageUnloadTriggered = !0, 
       _httpManager.setUnloading(_isPageUnloadTriggered)), _releaseAllQueues(2, 2);
      }
      function _handleShowEvents(evt) {
       _isPageUnloadTriggered = !1, _httpManager.setUnloading(_isPageUnloadTriggered);
      }
      function _addEventToQueues(event, append) {
       if (event.sendAttempt || (event.sendAttempt = 0), event.latency || (event.latency = 1), 
       event.ext && event.ext.trace && delete event.ext.trace, event.ext && event.ext.user && event.ext.user.id && delete event.ext.user.id, 
       _optimizeObject && (Utils.if, event.ext = (0, HelperFuncs.Ax)(event.ext), event.baseData && (event.baseData = (0, 
       HelperFuncs.Ax)(event.baseData)), event.data && (event.data = (0, HelperFuncs.Ax)(event.data))), 
       event.sync) if (_currentBackoffCount || _paused) event.latency = 3, event.sync = !1; else if (_httpManager) return _optimizeObject && (event = (0, 
       HelperFuncs.Ax)(event)), void _httpManager.sendSynchronousBatch(EventBatch.create(event.iKey, [ event ]), !0 === event.sync ? 1 : event.sync, 3);
       var evtLatency = event.latency, queueSize = _queueSize, queueLimit = _queueSizeLimit;
       4 === evtLatency && (queueSize = _immediateQueueSize, queueLimit = _immediateQueueSizeLimit);
       var eventDropped = !1;
       if (queueSize < queueLimit) eventDropped = !_addEventToProperQueue(event, append); else {
        var dropLatency = 1, dropNumber = 20;
        4 === evtLatency && (dropLatency = 4, dropNumber = 1), eventDropped = !0, function(iKey, latency, currentLatency, dropNumber) {
         for (;currentLatency <= latency; ) {
          var eventBatch = _getEventBatch(iKey, latency, !0);
          if (eventBatch && eventBatch.count() > 0) {
           var droppedEvents = eventBatch.split(0, dropNumber), droppedCount = droppedEvents.count();
           if (droppedCount > 0) return 4 === currentLatency ? _immediateQueueSize -= droppedCount : _queueSize -= droppedCount, 
           _notifyBatchEvents("eventsDiscarded", [ droppedEvents ], EventsDiscardedReason.h.QueueFull), 
           !0;
          }
          currentLatency++;
         }
         return _resetQueueCounts(), !1;
        }(event.iKey, event.latency, dropLatency, dropNumber) && (eventDropped = !_addEventToProperQueue(event, append));
       }
       eventDropped && _notifyEvents("eventsDiscarded", [ event ], EventsDiscardedReason.h.QueueFull);
      }
      function _sendEventsForLatencyAndAbove(latency, sendType, sendReason) {
       var queued = _queueBatches(latency, sendType, sendReason);
       return _httpManager.sendQueuedRequests(sendType, sendReason), queued;
      }
      function _hasEvents() {
       return _queueSize > 0;
      }
      function _scheduleTimer() {
       if (_delayedBatchSendLatency >= 0 && _queueBatches(_delayedBatchSendLatency, 0, _delayedBatchReason) && _httpManager.sendQueuedRequests(0, _delayedBatchReason), 
       _immediateQueueSize > 0 && !_immediateTimerId && !_paused) {
        var immediateTimeOut = _profiles[_currentProfile][2];
        immediateTimeOut >= 0 && (_immediateTimerId = _createTimer((function() {
         _immediateTimerId = null, _sendEventsForLatencyAndAbove(4, 0, 1), _scheduleTimer();
        }), immediateTimeOut));
       }
       var timeOut = _profiles[_currentProfile][1];
       !_scheduledTimerId && !_flushCallbackTimerId && timeOut >= 0 && !_paused && (_hasEvents() ? _scheduledTimerId = _createTimer((function() {
        _scheduledTimerId = null, _sendEventsForLatencyAndAbove(0 === _timerCount ? 3 : 1, 0, 1), 
        _timerCount++, _timerCount %= 2, _scheduleTimer();
       }), timeOut) : _timerCount = 0);
      }
      function _initDefaults() {
       _config = null, _isTeardownCalled = !1, _flushCallbackQueue = [], _flushCallbackTimerId = null, 
       _paused = !1, _immediateQueueSize = 0, _immediateQueueSizeLimit = 500, _queueSize = 0, 
       _queueSizeLimit = 1e4, _profiles = {}, _currentProfile = RT_PROFILE, _scheduledTimerId = null, 
       _immediateTimerId = null, _currentBackoffCount = 0, _timerCount = 0, _xhrOverride = null, 
       _batchQueues = {}, _autoFlushEventsLimit = void 0, _autoFlushBatchLimit = 0, _delayedBatchSendLatency = -1, 
       _delayedBatchReason = null, _optimizeObject = !0, _isPageUnloadTriggered = !1, _maxEventSendAttempts = 6, 
       _maxUnloadEventSendAttempts = 2, _evtNamespace = null, _timeoutWrapper = createTimeoutWrapper(), 
       _httpManager = new HttpManager(500, 2, 1, {
        requeue: _requeueEvents,
        send: _sendingEvent,
        sent: _eventsSentEvent,
        drop: _eventsDropped,
        rspFail: _eventsResponseFail,
        oth: _otherEvent
       }, _timeoutWrapper), _initializeProfiles(), _batchQueues[4] = {
        batches: [],
        iKeyMap: {}
       }, _batchQueues[3] = {
        batches: [],
        iKeyMap: {}
       }, _batchQueues[2] = {
        batches: [],
        iKeyMap: {}
       }, _batchQueues[1] = {
        batches: [],
        iKeyMap: {}
       }, _setAutoLimits();
      }
      function _createTimer(theTimerFunc, timeOut) {
       0 === timeOut && _currentBackoffCount && (timeOut = 1);
       var timerMultiplier = 1e3;
       return _currentBackoffCount && (timerMultiplier = retryPolicyGetMillisToBackoffForRetry(_currentBackoffCount - 1)), 
       _timeoutWrapper.set(theTimerFunc, timeOut * timerMultiplier);
      }
      function _clearScheduledTimer() {
       return null !== _scheduledTimerId && (_timeoutWrapper.clear(_scheduledTimerId), 
       _scheduledTimerId = null, _timerCount = 0, !0);
      }
      function _releaseAllQueues(sendType, sendReason) {
       _clearScheduledTimer(), _flushCallbackTimerId && (_timeoutWrapper.clear(_flushCallbackTimerId), 
       _flushCallbackTimerId = null), _paused || _sendEventsForLatencyAndAbove(1, sendType, sendReason);
      }
      function _getEventBatch(iKey, latency, create) {
       var batchQueue = _batchQueues[latency];
       batchQueue || (batchQueue = _batchQueues[latency = 1]);
       var eventBatch = batchQueue.iKeyMap[iKey];
       return !eventBatch && create && (eventBatch = EventBatch.create(iKey), batchQueue.batches.push(eventBatch), 
       batchQueue.iKeyMap[iKey] = eventBatch), eventBatch;
      }
      function _performAutoFlush(isAsync, doFlush) {
       _httpManager.canSendRequest() && !_currentBackoffCount && (_autoFlushEventsLimit > 0 && _queueSize > _autoFlushEventsLimit && (doFlush = !0), 
       doFlush && null == _flushCallbackTimerId && _self.flush(isAsync, null, 20));
      }
      function _addEventToProperQueue(event, append) {
       _optimizeObject && (event = (0, HelperFuncs.Ax)(event));
       var latency = event.latency, eventBatch = _getEventBatch(event.iKey, latency, !0);
       return !!eventBatch.addEvent(event) && (4 !== latency ? (_queueSize++, append && 0 === event.sendAttempt && _performAutoFlush(!event.sync, _autoFlushBatchLimit > 0 && eventBatch.count() >= _autoFlushBatchLimit)) : _immediateQueueSize++, 
       !0);
      }
      function _resetQueueCounts() {
       for (var immediateQueue = 0, normalQueue = 0, _loop_1 = function(latency) {
        var batchQueue = _batchQueues[latency];
        batchQueue && batchQueue.batches && (0, HelperFuncs.tO)(batchQueue.batches, (function(theBatch) {
         4 === latency ? immediateQueue += theBatch.count() : normalQueue += theBatch.count();
        }));
       }, latency = 1; latency <= 4; latency++) _loop_1(latency);
       _queueSize = normalQueue, _immediateQueueSize = immediateQueue;
      }
      function _queueBatches(latency, sendType, sendReason) {
       var eventsQueued = !1, isAsync = 0 === sendType;
       return !isAsync || _httpManager.canSendRequest() ? (0, PerfManager.Lm)(_self.core, (function() {
        return "PostChannel._queueBatches";
       }), (function() {
        for (var droppedEvents = [], latencyToProcess = 4; latencyToProcess >= latency; ) {
         var batchQueue = _batchQueues[latencyToProcess];
         batchQueue && batchQueue.batches && batchQueue.batches.length > 0 && ((0, HelperFuncs.tO)(batchQueue.batches, (function(theBatch) {
          _httpManager.addBatch(theBatch) ? eventsQueued = eventsQueued || theBatch && theBatch.count() > 0 : droppedEvents = droppedEvents.concat(theBatch.events()), 
          4 === latencyToProcess ? _immediateQueueSize -= theBatch.count() : _queueSize -= theBatch.count();
         })), batchQueue.batches = [], batchQueue.iKeyMap = {}), latencyToProcess--;
        }
        droppedEvents.length > 0 && _notifyEvents("eventsDiscarded", droppedEvents, EventsDiscardedReason.h.KillSwitch), 
        eventsQueued && _delayedBatchSendLatency >= latency && (_delayedBatchSendLatency = -1, 
        _delayedBatchReason = 0);
       }), (function() {
        return {
         latency,
         sendType,
         sendReason
        };
       }), !isAsync) : (_delayedBatchSendLatency = _delayedBatchSendLatency >= 0 ? Math.min(_delayedBatchSendLatency, latency) : latency, 
       _delayedBatchReason = Math.max(_delayedBatchReason, sendReason)), eventsQueued;
      }
      function _flushImpl(callback, sendReason) {
       _sendEventsForLatencyAndAbove(1, 0, sendReason), _resetQueueCounts(), _waitForIdleManager((function() {
        callback && callback(), _flushCallbackQueue.length > 0 ? _flushCallbackTimerId = _createTimer((function() {
         _flushCallbackTimerId = null, _flushImpl(_flushCallbackQueue.shift(), sendReason);
        }), 0) : (_flushCallbackTimerId = null, _scheduleTimer());
       }));
      }
      function _waitForIdleManager(callback) {
       _httpManager.isCompletelyIdle() ? callback() : _flushCallbackTimerId = _createTimer((function() {
        _flushCallbackTimerId = null, _waitForIdleManager(callback);
       }), .25);
      }
      function _initializeProfiles() {
       (_profiles = {})[RT_PROFILE] = [ 2, 1, 0 ], _profiles[NRT_PROFILE] = [ 6, 3, 0 ], 
       _profiles[BE_PROFILE] = [ 18, 9, 0 ];
      }
      function _requeueEvents(batches, reason) {
       var droppedEvents = [], maxSendAttempts = _maxEventSendAttempts;
       _isPageUnloadTriggered && (maxSendAttempts = _maxUnloadEventSendAttempts), (0, HelperFuncs.tO)(batches, (function(theBatch) {
        theBatch && theBatch.count() > 0 && (0, HelperFuncs.tO)(theBatch.events(), (function(theEvent) {
         theEvent && (theEvent.sync && (theEvent.latency = 4, theEvent.sync = !1), theEvent.sendAttempt < maxSendAttempts ? ((0, 
         Utils.if)(theEvent, _self.identifier), _addEventToQueues(theEvent, !1)) : droppedEvents.push(theEvent));
        }));
       })), droppedEvents.length > 0 && _notifyEvents("eventsDiscarded", droppedEvents, EventsDiscardedReason.h.NonRetryableStatus), 
       _isPageUnloadTriggered && _releaseAllQueues(2, 2);
      }
      function _callNotification(evtName, theArgs) {
       var manager = _self._notificationManager || {}, notifyFunc = manager[evtName];
       if (notifyFunc) try {
        notifyFunc.apply(manager, theArgs);
       } catch (e) {
        (0, DiagnosticLogger.kP)(_self.diagLog(), 1, 74, evtName + " notification failed: " + e);
       }
      }
      function _notifyEvents(evtName, theEvents) {
       for (var extraArgs = [], _i = 2; _i < arguments.length; _i++) extraArgs[_i - 2] = arguments[_i];
       theEvents && theEvents.length > 0 && _callNotification(evtName, [ theEvents ].concat(extraArgs));
      }
      function _notifyBatchEvents(evtName, batches) {
       for (var extraArgs = [], _i = 2; _i < arguments.length; _i++) extraArgs[_i - 2] = arguments[_i];
       batches && batches.length > 0 && (0, HelperFuncs.tO)(batches, (function(theBatch) {
        theBatch && theBatch.count() > 0 && _callNotification(evtName, [ theBatch.events() ].concat(extraArgs));
       }));
      }
      function _sendingEvent(batches, reason, isSyncRequest) {
       batches && batches.length > 0 && _callNotification("eventsSendRequest", [ reason >= 1e3 && reason <= 1999 ? reason - 1e3 : 0, !0 !== isSyncRequest ]);
      }
      function _eventsSentEvent(batches, reason) {
       _notifyBatchEvents("eventsSent", batches, reason), _scheduleTimer();
      }
      function _eventsDropped(batches, reason) {
       _notifyBatchEvents("eventsDiscarded", batches, reason >= 8e3 && reason <= 8999 ? reason - 8e3 : EventsDiscardedReason.h.Unknown);
      }
      function _eventsResponseFail(batches) {
       _notifyBatchEvents("eventsDiscarded", batches, EventsDiscardedReason.h.NonRetryableStatus), 
       _scheduleTimer();
      }
      function _otherEvent(batches, reason) {
       _notifyBatchEvents("eventsDiscarded", batches, EventsDiscardedReason.h.Unknown), 
       _scheduleTimer();
      }
      function _setAutoLimits() {
       _autoFlushBatchLimit = _config && _config.disableAutoBatchFlushLimit ? 0 : Math.max(1500, _queueSizeLimit / 6);
      }
      _initDefaults(), _self._getDbgPlgTargets = function() {
       return [ _httpManager ];
      }, _self.initialize = function(coreConfig, core, extensions) {
       (0, PerfManager.Lm)(core, (function() {
        return "PostChannel:initialize";
       }), (function() {
        var extendedCore = core;
        _base.initialize(coreConfig, core, extensions);
        try {
         core.addUnloadCb;
         _evtNamespace = (0, EventHelpers.jU)((0, DataCacheHelper.J)(_self.identifier), core.evtNamespace && core.evtNamespace());
         var ctx = _self._getTelCtx();
         coreConfig.extensionConfig[_self.identifier] = coreConfig.extensionConfig[_self.identifier] || {}, 
         _config = ctx.getExtCfg(_self.identifier), _timeoutWrapper = createTimeoutWrapper(_config.setTimeoutOverride, _config.clearTimeoutOverride), 
         _optimizeObject = !_config.disableOptimizeObj && (0, Utils.mJ)(), function(extendedCore) {
          var existingGetWParamMethod = extendedCore.getWParam;
          extendedCore.getWParam = function() {
           var wparam = 0;
           return _config.ignoreMc1Ms0CookieProcessing && (wparam |= 2), wparam | existingGetWParamMethod();
          };
         }(extendedCore), _config.eventsLimitInMem > 0 && (_queueSizeLimit = _config.eventsLimitInMem), 
         _config.immediateEventLimit > 0 && (_immediateQueueSizeLimit = _config.immediateEventLimit), 
         _config.autoFlushEventsLimit > 0 && (_autoFlushEventsLimit = _config.autoFlushEventsLimit), 
         (0, HelperFuncs.hj)(_config.maxEventRetryAttempts) && (_maxEventSendAttempts = _config.maxEventRetryAttempts), 
         (0, HelperFuncs.hj)(_config.maxUnloadEventRetryAttempts) && (_maxUnloadEventSendAttempts = _config.maxUnloadEventRetryAttempts), 
         _setAutoLimits(), _config.httpXHROverride && _config.httpXHROverride.sendPOST && (_xhrOverride = _config.httpXHROverride), 
         (0, Utils.Sn)(coreConfig.anonCookieName) && _httpManager.addQueryStringParameter("anoncknm", coreConfig.anonCookieName), 
         _httpManager.sendHook = _config.payloadPreprocessor, _httpManager.sendListener = _config.payloadListener;
         var endpointUrl = _config.overrideEndpointUrl ? _config.overrideEndpointUrl : coreConfig.endpointUrl;
         _self._notificationManager = core.getNotifyMgr(), _httpManager.initialize(endpointUrl, _self.core, _self, _xhrOverride, _config);
         var excludePageUnloadEvents = coreConfig.disablePageUnloadEvents || [];
         (0, EventHelpers.c9)(_handleUnloadEvents, excludePageUnloadEvents, _evtNamespace), 
         (0, EventHelpers.TJ)(_handleUnloadEvents, excludePageUnloadEvents, _evtNamespace), 
         (0, EventHelpers.nD)(_handleShowEvents, coreConfig.disablePageShowEvents, _evtNamespace);
        } catch (e) {
         throw _self.setInitialized(!1), e;
        }
       }), (function() {
        return {
         coreConfig,
         core,
         extensions
        };
       }));
      }, _self.processTelemetry = function(ev, itemCtx) {
       (0, Utils.if)(ev, _self.identifier);
       var channelConfig = (itemCtx = _self._getTelCtx(itemCtx)).getExtCfg(_self.identifier), disableTelemetry = !!_config.disableTelemetry;
       channelConfig && (disableTelemetry = disableTelemetry || !!channelConfig.disableTelemetry);
       var event = ev;
       disableTelemetry || _isTeardownCalled || (_config.overrideInstrumentationKey && (event.iKey = _config.overrideInstrumentationKey), 
       channelConfig && channelConfig.overrideInstrumentationKey && (event.iKey = channelConfig.overrideInstrumentationKey), 
       _addEventToQueues(event, !0), _isPageUnloadTriggered ? _releaseAllQueues(2, 2) : _scheduleTimer()), 
       _self.processNext(event, itemCtx);
      }, _self._doTeardown = function(unloadCtx, unloadState) {
       _releaseAllQueues(2, 2), _isTeardownCalled = !0, _httpManager.teardown(), (0, EventHelpers.JA)(null, _evtNamespace), 
       (0, EventHelpers.C9)(null, _evtNamespace), (0, EventHelpers.Yl)(null, _evtNamespace), 
       _initDefaults();
      }, _self.setEventQueueLimits = function(eventLimit, autoFlushLimit) {
       _queueSizeLimit = eventLimit > 0 ? eventLimit : 1e4, _autoFlushEventsLimit = autoFlushLimit > 0 ? autoFlushLimit : 0, 
       _setAutoLimits();
       var doFlush = _queueSize > eventLimit;
       if (!doFlush && _autoFlushBatchLimit > 0) for (var latency = 1; !doFlush && latency <= 3; latency++) {
        var batchQueue = _batchQueues[latency];
        batchQueue && batchQueue.batches && (0, HelperFuncs.tO)(batchQueue.batches, (function(theBatch) {
         theBatch && theBatch.count() >= _autoFlushBatchLimit && (doFlush = !0);
        }));
       }
       _performAutoFlush(!0, doFlush);
      }, _self.pause = function() {
       _clearScheduledTimer(), _paused = !0, _httpManager.pause();
      }, _self.resume = function() {
       _paused = !1, _httpManager.resume(), _scheduleTimer();
      }, _self.addResponseHandler = function(responseHandler) {
       _httpManager._responseHandlers.push(responseHandler);
      }, _self._loadTransmitProfiles = function(profiles) {
       _clearScheduledTimer(), _initializeProfiles(), _currentProfile = RT_PROFILE, _scheduleTimer(), 
       (0, HelperFuncs.rW)(profiles, (function(profileName, profileValue) {
        var profLen = profileValue.length;
        if (profLen >= 2) {
         var directValue = profLen > 2 ? profileValue[2] : 0;
         if (profileValue.splice(0, profLen - 2), profileValue[1] < 0 && (profileValue[0] = -1), 
         profileValue[1] > 0 && profileValue[0] > 0) {
          var timerMultiplier = profileValue[0] / profileValue[1];
          profileValue[0] = Math.ceil(timerMultiplier) * profileValue[1];
         }
         directValue >= 0 && profileValue[1] >= 0 && directValue > profileValue[1] && (directValue = profileValue[1]), 
         profileValue.push(directValue), _profiles[profileName] = profileValue;
        }
       }));
      }, _self.flush = function(async, callback, sendReason) {
       if (void 0 === async && (async = !0), !_paused) if (sendReason = sendReason || 1, 
       async) null == _flushCallbackTimerId ? (_clearScheduledTimer(), _queueBatches(1, 0, sendReason), 
       _flushCallbackTimerId = _createTimer((function() {
        _flushCallbackTimerId = null, _flushImpl(callback, sendReason);
       }), 0)) : _flushCallbackQueue.push(callback); else {
        var cleared = _clearScheduledTimer();
        _sendEventsForLatencyAndAbove(1, 1, sendReason), null != callback && callback(), 
        cleared && _scheduleTimer();
       }
      }, _self.setMsaAuthTicket = function(ticket) {
       _httpManager.addHeader("AuthMsaDeviceTicket", ticket);
      }, _self.hasEvents = _hasEvents, _self._setTransmitProfile = function(profileName) {
       _currentProfile !== profileName && void 0 !== _profiles[profileName] && (_clearScheduledTimer(), 
       _currentProfile = profileName, _scheduleTimer());
      }, _self._backOffTransmission = function() {
       _currentBackoffCount < 4 && (_currentBackoffCount++, _clearScheduledTimer(), _scheduleTimer());
      }, _self._clearBackOff = function() {
       _currentBackoffCount && (_currentBackoffCount = 0, _clearScheduledTimer(), _scheduleTimer());
      }, (0, HelperFuncs.l_)(_self, "_setTimeoutOverride", (function() {
       return _timeoutWrapper.set;
      }), (function(value) {
       _timeoutWrapper = createTimeoutWrapper(value, _timeoutWrapper.clear);
      })), (0, HelperFuncs.l_)(_self, "_clearTimeoutOverride", (function() {
       return _timeoutWrapper.clear;
      }), (function(value) {
       _timeoutWrapper = createTimeoutWrapper(_timeoutWrapper.set, value);
      }));
     })), _this;
    }
    return (0, TsLibShims.ne)(PostChannel, _super), PostChannel.__ieDyn = 1, PostChannel;
   }(BaseTelemetryPlugin.i);
  },
  50951: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    By: () => createEnumStyle
   });
   var _JavaScriptSDK_HelperFuncs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24869);
   function createEnumStyle(values) {
    var enumClass = {};
    return (0, _JavaScriptSDK_HelperFuncs__WEBPACK_IMPORTED_MODULE_0__.rW)(values, (function(field, value) {
     enumClass[field] = value, enumClass[value] = field;
    })), (0, _JavaScriptSDK_HelperFuncs__WEBPACK_IMPORTED_MODULE_0__._A)(enumClass);
   }
  },
  28452: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    h: () => EventsDiscardedReason
   });
   var EventsDiscardedReason = (0, __webpack_require__(50951).By)({
    Unknown: 0,
    NonRetryableStatus: 1,
    InvalidEvent: 2,
    SizeLimitExceeded: 3,
    KillSwitch: 4,
    QueueFull: 5
   });
  },
  87951: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    i: () => BaseTelemetryPlugin
   });
   var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29141), _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98145), _HelperFuncs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(24869), _InternalConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(96335), _ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(31030), _UnloadHandlerContainer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(38593), BaseTelemetryPlugin = function() {
    function BaseTelemetryPlugin() {
     var _isinitialized, _rootCtx, _nextPlugin, _unloadHandlerContainer, _hooks, _self = this;
     function _getTelCtx(currentCtx) {
      void 0 === currentCtx && (currentCtx = null);
      var itemCtx = currentCtx;
      if (!itemCtx) {
       var rootCtx = _rootCtx || (0, _ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_3__.CD)(null, {}, _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.oV]);
       itemCtx = _nextPlugin && _nextPlugin.getPlugin ? rootCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.zV](null, _nextPlugin.getPlugin) : rootCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.zV](null, _nextPlugin);
      }
      return itemCtx;
     }
     function _setDefaults(config, core, pluginChain) {
      config && (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_4__.sO)(config, _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.Zh, [], null, _HelperFuncs__WEBPACK_IMPORTED_MODULE_4__.le), 
      !pluginChain && core && (pluginChain = core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.SD]()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.W2]());
      var nextPlugin = _nextPlugin;
      _nextPlugin && _nextPlugin.getPlugin && (nextPlugin = _nextPlugin.getPlugin()), 
      _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.oV] = core, _rootCtx = (0, 
      _ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_3__.CD)(pluginChain, config, core, nextPlugin);
     }
     function _initDefaults() {
      _isinitialized = !1, _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.oV] = null, 
      _rootCtx = null, _nextPlugin = null, _hooks = [], _unloadHandlerContainer = (0, 
      _UnloadHandlerContainer__WEBPACK_IMPORTED_MODULE_5__.Y)();
     }
     _initDefaults(), (0, _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__.Z)(BaseTelemetryPlugin, _self, (function(_self) {
      _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.VL] = function(config, core, extensions, pluginChain) {
       _setDefaults(config, core, pluginChain), _isinitialized = !0;
      }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.fi] = function(unloadCtx, unloadState) {
       var _a, core = _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.oV];
       if (core && (!unloadCtx || core === unloadCtx[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.oV]())) {
        var result, unloadDone = !1, theUnloadCtx = unloadCtx || (0, _ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_3__.Bt)(null, core, _nextPlugin && _nextPlugin.getPlugin ? _nextPlugin.getPlugin() : _nextPlugin), theUnloadState = unloadState || ((_a = {
         reason: 0
        })[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.d] = !1, _a);
        return _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.F3] && !0 === _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.F3](theUnloadCtx, theUnloadState, _unloadCallback) ? result = !0 : _unloadCallback(), 
        result;
       }
       function _unloadCallback() {
        if (!unloadDone) {
         unloadDone = !0, _unloadHandlerContainer.run(theUnloadCtx, unloadState);
         var oldHooks = _hooks;
         _hooks = [], (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_4__.tO)(oldHooks, (function(fn) {
          fn.rm();
         })), !0 === result && theUnloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.uL](theUnloadState), 
         _initDefaults();
        }
       }
      }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Tu] = function(updateCtx, updateState) {
       var core = _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.oV];
       if (core && (!updateCtx || core === updateCtx[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.oV]())) {
        var result, updateDone = !1, theUpdateCtx = updateCtx || (0, _ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_3__.xy)(null, core, _nextPlugin && _nextPlugin.getPlugin ? _nextPlugin.getPlugin() : _nextPlugin), theUpdateState = updateState || {
         reason: 0
        };
        return _self._doUpdate && !0 === _self._doUpdate(theUpdateCtx, theUpdateState, _updateCallback) ? result = !0 : _updateCallback(), 
        result;
       }
       function _updateCallback() {
        updateDone || (updateDone = !0, _setDefaults(theUpdateCtx.getCfg(), theUpdateCtx.core(), theUpdateCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.W2]()));
       }
      }, _self._addHook = function(hooks) {
       hooks && ((0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_4__.kJ)(hooks) ? _hooks = _hooks.concat(hooks) : _hooks[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.MW](hooks));
      }, (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_4__.Oi)(_self, "_addUnloadCb", (function() {
       return _unloadHandlerContainer;
      }), "add");
     })), _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.mc] = function(itemCtx) {
      return _getTelCtx(itemCtx)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.mc]();
     }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.yl] = function() {
      return _isinitialized;
     }, _self.setInitialized = function(isInitialized) {
      _isinitialized = isInitialized;
     }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Jd] = function(next) {
      _nextPlugin = next;
     }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.uL] = function(env, itemCtx) {
      itemCtx ? itemCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.uL](env) : _nextPlugin && (0, 
      _HelperFuncs__WEBPACK_IMPORTED_MODULE_4__.mf)(_nextPlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.hL]) && _nextPlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.hL](env, null);
     }, _self._getTelCtx = _getTelCtx;
    }
    return BaseTelemetryPlugin.__ieDyn = 1, BaseTelemetryPlugin;
   }();
  },
  88140: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    JP: () => safeGetCookieMgr,
    Nz: () => createCookieMgr,
    UY: () => uaDisallowsSameSiteNone,
    kj: () => _gblCookieMgr,
    p7: () => areCookiesSupported
   });
   var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98145), _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(29339), _EnvUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49251), _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24869), _InternalConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(96335), strToGMTString = "toGMTString", strToUTCString = "toUTCString", strCookie = "cookie", strExpires = "expires", strEnabled = "enabled", strIsCookieUseDisabled = "isCookieUseDisabled", strDisableCookiesUsage = "disableCookiesUsage", strConfigCookieMgr = "_ckMgr", _supportsCookies = null, _allowUaSameSite = null, _parsedCookieValue = null, _doc = (0, 
   _EnvUtils__WEBPACK_IMPORTED_MODULE_0__.Me)(), _cookieCache = {}, _globalCookieConfig = {};
   function _gblCookieMgr(config, logger) {
    var inst = createCookieMgr[strConfigCookieMgr] || _globalCookieConfig[strConfigCookieMgr];
    return inst || (inst = createCookieMgr[strConfigCookieMgr] = createCookieMgr(config, logger), 
    _globalCookieConfig[strConfigCookieMgr] = inst), inst;
   }
   function _isMgrEnabled(cookieMgr) {
    return !cookieMgr || cookieMgr.isEnabled();
   }
   function _isIgnoredCookie(cookieMgrCfg, name) {
    return !!(name && cookieMgrCfg && (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.kJ)(cookieMgrCfg.ignoreCookies)) && -1 !== cookieMgrCfg.ignoreCookies[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.ou](name);
   }
   function safeGetCookieMgr(core, config) {
    var cookieMgr;
    if (core) cookieMgr = core.getCookieMgr(); else if (config) {
     var cookieCfg = config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Lk];
     cookieMgr = cookieCfg[strConfigCookieMgr] ? cookieCfg[strConfigCookieMgr] : createCookieMgr(config);
    }
    return cookieMgr || (cookieMgr = _gblCookieMgr(config, (core || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.eZ])), 
    cookieMgr;
   }
   function createCookieMgr(rootConfig, logger) {
    var _a, cookieMgrConfig = function(rootConfig) {
     var cookieMgrCfg = rootConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Lk] = rootConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Lk] || {};
     if ((0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.sO)(cookieMgrCfg, "domain", rootConfig.cookieDomain, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.BX, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.le), 
     (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.sO)(cookieMgrCfg, "path", rootConfig.cookiePath || "/", null, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.le), 
     (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.le)(cookieMgrCfg[strEnabled])) {
      var cookieEnabled = void 0;
      (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.o8)(rootConfig[strIsCookieUseDisabled]) || (cookieEnabled = !rootConfig[strIsCookieUseDisabled]), 
      (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.o8)(rootConfig[strDisableCookiesUsage]) || (cookieEnabled = !rootConfig[strDisableCookiesUsage]), 
      cookieMgrCfg[strEnabled] = cookieEnabled;
     }
     return cookieMgrCfg;
    }(rootConfig || _globalCookieConfig), _path = cookieMgrConfig.path || "/", _domain = cookieMgrConfig.domain, _enabled = !1 !== cookieMgrConfig[strEnabled], cookieMgr = ((_a = {
     isEnabled: function() {
      var enabled = _enabled && areCookiesSupported(logger), gblManager = _globalCookieConfig[strConfigCookieMgr];
      return enabled && gblManager && cookieMgr !== gblManager && (enabled = _isMgrEnabled(gblManager)), 
      enabled;
     }
    })[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.$h] = function(value) {
     _enabled = !1 !== value;
    }, _a.set = function(name, value, maxAgeSec, domain, path) {
     var result = !1;
     if (_isMgrEnabled(cookieMgr) && !function(cookieMgrCfg, name) {
      return !!(name && cookieMgrCfg && (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.kJ)(cookieMgrCfg.blockedCookies) && -1 !== cookieMgrCfg.blockedCookies[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.ou](name)) || _isIgnoredCookie(cookieMgrCfg, name);
     }(cookieMgrConfig, name)) {
      var values = {}, theValue = (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.nd)(value || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.qS), idx = theValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.ou](";");
      if (-1 !== idx && (theValue = (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.nd)(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.zc](0, idx)), 
      values = _extractParts(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.zc](idx + 1))), 
      (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.sO)(values, "domain", domain || _domain, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.fQ, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.o8), 
      !(0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.le)(maxAgeSec)) {
       var _isIE = (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_0__.w1)();
       if ((0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.o8)(values[strExpires])) {
        var expireMs = (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.m6)() + 1e3 * maxAgeSec;
        if (expireMs > 0) {
         var expiry = new Date;
         expiry.setTime(expireMs), (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.sO)(values, strExpires, _formatDate(expiry, _isIE ? strToGMTString : strToUTCString) || _formatDate(expiry, _isIE ? strToGMTString : strToUTCString) || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.qS, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.fQ);
        }
       }
       _isIE || (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.sO)(values, "max-age", _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.qS + maxAgeSec, null, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.o8);
      }
      var location_1 = (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_0__.k$)();
      location_1 && "https:" === location_1.protocol && ((0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.sO)(values, "secure", null, null, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.o8), 
      null === _allowUaSameSite && (_allowUaSameSite = !uaDisallowsSameSiteNone(((0, _EnvUtils__WEBPACK_IMPORTED_MODULE_0__.jW)() || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.qV])), 
      _allowUaSameSite && (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.sO)(values, "SameSite", "None", null, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.o8)), 
      (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.sO)(values, "path", path || _path, null, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.o8), 
      (cookieMgrConfig.setCookie || _setCookieValue)(name, _formatCookieValue(theValue, values)), 
      result = !0;
     }
     return result;
    }, _a.get = function(name) {
     var value = _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.qS;
     return _isMgrEnabled(cookieMgr) && !_isIgnoredCookie(cookieMgrConfig, name) && (value = (cookieMgrConfig.getCookie || _getCookieValue)(name)), 
     value;
    }, _a.del = function(name, path) {
     var result = !1;
     return _isMgrEnabled(cookieMgr) && (result = cookieMgr.purge(name, path)), result;
    }, _a.purge = function(name, path) {
     var _a, result = !1;
     if (areCookiesSupported(logger)) {
      var values = ((_a = {}).path = path || "/", _a[strExpires] = "Thu, 01 Jan 1970 00:00:01 GMT", 
      _a);
      (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_0__.w1)() || (values["max-age"] = "0"), (cookieMgrConfig.delCookie || _setCookieValue)(name, _formatCookieValue(_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.qS, values)), 
      result = !0;
     }
     return result;
    }, _a);
    return cookieMgr[strConfigCookieMgr] = cookieMgr, cookieMgr;
   }
   function areCookiesSupported(logger) {
    if (null === _supportsCookies) {
     _supportsCookies = !1;
     try {
      _supportsCookies = void 0 !== (_doc || {})[strCookie];
     } catch (e) {
      (0, _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_4__.kP)(logger, 2, 68, "Cannot access document.cookie - " + (0, 
      _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.jj)(e), {
       exception: (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_0__.eU)(e)
      });
     }
    }
    return _supportsCookies;
   }
   function _extractParts(theValue) {
    var values = {};
    if (theValue && theValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.R5]) {
     var parts = (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.nd)(theValue)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.w6](";");
     (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.tO)(parts, (function(thePart) {
      if (thePart = (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.nd)(thePart || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.qS)) {
       var idx = thePart[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.ou]("=");
       -1 === idx ? values[thePart] = null : values[(0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.nd)(thePart[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.zc](0, idx))] = (0, 
       _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.nd)(thePart[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.zc](idx + 1));
      }
     }));
    }
    return values;
   }
   function _formatDate(theDate, func) {
    return (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.mf)(theDate[func]) ? theDate[func]() : null;
   }
   function _formatCookieValue(value, values) {
    var cookieValue = value || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.qS;
    return (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.rW)(values, (function(name, theValue) {
     cookieValue += "; " + name + ((0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.le)(theValue) ? _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.qS : "=" + theValue);
    })), cookieValue;
   }
   function _getCookieValue(name) {
    var cookieValue = _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.qS;
    if (_doc) {
     var theCookie = _doc[strCookie] || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.qS;
     _parsedCookieValue !== theCookie && (_cookieCache = _extractParts(theCookie), _parsedCookieValue = theCookie), 
     cookieValue = (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.nd)(_cookieCache[name] || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.qS);
    }
    return cookieValue;
   }
   function _setCookieValue(name, cookieValue) {
    _doc && (_doc[strCookie] = name + "=" + cookieValue);
   }
   function uaDisallowsSameSiteNone(userAgent) {
    return !!(0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.HD)(userAgent) && (!(!(0, 
    _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__._Q)(userAgent, "CPU iPhone OS 12") && !(0, 
    _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__._Q)(userAgent, "iPad; CPU OS 12")) || (!!((0, 
    _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__._Q)(userAgent, "Macintosh; Intel Mac OS X 10_14") && (0, 
    _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__._Q)(userAgent, "Version/") && (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__._Q)(userAgent, "Safari")) || (!(!(0, 
    _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__._Q)(userAgent, "Macintosh; Intel Mac OS X 10_14") || !(0, 
    _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Id)(userAgent, "AppleWebKit/605.1.15 (KHTML, like Gecko)")) || (!(!(0, 
    _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__._Q)(userAgent, "Chrome/5") && !(0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__._Q)(userAgent, "Chrome/6")) || (!(!(0, 
    _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__._Q)(userAgent, "UnrealEngine") || (0, 
    _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__._Q)(userAgent, "Chrome")) || !(!(0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__._Q)(userAgent, "UCBrowser/12") && !(0, 
    _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__._Q)(userAgent, "UCBrowser/11")))))));
   }
  },
  28956: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    DO: () => generateW3CId,
    GW: () => newGuid,
    Jj: () => perfNow,
    zB: () => EventHelper
   });
   var _canUseCookies, _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(30175), _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98145), _CookieMgr__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(88140), _EnvUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49251), _EventHelpers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(47954), _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24869), _InternalConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(96335), _RandomHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19406), _cookieMgrs = null;
   function newGuid() {
    var uuid = generateW3CId();
    return uuid[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.zc](0, 8) + "-" + uuid[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.zc](8, 12) + "-" + uuid[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.zc](12, 16) + "-" + uuid[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.zc](16, 20) + "-" + uuid[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.zc](20);
   }
   function perfNow() {
    var perf = (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_1__.r)();
    return perf && perf.now ? perf.now() : (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.m6)();
   }
   function generateW3CId() {
    for (var tmp, hexValues = [ "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f" ], oct = _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.qS, a = 0; a < 4; a++) oct += hexValues[15 & (tmp = (0, 
    _RandomHelper__WEBPACK_IMPORTED_MODULE_4__._l)())] + hexValues[tmp >> 4 & 15] + hexValues[tmp >> 8 & 15] + hexValues[tmp >> 12 & 15] + hexValues[tmp >> 16 & 15] + hexValues[tmp >> 20 & 15] + hexValues[tmp >> 24 & 15] + hexValues[tmp >> 28 & 15];
    var clockSequenceHi = hexValues[8 + (3 & (0, _RandomHelper__WEBPACK_IMPORTED_MODULE_4__._l)()) | 0];
    return oct[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Jn](0, 8) + oct[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Jn](9, 4) + "4" + oct[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Jn](13, 3) + clockSequenceHi + oct[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Jn](16, 3) + oct[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Jn](19, 12);
   }
   var CoreUtils = {
    _canUseCookies: void 0,
    isTypeof: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Ym,
    isUndefined: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.o8,
    isNullOrUndefined: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.le,
    hasOwnProperty: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.nr,
    isFunction: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.mf,
    isObject: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Kn,
    isDate: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.J_,
    isArray: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.kJ,
    isError: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.VZ,
    isString: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.HD,
    isNumber: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.hj,
    isBoolean: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.jn,
    toISOString: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Y6,
    arrForEach: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.tO,
    arrIndexOf: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.UA,
    arrMap: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Mr,
    arrReduce: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Xz,
    strTrim: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.nd,
    objCreate: _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_5__.pu,
    objKeys: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.FY,
    objDefineAccessors: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.l_,
    addEventHandler: _EventHelpers__WEBPACK_IMPORTED_MODULE_6__.Ib,
    dateNow: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.m6,
    isIE: _EnvUtils__WEBPACK_IMPORTED_MODULE_1__.w1,
    disableCookies: function() {
     _legacyCookieMgr()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.$h](!1);
    },
    newGuid,
    perfNow,
    newId: _RandomHelper__WEBPACK_IMPORTED_MODULE_4__.pZ,
    randomValue: _RandomHelper__WEBPACK_IMPORTED_MODULE_4__.az,
    random32: _RandomHelper__WEBPACK_IMPORTED_MODULE_4__._l,
    mwcRandomSeed: _RandomHelper__WEBPACK_IMPORTED_MODULE_4__.CN,
    mwcRandom32: _RandomHelper__WEBPACK_IMPORTED_MODULE_4__.F6,
    generateW3CId
   }, EventHelper = {
    Attach: _EventHelpers__WEBPACK_IMPORTED_MODULE_6__.pZ,
    AttachEvent: _EventHelpers__WEBPACK_IMPORTED_MODULE_6__.pZ,
    Detach: _EventHelpers__WEBPACK_IMPORTED_MODULE_6__.pD,
    DetachEvent: _EventHelpers__WEBPACK_IMPORTED_MODULE_6__.pD
   };
   function _legacyCookieMgr(config, logger) {
    var cookieMgr = (0, _CookieMgr__WEBPACK_IMPORTED_MODULE_7__.kj)(config, logger), legacyCanUseCookies = CoreUtils._canUseCookies;
    return null === _cookieMgrs && (_cookieMgrs = [], _canUseCookies = legacyCanUseCookies, 
    (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.l_)(CoreUtils, "_canUseCookies", (function() {
     return _canUseCookies;
    }), (function(value) {
     _canUseCookies = value, (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.tO)(_cookieMgrs, (function(mgr) {
      mgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.$h](value);
     }));
    }))), -1 === (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.UA)(_cookieMgrs, cookieMgr) && _cookieMgrs[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.MW](cookieMgr), 
    (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.jn)(legacyCanUseCookies) && cookieMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.$h](legacyCanUseCookies), 
    (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.jn)(_canUseCookies) && cookieMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.$h](_canUseCookies), 
    cookieMgr;
   }
  },
  87624: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    J: () => createUniqueNamespace,
    K: () => createElmNodeData
   });
   var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1550), _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98145), _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24869), _InternalConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(96335), _RandomHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19406), _objDefineProperty = _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.RJ, version = "2.8.15", instanceName = "." + (0, 
   _RandomHelper__WEBPACK_IMPORTED_MODULE_1__.pZ)(6), _dataUid = 0;
   function _canAcceptData(target) {
    return 1 === target[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.xv] || 9 === target[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.xv] || !+target[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.xv];
   }
   function _getCache(data, target) {
    var theCache = target[data.id];
    if (!theCache) {
     theCache = {};
     try {
      _canAcceptData(target) && (function(target, prop, value) {
       if (_objDefineProperty) try {
        return _objDefineProperty(target, prop, {
         value,
         enumerable: !1,
         configurable: !0
        }), !0;
       } catch (e) {}
       return !1;
      }(target, data.id, theCache) || (target[data.id] = theCache));
     } catch (e) {}
    }
    return theCache;
   }
   function createUniqueNamespace(name, includeVersion) {
    return void 0 === includeVersion && (includeVersion = !1), (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.Gf)(name + _dataUid++ + (includeVersion ? "." + version : _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.qS) + instanceName);
   }
   function createElmNodeData(name) {
    var data = {
     id: createUniqueNamespace("_aiData-" + (name || _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.qS) + "." + version),
     accept: function(target) {
      return _canAcceptData(target);
     },
     get: function(target, name, defValue, addDefault) {
      var theCache = target[data.id];
      return theCache ? theCache[(0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.Gf)(name)] : (addDefault && ((theCache = _getCache(data, target))[(0, 
      _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.Gf)(name)] = defValue), defValue);
     },
     kill: function(target, name) {
      if (target && target[name]) try {
       delete target[name];
      } catch (e) {}
     }
    };
    return data;
   }
  },
  28341: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    j: () => getDebugExt,
    p: () => getDebugListener
   });
   var _debugListener, _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98145), _EnvUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49251), listenerFuncs = [ "eventsSent", "eventsDiscarded", "eventsSendRequest", "perfEvent" ], _aiNamespace = null;
   function _listenerProxyFunc(name, config) {
    return function() {
     var args = arguments, dbgExt = getDebugExt(config);
     if (dbgExt) {
      var listener = dbgExt.listener;
      listener && listener[name] && listener[name][_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.ZV](listener, args);
     }
    };
   }
   function getDebugExt(config) {
    var target, ns = _aiNamespace;
    return ns || !0 === config.disableDbgExt || (ns = _aiNamespace || ((target = (0, 
    _EnvUtils__WEBPACK_IMPORTED_MODULE_1__.a8)("Microsoft")) && (_aiNamespace = target.ApplicationInsights), 
    _aiNamespace)), ns ? ns.ChromeDbgExt : null;
   }
   function getDebugListener(config) {
    if (!_debugListener) {
     _debugListener = {};
     for (var lp = 0; lp < listenerFuncs[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.R5]; lp++) _debugListener[listenerFuncs[lp]] = _listenerProxyFunc(listenerFuncs[lp], config);
    }
    return _debugListener;
   }
  },
  29339: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    AQ: () => DiagnosticLogger,
    L4: () => _logInternalMessage,
    jV: () => _warnToConsole,
    kP: () => _throwInternal,
    lQ: () => _InternalLogMessage,
    vH: () => safeGetLogger
   });
   var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(29141), _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98145), _DbgExtensionUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(28341), _EnvUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49251), _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24869), _InternalConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96335);
   function _sanitizeDiagnosticText(text) {
    return text ? '"' + text[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.i7](/\"/g, _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.qS) + '"' : _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.qS;
   }
   function _logToConsole(func, message) {
    var theConsole = (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_2__.dr)();
    if (theConsole) {
     var logFunc = "log";
     theConsole[func] && (logFunc = func), (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.mf)(theConsole[logFunc]) && theConsole[logFunc](message);
    }
   }
   var _InternalLogMessage = function() {
    function _InternalLogMessage(msgId, msg, isUserAct, properties) {
     void 0 === isUserAct && (isUserAct = !1);
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Gc] = msgId, this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.gU] = (isUserAct ? "AI: " : "AI (Internal): ") + msgId;
     var strProps = _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.qS;
     (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_2__.nS)() && (strProps = (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_2__.xA)().stringify(properties));
     var diagnosticText = (msg ? " message:" + _sanitizeDiagnosticText(msg) : _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.qS) + (properties ? " props:" + _sanitizeDiagnosticText(strProps) : _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.qS);
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.gU] += diagnosticText;
    }
    return _InternalLogMessage.dataType = "MessageData", _InternalLogMessage;
   }();
   function safeGetLogger(core, config) {
    return (core || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.eZ] || new DiagnosticLogger(config);
   }
   var DiagnosticLogger = function() {
    function DiagnosticLogger(config) {
     this.identifier = "DiagnosticLogger", this.queue = [];
     var _loggingLevelConsole, _loggingLevelTelemetry, _maxInternalMessageLimit, _enableDebug, _messageCount = 0, _messageLogged = {};
     (0, _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_4__.Z)(DiagnosticLogger, this, (function(_self) {
      function _logInternalMessage(severity, message) {
       if (!(_messageCount >= _maxInternalMessageLimit)) {
        var logMessage = !0, messageKey = "AITR_" + message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Gc];
        if (_messageLogged[messageKey] ? logMessage = !1 : _messageLogged[messageKey] = !0, 
        logMessage && (severity <= _loggingLevelTelemetry && (_self.queue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.MW](message), 
        _messageCount++, _debugExtMsg(1 === severity ? "error" : "warn", message)), _messageCount === _maxInternalMessageLimit)) {
         var throttleLimitMessage = "Internal events throttle limit per PageView reached for this app.", throttleMessage = new _InternalLogMessage(23, throttleLimitMessage, !1);
         _self.queue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.MW](throttleMessage), 
         1 === severity ? _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.ys](throttleLimitMessage) : _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.cL](throttleLimitMessage);
        }
       }
      }
      function _debugExtMsg(name, data) {
       var dbgExt = (0, _DbgExtensionUtils__WEBPACK_IMPORTED_MODULE_5__.j)(config || {});
       dbgExt && dbgExt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.mc] && dbgExt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.mc](name, data);
      }
      !function(config) {
       _loggingLevelConsole = (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.v4)(config.loggingLevelConsole, 0), 
       _loggingLevelTelemetry = (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.v4)(config.loggingLevelTelemetry, 1), 
       _maxInternalMessageLimit = (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.v4)(config.maxMessageLimit, 25), 
       _enableDebug = (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.v4)(config.enableDebug, (0, 
       _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.v4)(config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Fr], !1));
      }(config || {}), _self.consoleLoggingLevel = function() {
       return _loggingLevelConsole;
      }, _self.telemetryLoggingLevel = function() {
       return _loggingLevelTelemetry;
      }, _self.maxInternalMessageLimit = function() {
       return _maxInternalMessageLimit;
      }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Fr] = function() {
       return _enableDebug;
      }, _self.throwInternal = function(severity, msgId, msg, properties, isUserAct) {
       void 0 === isUserAct && (isUserAct = !1);
       var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);
       if (_enableDebug) throw (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_2__.eU)(message);
       var logFunc = 1 === severity ? _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.ys : _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.cL;
       if ((0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.o8)(message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.gU])) _debugExtMsg("throw" + (1 === severity ? "Critical" : "Warning"), message); else {
        if (isUserAct) {
         var messageKey = +message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Gc];
         !_messageLogged[messageKey] && _loggingLevelConsole >= severity && (_self[logFunc](message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.gU]), 
         _messageLogged[messageKey] = !0);
        } else _loggingLevelConsole >= severity && _self[logFunc](message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.gU]);
        _logInternalMessage(severity, message);
       }
      }, _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.cL] = function(message) {
       _logToConsole("warn", message), _debugExtMsg("warning", message);
      }, _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.ys] = function(message) {
       _logToConsole("error", message), _debugExtMsg("error", message);
      }, _self.resetInternalMessageCount = function() {
       _messageCount = 0, _messageLogged = {};
      }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.jk] = _logInternalMessage;
     }));
    }
    return DiagnosticLogger.__ieDyn = 1, DiagnosticLogger;
   }();
   function _getLogger(logger) {
    return logger || new DiagnosticLogger;
   }
   function _throwInternal(logger, severity, msgId, msg, properties, isUserAct) {
    void 0 === isUserAct && (isUserAct = !1), _getLogger(logger).throwInternal(severity, msgId, msg, properties, isUserAct);
   }
   function _warnToConsole(logger, message) {
    _getLogger(logger)[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.cL](message);
   }
   function _logInternalMessage(logger, severity, message) {
    _getLogger(logger)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.jk](severity, message);
   }
  },
  49251: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    JO: () => isFetchSupported,
    Jj: () => getWindow,
    MF: () => isBeaconsSupported,
    MX: () => getCrypto,
    Me: () => getDocument,
    Nv: () => hasDocument,
    Ym: () => hasWindow,
    Z3: () => isXhrSupported,
    a8: () => getGlobalInst,
    b$: () => isReactNative,
    cp: () => useXDomainRequest,
    d6: () => hasNavigator,
    dI: () => setEnableEnvMocks,
    dr: () => getConsole,
    eU: () => dumpObj,
    ed: () => findMetaTag,
    fE: () => hasHistory,
    gz: () => getMsCrypto,
    jW: () => getNavigator,
    k$: () => getLocation,
    nS: () => hasJSON,
    pI: () => findNamedServerTiming,
    r: () => getPerformance,
    s1: () => getHistory,
    sA: () => getIEVersion,
    w1: () => isIE,
    xA: () => getJSON
   });
   var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1550), _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30175), _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98145), _HelperFuncs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24869), _InternalConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(96335), strWindow = "window", strDocument = "document", strDocumentMode = "documentMode", strNavigator = "navigator", strHistory = "history", strLocation = "location", strConsole = "console", strPerformance = "performance", strJSON = "JSON", strCrypto = "crypto", strMsCrypto = "msCrypto", strReactNative = "ReactNative", strMsie = "msie", strTrident = "trident/", strXMLHttpRequest = "XMLHttpRequest", _isTrident = null, _navUserAgentCheck = null, _enableMocks = !1, _useXDomainRequest = null, _beaconsSupported = null;
   function _hasProperty(theClass, property) {
    var supported = !1;
    if (theClass) {
     try {
      if (!(supported = property in theClass)) {
       var proto = theClass[_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.hB];
       proto && (supported = property in proto);
      }
     } catch (e) {}
     if (!supported) try {
      var tmp = new theClass;
      supported = !(0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_1__.o8)(tmp[property]);
     } catch (e) {}
    }
    return supported;
   }
   function setEnableEnvMocks(enabled) {
    _enableMocks = enabled;
   }
   function getGlobalInst(name) {
    var gbl = (0, _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_2__.Rd)();
    return gbl && gbl[name] ? gbl[name] : name === strWindow && hasWindow() ? window : null;
   }
   function hasWindow() {
    return Boolean(typeof window === _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.fK && window);
   }
   function getWindow() {
    return hasWindow() ? window : getGlobalInst(strWindow);
   }
   function hasDocument() {
    return Boolean(typeof document === _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.fK && document);
   }
   function getDocument() {
    return hasDocument() ? document : getGlobalInst(strDocument);
   }
   function hasNavigator() {
    return Boolean(typeof navigator === _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.fK && navigator);
   }
   function getNavigator() {
    return hasNavigator() ? navigator : getGlobalInst(strNavigator);
   }
   function hasHistory() {
    return Boolean(typeof history === _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.fK && history);
   }
   function getHistory() {
    return hasHistory() ? history : getGlobalInst(strHistory);
   }
   function getLocation(checkForMock) {
    if (checkForMock && _enableMocks) {
     var mockLocation = getGlobalInst("__mockLocation");
     if (mockLocation) return mockLocation;
    }
    return typeof location === _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.fK && location ? location : getGlobalInst(strLocation);
   }
   function getConsole() {
    return typeof console !== _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.jA ? console : getGlobalInst(strConsole);
   }
   function getPerformance() {
    return getGlobalInst(strPerformance);
   }
   function hasJSON() {
    return Boolean(typeof JSON === _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.fK && JSON || null !== getGlobalInst(strJSON));
   }
   function getJSON() {
    return hasJSON() ? JSON || getGlobalInst(strJSON) : null;
   }
   function getCrypto() {
    return getGlobalInst(strCrypto);
   }
   function getMsCrypto() {
    return getGlobalInst(strMsCrypto);
   }
   function isReactNative() {
    var nav = getNavigator();
    return !(!nav || !nav.product) && nav.product === strReactNative;
   }
   function isIE() {
    var nav = getNavigator();
    if (nav && (nav[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.qV] !== _navUserAgentCheck || null === _isTrident)) {
     var userAgent = ((_navUserAgentCheck = nav[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.qV]) || _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.qS)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.T1]();
     _isTrident = (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_1__._Q)(userAgent, strMsie) || (0, 
     _HelperFuncs__WEBPACK_IMPORTED_MODULE_1__._Q)(userAgent, strTrident);
    }
    return _isTrident;
   }
   function getIEVersion(userAgentStr) {
    if (void 0 === userAgentStr && (userAgentStr = null), !userAgentStr) {
     var navigator_1 = getNavigator() || {};
     userAgentStr = navigator_1 ? (navigator_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.qV] || _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.qS)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.T1]() : _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.qS;
    }
    var ua = (userAgentStr || _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.qS)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.T1]();
    if ((0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_1__._Q)(ua, strMsie)) {
     var doc = getDocument() || {};
     return Math.max(parseInt(ua[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.w6](strMsie)[1]), doc[strDocumentMode] || 0);
    }
    if ((0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_1__._Q)(ua, strTrident)) {
     var tridentVer = parseInt(ua[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.w6](strTrident)[1]);
     if (tridentVer) return tridentVer + 4;
    }
    return null;
   }
   function dumpObj(object) {
    var objectTypeDump = Object[_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.hB].toString[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._S](object), propertyValueDump = _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.qS;
    return "[object Error]" === objectTypeDump ? propertyValueDump = "{ stack: '" + object.stack + "', message: '" + object.message + "', name: '" + object[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.I] + "'" : hasJSON() && (propertyValueDump = getJSON().stringify(object)), 
    objectTypeDump + propertyValueDump;
   }
   function isBeaconsSupported() {
    return null === _beaconsSupported && (_beaconsSupported = hasNavigator() && Boolean(getNavigator().sendBeacon)), 
    _beaconsSupported;
   }
   function isFetchSupported(withKeepAlive) {
    var isSupported = !1;
    try {
     isSupported = !!getGlobalInst("fetch");
     var request = getGlobalInst("Request");
     isSupported && withKeepAlive && request && (isSupported = _hasProperty(request, "keepalive"));
    } catch (e) {}
    return isSupported;
   }
   function useXDomainRequest() {
    return null === _useXDomainRequest && (_useXDomainRequest = typeof XDomainRequest !== _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.jA) && isXhrSupported() && (_useXDomainRequest = _useXDomainRequest && !_hasProperty(getGlobalInst(strXMLHttpRequest), "withCredentials")), 
    _useXDomainRequest;
   }
   function isXhrSupported() {
    var isSupported = !1;
    try {
     isSupported = !!getGlobalInst(strXMLHttpRequest);
    } catch (e) {}
    return isSupported;
   }
   function _getNamedValue(values, name) {
    if (values) for (var i = 0; i < values[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.R5]; i++) {
     var value = values[i];
     if (value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.I] && value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.I] === name) return value;
    }
    return {};
   }
   function findMetaTag(name) {
    var doc = getDocument();
    return doc && name ? _getNamedValue(doc.querySelectorAll("meta"), name).content : null;
   }
   function findNamedServerTiming(name) {
    var value, perf = getPerformance();
    if (perf) {
     var navPerf = perf.getEntriesByType("navigation") || [];
     value = _getNamedValue((navPerf[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.R5] > 0 ? navPerf[0] : {}).serverTiming, name).description;
    }
    return value;
   }
  },
  47954: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    C1: () => removeEventHandler,
    C9: () => removePageHideEventListener,
    Ib: () => addEventHandler,
    JA: () => removePageUnloadEventListener,
    QY: () => eventOff,
    TJ: () => addPageHideEventListener,
    XO: () => eventOn,
    Yl: () => removePageShowEventListener,
    c9: () => addPageUnloadEventListener,
    jU: () => mergeEvtNamespace,
    nD: () => addPageShowEventListener,
    nJ: () => removeEventListeners,
    pD: () => detachEvent,
    pZ: () => attachEvent,
    um: () => __getRegisteredEvents,
    yw: () => addEventListeners
   });
   var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98145), _DataCacheHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87624), _EnvUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49251), _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24869), _InternalConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(96335), strOnPrefix = "on", strAttachEvent = "attachEvent", strAddEventHelper = "addEventListener", strDetachEvent = "detachEvent", strRemoveEventListener = "removeEventListener", strEvents = "events", strVisibilityChangeEvt = "visibilitychange", strPageHide = "pagehide", strPageShow = "pageshow", strUnload = "unload", strBeforeUnload = "beforeunload", strPageHideNamespace = (0, 
   _DataCacheHelper__WEBPACK_IMPORTED_MODULE_0__.J)("aiEvtPageHide"), strPageShowNamespace = (0, 
   _DataCacheHelper__WEBPACK_IMPORTED_MODULE_0__.J)("aiEvtPageShow"), rRemoveEmptyNs = /\.[\.]+/g, rRemoveTrailingEmptyNs = /[\.]+$/, _guid = 1, elmNodeData = (0, 
   _DataCacheHelper__WEBPACK_IMPORTED_MODULE_0__.K)("events"), eventNamespace = /^([^.]*)(?:\.(.+)|)/;
   function _normalizeNamespace(name) {
    return name && name[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.i7] ? name[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.i7](/^[\s\.]+|(?=[\s\.])[\.\s]+$/g, _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.qS) : name;
   }
   function _getEvtNamespace(eventName, evtNamespace) {
    var _a;
    if (evtNamespace) {
     var theNamespace_1 = _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.qS;
     (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.kJ)(evtNamespace) ? (theNamespace_1 = _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.qS, 
     (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.tO)(evtNamespace, (function(name) {
      (name = _normalizeNamespace(name)) && ("." !== name[0] && (name = "." + name), theNamespace_1 += name);
     }))) : theNamespace_1 = _normalizeNamespace(evtNamespace), theNamespace_1 && ("." !== theNamespace_1[0] && (theNamespace_1 = "." + theNamespace_1), 
     eventName = (eventName || _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.qS) + theNamespace_1);
    }
    var parsedEvent = eventNamespace.exec(eventName || _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.qS) || [];
    return (_a = {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.P6] = parsedEvent[1], 
    _a.ns = (parsedEvent[2] || _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.qS).replace(rRemoveEmptyNs, ".").replace(rRemoveTrailingEmptyNs, _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.qS)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.w6](".").sort().join("."), 
    _a;
   }
   function __getRegisteredEvents(target, eventName, evtNamespace) {
    var theEvents = [], eventCache = elmNodeData.get(target, strEvents, {}, !1), evtName = _getEvtNamespace(eventName, evtNamespace);
    return (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.rW)(eventCache, (function(evtType, registeredEvents) {
     (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.tO)(registeredEvents, (function(value) {
      var _a;
      evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.P6] && evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.P6] !== value.evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.P6] || evtName.ns && evtName.ns != evtName.ns || theEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.MW](((_a = {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.I] = value.evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.P6] + (value.evtName.ns ? "." + value.evtName.ns : _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.qS), 
      _a.handler = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Kn], _a));
     }));
    })), theEvents;
   }
   function _getRegisteredEvents(target, evtName, addDefault) {
    void 0 === addDefault && (addDefault = !0);
    var aiEvts = elmNodeData.get(target, strEvents, {}, addDefault), registeredEvents = aiEvts[evtName];
    return registeredEvents || (registeredEvents = aiEvts[evtName] = []), registeredEvents;
   }
   function _doDetach(obj, evtName, handlerRef, useCapture) {
    obj && evtName && evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.P6] && (obj[strRemoveEventListener] ? obj[strRemoveEventListener](evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.P6], handlerRef, useCapture) : obj[strDetachEvent] && obj[strDetachEvent](strOnPrefix + evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.P6], handlerRef));
   }
   function _doUnregister(target, events, evtName, unRegFn) {
    for (var idx = events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.R5]; idx--; ) {
     var theEvent = events[idx];
     theEvent && (evtName.ns && evtName.ns !== theEvent.evtName.ns || unRegFn && !unRegFn(theEvent) || (_doDetach(target, theEvent.evtName, theEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Kn], theEvent.capture), 
     events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.cb](idx, 1)));
    }
   }
   function mergeEvtNamespace(theNamespace, namespaces) {
    return namespaces ? _getEvtNamespace("xx", (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.kJ)(namespaces) ? [ theNamespace ].concat(namespaces) : [ theNamespace, namespaces ]).ns[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.w6](".") : theNamespace;
   }
   function eventOn(target, eventName, handlerRef, evtNamespace, useCapture) {
    var _a;
    void 0 === useCapture && (useCapture = !1);
    var result = !1;
    if (target) try {
     var evtName = _getEvtNamespace(eventName, evtNamespace);
     if (result = function(obj, evtName, handlerRef, useCapture) {
      var result = !1;
      return obj && evtName && evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.P6] && handlerRef && (obj[strAddEventHelper] ? (obj[strAddEventHelper](evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.P6], handlerRef, useCapture), 
      result = !0) : obj[strAttachEvent] && (obj[strAttachEvent](strOnPrefix + evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.P6], handlerRef), 
      result = !0)), result;
     }(target, evtName, handlerRef, useCapture), result && elmNodeData.accept(target)) {
      var registeredEvent = ((_a = {
       guid: _guid++,
       evtName
      })[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Kn] = handlerRef, _a.capture = useCapture, 
      _a);
      _getRegisteredEvents(target, evtName.type)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.MW](registeredEvent);
     }
    } catch (e) {}
    return result;
   }
   function eventOff(target, eventName, handlerRef, evtNamespace, useCapture) {
    if (void 0 === useCapture && (useCapture = !1), target) try {
     var evtName_1 = _getEvtNamespace(eventName, evtNamespace), found_1 = !1;
     !function(target, evtName, unRegFn) {
      if (evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.P6]) _doUnregister(target, _getRegisteredEvents(target, evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.P6]), evtName, unRegFn); else {
       var eventCache = elmNodeData.get(target, strEvents, {});
       (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.rW)(eventCache, (function(evtType, events) {
        _doUnregister(target, events, evtName, unRegFn);
       })), 0 === (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.FY)(eventCache)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.R5] && elmNodeData.kill(target, strEvents);
      }
     }(target, evtName_1, (function(regEvent) {
      return !((!evtName_1.ns || handlerRef) && regEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Kn] !== handlerRef) && (found_1 = !0, 
      !0);
     })), found_1 || _doDetach(target, evtName_1, handlerRef, useCapture);
    } catch (e) {}
   }
   function attachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {
    return void 0 === useCapture && (useCapture = !1), eventOn(obj, eventNameWithoutOn, handlerRef, null, useCapture);
   }
   function detachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {
    void 0 === useCapture && (useCapture = !1), eventOff(obj, eventNameWithoutOn, handlerRef, null, useCapture);
   }
   function addEventHandler(eventName, callback, evtNamespace) {
    var result = !1, w = (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_4__.Jj)();
    w && (result = eventOn(w, eventName, callback, evtNamespace), result = eventOn(w.body, eventName, callback, evtNamespace) || result);
    var doc = (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_4__.Me)();
    return doc && (result = eventOn(doc, eventName, callback, evtNamespace) || result), 
    result;
   }
   function removeEventHandler(eventName, callback, evtNamespace) {
    var w = (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_4__.Jj)();
    w && (eventOff(w, eventName, callback, evtNamespace), eventOff(w.body, eventName, callback, evtNamespace));
    var doc = (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_4__.Me)();
    doc && eventOff(doc, eventName, callback, evtNamespace);
   }
   function _addEventListeners(events, listener, excludeEvents, evtNamespace) {
    var added = !1;
    return listener && events && events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.R5] > 0 && (0, 
    _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.tO)(events, (function(name) {
     name && (excludeEvents && -1 !== (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.UA)(excludeEvents, name) || (added = addEventHandler(name, listener, evtNamespace) || added));
    })), added;
   }
   function addEventListeners(events, listener, excludeEvents, evtNamespace) {
    var added = !1;
    return listener && events && (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.kJ)(events) && !(added = _addEventListeners(events, listener, excludeEvents, evtNamespace)) && excludeEvents && excludeEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.R5] > 0 && (added = _addEventListeners(events, listener, null, evtNamespace)), 
    added;
   }
   function removeEventListeners(events, listener, evtNamespace) {
    events && (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.kJ)(events) && (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.tO)(events, (function(name) {
     name && removeEventHandler(name, listener, evtNamespace);
    }));
   }
   function addPageUnloadEventListener(listener, excludeEvents, evtNamespace) {
    return addEventListeners([ strBeforeUnload, strUnload, strPageHide ], listener, excludeEvents, evtNamespace);
   }
   function removePageUnloadEventListener(listener, evtNamespace) {
    removeEventListeners([ strBeforeUnload, strUnload, strPageHide ], listener, evtNamespace);
   }
   function addPageHideEventListener(listener, excludeEvents, evtNamespace) {
    var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace), pageUnloadAdded = _addEventListeners([ strPageHide ], listener, excludeEvents, newNamespaces);
    return excludeEvents && -1 !== (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.UA)(excludeEvents, strVisibilityChangeEvt) || (pageUnloadAdded = _addEventListeners([ strVisibilityChangeEvt ], (function(evt) {
     var doc = (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_4__.Me)();
     listener && doc && "hidden" === doc.visibilityState && listener(evt);
    }), excludeEvents, newNamespaces) || pageUnloadAdded), !pageUnloadAdded && excludeEvents && (pageUnloadAdded = addPageHideEventListener(listener, null, evtNamespace)), 
    pageUnloadAdded;
   }
   function removePageHideEventListener(listener, evtNamespace) {
    var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace);
    removeEventListeners([ strPageHide ], listener, newNamespaces), removeEventListeners([ strVisibilityChangeEvt ], null, newNamespaces);
   }
   function addPageShowEventListener(listener, excludeEvents, evtNamespace) {
    var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace), pageShowAdded = _addEventListeners([ strPageShow ], listener, excludeEvents, newNamespaces);
    return !(pageShowAdded = _addEventListeners([ strVisibilityChangeEvt ], (function(evt) {
     var doc = (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_4__.Me)();
     listener && doc && "visible" === doc.visibilityState && listener(evt);
    }), excludeEvents, newNamespaces) || pageShowAdded) && excludeEvents && (pageShowAdded = addPageShowEventListener(listener, null, evtNamespace)), 
    pageShowAdded;
   }
   function removePageShowEventListener(listener, evtNamespace) {
    var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace);
    removeEventListeners([ strPageShow ], listener, newNamespaces), removeEventListeners([ strVisibilityChangeEvt ], null, newNamespaces);
   }
  },
  24869: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Ax: () => optimizeObject,
    BX: () => isNotNullOrUndefined,
    F: () => isNotTruthy,
    FL: () => objFreeze,
    FY: () => objKeys,
    Gf: () => normalizeJsName,
    HD: () => isString,
    Id: () => strEndsWith,
    J_: () => isDate,
    Kn: () => isObject,
    Mr: () => arrMap,
    Oi: () => proxyFunctionAs,
    UA: () => arrIndexOf,
    VZ: () => isError,
    Vb: () => proxyFunctions,
    Xi: () => objSeal,
    Xz: () => arrReduce,
    Y6: () => toISOString,
    Ym: () => isTypeof,
    _A: () => deepFreeze,
    _Q: () => strContains,
    _y: () => throwError,
    cf: () => proxyAssign,
    fQ: () => isTruthy,
    hj: () => isNumber,
    jj: () => getExceptionName,
    jn: () => isBoolean,
    kJ: () => isArray,
    l_: () => objDefineAccessors,
    le: () => isNullOrUndefined,
    m6: () => dateNow,
    mf: () => isFunction,
    mm: () => objExtend,
    nd: () => strTrim,
    nr: () => hasOwnProperty,
    o8: () => isUndefined,
    qK: () => getSetValue,
    rW: () => objForEachKey,
    sO: () => setValue,
    tO: () => arrForEach,
    v4: () => getCfgValue,
    xe: () => strStartsWith
   });
   var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1550), _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30175), _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98145), _InternalConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(96335), strToISOString = "toISOString", cStrEndsWith = "endsWith", cStrStartsWith = "startsWith", strIndexOf = "indexOf", strMap = "map", strReduce = "reduce", cStrTrim = "trim", str__Proto = "__proto__", strConstructor = "constructor", _objDefineProperty = _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.RJ, _objFreeze = _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.Pw.freeze, _objSeal = _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.Pw.seal, _objKeys = _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.Pw.keys, StringProto = String[_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.hB], _strTrim = StringProto[cStrTrim], _strEndsWith = StringProto[cStrEndsWith], _strStartsWith = StringProto[cStrStartsWith], _dataToISOString = Date[_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.hB][strToISOString], _isArray = Array.isArray, _objToString = _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.V4.toString, _fnToString = _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.CY.toString, _objFunctionString = _fnToString[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._S](_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.Pw), rCamelCase = /-([a-z])/g, rNormalizeInvalid = /([^\w\d_$])/g, rLeadingNumeric = /^(\d+[\w\d_$])/, _objGetPrototypeOf = Object.getPrototypeOf;
   function isTypeof(value, theType) {
    return typeof value === theType;
   }
   function isUndefined(value) {
    return void 0 === value || typeof value === _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.jA;
   }
   function isNullOrUndefined(value) {
    return null === value || isUndefined(value);
   }
   function isNotNullOrUndefined(value) {
    return !isNullOrUndefined(value);
   }
   function hasOwnProperty(obj, prop) {
    return !(!obj || !_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.CY[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._S](obj, prop));
   }
   function isObject(value) {
    return !(!value || typeof value !== _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.fK);
   }
   function isFunction(value) {
    return !(!value || typeof value !== _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.cb);
   }
   function normalizeJsName(name) {
    var value = name;
    return value && isString(value) && (value = (value = (value = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.i7](rCamelCase, (function(_all, letter) {
     return letter.toUpperCase();
    })))[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.i7](rNormalizeInvalid, "_"))[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.i7](rLeadingNumeric, (function(_all, match) {
     return "_" + match;
    }))), value;
   }
   function objForEachKey(target, callbackfn) {
    if (target) for (var prop in target) _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.CY[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._S](target, prop) && callbackfn[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._S](target, prop, target[prop]);
   }
   function strEndsWith(value, search) {
    var result = !1;
    return value && search && !(result = value === search) && (result = _strEndsWith ? value[cStrEndsWith](search) : function(value, search) {
     var result = !1, searchLen = search ? search[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.R5] : 0, valLen = value ? value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.R5] : 0;
     if (searchLen && valLen && valLen >= searchLen && !(result = value === search)) {
      for (var pos = valLen - 1, lp = searchLen - 1; lp >= 0; lp--) {
       if (value[pos] != search[lp]) return !1;
       pos--;
      }
      result = !0;
     }
     return result;
    }(value, search)), result;
   }
   function strStartsWith(value, checkValue) {
    var result = !1;
    return value && checkValue && !(result = value === checkValue) && (result = _strStartsWith ? value[cStrStartsWith](checkValue) : function(value, checkValue) {
     var result = !1, chkLen = checkValue ? checkValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.R5] : 0;
     if (value && chkLen && value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.R5] >= chkLen && !(result = value === checkValue)) {
      for (var lp = 0; lp < chkLen; lp++) if (value[lp] !== checkValue[lp]) return !1;
      result = !0;
     }
     return result;
    }(value, checkValue)), result;
   }
   function strContains(value, search) {
    return !(!value || !search) && -1 !== value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.ou](search);
   }
   function isDate(obj) {
    return !(!obj || "[object Date]" !== _objToString[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._S](obj));
   }
   var isArray = _isArray || function(obj) {
    return !(!obj || "[object Array]" !== _objToString[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._S](obj));
   };
   function isError(obj) {
    return !(!obj || "[object Error]" !== _objToString[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._S](obj));
   }
   function isString(value) {
    return "string" == typeof value;
   }
   function isNumber(value) {
    return "number" == typeof value;
   }
   function isBoolean(value) {
    return "boolean" == typeof value;
   }
   function isPlainObject(value) {
    var result = !1;
    if (value && "object" == typeof value) {
     var proto = _objGetPrototypeOf ? _objGetPrototypeOf(value) : function(target) {
      if (target) {
       if (_objGetPrototypeOf) return _objGetPrototypeOf(target);
       var newProto = target[str__Proto] || target[_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.hB] || target[strConstructor];
       if (newProto) return newProto;
      }
      return null;
     }(value);
     proto ? (proto[strConstructor] && _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.CY[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._S](proto, strConstructor) && (proto = proto[strConstructor]), 
     result = typeof proto === _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.cb && _fnToString[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._S](proto) === _objFunctionString) : result = !0;
    }
    return result;
   }
   function toISOString(date) {
    if (date) return _dataToISOString ? date[strToISOString]() : function(date) {
     if (date && date.getUTCFullYear) {
      var pad = function(num) {
       var r = String(num);
       return 1 === r[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.R5] && (r = "0" + r), 
       r;
      };
      return date.getUTCFullYear() + "-" + pad(date.getUTCMonth() + 1) + "-" + pad(date.getUTCDate()) + "T" + pad(date.getUTCHours()) + ":" + pad(date.getUTCMinutes()) + ":" + pad(date.getUTCSeconds()) + "." + String((date.getUTCMilliseconds() / 1e3).toFixed(3)).slice(2, 5) + "Z";
     }
    }(date);
   }
   function arrForEach(arr, callbackfn, thisArg) {
    var len = arr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.R5];
    try {
     for (var idx = 0; idx < len && (!(idx in arr) || -1 !== callbackfn[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._S](thisArg || arr, arr[idx], idx, arr)); idx++) ;
    } catch (e) {}
   }
   function arrIndexOf(arr, searchElement, fromIndex) {
    if (arr) {
     if (arr[strIndexOf]) return arr[strIndexOf](searchElement, fromIndex);
     var len = arr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.R5], from = fromIndex || 0;
     try {
      for (var lp = Math.max(from >= 0 ? from : len - Math.abs(from), 0); lp < len; lp++) if (lp in arr && arr[lp] === searchElement) return lp;
     } catch (e) {}
    }
    return -1;
   }
   function arrMap(arr, callbackfn, thisArg) {
    var results;
    if (arr) {
     if (arr[strMap]) return arr[strMap](callbackfn, thisArg);
     var len = arr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.R5], _this = thisArg || arr;
     results = new Array(len);
     try {
      for (var lp = 0; lp < len; lp++) lp in arr && (results[lp] = callbackfn[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._S](_this, arr[lp], arr));
     } catch (e) {}
    }
    return results;
   }
   function arrReduce(arr, callbackfn, initialValue) {
    var value;
    if (arr) {
     if (arr[strReduce]) return arr[strReduce](callbackfn, initialValue);
     var len = arr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.R5], lp = 0;
     if (arguments[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.R5] >= 3) value = arguments[2]; else {
      for (;lp < len && !(lp in arr); ) lp++;
      value = arr[lp++];
     }
     for (;lp < len; ) lp in arr && (value = callbackfn(value, arr[lp], lp, arr)), lp++;
    }
    return value;
   }
   function strTrim(str) {
    return str && (str = _strTrim && str[cStrTrim] ? str[cStrTrim]() : str[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.i7] ? str[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.i7](/^\s+|(?=\s)\s+$/g, _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.qS) : str), 
    str;
   }
   var _objKeysHasDontEnumBug = !{
    toString: null
   }.propertyIsEnumerable("toString"), _objKeysDontEnums = [ "toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor" ];
   function objKeys(obj) {
    var objType = typeof obj;
    if (objType === _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.cb || objType === _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.fK && null !== obj || (0, 
    _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__.ZU)("objKeys called on non-object"), 
    !_objKeysHasDontEnumBug && _objKeys) return _objKeys(obj);
    var result = [];
    for (var prop in obj) obj && _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.CY[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._S](obj, prop) && result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.MW](prop);
    if (_objKeysHasDontEnumBug) for (var dontEnumsLength = _objKeysDontEnums[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.R5], lp = 0; lp < dontEnumsLength; lp++) obj && _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.CY[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._S](obj, _objKeysDontEnums[lp]) && result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.MW](_objKeysDontEnums[lp]);
    return result;
   }
   function objDefineAccessors(target, prop, getProp, setProp) {
    if (_objDefineProperty) try {
     var descriptor = {
      enumerable: !0,
      configurable: !0
     };
     return getProp && (descriptor.get = getProp), setProp && (descriptor.set = setProp), 
     _objDefineProperty(target, prop, descriptor), !0;
    } catch (e) {}
    return !1;
   }
   function _doNothing(value) {
    return value;
   }
   function deepFreeze(obj) {
    return _objFreeze && objForEachKey(obj, (function(name, value) {
     (isArray(value) || isObject(value)) && _objFreeze(value);
    })), objFreeze(obj);
   }
   var objFreeze = _objFreeze || _doNothing, objSeal = _objSeal || _doNothing;
   function dateNow() {
    var dt = Date;
    return dt.now ? dt.now() : (new dt).getTime();
   }
   function getExceptionName(object) {
    return isError(object) ? object[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.I] : _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.qS;
   }
   function setValue(target, field, value, valChk, srcChk) {
    var theValue = value;
    return target && ((theValue = target[field]) === value || srcChk && !srcChk(theValue) || valChk && !valChk(value) || (theValue = value, 
    target[field] = theValue)), theValue;
   }
   function getSetValue(target, field, defValue) {
    var theValue;
    return target ? !(theValue = target[field]) && isNullOrUndefined(theValue) && (theValue = isUndefined(defValue) ? {} : defValue, 
    target[field] = theValue) : theValue = isUndefined(defValue) ? {} : defValue, theValue;
   }
   function getCfgValue(theValue, defaultValue) {
    return isNullOrUndefined(theValue) ? defaultValue : theValue;
   }
   function isNotTruthy(value) {
    return !value;
   }
   function isTruthy(value) {
    return !!value;
   }
   function throwError(message) {
    throw new Error(message);
   }
   function _createProxyFunction(source, funcName) {
    var srcFunc = null, src = null;
    return isFunction(source) ? srcFunc = source : src = source, function() {
     var originalArguments = arguments;
     if (srcFunc && (src = srcFunc()), src) return src[funcName][_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.ZV](src, originalArguments);
    };
   }
   function proxyAssign(target, source, chkSet) {
    if (target && source && isObject(target) && isObject(source)) {
     var _loop_1 = function(field) {
      if (isString(field)) {
       var value = source[field];
       isFunction(value) ? chkSet && !chkSet(field, !0, source, target) || (target[field] = _createProxyFunction(source, field)) : chkSet && !chkSet(field, !1, source, target) || (hasOwnProperty(target, field) && delete target[field], 
       objDefineAccessors(target, field, (function() {
        return source[field];
       }), (function(theValue) {
        source[field] = theValue;
       })) || (target[field] = value));
      }
     };
     for (var field in source) _loop_1(field);
    }
    return target;
   }
   function proxyFunctionAs(target, name, source, theFunc, overwriteTarget) {
    target && name && source && (!1 !== overwriteTarget || isUndefined(target[name])) && (target[name] = _createProxyFunction(source, theFunc));
   }
   function proxyFunctions(target, source, functionsToProxy, overwriteTarget) {
    return target && source && isObject(target) && isArray(functionsToProxy) && arrForEach(functionsToProxy, (function(theFuncName) {
     isString(theFuncName) && proxyFunctionAs(target, theFuncName, source, theFuncName, overwriteTarget);
    })), target;
   }
   function optimizeObject(theObject) {
    return theObject && _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.rl && (theObject = (0, 
    _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.Pw)((0, _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.rl)({}, theObject))), 
    theObject;
   }
   function objExtend(obj1, obj2, obj3, obj4, obj5, obj6) {
    var theArgs = arguments, extended = theArgs[0] || {}, argLen = theArgs[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.R5], deep = !1, idx = 1;
    for (argLen > 0 && isBoolean(extended) && (deep = extended, extended = theArgs[idx] || {}, 
    idx++), isObject(extended) || (extended = {}); idx < argLen; idx++) {
     var arg = theArgs[idx], isArgArray = isArray(arg), isArgObj = isObject(arg);
     for (var prop in arg) {
      if (isArgArray && prop in arg || isArgObj && _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.CY[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._S](arg, prop)) {
       var newValue = arg[prop], isNewArray = void 0;
       if (deep && newValue && ((isNewArray = isArray(newValue)) || isPlainObject(newValue))) {
        var clone = extended[prop];
        isNewArray ? isArray(clone) || (clone = []) : isPlainObject(clone) || (clone = {}), 
        newValue = objExtend(deep, clone, newValue);
       }
       void 0 !== newValue && (extended[prop] = newValue);
      }
     }
    }
    return extended;
   }
  },
  96335: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    $F: () => STR_EVENTS_DISCARDED,
    C$: () => STR_PERF_EVENT,
    DN: () => STR_CREATE_PERF_MGR,
    Z: () => STR_CHANNELS,
    Zh: () => STR_EXTENSION_CONFIG,
    cL: () => STR_WARN_TO_CONSOLE,
    f_: () => STR_EVENTS_SEND_REQUEST,
    hL: () => STR_PROCESS_TELEMETRY,
    js: () => STR_EXTENSIONS,
    kl: () => STR_GET_PERF_MGR,
    mE: () => STR_DISABLED,
    oV: () => STR_CORE,
    qS: () => STR_EMPTY,
    uC: () => STR_EVENTS_SENT,
    yi: () => STR_PRIORITY,
    ys: () => STR_ERROR_TO_CONSOLE
   });
   var STR_EMPTY = "", STR_CHANNELS = "channels", STR_CORE = "core", STR_CREATE_PERF_MGR = "createPerfMgr", STR_DISABLED = "disabled", STR_EXTENSION_CONFIG = "extensionConfig", STR_EXTENSIONS = "extensions", STR_PROCESS_TELEMETRY = "processTelemetry", STR_PRIORITY = "priority", STR_EVENTS_SENT = "eventsSent", STR_EVENTS_DISCARDED = "eventsDiscarded", STR_EVENTS_SEND_REQUEST = "eventsSendRequest", STR_PERF_EVENT = "perfEvent", STR_ERROR_TO_CONSOLE = "errorToConsole", STR_WARN_TO_CONSOLE = "warnToConsole", STR_GET_PERF_MGR = "getPerfMgr";
  },
  81782: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Jk: () => PerfManager,
    Lm: () => doPerf,
    j5: () => getGblPerfMgr,
    zn: () => PerfEvent
   });
   var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29141), _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98145), _HelperFuncs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24869), _InternalConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(96335), strParentContextKey = "ParentContextKey", strChildrenContextKey = "ChildrenContextKey", _defaultPerfManager = null, PerfEvent = function() {
    function PerfEvent(name, payloadDetails, isAsync) {
     var theDetails_1, _self = this, accessorDefined = !1;
     (_self.start = (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_0__.m6)(), _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.I] = name, 
     _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.d] = isAsync, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.PL] = function() {
      return !1;
     }, (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_0__.mf)(payloadDetails)) && (accessorDefined = (0, 
     _HelperFuncs__WEBPACK_IMPORTED_MODULE_0__.l_)(_self, "payload", (function() {
      return !theDetails_1 && (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_0__.mf)(payloadDetails) && (theDetails_1 = payloadDetails(), 
      payloadDetails = null), theDetails_1;
     })));
     _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.T] = function(key) {
      return key ? key === PerfEvent[strParentContextKey] || key === PerfEvent[strChildrenContextKey] ? _self[key] : (_self.ctx || {})[key] : null;
     }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.wu] = function(key, value) {
      if (key) if (key === PerfEvent[strParentContextKey]) _self[key] || (_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.PL] = function() {
       return !0;
      }), _self[key] = value; else if (key === PerfEvent[strChildrenContextKey]) _self[key] = value; else {
       (_self.ctx = _self.ctx || {})[key] = value;
      }
     }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Km] = function() {
      var childTime = 0, childEvts = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.T](PerfEvent[strChildrenContextKey]);
      if ((0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_0__.kJ)(childEvts)) for (var lp = 0; lp < childEvts[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.R5]; lp++) {
       var childEvt = childEvts[lp];
       childEvt && (childTime += childEvt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Z_]);
      }
      _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Z_] = (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_0__.m6)() - _self.start, 
      _self.exTime = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Z_] - childTime, 
      _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Km] = function() {}, !accessorDefined && (0, 
      _HelperFuncs__WEBPACK_IMPORTED_MODULE_0__.mf)(payloadDetails) && (_self.payload = payloadDetails());
     };
    }
    return PerfEvent.ParentContextKey = "parent", PerfEvent.ChildrenContextKey = "childEvts", 
    PerfEvent;
   }(), PerfManager = function() {
    function PerfManager(manager) {
     this.ctx = {}, (0, _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_2__.Z)(PerfManager, this, (function(_self) {
      _self.create = function(src, payloadDetails, isAsync) {
       return new PerfEvent(src, payloadDetails, isAsync);
      }, _self.fire = function(perfEvent) {
       perfEvent && (perfEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Km](), manager && (0, 
       _HelperFuncs__WEBPACK_IMPORTED_MODULE_0__.mf)(manager[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.C$]) && manager[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.C$](perfEvent));
      }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.wu] = function(key, value) {
       key && ((_self.ctx = _self.ctx || {})[key] = value);
      }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.T] = function(key) {
       return (_self.ctx || {})[key];
      };
     }));
    }
    return PerfManager.__ieDyn = 1, PerfManager;
   }(), doPerfActiveKey = "CoreUtils.doPerf";
   function doPerf(mgrSource, getSource, func, details, isAsync) {
    if (mgrSource) {
     var perfMgr = mgrSource;
     if (perfMgr[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.kl] && (perfMgr = perfMgr[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.kl]()), 
     perfMgr) {
      var perfEvt = void 0, currentActive = perfMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.T](doPerfActiveKey);
      try {
       if (perfEvt = perfMgr.create(getSource(), details, isAsync)) {
        if (currentActive && perfEvt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.wu] && (perfEvt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.wu](PerfEvent[strParentContextKey], currentActive), 
        currentActive[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.T] && currentActive[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.wu])) {
         var children = currentActive[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.T](PerfEvent[strChildrenContextKey]);
         children || (children = [], currentActive[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.wu](PerfEvent[strChildrenContextKey], children)), 
         children[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.MW](perfEvt);
        }
        return perfMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.wu](doPerfActiveKey, perfEvt), 
        func(perfEvt);
       }
      } catch (ex) {
       perfEvt && perfEvt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.wu] && perfEvt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.wu]("exception", ex);
      } finally {
       perfEvt && perfMgr.fire(perfEvt), perfMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.wu](doPerfActiveKey, currentActive);
      }
     }
    }
    return func();
   }
   function getGblPerfMgr() {
    return _defaultPerfManager;
   }
  },
  31030: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Bt: () => createProcessTelemetryUnloadContext,
    CD: () => createProcessTelemetryContext,
    Vi: () => ProcessTelemetryContext,
    jV: () => createTelemetryProxyChain,
    xy: () => createProcessTelemetryUpdateContext
   });
   var _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98145), _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29339), _EnvUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49251), _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24869), _InternalConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(96335), _PerfManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(81782), _TelemetryHelpers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(69031), strTelemetryPluginChain = "TelemetryPluginChain", strHasRunFlags = "_hasRun", strGetTelCtx = "_getTelCtx", _chainId = 0;
   function _createInternalContext(telemetryChain, config, core, startAt) {
    var _nextProxy = null, _onComplete = [];
    null !== startAt && (_nextProxy = startAt ? function(proxy, core, startAt) {
     for (;proxy; ) {
      if (proxy[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.TO]() === startAt) return proxy;
      proxy = proxy[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.W2]();
     }
     return createTelemetryProxyChain([ startAt ], core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.TC] || {}, core);
    }(telemetryChain, core, startAt) : telemetryChain);
    var context = {
     _next: function() {
      var nextProxy = _nextProxy;
      if (_nextProxy = nextProxy ? nextProxy[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.W2]() : null, 
      !nextProxy) {
       var onComplete = _onComplete;
       onComplete && onComplete[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.R5] > 0 && ((0, 
       _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.tO)(onComplete, (function(completeDetails) {
        try {
         completeDetails.func[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._S](completeDetails.self, completeDetails.args);
        } catch (e) {
         (0, _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_1__.kP)(core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.eZ], 2, 73, "Unexpected Exception during onComplete - " + (0, 
         _EnvUtils__WEBPACK_IMPORTED_MODULE_3__.eU)(e));
        }
       })), _onComplete = []);
      }
      return nextProxy;
     },
     ctx: {
      core: function() {
       return core;
      },
      diagLog: function() {
       return (0, _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_1__.vH)(core, config);
      },
      getCfg: function() {
       return config;
      },
      getExtCfg: _getExtCfg,
      getConfig: function(identifier, field, defaultValue) {
       void 0 === defaultValue && (defaultValue = !1);
       var theValue, extConfig = _getExtCfg(identifier, null);
       extConfig && !(0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.le)(extConfig[field]) ? theValue = extConfig[field] : config && !(0, 
       _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.le)(config[field]) && (theValue = config[field]);
       return (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.le)(theValue) ? defaultValue : theValue;
      },
      hasNext: function() {
       return !!_nextProxy;
      },
      getNext: function() {
       return _nextProxy;
      },
      setNext: function(nextPlugin) {
       _nextProxy = nextPlugin;
      },
      iterate: function(cb) {
       var nextPlugin;
       for (;nextPlugin = context._next(); ) {
        var plugin = nextPlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.TO]();
        plugin && cb(plugin);
       }
      },
      onComplete: function(onComplete, that) {
       for (var args = [], _i = 2; _i < arguments.length; _i++) args[_i - 2] = arguments[_i];
       onComplete && _onComplete[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.MW]({
        func: onComplete,
        self: (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.o8)(that) ? context.ctx : that,
        args
       });
      }
     }
    };
    function _getExtCfg(identifier, defaultValue, mergeDefault) {
     var theConfig;
     if (void 0 === defaultValue && (defaultValue = {}), void 0 === mergeDefault && (mergeDefault = 0), 
     config) {
      var extConfig = config[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.Zh];
      extConfig && identifier && (theConfig = extConfig[identifier]);
     }
     if (theConfig) {
      if ((0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Kn)(defaultValue) && 0 !== mergeDefault) {
       var newConfig_1 = (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.mm)(!0, defaultValue, theConfig);
       config && 2 === mergeDefault && (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.rW)(defaultValue, (function(field) {
        if ((0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.le)(newConfig_1[field])) {
         var cfgValue = config[field];
         (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.le)(cfgValue) || (newConfig_1[field] = cfgValue);
        }
       })), theConfig = newConfig_1;
      }
     } else theConfig = defaultValue;
     return theConfig;
    }
    return context;
   }
   function createProcessTelemetryContext(telemetryChain, config, core, startAt) {
    var internalContext = _createInternalContext(telemetryChain, config, core, startAt), context = internalContext.ctx;
    return context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.uL] = function(env) {
     var nextPlugin = internalContext._next();
     return nextPlugin && nextPlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.hL](env, context), 
     !nextPlugin;
    }, context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.zV] = function(plugins, startAt) {
     return void 0 === plugins && (plugins = null), (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.kJ)(plugins) && (plugins = createTelemetryProxyChain(plugins, config, core, startAt)), 
     createProcessTelemetryContext(plugins || context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.W2](), config, core, startAt);
    }, context;
   }
   function createProcessTelemetryUnloadContext(telemetryChain, core, startAt) {
    var config = core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.TC] || {}, internalContext = _createInternalContext(telemetryChain, config, core, startAt), context = internalContext.ctx;
    return context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.uL] = function(unloadState) {
     var nextPlugin = internalContext._next();
     return nextPlugin && nextPlugin.unload(context, unloadState), !nextPlugin;
    }, context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.zV] = function(plugins, startAt) {
     return void 0 === plugins && (plugins = null), (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.kJ)(plugins) && (plugins = createTelemetryProxyChain(plugins, config, core, startAt)), 
     createProcessTelemetryUnloadContext(plugins || context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.W2](), core, startAt);
    }, context;
   }
   function createProcessTelemetryUpdateContext(telemetryChain, core, startAt) {
    var config = core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.TC] || {}, context = _createInternalContext(telemetryChain, config, core, startAt).ctx;
    return context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.uL] = function(updateState) {
     return context.iterate((function(plugin) {
      (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.mf)(plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Tu]) && plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Tu](context, updateState);
     }));
    }, context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.zV] = function(plugins, startAt) {
     return void 0 === plugins && (plugins = null), (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.kJ)(plugins) && (plugins = createTelemetryProxyChain(plugins, config, core, startAt)), 
     createProcessTelemetryUpdateContext(plugins || context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.W2](), core, startAt);
    }, context;
   }
   function createTelemetryProxyChain(plugins, config, core, startAt) {
    var firstProxy = null, add = !startAt;
    if ((0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.kJ)(plugins) && plugins[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.R5] > 0) {
     var lastProxy_1 = null;
     (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.tO)(plugins, (function(thePlugin) {
      if (add || startAt !== thePlugin || (add = !0), add && thePlugin && (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.mf)(thePlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.hL])) {
       var newProxy = function(plugin, config, core) {
        var chainId, nextProxy = null, hasProcessTelemetry = (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.mf)(plugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.hL]), hasSetNext = (0, 
        _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.mf)(plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Jd]);
        chainId = plugin ? plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.pZ] + "-" + plugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.yi] + "-" + _chainId++ : "Unknown-0-" + _chainId++;
        var proxyChain = {
         getPlugin: function() {
          return plugin;
         },
         getNext: function() {
          return nextProxy;
         },
         processTelemetry: _processTelemetry,
         unload: _unloadPlugin,
         update: _updatePlugin,
         _id: chainId,
         _setNext: function(nextPlugin) {
          nextProxy = nextPlugin;
         }
        };
        function _getTelCtx() {
         var itemCtx;
         return plugin && (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.mf)(plugin[strGetTelCtx]) && (itemCtx = plugin[strGetTelCtx]()), 
         itemCtx || (itemCtx = createProcessTelemetryContext(proxyChain, config, core)), 
         itemCtx;
        }
        function _processChain(itemCtx, processPluginFn, name, details, isAsync) {
         var hasRun = !1, identifier = plugin ? plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.pZ] : strTelemetryPluginChain, hasRunContext = itemCtx[strHasRunFlags];
         return hasRunContext || (hasRunContext = itemCtx[strHasRunFlags] = {}), itemCtx.setNext(nextProxy), 
         plugin && (0, _PerfManager__WEBPACK_IMPORTED_MODULE_5__.Lm)(itemCtx[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.oV](), (function() {
          return identifier + ":" + name;
         }), (function() {
          hasRunContext[chainId] = !0;
          try {
           var nextId = nextProxy ? nextProxy._id : _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.qS;
           nextId && (hasRunContext[nextId] = !1), hasRun = processPluginFn(itemCtx);
          } catch (error) {
           var hasNextRun = !nextProxy || hasRunContext[nextProxy._id];
           hasNextRun && (hasRun = !0), nextProxy && hasNextRun || (0, _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_1__.kP)(itemCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.mc](), 1, 73, "Plugin [" + identifier + "] failed during " + name + " - " + (0, 
           _EnvUtils__WEBPACK_IMPORTED_MODULE_3__.eU)(error) + ", run flags: " + (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_3__.eU)(hasRunContext));
          }
         }), details, isAsync), hasRun;
        }
        function _processTelemetry(env, itemCtx) {
         function _callProcessTelemetry(itemCtx) {
          if (!plugin || !hasProcessTelemetry) return !1;
          var pluginState = (0, _TelemetryHelpers__WEBPACK_IMPORTED_MODULE_6__.OY)(plugin);
          return !pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.fi] && !pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.mE] && (hasSetNext && plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Jd](nextProxy), 
          plugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.hL](env, itemCtx), !0);
         }
         _processChain(itemCtx = itemCtx || _getTelCtx(), _callProcessTelemetry, "processTelemetry", (function() {
          return {
           item: env
          };
         }), !env.sync) || itemCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.uL](env);
        }
        function _unloadPlugin(unloadCtx, unloadState) {
         function _callTeardown() {
          var hasRun = !1;
          if (plugin) {
           var pluginState = (0, _TelemetryHelpers__WEBPACK_IMPORTED_MODULE_6__.OY)(plugin), pluginCore = plugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.oV] || pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.oV];
           !plugin || pluginCore && pluginCore !== unloadCtx.core() || pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.fi] || (pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.oV] = null, 
           pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.fi] = !0, pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.yl] = !1, 
           plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.fi] && !0 === plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.fi](unloadCtx, unloadState) && (hasRun = !0));
          }
          return hasRun;
         }
         _processChain(unloadCtx, _callTeardown, "unload", (function() {}), unloadState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.d]) || unloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.uL](unloadState);
        }
        function _updatePlugin(updateCtx, updateState) {
         function _callUpdate() {
          var hasRun = !1;
          if (plugin) {
           var pluginState = (0, _TelemetryHelpers__WEBPACK_IMPORTED_MODULE_6__.OY)(plugin), pluginCore = plugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.oV] || pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.oV];
           !plugin || pluginCore && pluginCore !== updateCtx.core() || pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.fi] || plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Tu] && !0 === plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Tu](updateCtx, updateState) && (hasRun = !0);
          }
          return hasRun;
         }
         _processChain(updateCtx, _callUpdate, "update", (function() {}), !1) || updateCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.uL](updateState);
        }
        return (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.FL)(proxyChain);
       }(thePlugin, config, core);
       firstProxy || (firstProxy = newProxy), lastProxy_1 && lastProxy_1._setNext(newProxy), 
       lastProxy_1 = newProxy;
      }
     }));
    }
    return startAt && !firstProxy ? createTelemetryProxyChain([ startAt ], config, core) : firstProxy;
   }
   var ProcessTelemetryContext = function(pluginChain, config, core, startAt) {
    var context = createProcessTelemetryContext(pluginChain, config, core, startAt);
    (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Vb)(this, context, (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.FY)(context));
   };
  },
  19406: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    CN: () => mwcRandomSeed,
    F6: () => mwcRandom32,
    _l: () => random32,
    az: () => randomValue,
    pZ: () => newId
   });
   var _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98145), _EnvUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49251), _HelperFuncs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24869), _InternalConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(96335), UInt32Mask = 4294967296, MaxUInt32 = 4294967295, _mwcSeeded = !1, _mwcW = 123456789, _mwcZ = 987654321;
   function _mwcSeed(seedValue) {
    seedValue < 0 && (seedValue >>>= 0), _mwcW = 123456789 + seedValue & MaxUInt32, 
    _mwcZ = 987654321 - seedValue & MaxUInt32, _mwcSeeded = !0;
   }
   function _autoSeedMwc() {
    try {
     var now = 2147483647 & (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_0__.m6)();
     _mwcSeed((Math.random() * UInt32Mask ^ now) + now);
    } catch (e) {}
   }
   function randomValue(maxValue) {
    return maxValue > 0 ? Math.floor(random32() / MaxUInt32 * (maxValue + 1)) >>> 0 : 0;
   }
   function random32(signed) {
    var value = 0, c = (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_1__.MX)() || (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_1__.gz)();
    return c && c.getRandomValues && (value = c.getRandomValues(new Uint32Array(1))[0] & MaxUInt32), 
    0 === value && (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_1__.w1)() && (_mwcSeeded || _autoSeedMwc(), 
    value = mwcRandom32() & MaxUInt32), 0 === value && (value = Math.floor(UInt32Mask * Math.random() | 0)), 
    signed || (value >>>= 0), value;
   }
   function mwcRandomSeed(value) {
    value ? _mwcSeed(value) : _autoSeedMwc();
   }
   function mwcRandom32(signed) {
    var value = ((_mwcZ = 36969 * (65535 & _mwcZ) + (_mwcZ >> 16) & MaxUInt32) << 16) + (65535 & (_mwcW = 18e3 * (65535 & _mwcW) + (_mwcW >> 16) & MaxUInt32)) >>> 0 & MaxUInt32 | 0;
    return signed || (value >>>= 0), value;
   }
   function newId(maxLength) {
    void 0 === maxLength && (maxLength = 22);
    for (var number = random32() >>> 0, chars = 0, result = _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.qS; result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.R5] < maxLength; ) chars++, 
    result += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(63 & number), 
    number >>>= 6, 5 === chars && (number = (random32() << 2 & 4294967295 | 3 & number) >>> 0, 
    chars = 0);
    return result;
   }
  },
  69031: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    AA: () => sortPlugins,
    OY: () => _getPluginState,
    Yn: () => createDistributedTraceContext,
    bP: () => initializePlugins
   });
   var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98145), _DataCacheHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87624), _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24869), _InternalConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(96335), _W3cTraceParent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56207), pluginStateData = (0, 
   _DataCacheHelper__WEBPACK_IMPORTED_MODULE_0__.K)("plugin");
   function _getPluginState(plugin) {
    return pluginStateData.get(plugin, "state", {}, !0);
   }
   function initializePlugins(processContext, extensions) {
    for (var pluginState, initPlugins = [], lastPlugin = null, proxy = processContext[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.W2](); proxy; ) {
     var thePlugin = proxy[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.TO]();
     if (thePlugin) {
      lastPlugin && (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.mf)(lastPlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Jd]) && (0, 
      _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.mf)(thePlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.hL]) && lastPlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Jd](thePlugin);
      ((0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.mf)(thePlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.yl]) ? thePlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.yl]() : (pluginState = _getPluginState(thePlugin))[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.yl]) || initPlugins[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.MW](thePlugin), 
      lastPlugin = thePlugin, proxy = proxy[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.W2]();
     }
    }
    (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.tO)(initPlugins, (function(thePlugin) {
     var core = processContext[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.oV]();
     thePlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.VL](processContext.getCfg(), core, extensions, processContext[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.W2]()), 
     pluginState = _getPluginState(thePlugin), thePlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.oV] || pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.oV] || (pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.oV] = core), 
     pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.yl] = !0, delete pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.fi];
    }));
   }
   function sortPlugins(plugins) {
    return plugins.sort((function(extA, extB) {
     var result = 0;
     if (extB) {
      var bHasProcess = (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.mf)(extB[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.hL]);
      (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.mf)(extA[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.hL]) ? result = bHasProcess ? extA[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.yi] - extB[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.yi] : 1 : bHasProcess && (result = -1);
     } else result = extA ? 1 : -1;
     return result;
    }));
   }
   function createDistributedTraceContext(parentCtx) {
    var trace = {};
    return {
     getName: function() {
      return trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.I];
     },
     setName: function(newValue) {
      parentCtx && parentCtx.setName(newValue), trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.I] = newValue;
     },
     getTraceId: function() {
      return trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.nY];
     },
     setTraceId: function(newValue) {
      parentCtx && parentCtx.setTraceId(newValue), (0, _W3cTraceParent__WEBPACK_IMPORTED_MODULE_4__.jN)(newValue) && (trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.nY] = newValue);
     },
     getSpanId: function() {
      return trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._d];
     },
     setSpanId: function(newValue) {
      parentCtx && parentCtx.setSpanId(newValue), (0, _W3cTraceParent__WEBPACK_IMPORTED_MODULE_4__.Lc)(newValue) && (trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._d] = newValue);
     },
     getTraceFlags: function() {
      return trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.T0];
     },
     setTraceFlags: function(newTraceFlags) {
      parentCtx && parentCtx.setTraceFlags(newTraceFlags), trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.T0] = newTraceFlags;
     }
    };
   }
  },
  38593: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Y: () => createUnloadHandlerContainer
   });
   var _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98145), _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29339), _EnvUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49251), _HelperFuncs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24869);
   function createUnloadHandlerContainer() {
    var handlers = [];
    return {
     add: function(handler) {
      handler && handlers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.MW](handler);
     },
     run: function(unloadCtx, unloadState) {
      (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_1__.tO)(handlers, (function(handler) {
       try {
        handler(unloadCtx, unloadState);
       } catch (e) {
        (0, _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__.kP)(unloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.mc](), 2, 73, "Unexpected error calling unload handler - " + (0, 
        _EnvUtils__WEBPACK_IMPORTED_MODULE_3__.eU)(e));
       }
      })), handlers = [];
     }
    };
   }
  },
  56207: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    J6: () => isValidTraceParent,
    Lc: () => isValidSpanId,
    Pn: () => isSampledFlag,
    SU: () => createTraceParent,
    aR: () => formatTraceParent,
    jN: () => isValidTraceId,
    j_: () => parseTraceParent,
    lq: () => findW3cTraceParent
   });
   var _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98145), _CoreUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28956), _EnvUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49251), _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24869), TRACE_PARENT_REGEX = /^([\da-f]{2})-([\da-f]{32})-([\da-f]{16})-([\da-f]{2})(-[^\s]*)?$/, DEFAULT_VERSION = "00", INVALID_VERSION = "ff", INVALID_TRACE_ID = "00000000000000000000000000000000", INVALID_SPAN_ID = "0000000000000000", SAMPLED_FLAG = 1;
   function _isValid(value, len, invalidValue) {
    return !(!value || value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.R5] !== len || value === invalidValue) && !!value.match(/^[\da-f]*$/);
   }
   function _formatValue(value, len, defValue) {
    return _isValid(value, len) ? value : defValue;
   }
   function _formatFlags(value) {
    (isNaN(value) || value < 0 || value > 255) && (value = 1);
    for (var result = value.toString(16); result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.R5] < 2; ) result = "0" + result;
    return result;
   }
   function createTraceParent(traceId, spanId, flags, version) {
    var _a;
    return (_a = {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.PA] = _isValid(version, 2, INVALID_VERSION) ? version : DEFAULT_VERSION, 
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.nY] = isValidTraceId(traceId) ? traceId : (0, 
    _CoreUtils__WEBPACK_IMPORTED_MODULE_1__.DO)(), _a.spanId = isValidSpanId(spanId) ? spanId : (0, 
    _CoreUtils__WEBPACK_IMPORTED_MODULE_1__.DO)()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Jn](0, 16), 
    _a.traceFlags = flags >= 0 && flags <= 255 ? flags : 1, _a;
   }
   function parseTraceParent(value) {
    var _a;
    if (!value) return null;
    if ((0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.kJ)(value) && (value = value[0] || ""), 
    !value || !(0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.HD)(value) || value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.R5] > 8192) return null;
    var match = TRACE_PARENT_REGEX.exec((0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.nd)(value));
    return match && match[1] !== INVALID_VERSION && match[2] !== INVALID_TRACE_ID && match[3] !== INVALID_SPAN_ID ? ((_a = {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.PA] = match[1], 
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.nY] = match[2], _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._d] = match[3], 
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.T0] = parseInt(match[4], 16), 
    _a) : null;
   }
   function isValidTraceId(value) {
    return _isValid(value, 32, INVALID_TRACE_ID);
   }
   function isValidSpanId(value) {
    return _isValid(value, 16, INVALID_SPAN_ID);
   }
   function isValidTraceParent(value) {
    return !!(value && _isValid(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.PA], 2, INVALID_VERSION) && _isValid(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.nY], 32, INVALID_TRACE_ID) && _isValid(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._d], 16, INVALID_SPAN_ID) && _isValid(_formatFlags(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.T0]), 2));
   }
   function isSampledFlag(value) {
    return !!isValidTraceParent(value) && (value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.T0] & SAMPLED_FLAG) === SAMPLED_FLAG;
   }
   function formatTraceParent(value) {
    if (value) {
     var flags = _formatFlags(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.T0]);
     _isValid(flags, 2) || (flags = "01");
     var version = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.PA] || DEFAULT_VERSION;
     return "00" !== version && "ff" !== version && (version = DEFAULT_VERSION), "".concat(version, "-").concat(_formatValue(value.traceId, 32, INVALID_TRACE_ID), "-").concat(_formatValue(value.spanId, 16, INVALID_SPAN_ID), "-").concat(flags);
    }
    return "";
   }
   function findW3cTraceParent() {
    var traceParent = parseTraceParent((0, _EnvUtils__WEBPACK_IMPORTED_MODULE_3__.ed)("traceparent"));
    return traceParent || (traceParent = parseTraceParent((0, _EnvUtils__WEBPACK_IMPORTED_MODULE_3__.pI)("traceparent"))), 
    traceParent;
   }
  },
  98145: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    $h: () => _DYN_SET_ENABLED,
    F3: () => _DYN__DO_TEARDOWN,
    Fc: () => _DYN_ON_COMPLETE,
    Fr: () => _DYN_ENABLE_DEBUG_EXCEPTI4,
    Gc: () => _DYN_MESSAGE_ID,
    I: () => _DYN_NAME,
    Jd: () => _DYN_SET_NEXT_PLUGIN,
    Jn: () => _DYN_SUBSTR,
    Km: () => _DYN_COMPLETE,
    Kn: () => _DYN_HANDLER,
    LS: () => _DYN_STOP_POLLING_INTERNA3,
    Lk: () => _DYN_COOKIE_CFG,
    MW: () => _DYN_PUSH,
    P6: () => _DYN_TYPE,
    PA: () => _DYN_VERSION,
    PL: () => _DYN_IS_CHILD_EVT,
    R5: () => _DYN_LENGTH,
    SD: () => _DYN_GET_PROCESS_TEL_CONT0,
    T: () => _DYN_GET_CTX,
    T0: () => _DYN_TRACE_FLAGS,
    T1: () => _DYN_TO_LOWER_CASE,
    TC: () => _DYN_CONFIG,
    TO: () => _DYN_GET_PLUGIN,
    Tu: () => _DYN_UPDATE,
    VL: () => _DYN_INITIALIZE,
    W2: () => _DYN_GET_NEXT,
    ZV: () => _DYN_APPLY,
    Z_: () => _DYN_TIME,
    _S: () => _DYN_CALL,
    _d: () => _DYN_SPAN_ID,
    cb: () => _DYN_SPLICE,
    d: () => _DYN_IS_ASYNC,
    dE: () => _DYN_LISTENERS,
    eZ: () => _DYN_LOGGER,
    fi: () => _DYN_TEARDOWN,
    g: () => _DYN_ADD_NOTIFICATION_LIS1,
    gU: () => _DYN_MESSAGE,
    i7: () => _DYN_REPLACE,
    iC: () => _DYN__EXTENSIONS,
    jk: () => _DYN_LOG_INTERNAL_MESSAGE,
    kL: () => _DYN_FLUSH,
    mc: () => _DYN_DIAG_LOG,
    n7: () => _DYN_REMOVE_NOTIFICATION_2,
    nY: () => _DYN_TRACE_ID,
    ou: () => _DYN_INDEX_OF,
    p$: () => _DYN_INSTRUMENTATION_KEY,
    pZ: () => _DYN_IDENTIFIER,
    qV: () => _DYN_USER_AGENT,
    tb: () => _DYN_GET_NOTIFY_MGR,
    uL: () => _DYN_PROCESS_NEXT,
    w6: () => _DYN_SPLIT,
    wu: () => _DYN_SET_CTX,
    xv: () => _DYN_NODE_TYPE,
    yl: () => _DYN_IS_INITIALIZED,
    zV: () => _DYN_CREATE_NEW,
    zc: () => _DYN_SUBSTRING
   });
   var _DYN_INITIALIZE = "initialize", _DYN_NAME = "name", _DYN_GET_NOTIFY_MGR = "getNotifyMgr", _DYN_IDENTIFIER = "identifier", _DYN_PUSH = "push", _DYN_IS_INITIALIZED = "isInitialized", _DYN_CONFIG = "config", _DYN_INSTRUMENTATION_KEY = "instrumentationKey", _DYN_LOGGER = "logger", _DYN_LENGTH = "length", _DYN_TIME = "time", _DYN_PROCESS_NEXT = "processNext", _DYN_GET_PROCESS_TEL_CONT0 = "getProcessTelContext", _DYN_ADD_NOTIFICATION_LIS1 = "addNotificationListener", _DYN_REMOVE_NOTIFICATION_2 = "removeNotificationListener", _DYN_STOP_POLLING_INTERNA3 = "stopPollingInternalLogs", _DYN_ON_COMPLETE = "onComplete", _DYN_GET_PLUGIN = "getPlugin", _DYN_FLUSH = "flush", _DYN__EXTENSIONS = "_extensions", _DYN_SPLICE = "splice", _DYN_TEARDOWN = "teardown", _DYN_MESSAGE_ID = "messageId", _DYN_MESSAGE = "message", _DYN_IS_ASYNC = "isAsync", _DYN__DO_TEARDOWN = "_doTeardown", _DYN_UPDATE = "update", _DYN_GET_NEXT = "getNext", _DYN_DIAG_LOG = "diagLog", _DYN_SET_NEXT_PLUGIN = "setNextPlugin", _DYN_CREATE_NEW = "createNew", _DYN_COOKIE_CFG = "cookieCfg", _DYN_INDEX_OF = "indexOf", _DYN_SUBSTRING = "substring", _DYN_USER_AGENT = "userAgent", _DYN_SPLIT = "split", _DYN_SET_ENABLED = "setEnabled", _DYN_SUBSTR = "substr", _DYN_NODE_TYPE = "nodeType", _DYN_APPLY = "apply", _DYN_REPLACE = "replace", _DYN_ENABLE_DEBUG_EXCEPTI4 = "enableDebugExceptions", _DYN_LOG_INTERNAL_MESSAGE = "logInternalMessage", _DYN_TO_LOWER_CASE = "toLowerCase", _DYN_CALL = "call", _DYN_TYPE = "type", _DYN_HANDLER = "handler", _DYN_LISTENERS = "listeners", _DYN_IS_CHILD_EVT = "isChildEvt", _DYN_GET_CTX = "getCtx", _DYN_SET_CTX = "setCtx", _DYN_COMPLETE = "complete", _DYN_TRACE_ID = "traceId", _DYN_SPAN_ID = "spanId", _DYN_TRACE_FLAGS = "traceFlags", _DYN_VERSION = "version";
  },
  1550: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    CY: () => ObjHasOwnProperty,
    Pw: () => ObjClass,
    RJ: () => ObjDefineProperty,
    V4: () => ObjProto,
    bO: () => strShimHasOwnProperty,
    cb: () => strShimFunction,
    fK: () => strShimObject,
    hB: () => strShimPrototype,
    jA: () => strShimUndefined,
    rl: () => ObjAssign,
    yu: () => ObjCreate
   });
   var strShimFunction = "function", strShimObject = "object", strShimUndefined = "undefined", strShimPrototype = "prototype", strShimHasOwnProperty = "hasOwnProperty", ObjClass = Object, ObjProto = ObjClass[strShimPrototype], ObjAssign = ObjClass.assign, ObjCreate = ObjClass.create, ObjDefineProperty = ObjClass.defineProperty, ObjHasOwnProperty = ObjProto[strShimHasOwnProperty];
  },
  30175: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Rd: () => getGlobal,
    ZU: () => throwTypeError,
    pu: () => objCreateFn
   });
   var _Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1550), _cachedGlobal = null;
   function getGlobal(useCached) {
    void 0 === useCached && (useCached = !0);
    var result = !1 === useCached ? null : _cachedGlobal;
    return result || (typeof globalThis !== _Constants__WEBPACK_IMPORTED_MODULE_0__.jA && (result = globalThis), 
    result || typeof self === _Constants__WEBPACK_IMPORTED_MODULE_0__.jA || (result = self), 
    result || typeof window === _Constants__WEBPACK_IMPORTED_MODULE_0__.jA || (result = window), 
    result || typeof global === _Constants__WEBPACK_IMPORTED_MODULE_0__.jA || (result = global), 
    _cachedGlobal = result), result;
   }
   function throwTypeError(message) {
    throw new TypeError(message);
   }
   function objCreateFn(obj) {
    var func = _Constants__WEBPACK_IMPORTED_MODULE_0__.yu;
    if (func) return func(obj);
    if (null == obj) return {};
    var type = typeof obj;
    function tmpFunc() {}
    return type !== _Constants__WEBPACK_IMPORTED_MODULE_0__.fK && type !== _Constants__WEBPACK_IMPORTED_MODULE_0__.cb && throwTypeError("Object prototype may only be an Object:" + obj), 
    tmpFunc[_Constants__WEBPACK_IMPORTED_MODULE_0__.hB] = obj, new tmpFunc;
   }
  },
  27421: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    $h: () => __spreadArrayFn,
    ne: () => __extendsFn,
    uc: () => __assignFn
   });
   var _Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1550), _Helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30175), __assignFn = (((0, 
   _Helpers__WEBPACK_IMPORTED_MODULE_0__.Rd)() || {}).Symbol, ((0, _Helpers__WEBPACK_IMPORTED_MODULE_0__.Rd)() || {}).Reflect, 
   _Constants__WEBPACK_IMPORTED_MODULE_1__.rl || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) _Constants__WEBPACK_IMPORTED_MODULE_1__.V4[_Constants__WEBPACK_IMPORTED_MODULE_1__.bO].call(s, p) && (t[p] = s[p]);
    return t;
   }), extendStaticsFn = function(d, b) {
    return extendStaticsFn = _Constants__WEBPACK_IMPORTED_MODULE_1__.Pw.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) b[_Constants__WEBPACK_IMPORTED_MODULE_1__.bO](p) && (d[p] = b[p]);
    }, extendStaticsFn(d, b);
   };
   function __extendsFn(d, b) {
    function __() {
     this.constructor = d;
    }
    typeof b !== _Constants__WEBPACK_IMPORTED_MODULE_1__.cb && null !== b && (0, _Helpers__WEBPACK_IMPORTED_MODULE_0__.ZU)("Class extends value " + String(b) + " is not a constructor or null"), 
    extendStaticsFn(d, b), d[_Constants__WEBPACK_IMPORTED_MODULE_1__.hB] = null === b ? (0, 
    _Helpers__WEBPACK_IMPORTED_MODULE_0__.pu)(b) : (__[_Constants__WEBPACK_IMPORTED_MODULE_1__.hB] = b[_Constants__WEBPACK_IMPORTED_MODULE_1__.hB], 
    new __);
   }
   function __spreadArrayFn(to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
    return to;
   }
  },
  40166: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    webSnippet: () => webSnippet
   });
   var webSnippet = '!function(T,l,y){var S=T.location,k="script",D="instrumentationKey",C="ingestionendpoint",I="disableExceptionTracking",E="ai.device.",b="toLowerCase",w="crossOrigin",N="POST",e="appInsightsSDK",t=y.name||"appInsights";(y.name||T[e])&&(T[e]=t);var n=T[t]||function(d){var g=!1,f=!1,m={initialize:!0,queue:[],sv:"5",version:2,config:d};function v(e,t){var n={},a="Browser";return n[E+"id"]=a[b](),n[E+"type"]=a,n["ai.operation.name"]=S&&S.pathname||"_unknown_",n["ai.internal.sdkVersion"]="javascript:snippet_"+(m.sv||m.version),{time:function(){var e=new Date;function t(e){var t=""+e;return 1===t.length&&(t="0"+t),t}return e.getUTCFullYear()+"-"+t(1+e.getUTCMonth())+"-"+t(e.getUTCDate())+"T"+t(e.getUTCHours())+":"+t(e.getUTCMinutes())+":"+t(e.getUTCSeconds())+"."+((e.getUTCMilliseconds()/1e3).toFixed(3)+"").slice(2,5)+"Z"}(),iKey:e,name:"Microsoft.ApplicationInsights."+e.replace(/-/g,"")+"."+t,sampleRate:100,tags:n,data:{baseData:{ver:2}}}}var h=d.url||y.src;if(h){function a(e){var t,n,a,i,r,o,s,c,u,p,l;g=!0,m.queue=[],f||(f=!0,t=h,s=function(){var e={},t=d.connectionString;if(t)for(var n=t.split(";"),a=0;a<n.length;a++){var i=n[a].split("=");2===i.length&&(e[i[0][b]()]=i[1])}if(!e[C]){var r=e.endpointsuffix,o=r?e.location:null;e[C]="https://"+(o?o+".":"")+"dc."+(r||"services.visualstudio.com")}return e}(),c=s[D]||d[D]||"",u=s[C],p=u?u+"/v2/track":d.endpointUrl,(l=[]).push((n="SDK LOAD Failure: Failed to load Application Insights SDK script (See stack for details)",a=t,i=p,(o=(r=v(c,"Exception")).data).baseType="ExceptionData",o.baseData.exceptions=[{typeName:"SDKLoadFailed",message:n.replace(/\\./g,"-"),hasFullStack:!1,stack:n+"\\nSnippet failed to load ["+a+"] -- Telemetry is disabled\\nHelp Link: https://go.microsoft.com/fwlink/?linkid=2128109\\nHost: "+(S&&S.pathname||"_unknown_")+"\\nEndpoint: "+i,parsedStack:[]}],r)),l.push(function(e,t,n,a){var i=v(c,"Message"),r=i.data;r.baseType="MessageData";var o=r.baseData;return o.message=\'AI (Internal): 99 message:"\'+("SDK LOAD Failure: Failed to load Application Insights SDK script (See stack for details) ("+n+")").replace(/\\"/g,"")+\'"\',o.properties={endpoint:a},i}(0,0,t,p)),function(e,t){if(JSON){var n=T.fetch;if(n&&!y.useXhr)n(t,{method:N,body:JSON.stringify(e),mode:"cors"});else if(XMLHttpRequest){var a=new XMLHttpRequest;a.open(N,t),a.setRequestHeader("Content-type","application/json"),a.send(JSON.stringify(e))}}}(l,p))}function i(e,t){f||setTimeout(function(){!t&&m.core||a()},500)}var e=function(){var n=l.createElement(k);n.src=h;var e=y[w];return!e&&""!==e||"undefined"==n[w]||(n[w]=e),n.onload=i,n.onerror=a,n.onreadystatechange=function(e,t){"loaded"!==n.readyState&&"complete"!==n.readyState||i(0,t)},n}();y.ld<0?l.getElementsByTagName("head")[0].appendChild(e):setTimeout(function(){l.getElementsByTagName(k)[0].parentNode.appendChild(e)},y.ld||0)}try{m.cookie=l.cookie}catch(p){}function t(e){for(;e.length;)!function(t){m[t]=function(){var e=arguments;g||m.queue.push(function(){m[t].apply(m,e)})}}(e.pop())}var n="track",r="TrackPage",o="TrackEvent";t([n+"Event",n+"PageView",n+"Exception",n+"Trace",n+"DependencyData",n+"Metric",n+"PageViewPerformance","start"+r,"stop"+r,"start"+o,"stop"+o,"addTelemetryInitializer","setAuthenticatedUserContext","clearAuthenticatedUserContext","flush"]),m.SeverityLevel={Verbose:0,Information:1,Warning:2,Error:3,Critical:4};var s=(d.extensionConfig||{}).ApplicationInsightsAnalytics||{};if(!0!==d[I]&&!0!==s[I]){var c="onerror";t(["_"+c]);var u=T[c];T[c]=function(e,t,n,a,i){var r=u&&u(e,t,n,a,i);return!0!==r&&m["_"+c]({message:e,url:t,lineNumber:n,columnNumber:a,error:i}),r},d.autoExceptionInstrumented=!0}return m}(y.cfg);function a(){y.onInit&&y.onInit(n)}(T[t]=n).queue&&0===n.queue.length?(n.queue.push(a),n.trackPageView({})):a()}(window,document,{\r\nsrc: "https://js.monitor.azure.com/scripts/b/ai.2.min.js", // The SDK URL Source\r\n// name: "appInsights", // Global SDK Instance name defaults to "appInsights" when not supplied\r\n// ld: 0, // Defines the load delay (in ms) before attempting to load the sdk. -1 = block page load and add to head. (default) = 0ms load after timeout,\r\n// useXhr: 1, // Use XHR instead of fetch to report failures (if available),\r\n// crossOrigin: "anonymous", // When supplied this will add the provided value as the cross origin attribute on the script tag\r\n// onInit: null, // Once the application insights instance has loaded and initialized this callback function will be called with 1 argument -- the sdk instance (DO NOT ADD anything to the sdk.queue -- As they won\'t get called)\r\ncfg: { // Application Insights Configuration\r\n    instrumentationKey: "INSTRUMENTATION_KEY"\r\n}});';
  },
  29141: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   var _a;
   __webpack_require__.d(__webpack_exports__, {
    Z: () => dynamicProto
   });
   var Constructor = "constructor", Prototype = "prototype", strFunction = "function", DynInstFuncTable = "_dynInstFuncs", DynProxyTag = "_isDynProxy", DynClassName = "_dynClass", DynClassNamePrefix = "_dynCls$", DynInstChkTag = "_dynInstChk", DynAllowInstChkTag = DynInstChkTag, DynProtoDefaultOptions = "_dfOpts", UnknownValue = "_unknown_", str__Proto = "__proto__", DynProtoBaseProto = "_dyn" + str__Proto, DynProtoCurrent = "_dynInstProto", strUseBaseInst = "useBaseInst", strSetInstFuncs = "setInstFuncs", Obj = Object, _objGetPrototypeOf = Obj.getPrototypeOf, _objGetOwnProps = Obj.getOwnPropertyNames;
   var result, _gbl = ("undefined" != typeof globalThis && (result = globalThis), result || "undefined" == typeof self || (result = self), 
   result || "undefined" == typeof window || (result = window), result || "undefined" == typeof global || (result = global), 
   result || {}), _gblInst = _gbl.__dynProto$Gbl || (_gbl.__dynProto$Gbl = {
    o: (_a = {}, _a[strSetInstFuncs] = !0, _a[strUseBaseInst] = !0, _a),
    n: 1e3
   });
   function _hasOwnProperty(obj, prop) {
    return obj && Obj[Prototype].hasOwnProperty.call(obj, prop);
   }
   function _isObjectOrArrayPrototype(target) {
    return target && (target === Obj[Prototype] || target === Array[Prototype]);
   }
   function _isObjectArrayOrFunctionPrototype(target) {
    return _isObjectOrArrayPrototype(target) || target === Function[Prototype];
   }
   function _getObjProto(target) {
    var newProto;
    if (target) {
     if (_objGetPrototypeOf) return _objGetPrototypeOf(target);
     var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);
     newProto = target[DynProtoBaseProto] || curProto, _hasOwnProperty(target, DynProtoBaseProto) || (delete target[DynProtoCurrent], 
     newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto], 
     target[DynProtoCurrent] = curProto);
    }
    return newProto;
   }
   function _forEachProp(target, func) {
    var props = [];
    if (_objGetOwnProps) props = _objGetOwnProps(target); else for (var name_1 in target) "string" == typeof name_1 && _hasOwnProperty(target, name_1) && props.push(name_1);
    if (props && props.length > 0) for (var lp = 0; lp < props.length; lp++) func(props[lp]);
   }
   function _isDynamicCandidate(target, funcName, skipOwn) {
    return funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || _hasOwnProperty(target, funcName));
   }
   function _throwTypeError(message) {
    throw new TypeError("DynamicProto: " + message);
   }
   function _hasVisited(values, value) {
    for (var lp = values.length - 1; lp >= 0; lp--) if (values[lp] === value) return !0;
    return !1;
   }
   function _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {
    function _createDynamicPrototype(proto, funcName) {
     var dynProtoProxy = function() {
      var instFunc = function(target, funcName, proto, currentDynProtoProxy) {
       var instFunc = null;
       if (target && _hasOwnProperty(proto, DynClassName)) {
        var instFuncTable = target[DynInstFuncTable] || {};
        if ((instFunc = (instFuncTable[proto[DynClassName]] || {})[funcName]) || _throwTypeError("Missing [" + funcName + "] " + strFunction), 
        !instFunc[DynInstChkTag] && !1 !== instFuncTable[DynAllowInstChkTag]) {
         for (var canAddInst = !_hasOwnProperty(target, funcName), objProto = _getObjProto(target), visited = []; canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto); ) {
          var protoFunc = objProto[funcName];
          if (protoFunc) {
           canAddInst = protoFunc === currentDynProtoProxy;
           break;
          }
          visited.push(objProto), objProto = _getObjProto(objProto);
         }
         try {
          canAddInst && (target[funcName] = instFunc), instFunc[DynInstChkTag] = 1;
         } catch (e) {
          instFuncTable[DynAllowInstChkTag] = !1;
         }
        }
       }
       return instFunc;
      }(this, funcName, proto, dynProtoProxy) || function(funcName, proto, currentDynProtoProxy) {
       var protoFunc = proto[funcName];
       return protoFunc === currentDynProtoProxy && (protoFunc = _getObjProto(proto)[funcName]), 
       typeof protoFunc !== strFunction && _throwTypeError("[" + funcName + "] is not a " + strFunction), 
       protoFunc;
      }(funcName, proto, dynProtoProxy);
      return instFunc.apply(this, arguments);
     };
     return dynProtoProxy[DynProxyTag] = 1, dynProtoProxy;
    }
    if (!_isObjectOrArrayPrototype(proto)) {
     var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || {}, instFuncs_1 = instFuncTable[className] = instFuncTable[className] || {};
     !1 !== instFuncTable[DynAllowInstChkTag] && (instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc), 
     _forEachProp(target, (function(name) {
      _isDynamicCandidate(target, name, !1) && target[name] !== baseInstFuncs[name] && (instFuncs_1[name] = target[name], 
      delete target[name], (!_hasOwnProperty(proto, name) || proto[name] && !proto[name][DynProxyTag]) && (proto[name] = _createDynamicPrototype(proto, name)));
     }));
    }
   }
   function _getObjName(target, unknownValue) {
    return _hasOwnProperty(target, Prototype) ? target.name || unknownValue || UnknownValue : ((target || {})[Constructor] || {}).name || unknownValue || UnknownValue;
   }
   function dynamicProto(theClass, target, delegateFunc, options) {
    _hasOwnProperty(theClass, Prototype) || _throwTypeError("theClass is an invalid class definition.");
    var classProto = theClass[Prototype];
    (function(classProto, thisTarget) {
     if (_objGetPrototypeOf) {
      for (var visited = [], thisProto = _getObjProto(thisTarget); thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto); ) {
       if (thisProto === classProto) return !0;
       visited.push(thisProto), thisProto = _getObjProto(thisProto);
      }
      return !1;
     }
     return !0;
    })(classProto, target) || _throwTypeError("[" + _getObjName(theClass) + "] not in hierarchy of [" + _getObjName(target) + "]");
    var className = null;
    _hasOwnProperty(classProto, DynClassName) ? className = classProto[DynClassName] : (className = DynClassNamePrefix + _getObjName(theClass, "_") + "$" + _gblInst.n, 
    _gblInst.n++, classProto[DynClassName] = className);
    var perfOptions = dynamicProto[DynProtoDefaultOptions], useBaseInst = !!perfOptions[strUseBaseInst];
    useBaseInst && options && void 0 !== options[strUseBaseInst] && (useBaseInst = !!options[strUseBaseInst]);
    var instFuncs = function(thisTarget) {
     var instFuncs = {};
     return _forEachProp(thisTarget, (function(name) {
      !instFuncs[name] && _isDynamicCandidate(thisTarget, name, !1) && (instFuncs[name] = thisTarget[name]);
     })), instFuncs;
    }(target), baseFuncs = function(classProto, thisTarget, instFuncs, useBaseInst) {
     function _instFuncProxy(target, funcHost, funcName) {
      var theFunc = funcHost[funcName];
      if (theFunc[DynProxyTag] && useBaseInst) {
       var instFuncTable = target[DynInstFuncTable] || {};
       !1 !== instFuncTable[DynAllowInstChkTag] && (theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc);
      }
      return function() {
       return theFunc.apply(target, arguments);
      };
     }
     var baseFuncs = {};
     _forEachProp(instFuncs, (function(name) {
      baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);
     }));
     for (var baseProto = _getObjProto(classProto), visited = []; baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto); ) _forEachProp(baseProto, (function(name) {
      !baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf) && (baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name));
     })), visited.push(baseProto), baseProto = _getObjProto(baseProto);
     return baseFuncs;
    }(classProto, target, instFuncs, useBaseInst);
    delegateFunc(target, baseFuncs);
    var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];
    setInstanceFunc && options && (setInstanceFunc = !!options[strSetInstFuncs]), _populatePrototype(classProto, className, target, instFuncs, !1 !== setInstanceFunc);
   }
   dynamicProto[DynProtoDefaultOptions] = _gblInst.o;
  },
  7150: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    c: () => ContextAPI
   });
   var context = __webpack_require__(15834), __read = function(o, n) {
    var m = "function" == typeof Symbol && o[Symbol.iterator];
    if (!m) return o;
    var r, e, i = m.call(o), ar = [];
    try {
     for (;(void 0 === n || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
    } catch (error) {
     e = {
      error
     };
    } finally {
     try {
      r && !r.done && (m = i.return) && m.call(i);
     } finally {
      if (e) throw e.error;
     }
    }
    return ar;
   }, __spreadArray = function(to, from, pack) {
    if (pack || 2 === arguments.length) for (var ar, i = 0, l = from.length; i < l; i++) !ar && i in from || (ar || (ar = Array.prototype.slice.call(from, 0, i)), 
    ar[i] = from[i]);
    return to.concat(ar || Array.prototype.slice.call(from));
   }, NoopContextManager = function() {
    function NoopContextManager() {}
    return NoopContextManager.prototype.active = function() {
     return context.I;
    }, NoopContextManager.prototype.with = function(_context, fn, thisArg) {
     for (var args = [], _i = 3; _i < arguments.length; _i++) args[_i - 3] = arguments[_i];
     return fn.call.apply(fn, __spreadArray([ thisArg ], __read(args), !1));
    }, NoopContextManager.prototype.bind = function(_context, target) {
     return target;
    }, NoopContextManager.prototype.enable = function() {
     return this;
    }, NoopContextManager.prototype.disable = function() {
     return this;
    }, NoopContextManager;
   }(), global_utils = __webpack_require__(30658), diag = __webpack_require__(95774), context_read = function(o, n) {
    var m = "function" == typeof Symbol && o[Symbol.iterator];
    if (!m) return o;
    var r, e, i = m.call(o), ar = [];
    try {
     for (;(void 0 === n || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
    } catch (error) {
     e = {
      error
     };
    } finally {
     try {
      r && !r.done && (m = i.return) && m.call(i);
     } finally {
      if (e) throw e.error;
     }
    }
    return ar;
   }, context_spreadArray = function(to, from, pack) {
    if (pack || 2 === arguments.length) for (var ar, i = 0, l = from.length; i < l; i++) !ar && i in from || (ar || (ar = Array.prototype.slice.call(from, 0, i)), 
    ar[i] = from[i]);
    return to.concat(ar || Array.prototype.slice.call(from));
   }, NOOP_CONTEXT_MANAGER = new NoopContextManager, ContextAPI = function() {
    function ContextAPI() {}
    return ContextAPI.getInstance = function() {
     return this._instance || (this._instance = new ContextAPI), this._instance;
    }, ContextAPI.prototype.setGlobalContextManager = function(contextManager) {
     return (0, global_utils.TG)("context", contextManager, diag.G.instance());
    }, ContextAPI.prototype.active = function() {
     return this._getContextManager().active();
    }, ContextAPI.prototype.with = function(context, fn, thisArg) {
     for (var _a, args = [], _i = 3; _i < arguments.length; _i++) args[_i - 3] = arguments[_i];
     return (_a = this._getContextManager()).with.apply(_a, context_spreadArray([ context, fn, thisArg ], context_read(args), !1));
    }, ContextAPI.prototype.bind = function(context, target) {
     return this._getContextManager().bind(context, target);
    }, ContextAPI.prototype._getContextManager = function() {
     return (0, global_utils.Rd)("context") || NOOP_CONTEXT_MANAGER;
    }, ContextAPI.prototype.disable = function() {
     this._getContextManager().disable(), (0, global_utils.J_)("context", diag.G.instance());
    }, ContextAPI;
   }();
  },
  95774: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    G: () => DiagAPI
   });
   var global_utils = __webpack_require__(30658), __read = function(o, n) {
    var m = "function" == typeof Symbol && o[Symbol.iterator];
    if (!m) return o;
    var r, e, i = m.call(o), ar = [];
    try {
     for (;(void 0 === n || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
    } catch (error) {
     e = {
      error
     };
    } finally {
     try {
      r && !r.done && (m = i.return) && m.call(i);
     } finally {
      if (e) throw e.error;
     }
    }
    return ar;
   }, __spreadArray = function(to, from, pack) {
    if (pack || 2 === arguments.length) for (var ar, i = 0, l = from.length; i < l; i++) !ar && i in from || (ar || (ar = Array.prototype.slice.call(from, 0, i)), 
    ar[i] = from[i]);
    return to.concat(ar || Array.prototype.slice.call(from));
   }, DiagComponentLogger = function() {
    function DiagComponentLogger(props) {
     this._namespace = props.namespace || "DiagComponentLogger";
    }
    return DiagComponentLogger.prototype.debug = function() {
     for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
     return logProxy("debug", this._namespace, args);
    }, DiagComponentLogger.prototype.error = function() {
     for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
     return logProxy("error", this._namespace, args);
    }, DiagComponentLogger.prototype.info = function() {
     for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
     return logProxy("info", this._namespace, args);
    }, DiagComponentLogger.prototype.warn = function() {
     for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
     return logProxy("warn", this._namespace, args);
    }, DiagComponentLogger.prototype.verbose = function() {
     for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
     return logProxy("verbose", this._namespace, args);
    }, DiagComponentLogger;
   }();
   function logProxy(funcName, namespace, args) {
    var logger = (0, global_utils.Rd)("diag");
    if (logger) return args.unshift(namespace), logger[funcName].apply(logger, __spreadArray([], __read(args), !1));
   }
   var types = __webpack_require__(16740);
   var diag_read = function(o, n) {
    var m = "function" == typeof Symbol && o[Symbol.iterator];
    if (!m) return o;
    var r, e, i = m.call(o), ar = [];
    try {
     for (;(void 0 === n || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
    } catch (error) {
     e = {
      error
     };
    } finally {
     try {
      r && !r.done && (m = i.return) && m.call(i);
     } finally {
      if (e) throw e.error;
     }
    }
    return ar;
   }, diag_spreadArray = function(to, from, pack) {
    if (pack || 2 === arguments.length) for (var ar, i = 0, l = from.length; i < l; i++) !ar && i in from || (ar || (ar = Array.prototype.slice.call(from, 0, i)), 
    ar[i] = from[i]);
    return to.concat(ar || Array.prototype.slice.call(from));
   }, DiagAPI = function() {
    function DiagAPI() {
     function _logProxy(funcName) {
      return function() {
       for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
       var logger = (0, global_utils.Rd)("diag");
       if (logger) return logger[funcName].apply(logger, diag_spreadArray([], diag_read(args), !1));
      };
     }
     var self = this;
     self.setLogger = function(logger, optionsOrLogLevel) {
      var _a, _b, _c;
      if (void 0 === optionsOrLogLevel && (optionsOrLogLevel = {
       logLevel: types.n.INFO
      }), logger === self) {
       var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
       return self.error(null !== (_a = err.stack) && void 0 !== _a ? _a : err.message), 
       !1;
      }
      "number" == typeof optionsOrLogLevel && (optionsOrLogLevel = {
       logLevel: optionsOrLogLevel
      });
      var oldLogger = (0, global_utils.Rd)("diag"), newLogger = function(maxLevel, logger) {
       function _filterFunc(funcName, theLevel) {
        var theFunc = logger[funcName];
        return "function" == typeof theFunc && maxLevel >= theLevel ? theFunc.bind(logger) : function() {};
       }
       return maxLevel < types.n.NONE ? maxLevel = types.n.NONE : maxLevel > types.n.ALL && (maxLevel = types.n.ALL), 
       logger = logger || {}, {
        error: _filterFunc("error", types.n.ERROR),
        warn: _filterFunc("warn", types.n.WARN),
        info: _filterFunc("info", types.n.INFO),
        debug: _filterFunc("debug", types.n.DEBUG),
        verbose: _filterFunc("verbose", types.n.VERBOSE)
       };
      }(null !== (_b = optionsOrLogLevel.logLevel) && void 0 !== _b ? _b : types.n.INFO, logger);
      if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
       var stack = null !== (_c = (new Error).stack) && void 0 !== _c ? _c : "<failed to generate stacktrace>";
       oldLogger.warn("Current logger will be overwritten from " + stack), newLogger.warn("Current logger will overwrite one already registered from " + stack);
      }
      return (0, global_utils.TG)("diag", newLogger, self, !0);
     }, self.disable = function() {
      (0, global_utils.J_)("diag", self);
     }, self.createComponentLogger = function(options) {
      return new DiagComponentLogger(options);
     }, self.verbose = _logProxy("verbose"), self.debug = _logProxy("debug"), self.info = _logProxy("info"), 
     self.warn = _logProxy("warn"), self.error = _logProxy("error");
    }
    return DiagAPI.instance = function() {
     return this._instance || (this._instance = new DiagAPI), this._instance;
    }, DiagAPI;
   }();
  },
  92599: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    u: () => baggageEntryMetadataFromString,
    H: () => createBaggage
   });
   var diag = __webpack_require__(95774), __read = function(o, n) {
    var m = "function" == typeof Symbol && o[Symbol.iterator];
    if (!m) return o;
    var r, e, i = m.call(o), ar = [];
    try {
     for (;(void 0 === n || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
    } catch (error) {
     e = {
      error
     };
    } finally {
     try {
      r && !r.done && (m = i.return) && m.call(i);
     } finally {
      if (e) throw e.error;
     }
    }
    return ar;
   }, __values = function(o) {
    var s = "function" == typeof Symbol && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && "number" == typeof o.length) return {
     next: function() {
      return o && i >= o.length && (o = void 0), {
       value: o && o[i++],
       done: !o
      };
     }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
   }, BaggageImpl = function() {
    function BaggageImpl(entries) {
     this._entries = entries ? new Map(entries) : new Map;
    }
    return BaggageImpl.prototype.getEntry = function(key) {
     var entry = this._entries.get(key);
     if (entry) return Object.assign({}, entry);
    }, BaggageImpl.prototype.getAllEntries = function() {
     return Array.from(this._entries.entries()).map((function(_a) {
      var _b = __read(_a, 2);
      return [ _b[0], _b[1] ];
     }));
    }, BaggageImpl.prototype.setEntry = function(key, entry) {
     var newBaggage = new BaggageImpl(this._entries);
     return newBaggage._entries.set(key, entry), newBaggage;
    }, BaggageImpl.prototype.removeEntry = function(key) {
     var newBaggage = new BaggageImpl(this._entries);
     return newBaggage._entries.delete(key), newBaggage;
    }, BaggageImpl.prototype.removeEntries = function() {
     for (var e_1, _a, keys = [], _i = 0; _i < arguments.length; _i++) keys[_i] = arguments[_i];
     var newBaggage = new BaggageImpl(this._entries);
     try {
      for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
       var key = keys_1_1.value;
       newBaggage._entries.delete(key);
      }
     } catch (e_1_1) {
      e_1 = {
       error: e_1_1
      };
     } finally {
      try {
       keys_1_1 && !keys_1_1.done && (_a = keys_1.return) && _a.call(keys_1);
      } finally {
       if (e_1) throw e_1.error;
      }
     }
     return newBaggage;
    }, BaggageImpl.prototype.clear = function() {
     return new BaggageImpl;
    }, BaggageImpl;
   }(), baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata"), utils_diag = diag.G.instance();
   function createBaggage(entries) {
    return void 0 === entries && (entries = {}), new BaggageImpl(new Map(Object.entries(entries)));
   }
   function baggageEntryMetadataFromString(str) {
    return "string" != typeof str && (utils_diag.error("Cannot create baggage metadata from unknown type: " + typeof str), 
    str = ""), {
     __TYPE__: baggageEntryMetadataSymbol,
     toString: function() {
      return str;
     }
    };
   }
  },
  66339: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    D: () => context
   });
   var context = __webpack_require__(7150).c.getInstance();
  },
  15834: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   function createContextKey(description) {
    return Symbol.for(description);
   }
   __webpack_require__.d(__webpack_exports__, {
    I: () => ROOT_CONTEXT,
    Y: () => createContextKey
   });
   var ROOT_CONTEXT = new function BaseContext(parentContext) {
    var self = this;
    self._currentContext = parentContext ? new Map(parentContext) : new Map, self.getValue = function(key) {
     return self._currentContext.get(key);
    }, self.setValue = function(key, value) {
     var context = new BaseContext(self._currentContext);
     return context._currentContext.set(key, value), context;
    }, self.deleteValue = function(key) {
     var context = new BaseContext(self._currentContext);
     return context._currentContext.delete(key), context;
    };
   };
  },
  90928: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    K: () => diag
   });
   var diag = __webpack_require__(95774).G.instance();
  },
  16740: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   var DiagLogLevel;
   __webpack_require__.d(__webpack_exports__, {
    n: () => DiagLogLevel
   }), function(DiagLogLevel) {
    DiagLogLevel[DiagLogLevel.NONE = 0] = "NONE", DiagLogLevel[DiagLogLevel.ERROR = 30] = "ERROR", 
    DiagLogLevel[DiagLogLevel.WARN = 50] = "WARN", DiagLogLevel[DiagLogLevel.INFO = 60] = "INFO", 
    DiagLogLevel[DiagLogLevel.DEBUG = 70] = "DEBUG", DiagLogLevel[DiagLogLevel.VERBOSE = 80] = "VERBOSE", 
    DiagLogLevel[DiagLogLevel.ALL = 9999] = "ALL";
   }(DiagLogLevel || (DiagLogLevel = {}));
  },
  94284: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    DiagConsoleLogger: () => DiagConsoleLogger,
    DiagLogLevel: () => types.n,
    INVALID_SPANID: () => invalid_span_constants.fQ,
    INVALID_SPAN_CONTEXT: () => invalid_span_constants.Rr,
    INVALID_TRACEID: () => invalid_span_constants.AE,
    ProxyTracer: () => ProxyTracer.T,
    ProxyTracerProvider: () => ProxyTracerProvider.K,
    ROOT_CONTEXT: () => context.I,
    SamplingDecision: () => SamplingResult.U,
    SpanKind: () => span_kind.M,
    SpanStatusCode: () => trace_status.Q,
    TraceFlags: () => trace_flags.r,
    ValueType: () => ValueType,
    baggageEntryMetadataFromString: () => utils.u,
    context: () => context_api.D,
    createContextKey: () => context.Y,
    createNoopMeter: () => createNoopMeter,
    createTraceState: () => createTraceState,
    default: () => esm,
    defaultTextMapGetter: () => TextMapPropagator.r,
    defaultTextMapSetter: () => TextMapPropagator.M,
    diag: () => diag_api.K,
    isSpanContextValid: () => spancontext_utils.BM,
    isValidSpanId: () => spancontext_utils.Lc,
    isValidTraceId: () => spancontext_utils.jN,
    metrics: () => metrics,
    propagation: () => propagation_api.u,
    trace: () => trace_api.g
   });
   var extendStatics, ValueType, utils = __webpack_require__(92599), context = __webpack_require__(15834), consoleMap = [ {
    n: "error",
    c: "error"
   }, {
    n: "warn",
    c: "warn"
   }, {
    n: "info",
    c: "info"
   }, {
    n: "debug",
    c: "debug"
   }, {
    n: "verbose",
    c: "trace"
   } ], DiagConsoleLogger = function() {
    function _consoleFunc(funcName) {
     return function() {
      for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
      if (console) {
       var theFunc = console[funcName];
       if ("function" != typeof theFunc && (theFunc = console.log), "function" == typeof theFunc) return theFunc.apply(console, args);
      }
     };
    }
    for (var i = 0; i < consoleMap.length; i++) this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
   }, types = __webpack_require__(16740), __extends = (extendStatics = function(d, b) {
    return extendStatics = Object.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
    }, extendStatics(d, b);
   }, function(d, b) {
    if ("function" != typeof b && null !== b) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    function __() {
     this.constructor = d;
    }
    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
    new __);
   }), NoopMeter = function() {
    function NoopMeter() {}
    return NoopMeter.prototype.createHistogram = function(_name, _options) {
     return NOOP_HISTOGRAM_METRIC;
    }, NoopMeter.prototype.createCounter = function(_name, _options) {
     return NOOP_COUNTER_METRIC;
    }, NoopMeter.prototype.createUpDownCounter = function(_name, _options) {
     return NOOP_UP_DOWN_COUNTER_METRIC;
    }, NoopMeter.prototype.createObservableGauge = function(_name, _options) {
     return NOOP_OBSERVABLE_GAUGE_METRIC;
    }, NoopMeter.prototype.createObservableCounter = function(_name, _options) {
     return NOOP_OBSERVABLE_COUNTER_METRIC;
    }, NoopMeter.prototype.createObservableUpDownCounter = function(_name, _options) {
     return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    }, NoopMeter.prototype.addBatchObservableCallback = function(_callback, _observables) {}, 
    NoopMeter.prototype.removeBatchObservableCallback = function(_callback) {}, NoopMeter;
   }(), NoopMetric = function() {}, NoopCounterMetric = function(_super) {
    function NoopCounterMetric() {
     return null !== _super && _super.apply(this, arguments) || this;
    }
    return __extends(NoopCounterMetric, _super), NoopCounterMetric.prototype.add = function(_value, _attributes) {}, 
    NoopCounterMetric;
   }(NoopMetric), NoopUpDownCounterMetric = function(_super) {
    function NoopUpDownCounterMetric() {
     return null !== _super && _super.apply(this, arguments) || this;
    }
    return __extends(NoopUpDownCounterMetric, _super), NoopUpDownCounterMetric.prototype.add = function(_value, _attributes) {}, 
    NoopUpDownCounterMetric;
   }(NoopMetric), NoopHistogramMetric = function(_super) {
    function NoopHistogramMetric() {
     return null !== _super && _super.apply(this, arguments) || this;
    }
    return __extends(NoopHistogramMetric, _super), NoopHistogramMetric.prototype.record = function(_value, _attributes) {}, 
    NoopHistogramMetric;
   }(NoopMetric), NoopObservableMetric = function() {
    function NoopObservableMetric() {}
    return NoopObservableMetric.prototype.addCallback = function(_callback) {}, NoopObservableMetric.prototype.removeCallback = function(_callback) {}, 
    NoopObservableMetric;
   }(), NoopObservableCounterMetric = function(_super) {
    function NoopObservableCounterMetric() {
     return null !== _super && _super.apply(this, arguments) || this;
    }
    return __extends(NoopObservableCounterMetric, _super), NoopObservableCounterMetric;
   }(NoopObservableMetric), NoopObservableGaugeMetric = function(_super) {
    function NoopObservableGaugeMetric() {
     return null !== _super && _super.apply(this, arguments) || this;
    }
    return __extends(NoopObservableGaugeMetric, _super), NoopObservableGaugeMetric;
   }(NoopObservableMetric), NoopObservableUpDownCounterMetric = function(_super) {
    function NoopObservableUpDownCounterMetric() {
     return null !== _super && _super.apply(this, arguments) || this;
    }
    return __extends(NoopObservableUpDownCounterMetric, _super), NoopObservableUpDownCounterMetric;
   }(NoopObservableMetric), NOOP_METER = new NoopMeter, NOOP_COUNTER_METRIC = new NoopCounterMetric, NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric, NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric, NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric, NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric, NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric;
   function createNoopMeter() {
    return NOOP_METER;
   }
   !function(ValueType) {
    ValueType[ValueType.INT = 0] = "INT", ValueType[ValueType.DOUBLE = 1] = "DOUBLE";
   }(ValueType || (ValueType = {}));
   var TextMapPropagator = __webpack_require__(7008), ProxyTracer = __webpack_require__(69953), ProxyTracerProvider = __webpack_require__(5236), SamplingResult = __webpack_require__(51227), span_kind = __webpack_require__(70087), trace_status = __webpack_require__(1820), trace_flags = __webpack_require__(68726), VALID_KEY_REGEX = new RegExp("^(?:[a-z][_0-9a-z-*/]{0,255}|[a-z0-9][_0-9a-z-*/]{0,240}@[a-z][_0-9a-z-*/]{0,13})$"), VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/, INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
   var TraceStateImpl = function() {
    function TraceStateImpl(rawTraceState) {
     this._internalState = new Map, rawTraceState && this._parse(rawTraceState);
    }
    return TraceStateImpl.prototype.set = function(key, value) {
     var traceState = this._clone();
     return traceState._internalState.has(key) && traceState._internalState.delete(key), 
     traceState._internalState.set(key, value), traceState;
    }, TraceStateImpl.prototype.unset = function(key) {
     var traceState = this._clone();
     return traceState._internalState.delete(key), traceState;
    }, TraceStateImpl.prototype.get = function(key) {
     return this._internalState.get(key);
    }, TraceStateImpl.prototype.serialize = function() {
     var _this = this;
     return this._keys().reduce((function(agg, key) {
      return agg.push(key + "=" + _this.get(key)), agg;
     }), []).join(",");
    }, TraceStateImpl.prototype._parse = function(rawTraceState) {
     rawTraceState.length > 512 || (this._internalState = rawTraceState.split(",").reverse().reduce((function(agg, part) {
      var listMember = part.trim(), i = listMember.indexOf("=");
      if (-1 !== i) {
       var key = listMember.slice(0, i), value = listMember.slice(i + 1, part.length);
       (function(key) {
        return VALID_KEY_REGEX.test(key);
       })(key) && function(value) {
        return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
       }(value) && agg.set(key, value);
      }
      return agg;
     }), new Map), this._internalState.size > 32 && (this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, 32))));
    }, TraceStateImpl.prototype._keys = function() {
     return Array.from(this._internalState.keys()).reverse();
    }, TraceStateImpl.prototype._clone = function() {
     var traceState = new TraceStateImpl;
     return traceState._internalState = new Map(this._internalState), traceState;
    }, TraceStateImpl;
   }();
   function createTraceState(rawTraceState) {
    return new TraceStateImpl(rawTraceState);
   }
   var spancontext_utils = __webpack_require__(97228), invalid_span_constants = __webpack_require__(27007), context_api = __webpack_require__(66339), diag_api = __webpack_require__(90928), NOOP_METER_PROVIDER = new (function() {
    function NoopMeterProvider() {}
    return NoopMeterProvider.prototype.getMeter = function(_name, _version, _options) {
     return NOOP_METER;
    }, NoopMeterProvider;
   }()), global_utils = __webpack_require__(30658), diag = __webpack_require__(95774), metrics = function() {
    function MetricsAPI() {}
    return MetricsAPI.getInstance = function() {
     return this._instance || (this._instance = new MetricsAPI), this._instance;
    }, MetricsAPI.prototype.setGlobalMeterProvider = function(provider) {
     return (0, global_utils.TG)("metrics", provider, diag.G.instance());
    }, MetricsAPI.prototype.getMeterProvider = function() {
     return (0, global_utils.Rd)("metrics") || NOOP_METER_PROVIDER;
    }, MetricsAPI.prototype.getMeter = function(name, version, options) {
     return this.getMeterProvider().getMeter(name, version, options);
    }, MetricsAPI.prototype.disable = function() {
     (0, global_utils.J_)("metrics", diag.G.instance());
    }, MetricsAPI;
   }().getInstance(), propagation_api = __webpack_require__(68303), trace_api = __webpack_require__(52210);
   const esm = {
    context: context_api.D,
    diag: diag_api.K,
    metrics,
    propagation: propagation_api.u,
    trace: trace_api.g
   };
  },
  30658: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Rd: () => getGlobal,
    TG: () => registerGlobal,
    J_: () => unregisterGlobal
   });
   var _globalThis = "object" == typeof globalThis ? globalThis : global, VERSION = "1.4.1", re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
   var isCompatible = function(ownVersion) {
    var acceptedVersions = new Set([ ownVersion ]), rejectedVersions = new Set, myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) return function() {
     return !1;
    };
    var ownVersionParsed_major = +myVersionMatch[1], ownVersionParsed_minor = +myVersionMatch[2], ownVersionParsed_patch = +myVersionMatch[3];
    if (null != myVersionMatch[4]) return function(globalVersion) {
     return globalVersion === ownVersion;
    };
    function _reject(v) {
     return rejectedVersions.add(v), !1;
    }
    function _accept(v) {
     return acceptedVersions.add(v), !0;
    }
    return function(globalVersion) {
     if (acceptedVersions.has(globalVersion)) return !0;
     if (rejectedVersions.has(globalVersion)) return !1;
     var globalVersionMatch = globalVersion.match(re);
     if (!globalVersionMatch) return _reject(globalVersion);
     var globalVersionParsed_major = +globalVersionMatch[1], globalVersionParsed_minor = +globalVersionMatch[2], globalVersionParsed_patch = +globalVersionMatch[3];
     return null != globalVersionMatch[4] || ownVersionParsed_major !== globalVersionParsed_major ? _reject(globalVersion) : 0 === ownVersionParsed_major ? ownVersionParsed_minor === globalVersionParsed_minor && ownVersionParsed_patch <= globalVersionParsed_patch ? _accept(globalVersion) : _reject(globalVersion) : ownVersionParsed_minor <= globalVersionParsed_minor ? _accept(globalVersion) : _reject(globalVersion);
    };
   }(VERSION), major = VERSION.split(".")[0], GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major), _global = _globalThis;
   function registerGlobal(type, instance, diag, allowOverride) {
    var _a;
    void 0 === allowOverride && (allowOverride = !1);
    var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = null !== (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) && void 0 !== _a ? _a : {
     version: VERSION
    };
    if (!allowOverride && api[type]) {
     var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
     return diag.error(err.stack || err.message), !1;
    }
    if (api.version !== VERSION) {
     err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
     return diag.error(err.stack || err.message), !1;
    }
    return api[type] = instance, diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + "."), 
    !0;
   }
   function getGlobal(type) {
    var _a, _b, globalVersion = null === (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) || void 0 === _a ? void 0 : _a.version;
    if (globalVersion && isCompatible(globalVersion)) return null === (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) || void 0 === _b ? void 0 : _b[type];
   }
   function unregisterGlobal(type, diag) {
    diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
    var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    api && delete api[type];
   }
  },
  68303: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    u: () => propagation
   });
   var global_utils = __webpack_require__(30658), NoopTextMapPropagator = function() {
    function NoopTextMapPropagator() {}
    return NoopTextMapPropagator.prototype.inject = function(_context, _carrier) {}, 
    NoopTextMapPropagator.prototype.extract = function(context, _carrier) {
     return context;
    }, NoopTextMapPropagator.prototype.fields = function() {
     return [];
    }, NoopTextMapPropagator;
   }(), TextMapPropagator = __webpack_require__(7008), context = __webpack_require__(7150), BAGGAGE_KEY = (0, 
   __webpack_require__(15834).Y)("OpenTelemetry Baggage Key");
   function getBaggage(context) {
    return context.getValue(BAGGAGE_KEY) || void 0;
   }
   function getActiveBaggage() {
    return getBaggage(context.c.getInstance().active());
   }
   function setBaggage(context, baggage) {
    return context.setValue(BAGGAGE_KEY, baggage);
   }
   function deleteBaggage(context) {
    return context.deleteValue(BAGGAGE_KEY);
   }
   var utils = __webpack_require__(92599), diag = __webpack_require__(95774), NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator, PropagationAPI = function() {
    function PropagationAPI() {
     this.createBaggage = utils.H, this.getBaggage = getBaggage, this.getActiveBaggage = getActiveBaggage, 
     this.setBaggage = setBaggage, this.deleteBaggage = deleteBaggage;
    }
    return PropagationAPI.getInstance = function() {
     return this._instance || (this._instance = new PropagationAPI), this._instance;
    }, PropagationAPI.prototype.setGlobalPropagator = function(propagator) {
     return (0, global_utils.TG)("propagation", propagator, diag.G.instance());
    }, PropagationAPI.prototype.inject = function(context, carrier, setter) {
     return void 0 === setter && (setter = TextMapPropagator.M), this._getGlobalPropagator().inject(context, carrier, setter);
    }, PropagationAPI.prototype.extract = function(context, carrier, getter) {
     return void 0 === getter && (getter = TextMapPropagator.r), this._getGlobalPropagator().extract(context, carrier, getter);
    }, PropagationAPI.prototype.fields = function() {
     return this._getGlobalPropagator().fields();
    }, PropagationAPI.prototype.disable = function() {
     (0, global_utils.J_)("propagation", diag.G.instance());
    }, PropagationAPI.prototype._getGlobalPropagator = function() {
     return (0, global_utils.Rd)("propagation") || NOOP_TEXT_MAP_PROPAGATOR;
    }, PropagationAPI;
   }(), propagation = PropagationAPI.getInstance();
  },
  7008: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    M: () => defaultTextMapSetter,
    r: () => defaultTextMapGetter
   });
   var defaultTextMapGetter = {
    get: function(carrier, key) {
     if (null != carrier) return carrier[key];
    },
    keys: function(carrier) {
     return null == carrier ? [] : Object.keys(carrier);
    }
   }, defaultTextMapSetter = {
    set: function(carrier, key, value) {
     null != carrier && (carrier[key] = value);
    }
   };
  },
  52210: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    g: () => trace
   });
   var global_utils = __webpack_require__(30658), ProxyTracerProvider = __webpack_require__(5236), spancontext_utils = __webpack_require__(97228), context_utils = __webpack_require__(73557), diag = __webpack_require__(95774), trace = function() {
    function TraceAPI() {
     this._proxyTracerProvider = new ProxyTracerProvider.K, this.wrapSpanContext = spancontext_utils.kw, 
     this.isSpanContextValid = spancontext_utils.BM, this.deleteSpan = context_utils.TW, 
     this.getSpan = context_utils.Br, this.getActiveSpan = context_utils.HN, this.getSpanContext = context_utils.A3, 
     this.setSpan = context_utils.WZ, this.setSpanContext = context_utils.G3;
    }
    return TraceAPI.getInstance = function() {
     return this._instance || (this._instance = new TraceAPI), this._instance;
    }, TraceAPI.prototype.setGlobalTracerProvider = function(provider) {
     var success = (0, global_utils.TG)("trace", this._proxyTracerProvider, diag.G.instance());
     return success && this._proxyTracerProvider.setDelegate(provider), success;
    }, TraceAPI.prototype.getTracerProvider = function() {
     return (0, global_utils.Rd)("trace") || this._proxyTracerProvider;
    }, TraceAPI.prototype.getTracer = function(name, version) {
     return this.getTracerProvider().getTracer(name, version);
    }, TraceAPI.prototype.disable = function() {
     (0, global_utils.J_)("trace", diag.G.instance()), this._proxyTracerProvider = new ProxyTracerProvider.K;
    }, TraceAPI;
   }().getInstance();
  },
  97817: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    s: () => NonRecordingSpan
   });
   var _invalid_span_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27007), NonRecordingSpan = function() {
    function NonRecordingSpan(_spanContext) {
     void 0 === _spanContext && (_spanContext = _invalid_span_constants__WEBPACK_IMPORTED_MODULE_0__.Rr), 
     this._spanContext = _spanContext;
    }
    return NonRecordingSpan.prototype.spanContext = function() {
     return this._spanContext;
    }, NonRecordingSpan.prototype.setAttribute = function(_key, _value) {
     return this;
    }, NonRecordingSpan.prototype.setAttributes = function(_attributes) {
     return this;
    }, NonRecordingSpan.prototype.addEvent = function(_name, _attributes) {
     return this;
    }, NonRecordingSpan.prototype.setStatus = function(_status) {
     return this;
    }, NonRecordingSpan.prototype.updateName = function(_name) {
     return this;
    }, NonRecordingSpan.prototype.end = function(_endTime) {}, NonRecordingSpan.prototype.isRecording = function() {
     return !1;
    }, NonRecordingSpan.prototype.recordException = function(_exception, _time) {}, 
    NonRecordingSpan;
   }();
  },
  39127: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    E: () => NoopTracer
   });
   var _api_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7150), _trace_context_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(73557), _NonRecordingSpan__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97817), _spancontext_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(97228), contextApi = _api_context__WEBPACK_IMPORTED_MODULE_0__.c.getInstance(), NoopTracer = function() {
    function NoopTracer() {}
    return NoopTracer.prototype.startSpan = function(name, options, context) {
     if (void 0 === context && (context = contextApi.active()), Boolean(null == options ? void 0 : options.root)) return new _NonRecordingSpan__WEBPACK_IMPORTED_MODULE_1__.s;
     var spanContext, parentFromContext = context && (0, _trace_context_utils__WEBPACK_IMPORTED_MODULE_2__.A3)(context);
     return "object" == typeof (spanContext = parentFromContext) && "string" == typeof spanContext.spanId && "string" == typeof spanContext.traceId && "number" == typeof spanContext.traceFlags && (0, 
     _spancontext_utils__WEBPACK_IMPORTED_MODULE_3__.BM)(parentFromContext) ? new _NonRecordingSpan__WEBPACK_IMPORTED_MODULE_1__.s(parentFromContext) : new _NonRecordingSpan__WEBPACK_IMPORTED_MODULE_1__.s;
    }, NoopTracer.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
     var opts, ctx, fn;
     if (!(arguments.length < 2)) {
      2 === arguments.length ? fn = arg2 : 3 === arguments.length ? (opts = arg2, fn = arg3) : (opts = arg2, 
      ctx = arg3, fn = arg4);
      var parentContext = null != ctx ? ctx : contextApi.active(), span = this.startSpan(name, opts, parentContext), contextWithSpanSet = (0, 
      _trace_context_utils__WEBPACK_IMPORTED_MODULE_2__.WZ)(parentContext, span);
      return contextApi.with(contextWithSpanSet, fn, void 0, span);
     }
    }, NoopTracer;
   }();
  },
  69953: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    T: () => ProxyTracer
   });
   var NOOP_TRACER = new (__webpack_require__(39127).E), ProxyTracer = function() {
    function ProxyTracer(_provider, name, version, options) {
     this._provider = _provider, this.name = name, this.version = version, this.options = options;
    }
    return ProxyTracer.prototype.startSpan = function(name, options, context) {
     return this._getTracer().startSpan(name, options, context);
    }, ProxyTracer.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
     var tracer = this._getTracer();
     return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    }, ProxyTracer.prototype._getTracer = function() {
     if (this._delegate) return this._delegate;
     var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
     return tracer ? (this._delegate = tracer, this._delegate) : NOOP_TRACER;
    }, ProxyTracer;
   }();
  },
  5236: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    K: () => ProxyTracerProvider
   });
   var ProxyTracer = __webpack_require__(69953), NoopTracer = __webpack_require__(39127), NOOP_TRACER_PROVIDER = new (function() {
    function NoopTracerProvider() {}
    return NoopTracerProvider.prototype.getTracer = function(_name, _version, _options) {
     return new NoopTracer.E;
    }, NoopTracerProvider;
   }()), ProxyTracerProvider = function() {
    function ProxyTracerProvider() {}
    return ProxyTracerProvider.prototype.getTracer = function(name, version, options) {
     var _a;
     return null !== (_a = this.getDelegateTracer(name, version, options)) && void 0 !== _a ? _a : new ProxyTracer.T(this, name, version, options);
    }, ProxyTracerProvider.prototype.getDelegate = function() {
     var _a;
     return null !== (_a = this._delegate) && void 0 !== _a ? _a : NOOP_TRACER_PROVIDER;
    }, ProxyTracerProvider.prototype.setDelegate = function(delegate) {
     this._delegate = delegate;
    }, ProxyTracerProvider.prototype.getDelegateTracer = function(name, version, options) {
     var _a;
     return null === (_a = this._delegate) || void 0 === _a ? void 0 : _a.getTracer(name, version, options);
    }, ProxyTracerProvider;
   }();
  },
  51227: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   var SamplingDecision;
   __webpack_require__.d(__webpack_exports__, {
    U: () => SamplingDecision
   }), function(SamplingDecision) {
    SamplingDecision[SamplingDecision.NOT_RECORD = 0] = "NOT_RECORD", SamplingDecision[SamplingDecision.RECORD = 1] = "RECORD", 
    SamplingDecision[SamplingDecision.RECORD_AND_SAMPLED = 2] = "RECORD_AND_SAMPLED";
   }(SamplingDecision || (SamplingDecision = {}));
  },
  73557: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    A3: () => getSpanContext,
    Br: () => getSpan,
    G3: () => setSpanContext,
    HN: () => getActiveSpan,
    TW: () => deleteSpan,
    WZ: () => setSpan
   });
   var _context_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15834), _NonRecordingSpan__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97817), _api_context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7150), SPAN_KEY = (0, 
   _context_context__WEBPACK_IMPORTED_MODULE_0__.Y)("OpenTelemetry Context Key SPAN");
   function getSpan(context) {
    return context.getValue(SPAN_KEY) || void 0;
   }
   function getActiveSpan() {
    return getSpan(_api_context__WEBPACK_IMPORTED_MODULE_1__.c.getInstance().active());
   }
   function setSpan(context, span) {
    return context.setValue(SPAN_KEY, span);
   }
   function deleteSpan(context) {
    return context.deleteValue(SPAN_KEY);
   }
   function setSpanContext(context, spanContext) {
    return setSpan(context, new _NonRecordingSpan__WEBPACK_IMPORTED_MODULE_2__.s(spanContext));
   }
   function getSpanContext(context) {
    var _a;
    return null === (_a = getSpan(context)) || void 0 === _a ? void 0 : _a.spanContext();
   }
  },
  27007: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    AE: () => INVALID_TRACEID,
    Rr: () => INVALID_SPAN_CONTEXT,
    fQ: () => INVALID_SPANID
   });
   var _trace_flags__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68726), INVALID_SPANID = "0000000000000000", INVALID_TRACEID = "00000000000000000000000000000000", INVALID_SPAN_CONTEXT = {
    traceId: INVALID_TRACEID,
    spanId: INVALID_SPANID,
    traceFlags: _trace_flags__WEBPACK_IMPORTED_MODULE_0__.r.NONE
   };
  },
  70087: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   var SpanKind;
   __webpack_require__.d(__webpack_exports__, {
    M: () => SpanKind
   }), function(SpanKind) {
    SpanKind[SpanKind.INTERNAL = 0] = "INTERNAL", SpanKind[SpanKind.SERVER = 1] = "SERVER", 
    SpanKind[SpanKind.CLIENT = 2] = "CLIENT", SpanKind[SpanKind.PRODUCER = 3] = "PRODUCER", 
    SpanKind[SpanKind.CONSUMER = 4] = "CONSUMER";
   }(SpanKind || (SpanKind = {}));
  },
  97228: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    BM: () => isSpanContextValid,
    Lc: () => isValidSpanId,
    jN: () => isValidTraceId,
    kw: () => wrapSpanContext
   });
   var _invalid_span_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27007), _NonRecordingSpan__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97817), VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i, VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
   function isValidTraceId(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== _invalid_span_constants__WEBPACK_IMPORTED_MODULE_0__.AE;
   }
   function isValidSpanId(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== _invalid_span_constants__WEBPACK_IMPORTED_MODULE_0__.fQ;
   }
   function isSpanContextValid(spanContext) {
    return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
   }
   function wrapSpanContext(spanContext) {
    return new _NonRecordingSpan__WEBPACK_IMPORTED_MODULE_1__.s(spanContext);
   }
  },
  1820: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   var SpanStatusCode;
   __webpack_require__.d(__webpack_exports__, {
    Q: () => SpanStatusCode
   }), function(SpanStatusCode) {
    SpanStatusCode[SpanStatusCode.UNSET = 0] = "UNSET", SpanStatusCode[SpanStatusCode.OK = 1] = "OK", 
    SpanStatusCode[SpanStatusCode.ERROR = 2] = "ERROR";
   }(SpanStatusCode || (SpanStatusCode = {}));
  },
  68726: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   var TraceFlags;
   __webpack_require__.d(__webpack_exports__, {
    r: () => TraceFlags
   }), function(TraceFlags) {
    TraceFlags[TraceFlags.NONE = 0] = "NONE", TraceFlags[TraceFlags.SAMPLED = 1] = "SAMPLED";
   }(TraceFlags || (TraceFlags = {}));
  },
  63420: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   var ExportResultCode;
   __webpack_require__.d(__webpack_exports__, {
    I: () => ExportResultCode
   }), function(ExportResultCode) {
    ExportResultCode[ExportResultCode.SUCCESS = 0] = "SUCCESS", ExportResultCode[ExportResultCode.FAILED = 1] = "FAILED";
   }(ExportResultCode || (ExportResultCode = {}));
  },
  3250: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Cx: () => BAGGAGE_MAX_NAME_VALUE_PAIRS,
    H3: () => BAGGAGE_MAX_TOTAL_LENGTH,
    Vo: () => BAGGAGE_KEY_PAIR_SEPARATOR,
    WM: () => BAGGAGE_HEADER,
    bO: () => BAGGAGE_PROPERTIES_SEPARATOR,
    bU: () => BAGGAGE_ITEMS_SEPARATOR,
    ef: () => BAGGAGE_MAX_PER_NAME_VALUE_PAIRS
   });
   var BAGGAGE_KEY_PAIR_SEPARATOR = "=", BAGGAGE_PROPERTIES_SEPARATOR = ";", BAGGAGE_ITEMS_SEPARATOR = ",", BAGGAGE_HEADER = "baggage", BAGGAGE_MAX_NAME_VALUE_PAIRS = 180, BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096, BAGGAGE_MAX_TOTAL_LENGTH = 8192;
  },
  80926: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    a: () => W3CBaggagePropagator
   });
   var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68303), _trace_suppress_tracing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98397), _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3250), _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60315), W3CBaggagePropagator = function() {
    function W3CBaggagePropagator() {}
    return W3CBaggagePropagator.prototype.inject = function(context, carrier, setter) {
     var baggage = _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__.u.getBaggage(context);
     if (baggage && !(0, _trace_suppress_tracing__WEBPACK_IMPORTED_MODULE_1__.Ll)(context)) {
      var keyPairs = (0, _utils__WEBPACK_IMPORTED_MODULE_2__.getKeyPairs)(baggage).filter((function(pair) {
       return pair.length <= _constants__WEBPACK_IMPORTED_MODULE_3__.ef;
      })).slice(0, _constants__WEBPACK_IMPORTED_MODULE_3__.Cx), headerValue = (0, _utils__WEBPACK_IMPORTED_MODULE_2__.serializeKeyPairs)(keyPairs);
      headerValue.length > 0 && setter.set(carrier, _constants__WEBPACK_IMPORTED_MODULE_3__.WM, headerValue);
     }
    }, W3CBaggagePropagator.prototype.extract = function(context, carrier, getter) {
     var headerValue = getter.get(carrier, _constants__WEBPACK_IMPORTED_MODULE_3__.WM), baggageString = Array.isArray(headerValue) ? headerValue.join(_constants__WEBPACK_IMPORTED_MODULE_3__.bU) : headerValue;
     if (!baggageString) return context;
     var baggage = {};
     return 0 === baggageString.length ? context : (baggageString.split(_constants__WEBPACK_IMPORTED_MODULE_3__.bU).forEach((function(entry) {
      var keyPair = (0, _utils__WEBPACK_IMPORTED_MODULE_2__.parsePairKeyValue)(entry);
      if (keyPair) {
       var baggageEntry = {
        value: keyPair.value
       };
       keyPair.metadata && (baggageEntry.metadata = keyPair.metadata), baggage[keyPair.key] = baggageEntry;
      }
     })), 0 === Object.entries(baggage).length ? context : _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__.u.setBaggage(context, _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__.u.createBaggage(baggage)));
    }, W3CBaggagePropagator.prototype.fields = function() {
     return [ _constants__WEBPACK_IMPORTED_MODULE_3__.WM ];
    }, W3CBaggagePropagator;
   }();
  },
  60315: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    getKeyPairs: () => getKeyPairs,
    parseKeyPairsIntoRecord: () => parseKeyPairsIntoRecord,
    parsePairKeyValue: () => parsePairKeyValue,
    serializeKeyPairs: () => serializeKeyPairs
   });
   var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92599), _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3250), __read = function(o, n) {
    var m = "function" == typeof Symbol && o[Symbol.iterator];
    if (!m) return o;
    var r, e, i = m.call(o), ar = [];
    try {
     for (;(void 0 === n || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
    } catch (error) {
     e = {
      error
     };
    } finally {
     try {
      r && !r.done && (m = i.return) && m.call(i);
     } finally {
      if (e) throw e.error;
     }
    }
    return ar;
   };
   function serializeKeyPairs(keyPairs) {
    return keyPairs.reduce((function(hValue, current) {
     var value = "" + hValue + ("" !== hValue ? _constants__WEBPACK_IMPORTED_MODULE_0__.bU : "") + current;
     return value.length > _constants__WEBPACK_IMPORTED_MODULE_0__.H3 ? hValue : value;
    }), "");
   }
   function getKeyPairs(baggage) {
    return baggage.getAllEntries().map((function(_a) {
     var _b = __read(_a, 2), key = _b[0], value = _b[1], entry = encodeURIComponent(key) + "=" + encodeURIComponent(value.value);
     return void 0 !== value.metadata && (entry += _constants__WEBPACK_IMPORTED_MODULE_0__.bO + value.metadata.toString()), 
     entry;
    }));
   }
   function parsePairKeyValue(entry) {
    var valueProps = entry.split(_constants__WEBPACK_IMPORTED_MODULE_0__.bO);
    if (!(valueProps.length <= 0)) {
     var keyPairPart = valueProps.shift();
     if (keyPairPart) {
      var separatorIndex = keyPairPart.indexOf(_constants__WEBPACK_IMPORTED_MODULE_0__.Vo);
      if (!(separatorIndex <= 0)) {
       var metadata, key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim()), value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
       return valueProps.length > 0 && (metadata = (0, _opentelemetry_api__WEBPACK_IMPORTED_MODULE_1__.u)(valueProps.join(_constants__WEBPACK_IMPORTED_MODULE_0__.bO))), 
       {
        key,
        value,
        metadata
       };
      }
     }
    }
   }
   function parseKeyPairsIntoRecord(value) {
    return "string" != typeof value || 0 === value.length ? {} : value.split(_constants__WEBPACK_IMPORTED_MODULE_0__.bU).map((function(entry) {
     return parsePairKeyValue(entry);
    })).filter((function(keyPair) {
     return void 0 !== keyPair && keyPair.value.length > 0;
    })).reduce((function(headers, keyPair) {
     return headers[keyPair.key] = keyPair.value, headers;
    }), {});
   }
  },
  60551: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Do: () => isAttributeValue,
    FT: () => sanitizeAttributes,
    sy: () => isAttributeKey
   });
   var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90928), __values = function(o) {
    var s = "function" == typeof Symbol && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && "number" == typeof o.length) return {
     next: function() {
      return o && i >= o.length && (o = void 0), {
       value: o && o[i++],
       done: !o
      };
     }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
   }, __read = function(o, n) {
    var m = "function" == typeof Symbol && o[Symbol.iterator];
    if (!m) return o;
    var r, e, i = m.call(o), ar = [];
    try {
     for (;(void 0 === n || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
    } catch (error) {
     e = {
      error
     };
    } finally {
     try {
      r && !r.done && (m = i.return) && m.call(i);
     } finally {
      if (e) throw e.error;
     }
    }
    return ar;
   };
   function sanitizeAttributes(attributes) {
    var e_1, _a, out = {};
    if ("object" != typeof attributes || null == attributes) return out;
    try {
     for (var _b = __values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var _d = __read(_c.value, 2), key = _d[0], val = _d[1];
      isAttributeKey(key) ? isAttributeValue(val) ? Array.isArray(val) ? out[key] = val.slice() : out[key] = val : _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__.K.warn("Invalid attribute value set for key: " + key) : _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__.K.warn("Invalid attribute key: " + key);
     }
    } catch (e_1_1) {
     e_1 = {
      error: e_1_1
     };
    } finally {
     try {
      _c && !_c.done && (_a = _b.return) && _a.call(_b);
     } finally {
      if (e_1) throw e_1.error;
     }
    }
    return out;
   }
   function isAttributeKey(key) {
    return "string" == typeof key && key.length > 0;
   }
   function isAttributeValue(val) {
    return null == val || (Array.isArray(val) ? function(arr) {
     var e_2, _a, type;
     try {
      for (var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
       var element = arr_1_1.value;
       if (null != element) {
        if (!type) {
         if (isValidPrimitiveAttributeValue(element)) {
          type = typeof element;
          continue;
         }
         return !1;
        }
        if (typeof element !== type) return !1;
       }
      }
     } catch (e_2_1) {
      e_2 = {
       error: e_2_1
      };
     } finally {
      try {
       arr_1_1 && !arr_1_1.done && (_a = arr_1.return) && _a.call(arr_1);
      } finally {
       if (e_2) throw e_2.error;
      }
     }
     return !0;
    }(val) : isValidPrimitiveAttributeValue(val));
   }
   function isValidPrimitiveAttributeValue(val) {
    switch (typeof val) {
    case "number":
    case "boolean":
    case "string":
     return !0;
    }
    return !1;
   }
  },
  36220: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    L: () => globalErrorHandler,
    c: () => setGlobalErrorHandler
   });
   var delegateHandler = (0, __webpack_require__(26470).x)();
   function setGlobalErrorHandler(handler) {
    delegateHandler = handler;
   }
   function globalErrorHandler(ex) {
    try {
     delegateHandler(ex);
    } catch (_a) {}
   }
  },
  26470: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    x: () => loggingErrorHandler
   });
   var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90928);
   function loggingErrorHandler() {
    return function(ex) {
     _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__.K.error(function(ex) {
      return "string" == typeof ex ? ex : JSON.stringify(function(ex) {
       var result = {}, current = ex;
       for (;null !== current; ) Object.getOwnPropertyNames(current).forEach((function(propertyName) {
        if (!result[propertyName]) {
         var value = current[propertyName];
         value && (result[propertyName] = String(value));
        }
       })), current = Object.getPrototypeOf(current);
       return result;
      }(ex));
     }(ex));
    };
   }
  },
  97664: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Dt: () => isTimeInputHrTime,
    J3: () => hrTimeDuration,
    Jt: () => hrTime,
    KO: () => hrTimeToMilliseconds,
    PW: () => hrTimeToNanoseconds,
    U: () => getTimeOrigin,
    Us: () => hrTimeToTimeStamp,
    X_: () => isTimeInput,
    aE: () => timeInputToHrTime,
    i5: () => millisToHrTime,
    ji: () => hrTimeToMicroseconds,
    vF: () => addHrTimes
   });
   var _platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90471), NANOSECOND_DIGITS = 9, MILLISECONDS_TO_NANOSECONDS = Math.pow(10, 6), SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
   function millisToHrTime(epochMillis) {
    var epochSeconds = epochMillis / 1e3;
    return [ Math.trunc(epochSeconds), Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS) ];
   }
   function getTimeOrigin() {
    var timeOrigin = _platform__WEBPACK_IMPORTED_MODULE_0__.t.timeOrigin;
    if ("number" != typeof timeOrigin) {
     var perf = _platform__WEBPACK_IMPORTED_MODULE_0__.t;
     timeOrigin = perf.timing && perf.timing.fetchStart;
    }
    return timeOrigin;
   }
   function hrTime(performanceNow) {
    return addHrTimes(millisToHrTime(getTimeOrigin()), millisToHrTime("number" == typeof performanceNow ? performanceNow : _platform__WEBPACK_IMPORTED_MODULE_0__.t.now()));
   }
   function timeInputToHrTime(time) {
    if (isTimeInputHrTime(time)) return time;
    if ("number" == typeof time) return time < getTimeOrigin() ? hrTime(time) : millisToHrTime(time);
    if (time instanceof Date) return millisToHrTime(time.getTime());
    throw TypeError("Invalid input type");
   }
   function hrTimeDuration(startTime, endTime) {
    var seconds = endTime[0] - startTime[0], nanos = endTime[1] - startTime[1];
    return nanos < 0 && (seconds -= 1, nanos += SECOND_TO_NANOSECONDS), [ seconds, nanos ];
   }
   function hrTimeToTimeStamp(time) {
    var precision = NANOSECOND_DIGITS, tmp = "" + "0".repeat(precision) + time[1] + "Z", nanoString = tmp.substr(tmp.length - precision - 1);
    return new Date(1e3 * time[0]).toISOString().replace("000Z", nanoString);
   }
   function hrTimeToNanoseconds(time) {
    return time[0] * SECOND_TO_NANOSECONDS + time[1];
   }
   function hrTimeToMilliseconds(time) {
    return 1e3 * time[0] + time[1] / 1e6;
   }
   function hrTimeToMicroseconds(time) {
    return 1e6 * time[0] + time[1] / 1e3;
   }
   function isTimeInputHrTime(value) {
    return Array.isArray(value) && 2 === value.length && "number" == typeof value[0] && "number" == typeof value[1];
   }
   function isTimeInput(value) {
    return isTimeInputHrTime(value) || "number" == typeof value || value instanceof Date;
   }
   function addHrTimes(time1, time2) {
    var out = [ time1[0] + time2[0], time1[1] + time2[1] ];
    return out[1] >= SECOND_TO_NANOSECONDS && (out[1] -= SECOND_TO_NANOSECONDS, out[0] += 1), 
    out;
   }
  },
  47593: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    AlwaysOffSampler: () => AlwaysOffSampler,
    AlwaysOnSampler: () => AlwaysOnSampler,
    AnchoredClock: () => AnchoredClock,
    BindOnceFuture: () => callback.q,
    CompositePropagator: () => composite.Y,
    DEFAULT_ATTRIBUTE_COUNT_LIMIT: () => utils_environment.qG,
    DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT: () => utils_environment.KR,
    DEFAULT_ENVIRONMENT: () => utils_environment.J9,
    DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: () => utils_environment.Ys,
    DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: () => utils_environment.VH,
    ExportResultCode: () => ExportResult.I,
    ParentBasedSampler: () => ParentBasedSampler,
    RPCType: () => RPCType,
    RandomIdGenerator: () => RandomIdGenerator,
    SDK_INFO: () => sdk_info.m,
    TRACE_PARENT_HEADER: () => W3CTraceContextPropagator.FX,
    TRACE_STATE_HEADER: () => W3CTraceContextPropagator.C3,
    TimeoutError: () => TimeoutError,
    TraceIdRatioBasedSampler: () => TraceIdRatioBasedSampler,
    TraceState: () => TraceState.n,
    TracesSamplerValues: () => sampling.J,
    VERSION: () => version.q,
    W3CBaggagePropagator: () => W3CBaggagePropagator.a,
    W3CTraceContextPropagator: () => W3CTraceContextPropagator.jf,
    _globalThis: () => _globalThis,
    addHrTimes: () => time.vF,
    baggageUtils: () => utils,
    callWithTimeout: () => callWithTimeout,
    deleteRPCMetadata: () => deleteRPCMetadata,
    getEnv: () => environment.d,
    getEnvWithoutDefaults: () => utils_environment.vU,
    getRPCMetadata: () => getRPCMetadata,
    getTimeOrigin: () => time.U,
    globalErrorHandler: () => global_error_handler.L,
    hexToBase64: () => hexToBase64,
    hrTime: () => time.Jt,
    hrTimeDuration: () => time.J3,
    hrTimeToMicroseconds: () => time.ji,
    hrTimeToMilliseconds: () => time.KO,
    hrTimeToNanoseconds: () => time.PW,
    hrTimeToTimeStamp: () => time.Us,
    internal: () => internal,
    isAttributeKey: () => attributes.sy,
    isAttributeValue: () => attributes.Do,
    isTimeInput: () => time.X_,
    isTimeInputHrTime: () => time.Dt,
    isTracingSuppressed: () => suppress_tracing.Ll,
    isUrlIgnored: () => isUrlIgnored,
    isWrapped: () => isWrapped,
    loggingErrorHandler: () => logging_error_handler.x,
    merge: () => merge.T,
    millisToHrTime: () => time.i5,
    otperformance: () => performance.t,
    parseEnvironment: () => utils_environment.Ds,
    parseTraceParent: () => W3CTraceContextPropagator.j_,
    sanitizeAttributes: () => attributes.FT,
    setGlobalErrorHandler: () => global_error_handler.c,
    setRPCMetadata: () => setRPCMetadata,
    suppressTracing: () => suppress_tracing.hE,
    timeInputToHrTime: () => time.aE,
    unrefTimer: () => timer_util.g,
    unsuppressTracing: () => suppress_tracing.yy,
    urlMatches: () => urlMatches
   });
   var W3CBaggagePropagator = __webpack_require__(80926), AnchoredClock = function() {
    function AnchoredClock(systemClock, monotonicClock) {
     this._monotonicClock = monotonicClock, this._epochMillis = systemClock.now(), this._performanceMillis = monotonicClock.now();
    }
    return AnchoredClock.prototype.now = function() {
     var delta = this._monotonicClock.now() - this._performanceMillis;
     return this._epochMillis + delta;
    }, AnchoredClock;
   }(), attributes = __webpack_require__(60551), global_error_handler = __webpack_require__(36220), logging_error_handler = __webpack_require__(26470), time = __webpack_require__(97664), ExportResult = __webpack_require__(63420), version = __webpack_require__(18923), utils = __webpack_require__(60315), environment = __webpack_require__(54241), _globalThis = "object" == typeof globalThis ? globalThis : global;
   function intValue(charCode) {
    return charCode >= 48 && charCode <= 57 ? charCode - 48 : charCode >= 97 && charCode <= 102 ? charCode - 87 : charCode - 55;
   }
   var buf8 = Buffer.alloc(8), buf16 = Buffer.alloc(16);
   function hexToBase64(hexStr) {
    var buf;
    buf = 16 === hexStr.length ? buf8 : 32 === hexStr.length ? buf16 : Buffer.alloc(hexStr.length / 2);
    for (var offset = 0, i = 0; i < hexStr.length; i += 2) {
     var hi = intValue(hexStr.charCodeAt(i)), lo = intValue(hexStr.charCodeAt(i + 1));
     buf.writeUInt8(hi << 4 | lo, offset++);
    }
    return buf.toString("base64");
   }
   var RandomIdGenerator = function() {
    this.generateTraceId = getIdGenerator(16), this.generateSpanId = getIdGenerator(8);
   }, SHARED_BUFFER = Buffer.allocUnsafe(16);
   function getIdGenerator(bytes) {
    return function() {
     for (var i = 0; i < bytes / 4; i++) SHARED_BUFFER.writeUInt32BE(Math.random() * Math.pow(2, 32) >>> 0, 4 * i);
     for (i = 0; i < bytes && !(SHARED_BUFFER[i] > 0); i++) i === bytes - 1 && (SHARED_BUFFER[bytes - 1] = 1);
     return SHARED_BUFFER.toString("hex", 0, bytes);
    };
   }
   var RPCType, performance = __webpack_require__(90471), sdk_info = __webpack_require__(93290), timer_util = __webpack_require__(52140), composite = __webpack_require__(63135), W3CTraceContextPropagator = __webpack_require__(49588), RPC_METADATA_KEY = (0, 
   __webpack_require__(15834).Y)("OpenTelemetry SDK Context Key RPC_METADATA");
   function setRPCMetadata(context, meta) {
    return context.setValue(RPC_METADATA_KEY, meta);
   }
   function deleteRPCMetadata(context) {
    return context.deleteValue(RPC_METADATA_KEY);
   }
   function getRPCMetadata(context) {
    return context.getValue(RPC_METADATA_KEY);
   }
   !function(RPCType) {
    RPCType.HTTP = "http";
   }(RPCType || (RPCType = {}));
   var extendStatics, SamplingResult = __webpack_require__(51227), AlwaysOffSampler = function() {
    function AlwaysOffSampler() {}
    return AlwaysOffSampler.prototype.shouldSample = function() {
     return {
      decision: SamplingResult.U.NOT_RECORD
     };
    }, AlwaysOffSampler.prototype.toString = function() {
     return "AlwaysOffSampler";
    }, AlwaysOffSampler;
   }(), AlwaysOnSampler = function() {
    function AlwaysOnSampler() {}
    return AlwaysOnSampler.prototype.shouldSample = function() {
     return {
      decision: SamplingResult.U.RECORD_AND_SAMPLED
     };
    }, AlwaysOnSampler.prototype.toString = function() {
     return "AlwaysOnSampler";
    }, AlwaysOnSampler;
   }(), trace_api = __webpack_require__(52210), spancontext_utils = __webpack_require__(97228), trace_flags = __webpack_require__(68726), ParentBasedSampler = function() {
    function ParentBasedSampler(config) {
     var _a, _b, _c, _d;
     this._root = config.root, this._root || ((0, global_error_handler.L)(new Error("ParentBasedSampler must have a root sampler configured")), 
     this._root = new AlwaysOnSampler), this._remoteParentSampled = null !== (_a = config.remoteParentSampled) && void 0 !== _a ? _a : new AlwaysOnSampler, 
     this._remoteParentNotSampled = null !== (_b = config.remoteParentNotSampled) && void 0 !== _b ? _b : new AlwaysOffSampler, 
     this._localParentSampled = null !== (_c = config.localParentSampled) && void 0 !== _c ? _c : new AlwaysOnSampler, 
     this._localParentNotSampled = null !== (_d = config.localParentNotSampled) && void 0 !== _d ? _d : new AlwaysOffSampler;
    }
    return ParentBasedSampler.prototype.shouldSample = function(context, traceId, spanName, spanKind, attributes, links) {
     var parentContext = trace_api.g.getSpanContext(context);
     return parentContext && (0, spancontext_utils.BM)(parentContext) ? parentContext.isRemote ? parentContext.traceFlags & trace_flags.r.SAMPLED ? this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links) : this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links) : parentContext.traceFlags & trace_flags.r.SAMPLED ? this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links) : this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links) : this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    }, ParentBasedSampler.prototype.toString = function() {
     return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}";
    }, ParentBasedSampler;
   }(), TraceIdRatioBasedSampler = function() {
    function TraceIdRatioBasedSampler(_ratio) {
     void 0 === _ratio && (_ratio = 0), this._ratio = _ratio, this._ratio = this._normalize(_ratio), 
     this._upperBound = Math.floor(4294967295 * this._ratio);
    }
    return TraceIdRatioBasedSampler.prototype.shouldSample = function(context, traceId) {
     return {
      decision: (0, spancontext_utils.jN)(traceId) && this._accumulate(traceId) < this._upperBound ? SamplingResult.U.RECORD_AND_SAMPLED : SamplingResult.U.NOT_RECORD
     };
    }, TraceIdRatioBasedSampler.prototype.toString = function() {
     return "TraceIdRatioBased{" + this._ratio + "}";
    }, TraceIdRatioBasedSampler.prototype._normalize = function(ratio) {
     return "number" != typeof ratio || isNaN(ratio) ? 0 : ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
    }, TraceIdRatioBasedSampler.prototype._accumulate = function(traceId) {
     for (var accumulation = 0, i = 0; i < traceId.length / 8; i++) {
      var pos = 8 * i;
      accumulation = (accumulation ^ parseInt(traceId.slice(pos, pos + 8), 16)) >>> 0;
     }
     return accumulation;
    }, TraceIdRatioBasedSampler;
   }(), suppress_tracing = __webpack_require__(98397), TraceState = __webpack_require__(59598), utils_environment = __webpack_require__(70450), merge = __webpack_require__(39009), sampling = __webpack_require__(29290), __extends = (extendStatics = function(d, b) {
    return extendStatics = Object.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
    }, extendStatics(d, b);
   }, function(d, b) {
    if ("function" != typeof b && null !== b) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    function __() {
     this.constructor = d;
    }
    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
    new __);
   }), TimeoutError = function(_super) {
    function TimeoutError(message) {
     var _this = _super.call(this, message) || this;
     return Object.setPrototypeOf(_this, TimeoutError.prototype), _this;
    }
    return __extends(TimeoutError, _super), TimeoutError;
   }(Error);
   function callWithTimeout(promise, timeout) {
    var timeoutHandle, timeoutPromise = new Promise((function(_resolve, reject) {
     timeoutHandle = setTimeout((function() {
      reject(new TimeoutError("Operation timed out."));
     }), timeout);
    }));
    return Promise.race([ promise, timeoutPromise ]).then((function(result) {
     return clearTimeout(timeoutHandle), result;
    }), (function(reason) {
     throw clearTimeout(timeoutHandle), reason;
    }));
   }
   var __values = function(o) {
    var s = "function" == typeof Symbol && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && "number" == typeof o.length) return {
     next: function() {
      return o && i >= o.length && (o = void 0), {
       value: o && o[i++],
       done: !o
      };
     }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
   };
   function urlMatches(url, urlToMatch) {
    return "string" == typeof urlToMatch ? url === urlToMatch : !!url.match(urlToMatch);
   }
   function isUrlIgnored(url, ignoredUrls) {
    var e_1, _a;
    if (!ignoredUrls) return !1;
    try {
     for (var ignoredUrls_1 = __values(ignoredUrls), ignoredUrls_1_1 = ignoredUrls_1.next(); !ignoredUrls_1_1.done; ignoredUrls_1_1 = ignoredUrls_1.next()) {
      if (urlMatches(url, ignoredUrls_1_1.value)) return !0;
     }
    } catch (e_1_1) {
     e_1 = {
      error: e_1_1
     };
    } finally {
     try {
      ignoredUrls_1_1 && !ignoredUrls_1_1.done && (_a = ignoredUrls_1.return) && _a.call(ignoredUrls_1);
     } finally {
      if (e_1) throw e_1.error;
     }
    }
    return !1;
   }
   function isWrapped(func) {
    return "function" == typeof func && "function" == typeof func.__original && "function" == typeof func.__unwrap && !0 === func.__wrapped;
   }
   var callback = __webpack_require__(71399), context_api = __webpack_require__(66339);
   var internal = {
    _export: function(exporter, arg) {
     return new Promise((function(resolve) {
      context_api.D.with((0, suppress_tracing.hE)(context_api.D.active()), (function() {
       exporter.export(arg, (function(result) {
        resolve(result);
       }));
      }));
     }));
    }
   };
  },
  54241: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    d: () => getEnv
   });
   var os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(22037), _utils_environment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70450);
   function getEnv() {
    var processEnv = (0, _utils_environment__WEBPACK_IMPORTED_MODULE_1__.Ds)(process.env);
    return Object.assign({
     HOSTNAME: os__WEBPACK_IMPORTED_MODULE_0__.hostname()
    }, _utils_environment__WEBPACK_IMPORTED_MODULE_1__.J9, processEnv);
   }
  },
  90471: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    t: () => otperformance
   });
   var otperformance = require("perf_hooks").performance;
  },
  93290: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    m: () => SDK_INFO
   });
   var _a, _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18923), _opentelemetry_semantic_conventions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(95364), SDK_INFO = ((_a = {})[_opentelemetry_semantic_conventions__WEBPACK_IMPORTED_MODULE_0__.R9.TELEMETRY_SDK_NAME] = "opentelemetry", 
   _a[_opentelemetry_semantic_conventions__WEBPACK_IMPORTED_MODULE_0__.R9.PROCESS_RUNTIME_NAME] = "node", 
   _a[_opentelemetry_semantic_conventions__WEBPACK_IMPORTED_MODULE_0__.R9.TELEMETRY_SDK_LANGUAGE] = _opentelemetry_semantic_conventions__WEBPACK_IMPORTED_MODULE_0__.Te.NODEJS, 
   _a[_opentelemetry_semantic_conventions__WEBPACK_IMPORTED_MODULE_0__.R9.TELEMETRY_SDK_VERSION] = _version__WEBPACK_IMPORTED_MODULE_1__.q, 
   _a);
  },
  52140: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   function unrefTimer(timer) {
    timer.unref();
   }
   __webpack_require__.d(__webpack_exports__, {
    g: () => unrefTimer
   });
  },
  63135: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Y: () => CompositePropagator
   });
   var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90928), __values = function(o) {
    var s = "function" == typeof Symbol && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && "number" == typeof o.length) return {
     next: function() {
      return o && i >= o.length && (o = void 0), {
       value: o && o[i++],
       done: !o
      };
     }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
   }, CompositePropagator = function() {
    function CompositePropagator(config) {
     var _a;
     void 0 === config && (config = {}), this._propagators = null !== (_a = config.propagators) && void 0 !== _a ? _a : [], 
     this._fields = Array.from(new Set(this._propagators.map((function(p) {
      return "function" == typeof p.fields ? p.fields() : [];
     })).reduce((function(x, y) {
      return x.concat(y);
     }), [])));
    }
    return CompositePropagator.prototype.inject = function(context, carrier, setter) {
     var e_1, _a;
     try {
      for (var _b = __values(this._propagators), _c = _b.next(); !_c.done; _c = _b.next()) {
       var propagator = _c.value;
       try {
        propagator.inject(context, carrier, setter);
       } catch (err) {
        _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__.K.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
       }
      }
     } catch (e_1_1) {
      e_1 = {
       error: e_1_1
      };
     } finally {
      try {
       _c && !_c.done && (_a = _b.return) && _a.call(_b);
      } finally {
       if (e_1) throw e_1.error;
      }
     }
    }, CompositePropagator.prototype.extract = function(context, carrier, getter) {
     return this._propagators.reduce((function(ctx, propagator) {
      try {
       return propagator.extract(ctx, carrier, getter);
      } catch (err) {
       _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__.K.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
      }
      return ctx;
     }), context);
    }, CompositePropagator.prototype.fields = function() {
     return this._fields.slice();
    }, CompositePropagator;
   }();
  },
  59598: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    n: () => TraceState
   });
   var VALID_KEY_REGEX = new RegExp("^(?:[a-z][_0-9a-z-*/]{0,255}|[a-z0-9][_0-9a-z-*/]{0,240}@[a-z][_0-9a-z-*/]{0,13})$"), VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/, INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
   var TraceState = function() {
    function TraceState(rawTraceState) {
     this._internalState = new Map, rawTraceState && this._parse(rawTraceState);
    }
    return TraceState.prototype.set = function(key, value) {
     var traceState = this._clone();
     return traceState._internalState.has(key) && traceState._internalState.delete(key), 
     traceState._internalState.set(key, value), traceState;
    }, TraceState.prototype.unset = function(key) {
     var traceState = this._clone();
     return traceState._internalState.delete(key), traceState;
    }, TraceState.prototype.get = function(key) {
     return this._internalState.get(key);
    }, TraceState.prototype.serialize = function() {
     var _this = this;
     return this._keys().reduce((function(agg, key) {
      return agg.push(key + "=" + _this.get(key)), agg;
     }), []).join(",");
    }, TraceState.prototype._parse = function(rawTraceState) {
     rawTraceState.length > 512 || (this._internalState = rawTraceState.split(",").reverse().reduce((function(agg, part) {
      var listMember = part.trim(), i = listMember.indexOf("=");
      if (-1 !== i) {
       var key = listMember.slice(0, i), value = listMember.slice(i + 1, part.length);
       (function(key) {
        return VALID_KEY_REGEX.test(key);
       })(key) && function(value) {
        return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
       }(value) && agg.set(key, value);
      }
      return agg;
     }), new Map), this._internalState.size > 32 && (this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, 32))));
    }, TraceState.prototype._keys = function() {
     return Array.from(this._internalState.keys()).reverse();
    }, TraceState.prototype._clone = function() {
     var traceState = new TraceState;
     return traceState._internalState = new Map(this._internalState), traceState;
    }, TraceState;
   }();
  },
  49588: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    C3: () => TRACE_STATE_HEADER,
    FX: () => TRACE_PARENT_HEADER,
    j_: () => parseTraceParent,
    jf: () => W3CTraceContextPropagator
   });
   var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52210), _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97228), _opentelemetry_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(68726), _suppress_tracing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98397), _TraceState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(59598), TRACE_PARENT_HEADER = "traceparent", TRACE_STATE_HEADER = "tracestate", TRACE_PARENT_REGEX = new RegExp("^\\s?((?!ff)[\\da-f]{2})-((?![0]{32})[\\da-f]{32})-((?![0]{16})[\\da-f]{16})-([\\da-f]{2})(-.*)?\\s?$");
   function parseTraceParent(traceParent) {
    var match = TRACE_PARENT_REGEX.exec(traceParent);
    return match ? "00" === match[1] && match[5] ? null : {
     traceId: match[2],
     spanId: match[3],
     traceFlags: parseInt(match[4], 16)
    } : null;
   }
   var W3CTraceContextPropagator = function() {
    function W3CTraceContextPropagator() {}
    return W3CTraceContextPropagator.prototype.inject = function(context, carrier, setter) {
     var spanContext = _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__.g.getSpanContext(context);
     if (spanContext && !(0, _suppress_tracing__WEBPACK_IMPORTED_MODULE_1__.Ll)(context) && (0, 
     _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__.BM)(spanContext)) {
      var traceParent = "00-" + spanContext.traceId + "-" + spanContext.spanId + "-0" + Number(spanContext.traceFlags || _opentelemetry_api__WEBPACK_IMPORTED_MODULE_3__.r.NONE).toString(16);
      setter.set(carrier, TRACE_PARENT_HEADER, traceParent), spanContext.traceState && setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());
     }
    }, W3CTraceContextPropagator.prototype.extract = function(context, carrier, getter) {
     var traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);
     if (!traceParentHeader) return context;
     var traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
     if ("string" != typeof traceParent) return context;
     var spanContext = parseTraceParent(traceParent);
     if (!spanContext) return context;
     spanContext.isRemote = !0;
     var traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);
     if (traceStateHeader) {
      var state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
      spanContext.traceState = new _TraceState__WEBPACK_IMPORTED_MODULE_4__.n("string" == typeof state ? state : void 0);
     }
     return _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__.g.setSpanContext(context, spanContext);
    }, W3CTraceContextPropagator.prototype.fields = function() {
     return [ TRACE_PARENT_HEADER, TRACE_STATE_HEADER ];
    }, W3CTraceContextPropagator;
   }();
  },
  98397: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Ll: () => isTracingSuppressed,
    hE: () => suppressTracing,
    yy: () => unsuppressTracing
   });
   var SUPPRESS_TRACING_KEY = (0, __webpack_require__(15834).Y)("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
   function suppressTracing(context) {
    return context.setValue(SUPPRESS_TRACING_KEY, !0);
   }
   function unsuppressTracing(context) {
    return context.deleteValue(SUPPRESS_TRACING_KEY);
   }
   function isTracingSuppressed(context) {
    return !0 === context.getValue(SUPPRESS_TRACING_KEY);
   }
  },
  71399: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    q: () => BindOnceFuture
   });
   var Deferred = function() {
    function Deferred() {
     var _this = this;
     this._promise = new Promise((function(resolve, reject) {
      _this._resolve = resolve, _this._reject = reject;
     }));
    }
    return Object.defineProperty(Deferred.prototype, "promise", {
     get: function() {
      return this._promise;
     },
     enumerable: !1,
     configurable: !0
    }), Deferred.prototype.resolve = function(val) {
     this._resolve(val);
    }, Deferred.prototype.reject = function(err) {
     this._reject(err);
    }, Deferred;
   }(), __read = function(o, n) {
    var m = "function" == typeof Symbol && o[Symbol.iterator];
    if (!m) return o;
    var r, e, i = m.call(o), ar = [];
    try {
     for (;(void 0 === n || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
    } catch (error) {
     e = {
      error
     };
    } finally {
     try {
      r && !r.done && (m = i.return) && m.call(i);
     } finally {
      if (e) throw e.error;
     }
    }
    return ar;
   }, __spreadArray = function(to, from, pack) {
    if (pack || 2 === arguments.length) for (var ar, i = 0, l = from.length; i < l; i++) !ar && i in from || (ar || (ar = Array.prototype.slice.call(from, 0, i)), 
    ar[i] = from[i]);
    return to.concat(ar || Array.prototype.slice.call(from));
   }, BindOnceFuture = function() {
    function BindOnceFuture(_callback, _that) {
     this._callback = _callback, this._that = _that, this._isCalled = !1, this._deferred = new Deferred;
    }
    return Object.defineProperty(BindOnceFuture.prototype, "isCalled", {
     get: function() {
      return this._isCalled;
     },
     enumerable: !1,
     configurable: !0
    }), Object.defineProperty(BindOnceFuture.prototype, "promise", {
     get: function() {
      return this._deferred.promise;
     },
     enumerable: !1,
     configurable: !0
    }), BindOnceFuture.prototype.call = function() {
     for (var _a, _this = this, args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
     if (!this._isCalled) {
      this._isCalled = !0;
      try {
       Promise.resolve((_a = this._callback).call.apply(_a, __spreadArray([ this._that ], __read(args), !1))).then((function(val) {
        return _this._deferred.resolve(val);
       }), (function(err) {
        return _this._deferred.reject(err);
       }));
      } catch (err) {
       this._deferred.reject(err);
      }
     }
     return this._deferred.promise;
    }, BindOnceFuture;
   }();
  },
  70450: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    qG: () => DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    KR: () => DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    J9: () => DEFAULT_ENVIRONMENT,
    Ys: () => DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
    VH: () => DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
    vU: () => getEnvWithoutDefaults,
    Ds: () => parseEnvironment
   });
   var types = __webpack_require__(16740), sampling = __webpack_require__(29290), _globalThis = "object" == typeof globalThis ? globalThis : "object" == typeof self ? self : "object" == typeof window ? window : "object" == typeof global ? global : {}, DEFAULT_LIST_SEPARATOR = ",", ENVIRONMENT_BOOLEAN_KEYS = [ "OTEL_SDK_DISABLED" ];
   function isEnvVarABoolean(key) {
    return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
   }
   var ENVIRONMENT_NUMBERS_KEYS = [ "OTEL_BSP_EXPORT_TIMEOUT", "OTEL_BSP_MAX_EXPORT_BATCH_SIZE", "OTEL_BSP_MAX_QUEUE_SIZE", "OTEL_BSP_SCHEDULE_DELAY", "OTEL_BLRP_EXPORT_TIMEOUT", "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE", "OTEL_BLRP_MAX_QUEUE_SIZE", "OTEL_BLRP_SCHEDULE_DELAY", "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT", "OTEL_ATTRIBUTE_COUNT_LIMIT", "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT", "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT", "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT", "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT", "OTEL_SPAN_EVENT_COUNT_LIMIT", "OTEL_SPAN_LINK_COUNT_LIMIT", "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT", "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT", "OTEL_EXPORTER_OTLP_TIMEOUT", "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT", "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT", "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT", "OTEL_EXPORTER_JAEGER_AGENT_PORT" ];
   function isEnvVarANumber(key) {
    return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
   }
   var ENVIRONMENT_LISTS_KEYS = [ "OTEL_NO_PATCH_MODULES", "OTEL_PROPAGATORS" ];
   function isEnvVarAList(key) {
    return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
   }
   var DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = 1 / 0, DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128, DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128, DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128, DEFAULT_ENVIRONMENT = {
    OTEL_SDK_DISABLED: !1,
    CONTAINER_NAME: "",
    ECS_CONTAINER_METADATA_URI_V4: "",
    ECS_CONTAINER_METADATA_URI: "",
    HOSTNAME: "",
    KUBERNETES_SERVICE_HOST: "",
    NAMESPACE: "",
    OTEL_BSP_EXPORT_TIMEOUT: 3e4,
    OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BSP_MAX_QUEUE_SIZE: 2048,
    OTEL_BSP_SCHEDULE_DELAY: 5e3,
    OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
    OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
    OTEL_BLRP_SCHEDULE_DELAY: 5e3,
    OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
    OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
    OTEL_EXPORTER_JAEGER_ENDPOINT: "",
    OTEL_EXPORTER_JAEGER_PASSWORD: "",
    OTEL_EXPORTER_JAEGER_USER: "",
    OTEL_EXPORTER_OTLP_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_HEADERS: "",
    OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
    OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
    OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
    OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
    OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
    OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
    OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
    OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
    OTEL_LOG_LEVEL: types.n.INFO,
    OTEL_NO_PATCH_MODULES: [],
    OTEL_PROPAGATORS: [ "tracecontext", "baggage" ],
    OTEL_RESOURCE_ATTRIBUTES: "",
    OTEL_SERVICE_NAME: "",
    OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
    OTEL_SPAN_LINK_COUNT_LIMIT: 128,
    OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
    OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
    OTEL_TRACES_EXPORTER: "",
    OTEL_TRACES_SAMPLER: sampling.J.ParentBasedAlwaysOn,
    OTEL_TRACES_SAMPLER_ARG: "",
    OTEL_LOGS_EXPORTER: "",
    OTEL_EXPORTER_OTLP_INSECURE: "",
    OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
    OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
    OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
    OTEL_EXPORTER_OTLP_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative"
   };
   function parseBoolean(key, environment, values) {
    if (void 0 !== values[key]) {
     var value = String(values[key]);
     environment[key] = "true" === value.toLowerCase();
    }
   }
   function parseNumber(name, environment, values, min, max) {
    if (void 0 === min && (min = -1 / 0), void 0 === max && (max = 1 / 0), void 0 !== values[name]) {
     var value = Number(values[name]);
     isNaN(value) || (environment[name] = value < min ? min : value > max ? max : value);
    }
   }
   function parseStringList(name, output, input, separator) {
    void 0 === separator && (separator = DEFAULT_LIST_SEPARATOR);
    var givenValue = input[name];
    "string" == typeof givenValue && (output[name] = givenValue.split(separator).map((function(v) {
     return v.trim();
    })));
   }
   var logLevelMap = {
    ALL: types.n.ALL,
    VERBOSE: types.n.VERBOSE,
    DEBUG: types.n.DEBUG,
    INFO: types.n.INFO,
    WARN: types.n.WARN,
    ERROR: types.n.ERROR,
    NONE: types.n.NONE
   };
   function setLogLevelFromEnv(key, environment, values) {
    var value = values[key];
    if ("string" == typeof value) {
     var theLevel = logLevelMap[value.toUpperCase()];
     null != theLevel && (environment[key] = theLevel);
    }
   }
   function parseEnvironment(values) {
    var environment = {};
    for (var env in DEFAULT_ENVIRONMENT) {
     var key = env;
     if ("OTEL_LOG_LEVEL" === key) setLogLevelFromEnv(key, environment, values); else if (isEnvVarABoolean(key)) parseBoolean(key, environment, values); else if (isEnvVarANumber(key)) parseNumber(key, environment, values); else if (isEnvVarAList(key)) parseStringList(key, environment, values); else {
      var value = values[key];
      null != value && (environment[key] = String(value));
     }
    }
    return environment;
   }
   function getEnvWithoutDefaults() {
    return "undefined" != typeof process && process && process.env ? parseEnvironment(process.env) : parseEnvironment(_globalThis);
   }
  },
  39009: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    T: () => merge
   });
   var func, transform, objectTag = "[object Object]", nullTag = "[object Null]", undefinedTag = "[object Undefined]", funcToString = Function.prototype.toString, objectCtorString = funcToString.call(Object), getPrototype = (func = Object.getPrototypeOf, 
   transform = Object, function(arg) {
    return func(transform(arg));
   }), objectProto = Object.prototype, lodash_merge_hasOwnProperty = objectProto.hasOwnProperty, symToStringTag = Symbol ? Symbol.toStringTag : void 0, nativeObjectToString = objectProto.toString;
   function isPlainObject(value) {
    if (!function(value) {
     return null != value && "object" == typeof value;
    }(value) || function(value) {
     if (null == value) return void 0 === value ? undefinedTag : nullTag;
     return symToStringTag && symToStringTag in Object(value) ? function(value) {
      var isOwn = lodash_merge_hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag], unmasked = !1;
      try {
       value[symToStringTag] = void 0, unmasked = !0;
      } catch (e) {}
      var result = nativeObjectToString.call(value);
      unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]);
      return result;
     }(value) : function(value) {
      return nativeObjectToString.call(value);
     }(value);
    }(value) !== objectTag) return !1;
    var proto = getPrototype(value);
    if (null === proto) return !0;
    var Ctor = lodash_merge_hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return "function" == typeof Ctor && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
   }
   var MAX_LEVEL = 20;
   function merge() {
    for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
    for (var result = args.shift(), objects = new WeakMap; args.length > 0; ) result = mergeTwoObjects(result, args.shift(), 0, objects);
    return result;
   }
   function takeValue(value) {
    return isArray(value) ? value.slice() : value;
   }
   function mergeTwoObjects(one, two, level, objects) {
    var result;
    if (void 0 === level && (level = 0), !(level > MAX_LEVEL)) {
     if (level++, isPrimitive(one) || isPrimitive(two) || isFunction(two)) result = takeValue(two); else if (isArray(one)) {
      if (result = one.slice(), isArray(two)) for (var i = 0, j = two.length; i < j; i++) result.push(takeValue(two[i])); else if (isObject(two)) for (i = 0, 
      j = (keys = Object.keys(two)).length; i < j; i++) {
       result[key = keys[i]] = takeValue(two[key]);
      }
     } else if (isObject(one)) if (isObject(two)) {
      if (!function(one, two) {
       if (!isPlainObject(one) || !isPlainObject(two)) return !1;
       return !0;
      }(one, two)) return two;
      result = Object.assign({}, one);
      var keys;
      for (i = 0, j = (keys = Object.keys(two)).length; i < j; i++) {
       var key, twoValue = two[key = keys[i]];
       if (isPrimitive(twoValue)) void 0 === twoValue ? delete result[key] : result[key] = twoValue; else {
        var obj1 = result[key], obj2 = twoValue;
        if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) delete result[key]; else {
         if (isObject(obj1) && isObject(obj2)) {
          var arr1 = objects.get(obj1) || [], arr2 = objects.get(obj2) || [];
          arr1.push({
           obj: one,
           key
          }), arr2.push({
           obj: two,
           key
          }), objects.set(obj1, arr1), objects.set(obj2, arr2);
         }
         result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
        }
       }
      }
     } else result = two;
     return result;
    }
   }
   function wasObjectReferenced(obj, key, objects) {
    for (var arr = objects.get(obj[key]) || [], i = 0, j = arr.length; i < j; i++) {
     var info = arr[i];
     if (info.key === key && info.obj === obj) return !0;
    }
    return !1;
   }
   function isArray(value) {
    return Array.isArray(value);
   }
   function isFunction(value) {
    return "function" == typeof value;
   }
   function isObject(value) {
    return !isPrimitive(value) && !isArray(value) && !isFunction(value) && "object" == typeof value;
   }
   function isPrimitive(value) {
    return "string" == typeof value || "number" == typeof value || "boolean" == typeof value || void 0 === value || value instanceof Date || value instanceof RegExp || null === value;
   }
  },
  29290: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   var TracesSamplerValues;
   __webpack_require__.d(__webpack_exports__, {
    J: () => TracesSamplerValues
   }), function(TracesSamplerValues) {
    TracesSamplerValues.AlwaysOff = "always_off", TracesSamplerValues.AlwaysOn = "always_on", 
    TracesSamplerValues.ParentBasedAlwaysOff = "parentbased_always_off", TracesSamplerValues.ParentBasedAlwaysOn = "parentbased_always_on", 
    TracesSamplerValues.ParentBasedTraceIdRatio = "parentbased_traceidratio", TracesSamplerValues.TraceIdRatio = "traceidratio";
   }(TracesSamplerValues || (TracesSamplerValues = {}));
  },
  18923: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    q: () => VERSION
   });
   var VERSION = "1.15.2";
  },
  82506: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    AlwaysOffSampler: () => AlwaysOffSampler,
    AlwaysOnSampler: () => AlwaysOnSampler,
    BasicTracerProvider: () => BasicTracerProvider,
    BatchSpanProcessor: () => BatchSpanProcessor,
    ConsoleSpanExporter: () => ConsoleSpanExporter,
    ForceFlushState: () => ForceFlushState,
    InMemorySpanExporter: () => InMemorySpanExporter,
    NoopSpanProcessor: () => NoopSpanProcessor,
    ParentBasedSampler: () => ParentBasedSampler,
    RandomIdGenerator: () => RandomIdGenerator,
    SamplingDecision: () => SamplingDecision,
    SimpleSpanProcessor: () => SimpleSpanProcessor,
    Span: () => Span,
    TraceIdRatioBasedSampler: () => TraceIdRatioBasedSampler,
    Tracer: () => Tracer
   });
   var SamplingDecision, context_api = __webpack_require__(66339), trace_api = __webpack_require__(52210), diag_api = __webpack_require__(90928), invalid_span_constants = __webpack_require__(27007), span_kind = __webpack_require__(70087), SamplingResult = __webpack_require__(51227), trace_flags = __webpack_require__(68726), suppress_tracing = __webpack_require__(98397), common_attributes = __webpack_require__(60551), trace_status = __webpack_require__(1820), performance = __webpack_require__(90471), time = __webpack_require__(97664), SemanticAttributes = __webpack_require__(73108), __values = function(o) {
    var s = "function" == typeof Symbol && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && "number" == typeof o.length) return {
     next: function() {
      return o && i >= o.length && (o = void 0), {
       value: o && o[i++],
       done: !o
      };
     }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
   }, __read = function(o, n) {
    var m = "function" == typeof Symbol && o[Symbol.iterator];
    if (!m) return o;
    var r, e, i = m.call(o), ar = [];
    try {
     for (;(void 0 === n || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
    } catch (error) {
     e = {
      error
     };
    } finally {
     try {
      r && !r.done && (m = i.return) && m.call(i);
     } finally {
      if (e) throw e.error;
     }
    }
    return ar;
   }, Span = function() {
    function Span(parentTracer, context, spanName, spanContext, kind, parentSpanId, links, startTime, _deprecatedClock) {
     void 0 === links && (links = []), this.attributes = {}, this.links = [], this.events = [], 
     this._droppedAttributesCount = 0, this._droppedEventsCount = 0, this._droppedLinksCount = 0, 
     this.status = {
      code: trace_status.Q.UNSET
     }, this.endTime = [ 0, 0 ], this._ended = !1, this._duration = [ -1, -1 ], this.name = spanName, 
     this._spanContext = spanContext, this.parentSpanId = parentSpanId, this.kind = kind, 
     this.links = links;
     var now = Date.now();
     this._performanceStartTime = performance.t.now(), this._performanceOffset = now - (this._performanceStartTime + (0, 
     time.U)()), this._startTimeProvided = null != startTime, this.startTime = this._getTime(null != startTime ? startTime : now), 
     this.resource = parentTracer.resource, this.instrumentationLibrary = parentTracer.instrumentationLibrary, 
     this._spanLimits = parentTracer.getSpanLimits(), this._spanProcessor = parentTracer.getActiveSpanProcessor(), 
     this._spanProcessor.onStart(this, context), this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;
    }
    return Span.prototype.spanContext = function() {
     return this._spanContext;
    }, Span.prototype.setAttribute = function(key, value) {
     return null == value || this._isSpanEnded() ? this : 0 === key.length ? (diag_api.K.warn("Invalid attribute key: " + key), 
     this) : (0, common_attributes.Do)(value) ? Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key) ? (this._droppedAttributesCount++, 
     this) : (this.attributes[key] = this._truncateToSize(value), this) : (diag_api.K.warn("Invalid attribute value set for key: " + key), 
     this);
    }, Span.prototype.setAttributes = function(attributes) {
     var e_1, _a;
     try {
      for (var _b = __values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
       var _d = __read(_c.value, 2), k = _d[0], v = _d[1];
       this.setAttribute(k, v);
      }
     } catch (e_1_1) {
      e_1 = {
       error: e_1_1
      };
     } finally {
      try {
       _c && !_c.done && (_a = _b.return) && _a.call(_b);
      } finally {
       if (e_1) throw e_1.error;
      }
     }
     return this;
    }, Span.prototype.addEvent = function(name, attributesOrStartTime, timeStamp) {
     if (this._isSpanEnded()) return this;
     if (0 === this._spanLimits.eventCountLimit) return diag_api.K.warn("No events allowed."), 
     this._droppedEventsCount++, this;
     this.events.length >= this._spanLimits.eventCountLimit && (diag_api.K.warn("Dropping extra events."), 
     this.events.shift(), this._droppedEventsCount++), (0, time.X_)(attributesOrStartTime) && ((0, 
     time.X_)(timeStamp) || (timeStamp = attributesOrStartTime), attributesOrStartTime = void 0);
     var attributes = (0, common_attributes.FT)(attributesOrStartTime);
     return this.events.push({
      name,
      attributes,
      time: this._getTime(timeStamp),
      droppedAttributesCount: 0
     }), this;
    }, Span.prototype.setStatus = function(status) {
     return this._isSpanEnded() || (this.status = status), this;
    }, Span.prototype.updateName = function(name) {
     return this._isSpanEnded() || (this.name = name), this;
    }, Span.prototype.end = function(endTime) {
     this._isSpanEnded() ? diag_api.K.error(this.name + " " + this._spanContext.traceId + "-" + this._spanContext.spanId + " - You can only call end() on a span once.") : (this._ended = !0, 
     this.endTime = this._getTime(endTime), this._duration = (0, time.J3)(this.startTime, this.endTime), 
     this._duration[0] < 0 && (diag_api.K.warn("Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.", this.startTime, this.endTime), 
     this.endTime = this.startTime.slice(), this._duration = [ 0, 0 ]), this._spanProcessor.onEnd(this));
    }, Span.prototype._getTime = function(inp) {
     if ("number" == typeof inp && inp < performance.t.now()) return (0, time.Jt)(inp + this._performanceOffset);
     if ("number" == typeof inp) return (0, time.i5)(inp);
     if (inp instanceof Date) return (0, time.i5)(inp.getTime());
     if ((0, time.Dt)(inp)) return inp;
     if (this._startTimeProvided) return (0, time.i5)(Date.now());
     var msDuration = performance.t.now() - this._performanceStartTime;
     return (0, time.vF)(this.startTime, (0, time.i5)(msDuration));
    }, Span.prototype.isRecording = function() {
     return !1 === this._ended;
    }, Span.prototype.recordException = function(exception, time) {
     var attributes = {};
     "string" == typeof exception ? attributes[SemanticAttributes.og.EXCEPTION_MESSAGE] = exception : exception && (exception.code ? attributes[SemanticAttributes.og.EXCEPTION_TYPE] = exception.code.toString() : exception.name && (attributes[SemanticAttributes.og.EXCEPTION_TYPE] = exception.name), 
     exception.message && (attributes[SemanticAttributes.og.EXCEPTION_MESSAGE] = exception.message), 
     exception.stack && (attributes[SemanticAttributes.og.EXCEPTION_STACKTRACE] = exception.stack)), 
     attributes[SemanticAttributes.og.EXCEPTION_TYPE] || attributes[SemanticAttributes.og.EXCEPTION_MESSAGE] ? this.addEvent("exception", attributes, time) : diag_api.K.warn("Failed to record an exception " + exception);
    }, Object.defineProperty(Span.prototype, "duration", {
     get: function() {
      return this._duration;
     },
     enumerable: !1,
     configurable: !0
    }), Object.defineProperty(Span.prototype, "ended", {
     get: function() {
      return this._ended;
     },
     enumerable: !1,
     configurable: !0
    }), Object.defineProperty(Span.prototype, "droppedAttributesCount", {
     get: function() {
      return this._droppedAttributesCount;
     },
     enumerable: !1,
     configurable: !0
    }), Object.defineProperty(Span.prototype, "droppedEventsCount", {
     get: function() {
      return this._droppedEventsCount;
     },
     enumerable: !1,
     configurable: !0
    }), Object.defineProperty(Span.prototype, "droppedLinksCount", {
     get: function() {
      return this._droppedLinksCount;
     },
     enumerable: !1,
     configurable: !0
    }), Span.prototype._isSpanEnded = function() {
     return this._ended && diag_api.K.warn("Can not execute the operation on ended Span {traceId: " + this._spanContext.traceId + ", spanId: " + this._spanContext.spanId + "}"), 
     this._ended;
    }, Span.prototype._truncateToLimitUtil = function(value, limit) {
     return value.length <= limit ? value : value.substr(0, limit);
    }, Span.prototype._truncateToSize = function(value) {
     var _this = this, limit = this._attributeValueLengthLimit;
     return limit <= 0 ? (diag_api.K.warn("Attribute value limit must be positive, got " + limit), 
     value) : "string" == typeof value ? this._truncateToLimitUtil(value, limit) : Array.isArray(value) ? value.map((function(val) {
      return "string" == typeof val ? _this._truncateToLimitUtil(val, limit) : val;
     })) : value;
    }, Span;
   }(), node_environment = __webpack_require__(54241), sampling = __webpack_require__(29290);
   !function(SamplingDecision) {
    SamplingDecision[SamplingDecision.NOT_RECORD = 0] = "NOT_RECORD", SamplingDecision[SamplingDecision.RECORD = 1] = "RECORD", 
    SamplingDecision[SamplingDecision.RECORD_AND_SAMPLED = 2] = "RECORD_AND_SAMPLED";
   }(SamplingDecision || (SamplingDecision = {}));
   var AlwaysOffSampler = function() {
    function AlwaysOffSampler() {}
    return AlwaysOffSampler.prototype.shouldSample = function() {
     return {
      decision: SamplingDecision.NOT_RECORD
     };
    }, AlwaysOffSampler.prototype.toString = function() {
     return "AlwaysOffSampler";
    }, AlwaysOffSampler;
   }(), AlwaysOnSampler = function() {
    function AlwaysOnSampler() {}
    return AlwaysOnSampler.prototype.shouldSample = function() {
     return {
      decision: SamplingDecision.RECORD_AND_SAMPLED
     };
    }, AlwaysOnSampler.prototype.toString = function() {
     return "AlwaysOnSampler";
    }, AlwaysOnSampler;
   }(), spancontext_utils = __webpack_require__(97228), global_error_handler = __webpack_require__(36220), ParentBasedSampler = function() {
    function ParentBasedSampler(config) {
     var _a, _b, _c, _d;
     this._root = config.root, this._root || ((0, global_error_handler.L)(new Error("ParentBasedSampler must have a root sampler configured")), 
     this._root = new AlwaysOnSampler), this._remoteParentSampled = null !== (_a = config.remoteParentSampled) && void 0 !== _a ? _a : new AlwaysOnSampler, 
     this._remoteParentNotSampled = null !== (_b = config.remoteParentNotSampled) && void 0 !== _b ? _b : new AlwaysOffSampler, 
     this._localParentSampled = null !== (_c = config.localParentSampled) && void 0 !== _c ? _c : new AlwaysOnSampler, 
     this._localParentNotSampled = null !== (_d = config.localParentNotSampled) && void 0 !== _d ? _d : new AlwaysOffSampler;
    }
    return ParentBasedSampler.prototype.shouldSample = function(context, traceId, spanName, spanKind, attributes, links) {
     var parentContext = trace_api.g.getSpanContext(context);
     return parentContext && (0, spancontext_utils.BM)(parentContext) ? parentContext.isRemote ? parentContext.traceFlags & trace_flags.r.SAMPLED ? this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links) : this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links) : parentContext.traceFlags & trace_flags.r.SAMPLED ? this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links) : this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links) : this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    }, ParentBasedSampler.prototype.toString = function() {
     return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}";
    }, ParentBasedSampler;
   }(), TraceIdRatioBasedSampler = function() {
    function TraceIdRatioBasedSampler(_ratio) {
     void 0 === _ratio && (_ratio = 0), this._ratio = _ratio, this._ratio = this._normalize(_ratio), 
     this._upperBound = Math.floor(4294967295 * this._ratio);
    }
    return TraceIdRatioBasedSampler.prototype.shouldSample = function(context, traceId) {
     return {
      decision: (0, spancontext_utils.jN)(traceId) && this._accumulate(traceId) < this._upperBound ? SamplingDecision.RECORD_AND_SAMPLED : SamplingDecision.NOT_RECORD
     };
    }, TraceIdRatioBasedSampler.prototype.toString = function() {
     return "TraceIdRatioBased{" + this._ratio + "}";
    }, TraceIdRatioBasedSampler.prototype._normalize = function(ratio) {
     return "number" != typeof ratio || isNaN(ratio) ? 0 : ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
    }, TraceIdRatioBasedSampler.prototype._accumulate = function(traceId) {
     for (var accumulation = 0, i = 0; i < traceId.length / 8; i++) {
      var pos = 8 * i;
      accumulation = (accumulation ^ parseInt(traceId.slice(pos, pos + 8), 16)) >>> 0;
     }
     return accumulation;
    }, TraceIdRatioBasedSampler;
   }(), env = (0, node_environment.d)(), FALLBACK_OTEL_TRACES_SAMPLER = sampling.J.AlwaysOn, DEFAULT_RATIO = 1;
   function loadDefaultConfig() {
    return {
     sampler: buildSamplerFromEnv(env),
     forceFlushTimeoutMillis: 3e4,
     generalLimits: {
      attributeValueLengthLimit: (0, node_environment.d)().OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      attributeCountLimit: (0, node_environment.d)().OTEL_ATTRIBUTE_COUNT_LIMIT
     },
     spanLimits: {
      attributeValueLengthLimit: (0, node_environment.d)().OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      attributeCountLimit: (0, node_environment.d)().OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
      linkCountLimit: (0, node_environment.d)().OTEL_SPAN_LINK_COUNT_LIMIT,
      eventCountLimit: (0, node_environment.d)().OTEL_SPAN_EVENT_COUNT_LIMIT,
      attributePerEventCountLimit: (0, node_environment.d)().OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      attributePerLinkCountLimit: (0, node_environment.d)().OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT
     }
    };
   }
   function buildSamplerFromEnv(environment) {
    switch (void 0 === environment && (environment = (0, node_environment.d)()), environment.OTEL_TRACES_SAMPLER) {
    case sampling.J.AlwaysOn:
     return new AlwaysOnSampler;

    case sampling.J.AlwaysOff:
     return new AlwaysOffSampler;

    case sampling.J.ParentBasedAlwaysOn:
     return new ParentBasedSampler({
      root: new AlwaysOnSampler
     });

    case sampling.J.ParentBasedAlwaysOff:
     return new ParentBasedSampler({
      root: new AlwaysOffSampler
     });

    case sampling.J.TraceIdRatio:
     return new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment));

    case sampling.J.ParentBasedTraceIdRatio:
     return new ParentBasedSampler({
      root: new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment))
     });

    default:
     return diag_api.K.error('OTEL_TRACES_SAMPLER value "' + environment.OTEL_TRACES_SAMPLER + " invalid, defaulting to " + FALLBACK_OTEL_TRACES_SAMPLER + '".'), 
     new AlwaysOnSampler;
    }
   }
   function getSamplerProbabilityFromEnv(environment) {
    if (void 0 === environment.OTEL_TRACES_SAMPLER_ARG || "" === environment.OTEL_TRACES_SAMPLER_ARG) return diag_api.K.error("OTEL_TRACES_SAMPLER_ARG is blank, defaulting to " + DEFAULT_RATIO + "."), 
    DEFAULT_RATIO;
    var probability = Number(environment.OTEL_TRACES_SAMPLER_ARG);
    return isNaN(probability) ? (diag_api.K.error("OTEL_TRACES_SAMPLER_ARG=" + environment.OTEL_TRACES_SAMPLER_ARG + " was given, but it is invalid, defaulting to " + DEFAULT_RATIO + "."), 
    DEFAULT_RATIO) : probability < 0 || probability > 1 ? (diag_api.K.error("OTEL_TRACES_SAMPLER_ARG=" + environment.OTEL_TRACES_SAMPLER_ARG + " was given, but it is out of range ([0..1]), defaulting to " + DEFAULT_RATIO + "."), 
    DEFAULT_RATIO) : probability;
   }
   var environment = __webpack_require__(70450);
   var RandomIdGenerator = function() {
    this.generateTraceId = getIdGenerator(16), this.generateSpanId = getIdGenerator(8);
   }, SHARED_BUFFER = Buffer.allocUnsafe(16);
   function getIdGenerator(bytes) {
    return function() {
     for (var i = 0; i < bytes / 4; i++) SHARED_BUFFER.writeUInt32BE(Math.random() * Math.pow(2, 32) >>> 0, 4 * i);
     for (i = 0; i < bytes && !(SHARED_BUFFER[i] > 0); i++) i === bytes - 1 && (SHARED_BUFFER[bytes - 1] = 1);
     return SHARED_BUFFER.toString("hex", 0, bytes);
    };
   }
   var Tracer = function() {
    function Tracer(instrumentationLibrary, config, _tracerProvider) {
     this._tracerProvider = _tracerProvider;
     var userConfig, perInstanceDefaults, DEFAULT_CONFIG, target, localConfig = (userConfig = config, 
     perInstanceDefaults = {
      sampler: buildSamplerFromEnv()
     }, DEFAULT_CONFIG = loadDefaultConfig(), (target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig)).generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {}), 
     target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {}), 
     target);
     this._sampler = localConfig.sampler, this._generalLimits = localConfig.generalLimits, 
     this._spanLimits = localConfig.spanLimits, this._idGenerator = config.idGenerator || new RandomIdGenerator, 
     this.resource = _tracerProvider.resource, this.instrumentationLibrary = instrumentationLibrary;
    }
    return Tracer.prototype.startSpan = function(name, options, context) {
     var _a, _b, _c;
     void 0 === options && (options = {}), void 0 === context && (context = context_api.D.active()), 
     options.root && (context = trace_api.g.deleteSpan(context));
     var parentSpan = trace_api.g.getSpan(context);
     if ((0, suppress_tracing.Ll)(context)) return diag_api.K.debug("Instrumentation suppressed, returning Noop Span"), 
     trace_api.g.wrapSpanContext(invalid_span_constants.Rr);
     var traceId, traceState, parentSpanId, parentSpanContext = null == parentSpan ? void 0 : parentSpan.spanContext(), spanId = this._idGenerator.generateSpanId();
     parentSpanContext && trace_api.g.isSpanContextValid(parentSpanContext) ? (traceId = parentSpanContext.traceId, 
     traceState = parentSpanContext.traceState, parentSpanId = parentSpanContext.spanId) : traceId = this._idGenerator.generateTraceId();
     var spanKind = null !== (_a = options.kind) && void 0 !== _a ? _a : span_kind.M.INTERNAL, links = (null !== (_b = options.links) && void 0 !== _b ? _b : []).map((function(link) {
      return {
       context: link.context,
       attributes: (0, common_attributes.FT)(link.attributes)
      };
     })), attributes = (0, common_attributes.FT)(options.attributes), samplingResult = this._sampler.shouldSample(context, traceId, name, spanKind, attributes, links);
     traceState = null !== (_c = samplingResult.traceState) && void 0 !== _c ? _c : traceState;
     var spanContext = {
      traceId,
      spanId,
      traceFlags: samplingResult.decision === SamplingResult.U.RECORD_AND_SAMPLED ? trace_flags.r.SAMPLED : trace_flags.r.NONE,
      traceState
     };
     if (samplingResult.decision === SamplingResult.U.NOT_RECORD) return diag_api.K.debug("Recording is off, propagating context in a non-recording span"), 
     trace_api.g.wrapSpanContext(spanContext);
     var span = new Span(this, context, name, spanContext, spanKind, parentSpanId, links, options.startTime), initAttributes = (0, 
     common_attributes.FT)(Object.assign(attributes, samplingResult.attributes));
     return span.setAttributes(initAttributes), span;
    }, Tracer.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
     var opts, ctx, fn;
     if (!(arguments.length < 2)) {
      2 === arguments.length ? fn = arg2 : 3 === arguments.length ? (opts = arg2, fn = arg3) : (opts = arg2, 
      ctx = arg3, fn = arg4);
      var parentContext = null != ctx ? ctx : context_api.D.active(), span = this.startSpan(name, opts, parentContext), contextWithSpanSet = trace_api.g.setSpan(parentContext, span);
      return context_api.D.with(contextWithSpanSet, fn, void 0, span);
     }
    }, Tracer.prototype.getGeneralLimits = function() {
     return this._generalLimits;
    }, Tracer.prototype.getSpanLimits = function() {
     return this._spanLimits;
    }, Tracer.prototype.getActiveSpanProcessor = function() {
     return this._tracerProvider.getActiveSpanProcessor();
    }, Tracer;
   }(), propagation_api = __webpack_require__(68303), merge = __webpack_require__(39009), composite = __webpack_require__(63135), W3CTraceContextPropagator = __webpack_require__(49588), W3CBaggagePropagator = __webpack_require__(80926), SemanticResourceAttributes = __webpack_require__(95364), sdk_info = __webpack_require__(93290);
   var extendStatics, ForceFlushState, __assign = function() {
    return __assign = Object.assign || function(t) {
     for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
     return t;
    }, __assign.apply(this, arguments);
   }, __awaiter = function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }, __generator = function(thisArg, body) {
    var f, y, t, g, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    };
    return g = {
     next: verb(0),
     throw: verb(1),
     return: verb(2)
    }, "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;_; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   }, Resource_read = function(o, n) {
    var m = "function" == typeof Symbol && o[Symbol.iterator];
    if (!m) return o;
    var r, e, i = m.call(o), ar = [];
    try {
     for (;(void 0 === n || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
    } catch (error) {
     e = {
      error
     };
    } finally {
     try {
      r && !r.done && (m = i.return) && m.call(i);
     } finally {
      if (e) throw e.error;
     }
    }
    return ar;
   }, Resource = function() {
    function Resource(attributes, asyncAttributesPromise) {
     var _a, _this = this;
     this._attributes = attributes, this.asyncAttributesPending = null != asyncAttributesPromise, 
     this._syncAttributes = null !== (_a = this._attributes) && void 0 !== _a ? _a : {}, 
     this._asyncAttributesPromise = null == asyncAttributesPromise ? void 0 : asyncAttributesPromise.then((function(asyncAttributes) {
      return _this._attributes = Object.assign({}, _this._attributes, asyncAttributes), 
      _this.asyncAttributesPending = !1, asyncAttributes;
     }), (function(err) {
      return diag_api.K.debug("a resource's async attributes promise rejected: %s", err), 
      _this.asyncAttributesPending = !1, {};
     }));
    }
    return Resource.empty = function() {
     return Resource.EMPTY;
    }, Resource.default = function() {
     var _a;
     return new Resource(((_a = {})[SemanticResourceAttributes.R9.SERVICE_NAME] = "unknown_service:" + process.argv0, 
     _a[SemanticResourceAttributes.R9.TELEMETRY_SDK_LANGUAGE] = sdk_info.m[SemanticResourceAttributes.R9.TELEMETRY_SDK_LANGUAGE], 
     _a[SemanticResourceAttributes.R9.TELEMETRY_SDK_NAME] = sdk_info.m[SemanticResourceAttributes.R9.TELEMETRY_SDK_NAME], 
     _a[SemanticResourceAttributes.R9.TELEMETRY_SDK_VERSION] = sdk_info.m[SemanticResourceAttributes.R9.TELEMETRY_SDK_VERSION], 
     _a));
    }, Object.defineProperty(Resource.prototype, "attributes", {
     get: function() {
      var _a;
      return this.asyncAttributesPending && diag_api.K.error("Accessing resource attributes before async attributes settled"), 
      null !== (_a = this._attributes) && void 0 !== _a ? _a : {};
     },
     enumerable: !1,
     configurable: !0
    }), Resource.prototype.waitForAsyncAttributes = function() {
     return __awaiter(this, void 0, void 0, (function() {
      return __generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return this.asyncAttributesPending ? [ 4, this._asyncAttributesPromise ] : [ 3, 2 ];

       case 1:
        _a.sent(), _a.label = 2;

       case 2:
        return [ 2 ];
       }
      }));
     }));
    }, Resource.prototype.merge = function(other) {
     var _a, _this = this;
     if (!other) return this;
     var mergedSyncAttributes = __assign(__assign({}, this._syncAttributes), null !== (_a = other._syncAttributes) && void 0 !== _a ? _a : other.attributes);
     if (!this._asyncAttributesPromise && !other._asyncAttributesPromise) return new Resource(mergedSyncAttributes);
     var mergedAttributesPromise = Promise.all([ this._asyncAttributesPromise, other._asyncAttributesPromise ]).then((function(_a) {
      var _b, _c = Resource_read(_a, 2), thisAsyncAttributes = _c[0], otherAsyncAttributes = _c[1];
      return __assign(__assign(__assign(__assign({}, _this._syncAttributes), thisAsyncAttributes), null !== (_b = other._syncAttributes) && void 0 !== _b ? _b : other.attributes), otherAsyncAttributes);
     }));
     return new Resource(mergedSyncAttributes, mergedAttributesPromise);
    }, Resource.EMPTY = new Resource({}), Resource;
   }(), MultiSpanProcessor_values = function(o) {
    var s = "function" == typeof Symbol && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && "number" == typeof o.length) return {
     next: function() {
      return o && i >= o.length && (o = void 0), {
       value: o && o[i++],
       done: !o
      };
     }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
   }, MultiSpanProcessor = function() {
    function MultiSpanProcessor(_spanProcessors) {
     this._spanProcessors = _spanProcessors;
    }
    return MultiSpanProcessor.prototype.forceFlush = function() {
     var e_1, _a, promises = [];
     try {
      for (var _b = MultiSpanProcessor_values(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
       var spanProcessor = _c.value;
       promises.push(spanProcessor.forceFlush());
      }
     } catch (e_1_1) {
      e_1 = {
       error: e_1_1
      };
     } finally {
      try {
       _c && !_c.done && (_a = _b.return) && _a.call(_b);
      } finally {
       if (e_1) throw e_1.error;
      }
     }
     return new Promise((function(resolve) {
      Promise.all(promises).then((function() {
       resolve();
      })).catch((function(error) {
       (0, global_error_handler.L)(error || new Error("MultiSpanProcessor: forceFlush failed")), 
       resolve();
      }));
     }));
    }, MultiSpanProcessor.prototype.onStart = function(span, context) {
     var e_2, _a;
     try {
      for (var _b = MultiSpanProcessor_values(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
       _c.value.onStart(span, context);
      }
     } catch (e_2_1) {
      e_2 = {
       error: e_2_1
      };
     } finally {
      try {
       _c && !_c.done && (_a = _b.return) && _a.call(_b);
      } finally {
       if (e_2) throw e_2.error;
      }
     }
    }, MultiSpanProcessor.prototype.onEnd = function(span) {
     var e_3, _a;
     try {
      for (var _b = MultiSpanProcessor_values(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
       _c.value.onEnd(span);
      }
     } catch (e_3_1) {
      e_3 = {
       error: e_3_1
      };
     } finally {
      try {
       _c && !_c.done && (_a = _b.return) && _a.call(_b);
      } finally {
       if (e_3) throw e_3.error;
      }
     }
    }, MultiSpanProcessor.prototype.shutdown = function() {
     var e_4, _a, promises = [];
     try {
      for (var _b = MultiSpanProcessor_values(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
       var spanProcessor = _c.value;
       promises.push(spanProcessor.shutdown());
      }
     } catch (e_4_1) {
      e_4 = {
       error: e_4_1
      };
     } finally {
      try {
       _c && !_c.done && (_a = _b.return) && _a.call(_b);
      } finally {
       if (e_4) throw e_4.error;
      }
     }
     return new Promise((function(resolve, reject) {
      Promise.all(promises).then((function() {
       resolve();
      }), reject);
     }));
    }, MultiSpanProcessor;
   }(), NoopSpanProcessor = function() {
    function NoopSpanProcessor() {}
    return NoopSpanProcessor.prototype.onStart = function(_span, _context) {}, NoopSpanProcessor.prototype.onEnd = function(_span) {}, 
    NoopSpanProcessor.prototype.shutdown = function() {
     return Promise.resolve();
    }, NoopSpanProcessor.prototype.forceFlush = function() {
     return Promise.resolve();
    }, NoopSpanProcessor;
   }(), callback = __webpack_require__(71399), ExportResult = __webpack_require__(63420), timer_util = __webpack_require__(52140), BatchSpanProcessorBase = function() {
    function BatchSpanProcessorBase(_exporter, config) {
     this._exporter = _exporter, this._finishedSpans = [], this._droppedSpansCount = 0;
     var env = (0, node_environment.d)();
     this._maxExportBatchSize = "number" == typeof (null == config ? void 0 : config.maxExportBatchSize) ? config.maxExportBatchSize : env.OTEL_BSP_MAX_EXPORT_BATCH_SIZE, 
     this._maxQueueSize = "number" == typeof (null == config ? void 0 : config.maxQueueSize) ? config.maxQueueSize : env.OTEL_BSP_MAX_QUEUE_SIZE, 
     this._scheduledDelayMillis = "number" == typeof (null == config ? void 0 : config.scheduledDelayMillis) ? config.scheduledDelayMillis : env.OTEL_BSP_SCHEDULE_DELAY, 
     this._exportTimeoutMillis = "number" == typeof (null == config ? void 0 : config.exportTimeoutMillis) ? config.exportTimeoutMillis : env.OTEL_BSP_EXPORT_TIMEOUT, 
     this._shutdownOnce = new callback.q(this._shutdown, this), this._maxExportBatchSize > this._maxQueueSize && (diag_api.K.warn("BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize"), 
     this._maxExportBatchSize = this._maxQueueSize);
    }
    return BatchSpanProcessorBase.prototype.forceFlush = function() {
     return this._shutdownOnce.isCalled ? this._shutdownOnce.promise : this._flushAll();
    }, BatchSpanProcessorBase.prototype.onStart = function(_span, _parentContext) {}, 
    BatchSpanProcessorBase.prototype.onEnd = function(span) {
     this._shutdownOnce.isCalled || 0 != (span.spanContext().traceFlags & trace_flags.r.SAMPLED) && this._addToBuffer(span);
    }, BatchSpanProcessorBase.prototype.shutdown = function() {
     return this._shutdownOnce.call();
    }, BatchSpanProcessorBase.prototype._shutdown = function() {
     var _this = this;
     return Promise.resolve().then((function() {
      return _this.onShutdown();
     })).then((function() {
      return _this._flushAll();
     })).then((function() {
      return _this._exporter.shutdown();
     }));
    }, BatchSpanProcessorBase.prototype._addToBuffer = function(span) {
     if (this._finishedSpans.length >= this._maxQueueSize) return 0 === this._droppedSpansCount && diag_api.K.debug("maxQueueSize reached, dropping spans"), 
     void this._droppedSpansCount++;
     this._droppedSpansCount > 0 && (diag_api.K.warn("Dropped " + this._droppedSpansCount + " spans because maxQueueSize reached"), 
     this._droppedSpansCount = 0), this._finishedSpans.push(span), this._maybeStartTimer();
    }, BatchSpanProcessorBase.prototype._flushAll = function() {
     var _this = this;
     return new Promise((function(resolve, reject) {
      for (var promises = [], i = 0, j = Math.ceil(_this._finishedSpans.length / _this._maxExportBatchSize); i < j; i++) promises.push(_this._flushOneBatch());
      Promise.all(promises).then((function() {
       resolve();
      })).catch(reject);
     }));
    }, BatchSpanProcessorBase.prototype._flushOneBatch = function() {
     var _this = this;
     return this._clearTimer(), 0 === this._finishedSpans.length ? Promise.resolve() : new Promise((function(resolve, reject) {
      var timer = setTimeout((function() {
       reject(new Error("Timeout"));
      }), _this._exportTimeoutMillis);
      context_api.D.with((0, suppress_tracing.hE)(context_api.D.active()), (function() {
       var spans = _this._finishedSpans.splice(0, _this._maxExportBatchSize), doExport = function() {
        return _this._exporter.export(spans, (function(result) {
         var _a;
         clearTimeout(timer), result.code === ExportResult.I.SUCCESS ? resolve() : reject(null !== (_a = result.error) && void 0 !== _a ? _a : new Error("BatchSpanProcessor: span export failed"));
        }));
       }, pendingResources = spans.map((function(span) {
        return span.resource;
       })).filter((function(resource) {
        return resource.asyncAttributesPending;
       }));
       0 === pendingResources.length ? doExport() : Promise.all(pendingResources.map((function(resource) {
        var _a;
        return null === (_a = resource.waitForAsyncAttributes) || void 0 === _a ? void 0 : _a.call(resource);
       }))).then(doExport, (function(err) {
        (0, global_error_handler.L)(err), reject(err);
       }));
      }));
     }));
    }, BatchSpanProcessorBase.prototype._maybeStartTimer = function() {
     var _this = this;
     void 0 === this._timer && (this._timer = setTimeout((function() {
      _this._flushOneBatch().then((function() {
       _this._finishedSpans.length > 0 && (_this._clearTimer(), _this._maybeStartTimer());
      })).catch((function(e) {
       (0, global_error_handler.L)(e);
      }));
     }), this._scheduledDelayMillis), (0, timer_util.g)(this._timer));
    }, BatchSpanProcessorBase.prototype._clearTimer = function() {
     void 0 !== this._timer && (clearTimeout(this._timer), this._timer = void 0);
    }, BatchSpanProcessorBase;
   }(), __extends = (extendStatics = function(d, b) {
    return extendStatics = Object.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
    }, extendStatics(d, b);
   }, function(d, b) {
    if ("function" != typeof b && null !== b) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    function __() {
     this.constructor = d;
    }
    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
    new __);
   }), BatchSpanProcessor = function(_super) {
    function BatchSpanProcessor() {
     return null !== _super && _super.apply(this, arguments) || this;
    }
    return __extends(BatchSpanProcessor, _super), BatchSpanProcessor.prototype.onShutdown = function() {}, 
    BatchSpanProcessor;
   }(BatchSpanProcessorBase);
   !function(ForceFlushState) {
    ForceFlushState[ForceFlushState.resolved = 0] = "resolved", ForceFlushState[ForceFlushState.timeout = 1] = "timeout", 
    ForceFlushState[ForceFlushState.error = 2] = "error", ForceFlushState[ForceFlushState.unresolved = 3] = "unresolved";
   }(ForceFlushState || (ForceFlushState = {}));
   var BasicTracerProvider = function() {
    function BasicTracerProvider(config) {
     var _a;
     void 0 === config && (config = {}), this._registeredSpanProcessors = [], this._tracers = new Map;
     var mergedConfig = (0, merge.T)({}, loadDefaultConfig(), function(userConfig) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, spanLimits = Object.assign({}, userConfig.spanLimits), parsedEnvConfig = (0, 
      environment.vU)();
      return spanLimits.attributeCountLimit = null !== (_f = null !== (_e = null !== (_d = null !== (_b = null === (_a = userConfig.spanLimits) || void 0 === _a ? void 0 : _a.attributeCountLimit) && void 0 !== _b ? _b : null === (_c = userConfig.generalLimits) || void 0 === _c ? void 0 : _c.attributeCountLimit) && void 0 !== _d ? _d : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) && void 0 !== _e ? _e : parsedEnvConfig.OTEL_ATTRIBUTE_COUNT_LIMIT) && void 0 !== _f ? _f : environment.qG, 
      spanLimits.attributeValueLengthLimit = null !== (_m = null !== (_l = null !== (_k = null !== (_h = null === (_g = userConfig.spanLimits) || void 0 === _g ? void 0 : _g.attributeValueLengthLimit) && void 0 !== _h ? _h : null === (_j = userConfig.generalLimits) || void 0 === _j ? void 0 : _j.attributeValueLengthLimit) && void 0 !== _k ? _k : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) && void 0 !== _l ? _l : parsedEnvConfig.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) && void 0 !== _m ? _m : environment.KR, 
      Object.assign({}, userConfig, {
       spanLimits
      });
     }(config));
     this.resource = null !== (_a = mergedConfig.resource) && void 0 !== _a ? _a : Resource.empty(), 
     this.resource = Resource.default().merge(this.resource), this._config = Object.assign({}, mergedConfig, {
      resource: this.resource
     });
     var defaultExporter = this._buildExporterFromEnv();
     if (void 0 !== defaultExporter) {
      var batchProcessor = new BatchSpanProcessor(defaultExporter);
      this.activeSpanProcessor = batchProcessor;
     } else this.activeSpanProcessor = new NoopSpanProcessor;
    }
    return BasicTracerProvider.prototype.getTracer = function(name, version, options) {
     var key = name + "@" + (version || "") + ":" + ((null == options ? void 0 : options.schemaUrl) || "");
     return this._tracers.has(key) || this._tracers.set(key, new Tracer({
      name,
      version,
      schemaUrl: null == options ? void 0 : options.schemaUrl
     }, this._config, this)), this._tracers.get(key);
    }, BasicTracerProvider.prototype.addSpanProcessor = function(spanProcessor) {
     0 === this._registeredSpanProcessors.length && this.activeSpanProcessor.shutdown().catch((function(err) {
      return diag_api.K.error("Error while trying to shutdown current span processor", err);
     })), this._registeredSpanProcessors.push(spanProcessor), this.activeSpanProcessor = new MultiSpanProcessor(this._registeredSpanProcessors);
    }, BasicTracerProvider.prototype.getActiveSpanProcessor = function() {
     return this.activeSpanProcessor;
    }, BasicTracerProvider.prototype.register = function(config) {
     void 0 === config && (config = {}), trace_api.g.setGlobalTracerProvider(this), void 0 === config.propagator && (config.propagator = this._buildPropagatorFromEnv()), 
     config.contextManager && context_api.D.setGlobalContextManager(config.contextManager), 
     config.propagator && propagation_api.u.setGlobalPropagator(config.propagator);
    }, BasicTracerProvider.prototype.forceFlush = function() {
     var timeout = this._config.forceFlushTimeoutMillis, promises = this._registeredSpanProcessors.map((function(spanProcessor) {
      return new Promise((function(resolve) {
       var state, timeoutInterval = setTimeout((function() {
        resolve(new Error("Span processor did not completed within timeout period of " + timeout + " ms")), 
        state = ForceFlushState.timeout;
       }), timeout);
       spanProcessor.forceFlush().then((function() {
        clearTimeout(timeoutInterval), state !== ForceFlushState.timeout && (state = ForceFlushState.resolved, 
        resolve(state));
       })).catch((function(error) {
        clearTimeout(timeoutInterval), state = ForceFlushState.error, resolve(error);
       }));
      }));
     }));
     return new Promise((function(resolve, reject) {
      Promise.all(promises).then((function(results) {
       var errors = results.filter((function(result) {
        return result !== ForceFlushState.resolved;
       }));
       errors.length > 0 ? reject(errors) : resolve();
      })).catch((function(error) {
       return reject([ error ]);
      }));
     }));
    }, BasicTracerProvider.prototype.shutdown = function() {
     return this.activeSpanProcessor.shutdown();
    }, BasicTracerProvider.prototype._getPropagator = function(name) {
     var _a;
     return null === (_a = this.constructor._registeredPropagators.get(name)) || void 0 === _a ? void 0 : _a();
    }, BasicTracerProvider.prototype._getSpanExporter = function(name) {
     var _a;
     return null === (_a = this.constructor._registeredExporters.get(name)) || void 0 === _a ? void 0 : _a();
    }, BasicTracerProvider.prototype._buildPropagatorFromEnv = function() {
     var _this = this, uniquePropagatorNames = Array.from(new Set((0, node_environment.d)().OTEL_PROPAGATORS)), validPropagators = uniquePropagatorNames.map((function(name) {
      var propagator = _this._getPropagator(name);
      return propagator || diag_api.K.warn('Propagator "' + name + '" requested through environment variable is unavailable.'), 
      propagator;
     })).reduce((function(list, item) {
      return item && list.push(item), list;
     }), []);
     return 0 === validPropagators.length ? void 0 : 1 === uniquePropagatorNames.length ? validPropagators[0] : new composite.Y({
      propagators: validPropagators
     });
    }, BasicTracerProvider.prototype._buildExporterFromEnv = function() {
     var exporterName = (0, node_environment.d)().OTEL_TRACES_EXPORTER;
     if ("none" !== exporterName && "" !== exporterName) {
      var exporter = this._getSpanExporter(exporterName);
      return exporter || diag_api.K.error('Exporter "' + exporterName + '" requested through environment variable is unavailable.'), 
      exporter;
     }
    }, BasicTracerProvider._registeredPropagators = new Map([ [ "tracecontext", function() {
     return new W3CTraceContextPropagator.jf;
    } ], [ "baggage", function() {
     return new W3CBaggagePropagator.a;
    } ] ]), BasicTracerProvider._registeredExporters = new Map, BasicTracerProvider;
   }(), ConsoleSpanExporter_values = function(o) {
    var s = "function" == typeof Symbol && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && "number" == typeof o.length) return {
     next: function() {
      return o && i >= o.length && (o = void 0), {
       value: o && o[i++],
       done: !o
      };
     }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
   }, ConsoleSpanExporter = function() {
    function ConsoleSpanExporter() {}
    return ConsoleSpanExporter.prototype.export = function(spans, resultCallback) {
     return this._sendSpans(spans, resultCallback);
    }, ConsoleSpanExporter.prototype.shutdown = function() {
     return this._sendSpans([]), this.forceFlush();
    }, ConsoleSpanExporter.prototype.forceFlush = function() {
     return Promise.resolve();
    }, ConsoleSpanExporter.prototype._exportInfo = function(span) {
     var _a;
     return {
      traceId: span.spanContext().traceId,
      parentId: span.parentSpanId,
      traceState: null === (_a = span.spanContext().traceState) || void 0 === _a ? void 0 : _a.serialize(),
      name: span.name,
      id: span.spanContext().spanId,
      kind: span.kind,
      timestamp: (0, time.ji)(span.startTime),
      duration: (0, time.ji)(span.duration),
      attributes: span.attributes,
      status: span.status,
      events: span.events,
      links: span.links
     };
    }, ConsoleSpanExporter.prototype._sendSpans = function(spans, done) {
     var e_1, _a;
     try {
      for (var spans_1 = ConsoleSpanExporter_values(spans), spans_1_1 = spans_1.next(); !spans_1_1.done; spans_1_1 = spans_1.next()) {
       var span = spans_1_1.value;
       console.dir(this._exportInfo(span), {
        depth: 3
       });
      }
     } catch (e_1_1) {
      e_1 = {
       error: e_1_1
      };
     } finally {
      try {
       spans_1_1 && !spans_1_1.done && (_a = spans_1.return) && _a.call(spans_1);
      } finally {
       if (e_1) throw e_1.error;
      }
     }
     if (done) return done({
      code: ExportResult.I.SUCCESS
     });
    }, ConsoleSpanExporter;
   }(), InMemorySpanExporter_read = function(o, n) {
    var m = "function" == typeof Symbol && o[Symbol.iterator];
    if (!m) return o;
    var r, e, i = m.call(o), ar = [];
    try {
     for (;(void 0 === n || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
    } catch (error) {
     e = {
      error
     };
    } finally {
     try {
      r && !r.done && (m = i.return) && m.call(i);
     } finally {
      if (e) throw e.error;
     }
    }
    return ar;
   }, __spreadArray = function(to, from, pack) {
    if (pack || 2 === arguments.length) for (var ar, i = 0, l = from.length; i < l; i++) !ar && i in from || (ar || (ar = Array.prototype.slice.call(from, 0, i)), 
    ar[i] = from[i]);
    return to.concat(ar || Array.prototype.slice.call(from));
   }, InMemorySpanExporter = function() {
    function InMemorySpanExporter() {
     this._finishedSpans = [], this._stopped = !1;
    }
    return InMemorySpanExporter.prototype.export = function(spans, resultCallback) {
     var _a;
     if (this._stopped) return resultCallback({
      code: ExportResult.I.FAILED,
      error: new Error("Exporter has been stopped")
     });
     (_a = this._finishedSpans).push.apply(_a, __spreadArray([], InMemorySpanExporter_read(spans), !1)), 
     setTimeout((function() {
      return resultCallback({
       code: ExportResult.I.SUCCESS
      });
     }), 0);
    }, InMemorySpanExporter.prototype.shutdown = function() {
     return this._stopped = !0, this._finishedSpans = [], this.forceFlush();
    }, InMemorySpanExporter.prototype.forceFlush = function() {
     return Promise.resolve();
    }, InMemorySpanExporter.prototype.reset = function() {
     this._finishedSpans = [];
    }, InMemorySpanExporter.prototype.getFinishedSpans = function() {
     return this._finishedSpans;
    }, InMemorySpanExporter;
   }(), esm = __webpack_require__(47593), SimpleSpanProcessor_awaiter = function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }, SimpleSpanProcessor_generator = function(thisArg, body) {
    var f, y, t, g, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    };
    return g = {
     next: verb(0),
     throw: verb(1),
     return: verb(2)
    }, "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;_; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   }, SimpleSpanProcessor = function() {
    function SimpleSpanProcessor(_exporter) {
     this._exporter = _exporter, this._shutdownOnce = new callback.q(this._shutdown, this), 
     this._unresolvedExports = new Set;
    }
    return SimpleSpanProcessor.prototype.forceFlush = function() {
     return SimpleSpanProcessor_awaiter(this, void 0, void 0, (function() {
      return SimpleSpanProcessor_generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return [ 4, Promise.all(Array.from(this._unresolvedExports)) ];

       case 1:
        return _a.sent(), this._exporter.forceFlush ? [ 4, this._exporter.forceFlush() ] : [ 3, 3 ];

       case 2:
        _a.sent(), _a.label = 3;

       case 3:
        return [ 2 ];
       }
      }));
     }));
    }, SimpleSpanProcessor.prototype.onStart = function(_span, _parentContext) {}, SimpleSpanProcessor.prototype.onEnd = function(span) {
     var _a, _b, _this = this;
     if (!this._shutdownOnce.isCalled && 0 != (span.spanContext().traceFlags & trace_flags.r.SAMPLED)) {
      var doExport = function() {
       return esm.internal._export(_this._exporter, [ span ]).then((function(result) {
        var _a;
        result.code !== ExportResult.I.SUCCESS && (0, global_error_handler.L)(null !== (_a = result.error) && void 0 !== _a ? _a : new Error("SimpleSpanProcessor: span export failed (status " + result + ")"));
       })).catch((function(error) {
        (0, global_error_handler.L)(error);
       }));
      };
      if (span.resource.asyncAttributesPending) {
       var exportPromise_1 = null === (_b = (_a = span.resource).waitForAsyncAttributes) || void 0 === _b ? void 0 : _b.call(_a).then((function() {
        return null != exportPromise_1 && _this._unresolvedExports.delete(exportPromise_1), 
        doExport();
       }), (function(err) {
        return (0, global_error_handler.L)(err);
       }));
       null != exportPromise_1 && this._unresolvedExports.add(exportPromise_1);
      } else doExport();
     }
    }, SimpleSpanProcessor.prototype.shutdown = function() {
     return this._shutdownOnce.call();
    }, SimpleSpanProcessor.prototype._shutdown = function() {
     return this._exporter.shutdown();
    }, SimpleSpanProcessor;
   }();
  },
  47480: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    AwsEcsLaunchtypeValues: () => SemanticResourceAttributes._t,
    CloudPlatformValues: () => SemanticResourceAttributes.CY,
    CloudProviderValues: () => SemanticResourceAttributes.LH,
    DbCassandraConsistencyLevelValues: () => SemanticAttributes.xM,
    DbSystemValues: () => SemanticAttributes.fL,
    FaasDocumentOperationValues: () => SemanticAttributes.ZI,
    FaasInvokedProviderValues: () => SemanticAttributes.o0,
    FaasTriggerValues: () => SemanticAttributes.iD,
    HostArchValues: () => SemanticResourceAttributes.IV,
    HttpFlavorValues: () => SemanticAttributes.Yi,
    MessageTypeValues: () => SemanticAttributes._J,
    MessagingDestinationKindValues: () => SemanticAttributes.y8,
    MessagingOperationValues: () => SemanticAttributes.jU,
    NetHostConnectionSubtypeValues: () => SemanticAttributes.oP,
    NetHostConnectionTypeValues: () => SemanticAttributes.ZM,
    NetTransportValues: () => SemanticAttributes.Di,
    OsTypeValues: () => SemanticResourceAttributes.er,
    RpcGrpcStatusCodeValues: () => SemanticAttributes.yG,
    SemanticAttributes: () => SemanticAttributes.og,
    SemanticResourceAttributes: () => SemanticResourceAttributes.R9,
    TelemetrySdkLanguageValues: () => SemanticResourceAttributes.Te
   });
   var SemanticAttributes = __webpack_require__(73108), SemanticResourceAttributes = __webpack_require__(95364);
  },
  95364: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    CY: () => CloudPlatformValues,
    IV: () => HostArchValues,
    LH: () => CloudProviderValues,
    R9: () => SemanticResourceAttributes,
    Te: () => TelemetrySdkLanguageValues,
    _t: () => AwsEcsLaunchtypeValues,
    er: () => OsTypeValues
   });
   var SemanticResourceAttributes = {
    CLOUD_PROVIDER: "cloud.provider",
    CLOUD_ACCOUNT_ID: "cloud.account.id",
    CLOUD_REGION: "cloud.region",
    CLOUD_AVAILABILITY_ZONE: "cloud.availability_zone",
    CLOUD_PLATFORM: "cloud.platform",
    AWS_ECS_CONTAINER_ARN: "aws.ecs.container.arn",
    AWS_ECS_CLUSTER_ARN: "aws.ecs.cluster.arn",
    AWS_ECS_LAUNCHTYPE: "aws.ecs.launchtype",
    AWS_ECS_TASK_ARN: "aws.ecs.task.arn",
    AWS_ECS_TASK_FAMILY: "aws.ecs.task.family",
    AWS_ECS_TASK_REVISION: "aws.ecs.task.revision",
    AWS_EKS_CLUSTER_ARN: "aws.eks.cluster.arn",
    AWS_LOG_GROUP_NAMES: "aws.log.group.names",
    AWS_LOG_GROUP_ARNS: "aws.log.group.arns",
    AWS_LOG_STREAM_NAMES: "aws.log.stream.names",
    AWS_LOG_STREAM_ARNS: "aws.log.stream.arns",
    CONTAINER_NAME: "container.name",
    CONTAINER_ID: "container.id",
    CONTAINER_RUNTIME: "container.runtime",
    CONTAINER_IMAGE_NAME: "container.image.name",
    CONTAINER_IMAGE_TAG: "container.image.tag",
    DEPLOYMENT_ENVIRONMENT: "deployment.environment",
    DEVICE_ID: "device.id",
    DEVICE_MODEL_IDENTIFIER: "device.model.identifier",
    DEVICE_MODEL_NAME: "device.model.name",
    FAAS_NAME: "faas.name",
    FAAS_ID: "faas.id",
    FAAS_VERSION: "faas.version",
    FAAS_INSTANCE: "faas.instance",
    FAAS_MAX_MEMORY: "faas.max_memory",
    HOST_ID: "host.id",
    HOST_NAME: "host.name",
    HOST_TYPE: "host.type",
    HOST_ARCH: "host.arch",
    HOST_IMAGE_NAME: "host.image.name",
    HOST_IMAGE_ID: "host.image.id",
    HOST_IMAGE_VERSION: "host.image.version",
    K8S_CLUSTER_NAME: "k8s.cluster.name",
    K8S_NODE_NAME: "k8s.node.name",
    K8S_NODE_UID: "k8s.node.uid",
    K8S_NAMESPACE_NAME: "k8s.namespace.name",
    K8S_POD_UID: "k8s.pod.uid",
    K8S_POD_NAME: "k8s.pod.name",
    K8S_CONTAINER_NAME: "k8s.container.name",
    K8S_REPLICASET_UID: "k8s.replicaset.uid",
    K8S_REPLICASET_NAME: "k8s.replicaset.name",
    K8S_DEPLOYMENT_UID: "k8s.deployment.uid",
    K8S_DEPLOYMENT_NAME: "k8s.deployment.name",
    K8S_STATEFULSET_UID: "k8s.statefulset.uid",
    K8S_STATEFULSET_NAME: "k8s.statefulset.name",
    K8S_DAEMONSET_UID: "k8s.daemonset.uid",
    K8S_DAEMONSET_NAME: "k8s.daemonset.name",
    K8S_JOB_UID: "k8s.job.uid",
    K8S_JOB_NAME: "k8s.job.name",
    K8S_CRONJOB_UID: "k8s.cronjob.uid",
    K8S_CRONJOB_NAME: "k8s.cronjob.name",
    OS_TYPE: "os.type",
    OS_DESCRIPTION: "os.description",
    OS_NAME: "os.name",
    OS_VERSION: "os.version",
    PROCESS_PID: "process.pid",
    PROCESS_EXECUTABLE_NAME: "process.executable.name",
    PROCESS_EXECUTABLE_PATH: "process.executable.path",
    PROCESS_COMMAND: "process.command",
    PROCESS_COMMAND_LINE: "process.command_line",
    PROCESS_COMMAND_ARGS: "process.command_args",
    PROCESS_OWNER: "process.owner",
    PROCESS_RUNTIME_NAME: "process.runtime.name",
    PROCESS_RUNTIME_VERSION: "process.runtime.version",
    PROCESS_RUNTIME_DESCRIPTION: "process.runtime.description",
    SERVICE_NAME: "service.name",
    SERVICE_NAMESPACE: "service.namespace",
    SERVICE_INSTANCE_ID: "service.instance.id",
    SERVICE_VERSION: "service.version",
    TELEMETRY_SDK_NAME: "telemetry.sdk.name",
    TELEMETRY_SDK_LANGUAGE: "telemetry.sdk.language",
    TELEMETRY_SDK_VERSION: "telemetry.sdk.version",
    TELEMETRY_AUTO_VERSION: "telemetry.auto.version",
    WEBENGINE_NAME: "webengine.name",
    WEBENGINE_VERSION: "webengine.version",
    WEBENGINE_DESCRIPTION: "webengine.description"
   }, CloudProviderValues = {
    ALIBABA_CLOUD: "alibaba_cloud",
    AWS: "aws",
    AZURE: "azure",
    GCP: "gcp"
   }, CloudPlatformValues = {
    ALIBABA_CLOUD_ECS: "alibaba_cloud_ecs",
    ALIBABA_CLOUD_FC: "alibaba_cloud_fc",
    AWS_EC2: "aws_ec2",
    AWS_ECS: "aws_ecs",
    AWS_EKS: "aws_eks",
    AWS_LAMBDA: "aws_lambda",
    AWS_ELASTIC_BEANSTALK: "aws_elastic_beanstalk",
    AZURE_VM: "azure_vm",
    AZURE_CONTAINER_INSTANCES: "azure_container_instances",
    AZURE_AKS: "azure_aks",
    AZURE_FUNCTIONS: "azure_functions",
    AZURE_APP_SERVICE: "azure_app_service",
    GCP_COMPUTE_ENGINE: "gcp_compute_engine",
    GCP_CLOUD_RUN: "gcp_cloud_run",
    GCP_KUBERNETES_ENGINE: "gcp_kubernetes_engine",
    GCP_CLOUD_FUNCTIONS: "gcp_cloud_functions",
    GCP_APP_ENGINE: "gcp_app_engine"
   }, AwsEcsLaunchtypeValues = {
    EC2: "ec2",
    FARGATE: "fargate"
   }, HostArchValues = {
    AMD64: "amd64",
    ARM32: "arm32",
    ARM64: "arm64",
    IA64: "ia64",
    PPC32: "ppc32",
    PPC64: "ppc64",
    X86: "x86"
   }, OsTypeValues = {
    WINDOWS: "windows",
    LINUX: "linux",
    DARWIN: "darwin",
    FREEBSD: "freebsd",
    NETBSD: "netbsd",
    OPENBSD: "openbsd",
    DRAGONFLYBSD: "dragonflybsd",
    HPUX: "hpux",
    AIX: "aix",
    SOLARIS: "solaris",
    Z_OS: "z_os"
   }, TelemetrySdkLanguageValues = {
    CPP: "cpp",
    DOTNET: "dotnet",
    ERLANG: "erlang",
    GO: "go",
    JAVA: "java",
    NODEJS: "nodejs",
    PHP: "php",
    PYTHON: "python",
    RUBY: "ruby",
    WEBJS: "webjs"
   };
  },
  73108: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Di: () => NetTransportValues,
    Yi: () => HttpFlavorValues,
    ZI: () => FaasDocumentOperationValues,
    ZM: () => NetHostConnectionTypeValues,
    _J: () => MessageTypeValues,
    fL: () => DbSystemValues,
    iD: () => FaasTriggerValues,
    jU: () => MessagingOperationValues,
    o0: () => FaasInvokedProviderValues,
    oP: () => NetHostConnectionSubtypeValues,
    og: () => SemanticAttributes,
    xM: () => DbCassandraConsistencyLevelValues,
    y8: () => MessagingDestinationKindValues,
    yG: () => RpcGrpcStatusCodeValues
   });
   var SemanticAttributes = {
    AWS_LAMBDA_INVOKED_ARN: "aws.lambda.invoked_arn",
    DB_SYSTEM: "db.system",
    DB_CONNECTION_STRING: "db.connection_string",
    DB_USER: "db.user",
    DB_JDBC_DRIVER_CLASSNAME: "db.jdbc.driver_classname",
    DB_NAME: "db.name",
    DB_STATEMENT: "db.statement",
    DB_OPERATION: "db.operation",
    DB_MSSQL_INSTANCE_NAME: "db.mssql.instance_name",
    DB_CASSANDRA_KEYSPACE: "db.cassandra.keyspace",
    DB_CASSANDRA_PAGE_SIZE: "db.cassandra.page_size",
    DB_CASSANDRA_CONSISTENCY_LEVEL: "db.cassandra.consistency_level",
    DB_CASSANDRA_TABLE: "db.cassandra.table",
    DB_CASSANDRA_IDEMPOTENCE: "db.cassandra.idempotence",
    DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: "db.cassandra.speculative_execution_count",
    DB_CASSANDRA_COORDINATOR_ID: "db.cassandra.coordinator.id",
    DB_CASSANDRA_COORDINATOR_DC: "db.cassandra.coordinator.dc",
    DB_HBASE_NAMESPACE: "db.hbase.namespace",
    DB_REDIS_DATABASE_INDEX: "db.redis.database_index",
    DB_MONGODB_COLLECTION: "db.mongodb.collection",
    DB_SQL_TABLE: "db.sql.table",
    EXCEPTION_TYPE: "exception.type",
    EXCEPTION_MESSAGE: "exception.message",
    EXCEPTION_STACKTRACE: "exception.stacktrace",
    EXCEPTION_ESCAPED: "exception.escaped",
    FAAS_TRIGGER: "faas.trigger",
    FAAS_EXECUTION: "faas.execution",
    FAAS_DOCUMENT_COLLECTION: "faas.document.collection",
    FAAS_DOCUMENT_OPERATION: "faas.document.operation",
    FAAS_DOCUMENT_TIME: "faas.document.time",
    FAAS_DOCUMENT_NAME: "faas.document.name",
    FAAS_TIME: "faas.time",
    FAAS_CRON: "faas.cron",
    FAAS_COLDSTART: "faas.coldstart",
    FAAS_INVOKED_NAME: "faas.invoked_name",
    FAAS_INVOKED_PROVIDER: "faas.invoked_provider",
    FAAS_INVOKED_REGION: "faas.invoked_region",
    NET_TRANSPORT: "net.transport",
    NET_PEER_IP: "net.peer.ip",
    NET_PEER_PORT: "net.peer.port",
    NET_PEER_NAME: "net.peer.name",
    NET_HOST_IP: "net.host.ip",
    NET_HOST_PORT: "net.host.port",
    NET_HOST_NAME: "net.host.name",
    NET_HOST_CONNECTION_TYPE: "net.host.connection.type",
    NET_HOST_CONNECTION_SUBTYPE: "net.host.connection.subtype",
    NET_HOST_CARRIER_NAME: "net.host.carrier.name",
    NET_HOST_CARRIER_MCC: "net.host.carrier.mcc",
    NET_HOST_CARRIER_MNC: "net.host.carrier.mnc",
    NET_HOST_CARRIER_ICC: "net.host.carrier.icc",
    PEER_SERVICE: "peer.service",
    ENDUSER_ID: "enduser.id",
    ENDUSER_ROLE: "enduser.role",
    ENDUSER_SCOPE: "enduser.scope",
    THREAD_ID: "thread.id",
    THREAD_NAME: "thread.name",
    CODE_FUNCTION: "code.function",
    CODE_NAMESPACE: "code.namespace",
    CODE_FILEPATH: "code.filepath",
    CODE_LINENO: "code.lineno",
    HTTP_METHOD: "http.method",
    HTTP_URL: "http.url",
    HTTP_TARGET: "http.target",
    HTTP_HOST: "http.host",
    HTTP_SCHEME: "http.scheme",
    HTTP_STATUS_CODE: "http.status_code",
    HTTP_FLAVOR: "http.flavor",
    HTTP_USER_AGENT: "http.user_agent",
    HTTP_REQUEST_CONTENT_LENGTH: "http.request_content_length",
    HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: "http.request_content_length_uncompressed",
    HTTP_RESPONSE_CONTENT_LENGTH: "http.response_content_length",
    HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: "http.response_content_length_uncompressed",
    HTTP_SERVER_NAME: "http.server_name",
    HTTP_ROUTE: "http.route",
    HTTP_CLIENT_IP: "http.client_ip",
    AWS_DYNAMODB_TABLE_NAMES: "aws.dynamodb.table_names",
    AWS_DYNAMODB_CONSUMED_CAPACITY: "aws.dynamodb.consumed_capacity",
    AWS_DYNAMODB_ITEM_COLLECTION_METRICS: "aws.dynamodb.item_collection_metrics",
    AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: "aws.dynamodb.provisioned_read_capacity",
    AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: "aws.dynamodb.provisioned_write_capacity",
    AWS_DYNAMODB_CONSISTENT_READ: "aws.dynamodb.consistent_read",
    AWS_DYNAMODB_PROJECTION: "aws.dynamodb.projection",
    AWS_DYNAMODB_LIMIT: "aws.dynamodb.limit",
    AWS_DYNAMODB_ATTRIBUTES_TO_GET: "aws.dynamodb.attributes_to_get",
    AWS_DYNAMODB_INDEX_NAME: "aws.dynamodb.index_name",
    AWS_DYNAMODB_SELECT: "aws.dynamodb.select",
    AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: "aws.dynamodb.global_secondary_indexes",
    AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: "aws.dynamodb.local_secondary_indexes",
    AWS_DYNAMODB_EXCLUSIVE_START_TABLE: "aws.dynamodb.exclusive_start_table",
    AWS_DYNAMODB_TABLE_COUNT: "aws.dynamodb.table_count",
    AWS_DYNAMODB_SCAN_FORWARD: "aws.dynamodb.scan_forward",
    AWS_DYNAMODB_SEGMENT: "aws.dynamodb.segment",
    AWS_DYNAMODB_TOTAL_SEGMENTS: "aws.dynamodb.total_segments",
    AWS_DYNAMODB_COUNT: "aws.dynamodb.count",
    AWS_DYNAMODB_SCANNED_COUNT: "aws.dynamodb.scanned_count",
    AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: "aws.dynamodb.attribute_definitions",
    AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: "aws.dynamodb.global_secondary_index_updates",
    MESSAGING_SYSTEM: "messaging.system",
    MESSAGING_DESTINATION: "messaging.destination",
    MESSAGING_DESTINATION_KIND: "messaging.destination_kind",
    MESSAGING_TEMP_DESTINATION: "messaging.temp_destination",
    MESSAGING_PROTOCOL: "messaging.protocol",
    MESSAGING_PROTOCOL_VERSION: "messaging.protocol_version",
    MESSAGING_URL: "messaging.url",
    MESSAGING_MESSAGE_ID: "messaging.message_id",
    MESSAGING_CONVERSATION_ID: "messaging.conversation_id",
    MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: "messaging.message_payload_size_bytes",
    MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: "messaging.message_payload_compressed_size_bytes",
    MESSAGING_OPERATION: "messaging.operation",
    MESSAGING_CONSUMER_ID: "messaging.consumer_id",
    MESSAGING_RABBITMQ_ROUTING_KEY: "messaging.rabbitmq.routing_key",
    MESSAGING_KAFKA_MESSAGE_KEY: "messaging.kafka.message_key",
    MESSAGING_KAFKA_CONSUMER_GROUP: "messaging.kafka.consumer_group",
    MESSAGING_KAFKA_CLIENT_ID: "messaging.kafka.client_id",
    MESSAGING_KAFKA_PARTITION: "messaging.kafka.partition",
    MESSAGING_KAFKA_TOMBSTONE: "messaging.kafka.tombstone",
    RPC_SYSTEM: "rpc.system",
    RPC_SERVICE: "rpc.service",
    RPC_METHOD: "rpc.method",
    RPC_GRPC_STATUS_CODE: "rpc.grpc.status_code",
    RPC_JSONRPC_VERSION: "rpc.jsonrpc.version",
    RPC_JSONRPC_REQUEST_ID: "rpc.jsonrpc.request_id",
    RPC_JSONRPC_ERROR_CODE: "rpc.jsonrpc.error_code",
    RPC_JSONRPC_ERROR_MESSAGE: "rpc.jsonrpc.error_message",
    MESSAGE_TYPE: "message.type",
    MESSAGE_ID: "message.id",
    MESSAGE_COMPRESSED_SIZE: "message.compressed_size",
    MESSAGE_UNCOMPRESSED_SIZE: "message.uncompressed_size"
   }, DbSystemValues = {
    OTHER_SQL: "other_sql",
    MSSQL: "mssql",
    MYSQL: "mysql",
    ORACLE: "oracle",
    DB2: "db2",
    POSTGRESQL: "postgresql",
    REDSHIFT: "redshift",
    HIVE: "hive",
    CLOUDSCAPE: "cloudscape",
    HSQLDB: "hsqldb",
    PROGRESS: "progress",
    MAXDB: "maxdb",
    HANADB: "hanadb",
    INGRES: "ingres",
    FIRSTSQL: "firstsql",
    EDB: "edb",
    CACHE: "cache",
    ADABAS: "adabas",
    FIREBIRD: "firebird",
    DERBY: "derby",
    FILEMAKER: "filemaker",
    INFORMIX: "informix",
    INSTANTDB: "instantdb",
    INTERBASE: "interbase",
    MARIADB: "mariadb",
    NETEZZA: "netezza",
    PERVASIVE: "pervasive",
    POINTBASE: "pointbase",
    SQLITE: "sqlite",
    SYBASE: "sybase",
    TERADATA: "teradata",
    VERTICA: "vertica",
    H2: "h2",
    COLDFUSION: "coldfusion",
    CASSANDRA: "cassandra",
    HBASE: "hbase",
    MONGODB: "mongodb",
    REDIS: "redis",
    COUCHBASE: "couchbase",
    COUCHDB: "couchdb",
    COSMOSDB: "cosmosdb",
    DYNAMODB: "dynamodb",
    NEO4J: "neo4j",
    GEODE: "geode",
    ELASTICSEARCH: "elasticsearch",
    MEMCACHED: "memcached",
    COCKROACHDB: "cockroachdb"
   }, DbCassandraConsistencyLevelValues = {
    ALL: "all",
    EACH_QUORUM: "each_quorum",
    QUORUM: "quorum",
    LOCAL_QUORUM: "local_quorum",
    ONE: "one",
    TWO: "two",
    THREE: "three",
    LOCAL_ONE: "local_one",
    ANY: "any",
    SERIAL: "serial",
    LOCAL_SERIAL: "local_serial"
   }, FaasTriggerValues = {
    DATASOURCE: "datasource",
    HTTP: "http",
    PUBSUB: "pubsub",
    TIMER: "timer",
    OTHER: "other"
   }, FaasDocumentOperationValues = {
    INSERT: "insert",
    EDIT: "edit",
    DELETE: "delete"
   }, FaasInvokedProviderValues = {
    ALIBABA_CLOUD: "alibaba_cloud",
    AWS: "aws",
    AZURE: "azure",
    GCP: "gcp"
   }, NetTransportValues = {
    IP_TCP: "ip_tcp",
    IP_UDP: "ip_udp",
    IP: "ip",
    UNIX: "unix",
    PIPE: "pipe",
    INPROC: "inproc",
    OTHER: "other"
   }, NetHostConnectionTypeValues = {
    WIFI: "wifi",
    WIRED: "wired",
    CELL: "cell",
    UNAVAILABLE: "unavailable",
    UNKNOWN: "unknown"
   }, NetHostConnectionSubtypeValues = {
    GPRS: "gprs",
    EDGE: "edge",
    UMTS: "umts",
    CDMA: "cdma",
    EVDO_0: "evdo_0",
    EVDO_A: "evdo_a",
    CDMA2000_1XRTT: "cdma2000_1xrtt",
    HSDPA: "hsdpa",
    HSUPA: "hsupa",
    HSPA: "hspa",
    IDEN: "iden",
    EVDO_B: "evdo_b",
    LTE: "lte",
    EHRPD: "ehrpd",
    HSPAP: "hspap",
    GSM: "gsm",
    TD_SCDMA: "td_scdma",
    IWLAN: "iwlan",
    NR: "nr",
    NRNSA: "nrnsa",
    LTE_CA: "lte_ca"
   }, HttpFlavorValues = {
    HTTP_1_0: "1.0",
    HTTP_1_1: "1.1",
    HTTP_2_0: "2.0",
    SPDY: "SPDY",
    QUIC: "QUIC"
   }, MessagingDestinationKindValues = {
    QUEUE: "queue",
    TOPIC: "topic"
   }, MessagingOperationValues = {
    RECEIVE: "receive",
    PROCESS: "process"
   }, RpcGrpcStatusCodeValues = {
    OK: 0,
    CANCELLED: 1,
    UNKNOWN: 2,
    INVALID_ARGUMENT: 3,
    DEADLINE_EXCEEDED: 4,
    NOT_FOUND: 5,
    ALREADY_EXISTS: 6,
    PERMISSION_DENIED: 7,
    RESOURCE_EXHAUSTED: 8,
    FAILED_PRECONDITION: 9,
    ABORTED: 10,
    OUT_OF_RANGE: 11,
    UNIMPLEMENTED: 12,
    INTERNAL: 13,
    UNAVAILABLE: 14,
    DATA_LOSS: 15,
    UNAUTHENTICATED: 16
   }, MessageTypeValues = {
    SENT: "SENT",
    RECEIVED: "RECEIVED"
   };
  },
  40725: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    }), Object.defineProperty(o, k2, desc);
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
     enumerable: !0,
     value: v
    });
   } : function(o, v) {
    o.default = v;
   }), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.oneDataSystemClientFactory = void 0;
   exports.oneDataSystemClientFactory = async (key, vscodeAPI, xhrOverride) => {
    let appInsightsCore = await (async (key, vscodeAPI, xhrOverride) => {
     const oneDs = await Promise.resolve().then((() => __importStar(__webpack_require__(67164)))), postPlugin = await Promise.resolve().then((() => __importStar(__webpack_require__(71488)))), appInsightsCore = new oneDs.AppInsightsCore, collectorChannelPlugin = new postPlugin.PostChannel, coreConfig = {
      instrumentationKey: key,
      endpointUrl: "https://mobile.events.data.microsoft.com/OneCollector/1.0",
      loggingLevelTelemetry: 0,
      loggingLevelConsole: 0,
      disableCookiesUsage: !0,
      disableDbgExt: !0,
      disableInstrumentationKeyValidation: !0,
      channels: [ [ collectorChannelPlugin ] ]
     };
     if (xhrOverride) {
      coreConfig.extensionConfig = {};
      const channelConfig = {
       alwaysUseXhrOverride: !0,
       httpXHROverride: xhrOverride
      };
      coreConfig.extensionConfig[collectorChannelPlugin.identifier] = channelConfig;
     }
     const internalTesting = vscodeAPI.workspace.getConfiguration("telemetry").get("internalTesting");
     return appInsightsCore.initialize(coreConfig, []), appInsightsCore.addTelemetryInitializer((envelope => {
      internalTesting && (envelope.ext = envelope.ext ?? {}, envelope.ext.utc = envelope.ext.utc ?? {}, 
      envelope.ext.utc.flags = 8462029);
     })), appInsightsCore;
    })(key, vscodeAPI, xhrOverride);
    const flushOneDS = async () => {
     try {
      return new Promise(((resolve, reject) => {
       appInsightsCore ? appInsightsCore.flush(!0, (completedFlush => {
        completedFlush || reject("Failed to flush app 1DS!");
       })) : resolve();
      }));
     } catch (e) {
      throw new Error("Failed to flush 1DS!\n" + e.message);
     }
    };
    return {
     logEvent: (eventName, data) => {
      try {
       appInsightsCore?.track({
        name: eventName,
        baseData: {
         name: eventName,
         properties: data?.properties,
         measurements: data?.measurements
        }
       });
      } catch (e) {
       throw new Error("Failed to log event to app insights!\n" + e.message);
      }
     },
     flush: flushOneDS,
     dispose: async () => {
      await flushOneDS();
      return new Promise((resolve => {
       appInsightsCore ? appInsightsCore.unload(!0, (() => {
        resolve(), appInsightsCore = void 0;
       })) : resolve();
      }));
     }
    };
   };
  },
  33456: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.BaseTelemetryReporter = void 0;
   exports.BaseTelemetryReporter = class {
    constructor(telemetrySender, vscodeAPI, initializationOptions) {
     this.telemetrySender = telemetrySender, this.vscodeAPI = vscodeAPI, this.userOptIn = !1, 
     this.errorOptIn = !1, this.disposables = [], this._onDidChangeTelemetryLevel = new this.vscodeAPI.EventEmitter, 
     this.onDidChangeTelemetryLevel = this._onDidChangeTelemetryLevel.event, this.telemetryLogger = this.vscodeAPI.env.createTelemetryLogger(this.telemetrySender, initializationOptions), 
     this.updateUserOptIn(), this.telemetryLogger.onDidChangeEnableStates((() => {
      this.updateUserOptIn();
     }));
    }
    updateUserOptIn() {
     this.errorOptIn = this.telemetryLogger.isErrorsEnabled, this.userOptIn = this.telemetryLogger.isUsageEnabled, 
     (this.telemetryLogger.isErrorsEnabled || this.telemetryLogger.isUsageEnabled) && this.telemetrySender.instantiateSender(), 
     this._onDidChangeTelemetryLevel.fire(this.telemetryLevel);
    }
    get telemetryLevel() {
     return this.errorOptIn && this.userOptIn ? "all" : this.errorOptIn ? "error" : "off";
    }
    internalSendTelemetryEvent(eventName, properties, measurements, dangerous) {
     dangerous ? this.telemetrySender.sendEventData(eventName, {
      properties,
      measurements
     }) : this.telemetryLogger.logUsage(eventName, {
      properties,
      measurements
     });
    }
    sendTelemetryEvent(eventName, properties, measurements) {
     this.internalSendTelemetryEvent(eventName, properties, measurements, !1);
    }
    sendRawTelemetryEvent(eventName, properties, measurements) {
     const modifiedProperties = {
      ...properties
     };
     for (const propertyKey of Object.keys(modifiedProperties ?? {})) {
      const propertyValue = modifiedProperties[propertyKey];
      "string" == typeof propertyKey && void 0 !== propertyValue && (modifiedProperties[propertyKey] = new this.vscodeAPI.TelemetryTrustedValue("string" == typeof propertyValue ? propertyValue : propertyValue.value));
     }
     this.sendTelemetryEvent(eventName, modifiedProperties, measurements);
    }
    sendDangerousTelemetryEvent(eventName, properties, measurements) {
     this.telemetrySender.instantiateSender(), this.internalSendTelemetryEvent(eventName, properties, measurements, !0);
    }
    internalSendTelemetryErrorEvent(eventName, properties, measurements, dangerous) {
     dangerous ? this.telemetrySender.sendEventData(eventName, {
      properties,
      measurements
     }) : this.telemetryLogger.logError(eventName, {
      properties,
      measurements
     });
    }
    sendTelemetryErrorEvent(eventName, properties, measurements) {
     this.internalSendTelemetryErrorEvent(eventName, properties, measurements, !1);
    }
    sendDangerousTelemetryErrorEvent(eventName, properties, measurements) {
     this.telemetrySender.instantiateSender(), this.internalSendTelemetryErrorEvent(eventName, properties, measurements, !0);
    }
    async dispose() {
     return await this.telemetrySender.dispose(), this.telemetryLogger.dispose(), Promise.all(this.disposables.map((d => d.dispose())));
    }
   };
  },
  12015: (__unused_webpack_module, exports) => {
   "use strict";
   var InstantiationStatus;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.BaseTelemetrySender = void 0, function(InstantiationStatus) {
    InstantiationStatus[InstantiationStatus.NOT_INSTANTIATED = 0] = "NOT_INSTANTIATED", 
    InstantiationStatus[InstantiationStatus.INSTANTIATING = 1] = "INSTANTIATING", InstantiationStatus[InstantiationStatus.INSTANTIATED = 2] = "INSTANTIATED";
   }(InstantiationStatus || (InstantiationStatus = {}));
   exports.BaseTelemetrySender = class {
    constructor(key, clientFactory) {
     this._instantiationStatus = InstantiationStatus.NOT_INSTANTIATED, this._eventQueue = [], 
     this._exceptionQueue = [], this._clientFactory = clientFactory, this._key = key;
    }
    sendEventData(eventName, data) {
     this._telemetryClient ? this._telemetryClient.logEvent(eventName, data) : this._instantiationStatus !== InstantiationStatus.INSTANTIATED && this._eventQueue.push({
      eventName,
      data
     });
    }
    sendErrorData(exception, data) {
     if (!this._telemetryClient) return void (this._instantiationStatus !== InstantiationStatus.INSTANTIATED && this._exceptionQueue.push({
      exception,
      data
     }));
     const errorData = {
      stack: exception.stack,
      message: exception.message,
      name: exception.name
     };
     data ? data.properties = {
      ...data.properties,
      ...errorData
     } : data = {
      properties: errorData
     }, this._telemetryClient.logEvent("unhandlederror", data);
    }
    async flush() {
     return this._telemetryClient?.flush();
    }
    async dispose() {
     await this.flush(), this._telemetryClient && (await this._telemetryClient.dispose(), 
     this._telemetryClient = void 0);
    }
    _flushQueues() {
     this._eventQueue.forEach((({eventName, data}) => this.sendEventData(eventName, data))), 
     this._eventQueue = [], this._exceptionQueue.forEach((({exception, data}) => this.sendErrorData(exception, data))), 
     this._exceptionQueue = [];
    }
    instantiateSender() {
     this._instantiationStatus === InstantiationStatus.NOT_INSTANTIATED && (this._instantiationStatus = InstantiationStatus.INSTANTIATING, 
     this._clientFactory(this._key).then((client => {
      this._telemetryClient = client, this._instantiationStatus = InstantiationStatus.INSTANTIATED, 
      this._flushQueues();
     })).catch((err => {
      console.error(err), this._instantiationStatus = InstantiationStatus.INSTANTIATED;
     })));
    }
   };
  },
  95888: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.TelemetryUtil = void 0;
   class TelemetryUtil {
    static applyReplacements(data, replacementOptions) {
     for (const key of Object.keys(data)) for (const option of replacementOptions) option.lookup.test(key) && (void 0 !== option.replacementString ? data[key] = option.replacementString : delete data[key]);
    }
    static shouldUseOneDataSystemSDK(key) {
     return 74 === key.length && "-" === key[32] && "-" === key[41] && "-" === key[46] && "-" === key[51] && "-" === key[56] && "-" === key[69];
    }
    static getAdditionalCommonProperties(osShim) {
     return {
      "common.os": osShim.platform,
      "common.nodeArch": osShim.architecture,
      "common.platformversion": (osShim.release || "").replace(/^(\d+)(\.\d+)?(\.\d+)?(.*)/, "$1$2$3"),
      "common.telemetryclientversion": "0.8.4"
     };
    }
    static getInstance() {
     return TelemetryUtil._instance || (TelemetryUtil._instance = new TelemetryUtil), 
     TelemetryUtil._instance;
    }
   }
   exports.TelemetryUtil = TelemetryUtil;
  },
  92291: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    }), Object.defineProperty(o, k2, desc);
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
     enumerable: !0,
     value: v
    });
   } : function(o, v) {
    o.default = v;
   }), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   const os = __importStar(__webpack_require__(22037)), vscode = __importStar(__webpack_require__(66828)), https = __importStar(__webpack_require__(95687)), baseTelemetryReporter_1 = __webpack_require__(33456), baseTelemetrySender_1 = __webpack_require__(12015), util_1 = __webpack_require__(95888), _1dsClientFactory_1 = __webpack_require__(40725), appInsightsClientFactory = async (key, replacementOptions) => {
    let appInsightsClient;
    try {
     process.env.APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL = "1";
     const appInsights = await Promise.resolve().then((() => __importStar(__webpack_require__(9574))));
     appInsights.defaultClient ? (appInsightsClient = new appInsights.TelemetryClient(key), 
     appInsightsClient.channel.setUseDiskRetryCaching(!0)) : (appInsights.setup(key).setAutoCollectRequests(!1).setAutoCollectPerformance(!1).setAutoCollectExceptions(!1).setAutoCollectDependencies(!1).setAutoDependencyCorrelation(!1).setAutoCollectConsole(!1).setAutoCollectHeartbeat(!1).setAutoCollectIncomingRequestAzureFunctions(!1).setUseDiskRetryCaching(!0).start(), 
     appInsightsClient = appInsights.defaultClient), vscode && vscode.env && (appInsightsClient.context.tags[appInsightsClient.context.keys.userId] = vscode.env.machineId, 
     appInsightsClient.context.tags[appInsightsClient.context.keys.sessionId] = vscode.env.sessionId, 
     appInsightsClient.context.tags[appInsightsClient.context.keys.cloudRole] = vscode.env.appName, 
     appInsightsClient.context.tags[appInsightsClient.context.keys.cloudRoleInstance] = vscode.env.appName);
    } catch (e) {
     return Promise.reject("Failed to initialize app insights!\n" + e.message);
    }
    replacementOptions?.length && function(appInsightsClient, replacementOptions) {
     appInsightsClient.addTelemetryProcessor((event => (Array.isArray(event.tags) ? event.tags.forEach((tag => util_1.TelemetryUtil.applyReplacements(tag, replacementOptions))) : event.tags && util_1.TelemetryUtil.applyReplacements(event.tags, replacementOptions), 
     event.data.baseData && util_1.TelemetryUtil.applyReplacements(event.data.baseData, replacementOptions), 
     !0)));
    }(appInsightsClient, replacementOptions);
    return {
     logEvent: (eventName, data) => {
      try {
       appInsightsClient?.trackEvent({
        name: eventName,
        properties: data?.properties,
        measurements: data?.measurements
       });
      } catch (e) {
       throw new Error("Failed to log event to app insights!\n" + e.message);
      }
     },
     flush: async () => {
      try {
       appInsightsClient?.flush();
      } catch (e) {
       throw new Error("Failed to flush app insights!\n" + e.message);
      }
     },
     dispose: async () => {
      appInsightsClient?.flush(), appInsightsClient = void 0;
     }
    };
   };
   class TelemetryReporter extends baseTelemetryReporter_1.BaseTelemetryReporter {
    constructor(key, replacementOptions) {
     let clientFactory = key => appInsightsClientFactory(key, replacementOptions);
     util_1.TelemetryUtil.shouldUseOneDataSystemSDK(key) && (clientFactory = key => (0, 
     _1dsClientFactory_1.oneDataSystemClientFactory)(key, vscode, {
      sendPOST: (payload, oncomplete) => {
       const options = {
        method: "POST",
        headers: {
         ...payload.headers,
         "Content-Type": "application/json",
         "Content-Length": Buffer.byteLength(payload.data)
        }
       };
       try {
        const req = https.request(payload.urlString, options, (res => {
         res.on("data", (function(responseData) {
          oncomplete(res.statusCode ?? 200, res.headers, responseData.toString());
         })), res.on("error", (function() {
          oncomplete(0, {});
         }));
        }));
        req.write(payload.data, (err => {
         err && oncomplete(0, {});
        })), req.end();
       } catch {
        oncomplete(0, {});
       }
      }
     }));
     const osShim = {
      release: os.release(),
      platform: os.platform(),
      architecture: os.arch()
     }, sender = new baseTelemetrySender_1.BaseTelemetrySender(key, clientFactory);
     if (key && 0 === key.indexOf("AIF-")) throw new Error("AIF keys are no longer supported. Please switch to 1DS keys for 1st party extensions");
     super(sender, vscode, {
      additionalCommonProperties: util_1.TelemetryUtil.getAdditionalCommonProperties(osShim)
     });
    }
   }
   exports.default = TelemetryReporter;
  },
  88054: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
     default: mod
    };
   };
   const events_1 = __webpack_require__(82361), debug_1 = __importDefault(__webpack_require__(15158)), promisify_1 = __importDefault(__webpack_require__(96304)), debug = debug_1.default("agent-base");
   function isSecureEndpoint() {
    const {stack} = new Error;
    return "string" == typeof stack && stack.split("\n").some((l => -1 !== l.indexOf("(https.js:") || -1 !== l.indexOf("node:https:")));
   }
   function createAgent(callback, opts) {
    return new createAgent.Agent(callback, opts);
   }
   !function(createAgent) {
    class Agent extends events_1.EventEmitter {
     constructor(callback, _opts) {
      super();
      let opts = _opts;
      "function" == typeof callback ? this.callback = callback : callback && (opts = callback), 
      this.timeout = null, opts && "number" == typeof opts.timeout && (this.timeout = opts.timeout), 
      this.maxFreeSockets = 1, this.maxSockets = 1, this.maxTotalSockets = 1 / 0, this.sockets = {}, 
      this.freeSockets = {}, this.requests = {}, this.options = {};
     }
     get defaultPort() {
      return "number" == typeof this.explicitDefaultPort ? this.explicitDefaultPort : isSecureEndpoint() ? 443 : 80;
     }
     set defaultPort(v) {
      this.explicitDefaultPort = v;
     }
     get protocol() {
      return "string" == typeof this.explicitProtocol ? this.explicitProtocol : isSecureEndpoint() ? "https:" : "http:";
     }
     set protocol(v) {
      this.explicitProtocol = v;
     }
     callback(req, opts, fn) {
      throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
     }
     addRequest(req, _opts) {
      const opts = Object.assign({}, _opts);
      "boolean" != typeof opts.secureEndpoint && (opts.secureEndpoint = isSecureEndpoint()), 
      null == opts.host && (opts.host = "localhost"), null == opts.port && (opts.port = opts.secureEndpoint ? 443 : 80), 
      null == opts.protocol && (opts.protocol = opts.secureEndpoint ? "https:" : "http:"), 
      opts.host && opts.path && delete opts.path, delete opts.agent, delete opts.hostname, 
      delete opts._defaultAgent, delete opts.defaultPort, delete opts.createConnection, 
      req._last = !0, req.shouldKeepAlive = !1;
      let timedOut = !1, timeoutId = null;
      const timeoutMs = opts.timeout || this.timeout, onerror = err => {
       req._hadError || (req.emit("error", err), req._hadError = !0);
      }, ontimeout = () => {
       timeoutId = null, timedOut = !0;
       const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
       err.code = "ETIMEOUT", onerror(err);
      }, callbackError = err => {
       timedOut || (null !== timeoutId && (clearTimeout(timeoutId), timeoutId = null), 
       onerror(err));
      }, onsocket = socket => {
       if (timedOut) return;
       if (null != timeoutId && (clearTimeout(timeoutId), timeoutId = null), v = socket, 
       Boolean(v) && "function" == typeof v.addRequest) return debug("Callback returned another Agent instance %o", socket.constructor.name), 
       void socket.addRequest(req, opts);
       var v;
       if (socket) return socket.once("free", (() => {
        this.freeSocket(socket, opts);
       })), void req.onSocket(socket);
       const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
       onerror(err);
      };
      if ("function" == typeof this.callback) {
       this.promisifiedCallback || (this.callback.length >= 3 ? (debug("Converting legacy callback function to promise"), 
       this.promisifiedCallback = promisify_1.default(this.callback)) : this.promisifiedCallback = this.callback), 
       "number" == typeof timeoutMs && timeoutMs > 0 && (timeoutId = setTimeout(ontimeout, timeoutMs)), 
       "port" in opts && "number" != typeof opts.port && (opts.port = Number(opts.port));
       try {
        debug("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`), 
        Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
       } catch (err) {
        Promise.reject(err).catch(callbackError);
       }
      } else onerror(new Error("`callback` is not defined"));
     }
     freeSocket(socket, opts) {
      debug("Freeing socket %o %o", socket.constructor.name, opts), socket.destroy();
     }
     destroy() {
      debug("Destroying agent %o", this.constructor.name);
     }
    }
    createAgent.Agent = Agent, createAgent.prototype = createAgent.Agent.prototype;
   }(createAgent || (createAgent = {})), module.exports = createAgent;
  },
  96304: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.default = function(fn) {
    return function(req, opts) {
     return new Promise(((resolve, reject) => {
      fn.call(this, req, opts, ((err, rtn) => {
       err ? reject(err) : resolve(rtn);
      }));
     }));
    };
   };
  },
  20699: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __assign = this && this.__assign || function() {
    return __assign = Object.assign || function(t) {
     for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
     return t;
    }, __assign.apply(this, arguments);
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.AsyncScopeManager = exports.OpenTelemetryScopeManagerWrapper = void 0;
   var CorrelationContextManager_1 = __webpack_require__(70894), events_1 = __webpack_require__(82361), OpenTelemetryScopeManagerWrapper = function() {
    function OpenTelemetryScopeManagerWrapper() {}
    return OpenTelemetryScopeManagerWrapper.prototype.active = function() {
     var _this = this, context = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
     return __assign(__assign({}, context), {
      getValue: function(key) {
       return _this._activeSymbol ? key === _this._activeSymbol && context : (_this._activeSymbol = key, 
       context);
      },
      setValue: function() {}
     });
    }, OpenTelemetryScopeManagerWrapper.prototype.with = function(span, fn) {
     var parentSpanId = span.parentSpanId, name = span.name, correlationContext = OpenTelemetryScopeManagerWrapper._spanToContext(span, parentSpanId, name);
     return CorrelationContextManager_1.CorrelationContextManager.runWithContext(correlationContext, fn)();
    }, OpenTelemetryScopeManagerWrapper.prototype.bind = function(target) {
     return "function" == typeof target ? CorrelationContextManager_1.CorrelationContextManager.wrapCallback(target) : (target instanceof events_1.EventEmitter && CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(target), 
     target);
    }, OpenTelemetryScopeManagerWrapper.prototype.enable = function() {
     return CorrelationContextManager_1.CorrelationContextManager.enable(), this;
    }, OpenTelemetryScopeManagerWrapper.prototype.disable = function() {
     return CorrelationContextManager_1.CorrelationContextManager.disable(), this;
    }, OpenTelemetryScopeManagerWrapper._spanToContext = function(span, parentSpanId, name) {
     var spanContext = span.spanContext ? span.spanContext() : span.context(), context = __assign(__assign({}, span.spanContext()), {
      traceFlags: span.spanContext().traceFlags
     }), parentId = parentSpanId ? "|" + spanContext.traceId + "." + parentSpanId + "." : spanContext.traceId, aiContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
     return aiContext && (context.traceId = aiContext.operation.id, parentSpanId || (parentId = aiContext.operation.parentId)), 
     CorrelationContextManager_1.CorrelationContextManager.spanToContextObject(context, parentId, name);
    }, OpenTelemetryScopeManagerWrapper;
   }();
   exports.OpenTelemetryScopeManagerWrapper = OpenTelemetryScopeManagerWrapper, exports.AsyncScopeManager = new OpenTelemetryScopeManagerWrapper;
  },
  81162: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }, __generator = this && this.__generator || function(thisArg, body) {
    var f, y, t, g, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    };
    return g = {
     next: verb(0),
     throw: verb(1),
     return: verb(2)
    }, "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;_; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.AzureFunctionsHook = void 0;
   var Logging = __webpack_require__(95282), CorrelationContextManager_1 = __webpack_require__(70894), AzureFunctionsHook = function() {
    function AzureFunctionsHook(client) {
     this._client = client, this._autoGenerateIncomingRequests = !1;
     try {
      this._functionsCoreModule = __webpack_require__(19605);
      var funcProgModel = this._functionsCoreModule.getProgrammingModel();
      "@azure/functions" === funcProgModel.name && funcProgModel.version.startsWith("3.") ? (this._addPreInvocationHook(), 
      this._addPostInvocationHook()) : Logging.warn('AzureFunctionsHook does not support model "' + funcProgModel.name + '" version "' + funcProgModel.version + '"');
     } catch (error) {
      Logging.info("AzureFunctionsHook failed to load, not running in Azure Functions");
     }
    }
    return AzureFunctionsHook.prototype.enable = function(isEnabled) {
     this._autoGenerateIncomingRequests = isEnabled;
    }, AzureFunctionsHook.prototype.dispose = function() {
     this.enable(!1), this._removeInvocationHooks(), this._functionsCoreModule = void 0;
    }, AzureFunctionsHook.prototype._addPreInvocationHook = function() {
     var _this = this;
     this._preInvocationHook || (this._preInvocationHook = this._functionsCoreModule.registerHook("preInvocation", (function(preInvocationContext) {
      return __awaiter(_this, void 0, void 0, (function() {
       var ctx, extractedContext;
       return __generator(this, (function(_a) {
        ctx = preInvocationContext.invocationContext;
        try {
         (extractedContext = CorrelationContextManager_1.CorrelationContextManager.startOperation(ctx)) && (extractedContext.customProperties.setProperty("InvocationId", ctx.invocationId), 
         ctx.traceContext.attributes && (extractedContext.customProperties.setProperty("ProcessId", ctx.traceContext.attributes.ProcessId), 
         extractedContext.customProperties.setProperty("LogLevel", ctx.traceContext.attributes.LogLevel), 
         extractedContext.customProperties.setProperty("Category", ctx.traceContext.attributes.Category), 
         extractedContext.customProperties.setProperty("HostInstanceId", ctx.traceContext.attributes.HostInstanceId), 
         extractedContext.customProperties.setProperty("AzFuncLiveLogsSessionId", ctx.traceContext.attributes["#AzFuncLiveLogsSessionId"])), 
         preInvocationContext.functionCallback = CorrelationContextManager_1.CorrelationContextManager.wrapCallback(preInvocationContext.functionCallback, extractedContext), 
         this._isHttpTrigger(ctx) && this._autoGenerateIncomingRequests && (preInvocationContext.hookData.appInsightsExtractedContext = extractedContext, 
         preInvocationContext.hookData.appInsightsStartTime = Date.now()));
        } catch (err) {
         return Logging.warn("Failed to propagate context in Azure Functions", err), [ 2 ];
        }
        return [ 2 ];
       }));
      }));
     })));
    }, AzureFunctionsHook.prototype._addPostInvocationHook = function() {
     var _this = this;
     this._postInvocationHook || (this._postInvocationHook = this._functionsCoreModule.registerHook("postInvocation", (function(postInvocationContext) {
      return __awaiter(_this, void 0, void 0, (function() {
       var ctx, request_1, startTime_1, response_1, extractedContext_1, _this = this;
       return __generator(this, (function(_a) {
        try {
         this._autoGenerateIncomingRequests && (ctx = postInvocationContext.invocationContext, 
         this._isHttpTrigger(ctx) && (request_1 = postInvocationContext.inputs[0]) && (startTime_1 = postInvocationContext.hookData.appInsightsStartTime || Date.now(), 
         response_1 = this._getAzureFunctionResponse(postInvocationContext, ctx), (extractedContext_1 = postInvocationContext.hookData.appInsightsExtractedContext) ? CorrelationContextManager_1.CorrelationContextManager.runWithContext(extractedContext_1, (function() {
          _this._createIncomingRequestTelemetry(request_1, response_1, startTime_1, extractedContext_1.operation.parentId);
         })) : this._createIncomingRequestTelemetry(request_1, response_1, startTime_1, null)));
        } catch (err) {
         Logging.warn("Error creating automatic incoming request in Azure Functions", err);
        }
        return [ 2 ];
       }));
      }));
     })));
    }, AzureFunctionsHook.prototype._createIncomingRequestTelemetry = function(request, response, startTime, parentId) {
     var statusCode = 200;
     if (response) for (var _i = 0, _a = [ response.statusCode, response.status ]; _i < _a.length; _i++) {
      var value = _a[_i];
      if ("number" == typeof value && Number.isInteger(value)) {
       statusCode = value;
       break;
      }
      if ("string" == typeof value) {
       var parsedVal = parseInt(value);
       if (!isNaN(parsedVal)) {
        statusCode = parsedVal;
        break;
       }
      }
     } else statusCode = void 0;
     this._client.trackRequest({
      name: request.method + " " + request.url,
      resultCode: statusCode,
      success: "number" == typeof statusCode ? 0 < statusCode && statusCode < 400 : void 0,
      url: request.url,
      time: new Date(startTime),
      duration: Date.now() - startTime,
      id: parentId
     }), this._client.flush();
    }, AzureFunctionsHook.prototype._getAzureFunctionResponse = function(postInvocationContext, ctx) {
     var httpOutputBinding = ctx.bindingDefinitions.find((function(b) {
      return "out" === b.direction && "http" === b.type.toLowerCase();
     }));
     return "$return" === (null == httpOutputBinding ? void 0 : httpOutputBinding.name) ? postInvocationContext.result : httpOutputBinding && ctx.bindings && void 0 !== ctx.bindings[httpOutputBinding.name] ? ctx.bindings[httpOutputBinding.name] : ctx.res;
    }, AzureFunctionsHook.prototype._isHttpTrigger = function(ctx) {
     return ctx.bindingDefinitions.find((function(b) {
      var _a;
      return "httptrigger" === (null === (_a = b.type) || void 0 === _a ? void 0 : _a.toLowerCase());
     }));
    }, AzureFunctionsHook.prototype._removeInvocationHooks = function() {
     this._preInvocationHook && (this._preInvocationHook.dispose(), this._preInvocationHook = void 0), 
     this._postInvocationHook && (this._postInvocationHook.dispose(), this._postInvocationHook = void 0);
    }, AzureFunctionsHook;
   }();
   exports.AzureFunctionsHook = AzureFunctionsHook;
  },
  66281: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var DiagChannel = __webpack_require__(87396), AutoCollectConsole = function() {
    function AutoCollectConsole(client) {
     if (AutoCollectConsole.INSTANCE) throw new Error("Console logging adapter tracking should be configured from the applicationInsights object");
     this._client = client, AutoCollectConsole.INSTANCE = this;
    }
    return AutoCollectConsole.prototype.enable = function(isEnabled, collectConsoleLog) {
     DiagChannel.IsInitialized && (__webpack_require__(14309).wp(isEnabled && collectConsoleLog, this._client), 
     __webpack_require__(35823).wp(isEnabled, this._client), __webpack_require__(30454).wp(isEnabled, this._client));
    }, AutoCollectConsole.prototype.isInitialized = function() {
     return this._isInitialized;
    }, AutoCollectConsole.prototype.dispose = function() {
     AutoCollectConsole.INSTANCE = null, this.enable(!1, !1);
    }, AutoCollectConsole._methodNames = [ "debug", "info", "log", "warn", "error" ], 
    AutoCollectConsole;
   }();
   module.exports = AutoCollectConsole;
  },
  70894: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.CorrelationContextManager = void 0;
   var Logging = __webpack_require__(95282), DiagChannel = __webpack_require__(87396), Traceparent = __webpack_require__(58090), Tracestate = __webpack_require__(10420), HttpRequestParser = __webpack_require__(86694), Util = __webpack_require__(25740), CorrelationContextManager = function() {
    function CorrelationContextManager() {}
    return CorrelationContextManager.getCurrentContext = function() {
     if (!CorrelationContextManager.enabled) return null;
     var context = CorrelationContextManager.session.get(CorrelationContextManager.CONTEXT_NAME);
     return void 0 === context ? null : context;
    }, CorrelationContextManager.generateContextObject = function(operationId, parentId, operationName, correlationContextHeader, traceparent, tracestate) {
     return parentId = parentId || operationId, this.enabled ? {
      operation: {
       name: operationName,
       id: operationId,
       parentId,
       traceparent,
       tracestate
      },
      customProperties: new CustomPropertiesImpl(correlationContextHeader)
     } : null;
    }, CorrelationContextManager.spanToContextObject = function(spanContext, parentId, name) {
     var traceContext = new Traceparent;
     return traceContext.traceId = spanContext.traceId, traceContext.spanId = spanContext.spanId, 
     traceContext.traceFlag = Traceparent.formatOpenTelemetryTraceFlags(spanContext.traceFlags) || Traceparent.DEFAULT_TRACE_FLAG, 
     traceContext.parentId = parentId, CorrelationContextManager.generateContextObject(traceContext.traceId, traceContext.parentId, name, null, traceContext);
    }, CorrelationContextManager.runWithContext = function(context, fn) {
     var _a;
     if (CorrelationContextManager.enabled) try {
      return CorrelationContextManager.session.bind(fn, ((_a = {})[CorrelationContextManager.CONTEXT_NAME] = context, 
      _a))();
     } catch (error) {
      Logging.warn("Error binding to session context", Util.dumpObj(error));
     }
     return fn();
    }, CorrelationContextManager.wrapEmitter = function(emitter) {
     if (CorrelationContextManager.enabled) try {
      CorrelationContextManager.session.bindEmitter(emitter);
     } catch (error) {
      Logging.warn("Error binding to session context", Util.dumpObj(error));
     }
    }, CorrelationContextManager.wrapCallback = function(fn, context) {
     var _a;
     if (CorrelationContextManager.enabled) try {
      return CorrelationContextManager.session.bind(fn, context ? ((_a = {})[CorrelationContextManager.CONTEXT_NAME] = context, 
      _a) : void 0);
     } catch (error) {
      Logging.warn("Error binding to session context", Util.dumpObj(error));
     }
     return fn;
    }, CorrelationContextManager.enable = function(forceClsHooked) {
     this.enabled || (this.isNodeVersionCompatible() ? (CorrelationContextManager.hasEverEnabled || (this.forceClsHooked = forceClsHooked, 
     this.hasEverEnabled = !0, void 0 === this.cls && (!0 === CorrelationContextManager.forceClsHooked || void 0 === CorrelationContextManager.forceClsHooked && CorrelationContextManager.shouldUseClsHooked() ? this.cls = __webpack_require__(39562) : this.cls = __webpack_require__(13057)), 
     CorrelationContextManager.session = this.cls.createNamespace("AI-CLS-Session"), 
     DiagChannel.registerContextPreservation((function(cb) {
      try {
       return CorrelationContextManager.session.bind(cb);
      } catch (error) {
       Logging.warn("Error binding to session context", Util.dumpObj(error));
      }
     }))), this.enabled = !0) : this.enabled = !1);
    }, CorrelationContextManager.startOperation = function(input, request) {
     var traceContext = input && input.traceContext || null, span = input && input.spanContext ? input : null, spanContext = input && input.traceId ? input : null, headers = input && input.headers;
     if (span) return this.spanToContextObject(span.spanContext(), span.parentSpanId, span.name);
     if (spanContext) return this.spanToContextObject(spanContext, "|" + spanContext.traceId + "." + spanContext.spanId + ".", "string" == typeof request ? request : "");
     var operationName = "string" == typeof request ? request : "";
     if (traceContext) {
      var traceparent = null, tracestate = null;
      if (operationName = traceContext.attributes.OperationName || operationName, request) {
       var azureFnRequest = request;
       azureFnRequest.headers && (azureFnRequest.headers.traceparent ? traceparent = new Traceparent(azureFnRequest.headers.traceparent) : azureFnRequest.headers["request-id"] && (traceparent = new Traceparent(null, azureFnRequest.headers["request-id"])), 
       azureFnRequest.headers.tracestate && (tracestate = new Tracestate(azureFnRequest.headers.tracestate)));
      }
      traceparent || (traceparent = new Traceparent(traceContext.traceparent)), tracestate || (tracestate = new Tracestate(traceContext.tracestate));
      var correlationContextHeader = void 0;
      if ("object" == typeof request) correlationContextHeader = (parser = new HttpRequestParser(request)).getCorrelationContextHeader(), 
      operationName = parser.getOperationName({});
      return CorrelationContextManager.generateContextObject(traceparent.traceId, traceparent.parentId, operationName, correlationContextHeader, traceparent, tracestate);
     }
     if (headers) {
      traceparent = new Traceparent(headers.traceparent ? headers.traceparent.toString() : null), 
      tracestate = new Tracestate(headers.tracestate ? headers.tracestate.toString() : null);
      var parser = new HttpRequestParser(input);
      return CorrelationContextManager.generateContextObject(traceparent.traceId, traceparent.parentId, parser.getOperationName({}), parser.getCorrelationContextHeader(), traceparent, tracestate);
     }
     return Logging.warn("startOperation was called with invalid arguments", arguments), 
     null;
    }, CorrelationContextManager.disable = function() {
     this.enabled = !1;
    }, CorrelationContextManager.reset = function() {
     CorrelationContextManager.hasEverEnabled && (CorrelationContextManager.session = null, 
     CorrelationContextManager.session = this.cls.createNamespace("AI-CLS-Session"));
    }, CorrelationContextManager.isNodeVersionCompatible = function() {
     var nodeVer = process.versions.node.split(".");
     return parseInt(nodeVer[0]) > 3 || parseInt(nodeVer[0]) > 2 && parseInt(nodeVer[1]) > 2;
    }, CorrelationContextManager.shouldUseClsHooked = function() {
     var nodeVer = process.versions.node.split(".");
     return parseInt(nodeVer[0]) > 8 || parseInt(nodeVer[0]) >= 8 && parseInt(nodeVer[1]) >= 2;
    }, CorrelationContextManager.canUseClsHooked = function() {
     var nodeVer = process.versions.node.split("."), greater800 = parseInt(nodeVer[0]) > 8 || parseInt(nodeVer[0]) >= 8 && parseInt(nodeVer[1]) >= 0, less820 = parseInt(nodeVer[0]) < 8 || parseInt(nodeVer[0]) <= 8 && parseInt(nodeVer[1]) < 2, greater470 = parseInt(nodeVer[0]) > 4 || parseInt(nodeVer[0]) >= 4 && parseInt(nodeVer[1]) >= 7;
     return !(greater800 && less820) && greater470;
    }, CorrelationContextManager.enabled = !1, CorrelationContextManager.hasEverEnabled = !1, 
    CorrelationContextManager.forceClsHooked = void 0, CorrelationContextManager.CONTEXT_NAME = "ApplicationInsights-Context", 
    CorrelationContextManager;
   }();
   exports.CorrelationContextManager = CorrelationContextManager;
   var CustomPropertiesImpl = function() {
    function CustomPropertiesImpl(header) {
     this.props = [], this.addHeaderData(header);
    }
    return CustomPropertiesImpl.prototype.addHeaderData = function(header) {
     var keyvals = header ? header.split(", ") : [];
     this.props = keyvals.map((function(keyval) {
      var parts = keyval.split("=");
      return {
       key: parts[0],
       value: parts[1]
      };
     })).concat(this.props);
    }, CustomPropertiesImpl.prototype.serializeToHeader = function() {
     return this.props.map((function(keyval) {
      return keyval.key + "=" + keyval.value;
     })).join(", ");
    }, CustomPropertiesImpl.prototype.getProperty = function(prop) {
     for (var i = 0; i < this.props.length; ++i) {
      var keyval = this.props[i];
      if (keyval.key === prop) return keyval.value;
     }
    }, CustomPropertiesImpl.prototype.setProperty = function(prop, val) {
     if (CustomPropertiesImpl.bannedCharacters.test(prop) || CustomPropertiesImpl.bannedCharacters.test(val)) Logging.warn("Correlation context property keys and values must not contain ',' or '='. setProperty was called with key: " + prop + " and value: " + val); else {
      for (var i = 0; i < this.props.length; ++i) {
       var keyval = this.props[i];
       if (keyval.key === prop) return void (keyval.value = val);
      }
      this.props.push({
       key: prop,
       value: val
      });
     }
    }, CustomPropertiesImpl.bannedCharacters = /[,=]/, CustomPropertiesImpl;
   }();
  },
  6639: module => {
   "use strict";
   var AutoCollectExceptions = function() {
    function AutoCollectExceptions(client) {
     if (AutoCollectExceptions.INSTANCE) throw new Error("Exception tracking should be configured from the applicationInsights object");
     AutoCollectExceptions.INSTANCE = this, this._client = client;
     var nodeVer = process.versions.node.split(".");
     AutoCollectExceptions._canUseUncaughtExceptionMonitor = parseInt(nodeVer[0]) > 13 || 13 === parseInt(nodeVer[0]) && parseInt(nodeVer[1]) >= 7;
    }
    return AutoCollectExceptions.prototype.isInitialized = function() {
     return this._isInitialized;
    }, AutoCollectExceptions.prototype.enable = function(isEnabled) {
     var _this = this;
     if (isEnabled) {
      if (this._isInitialized = !0, !this._exceptionListenerHandle) {
       var handle = function(reThrow, name, error) {
        void 0 === error && (error = new Error(AutoCollectExceptions._FALLBACK_ERROR_MESSAGE));
        var exceptionTelemetry = {
         exception: error,
         contextObjects: {}
        };
        exceptionTelemetry.contextObjects.Error = error, _this._client.trackException(exceptionTelemetry), 
        _this._client.flush({
         isAppCrashing: !0
        }), reThrow && name && 1 === process.listeners(name).length && (console.error(error), 
        process.exit(1));
       };
       AutoCollectExceptions._canUseUncaughtExceptionMonitor ? (this._exceptionListenerHandle = handle.bind(this, !1, void 0), 
       process.on(AutoCollectExceptions.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME, this._exceptionListenerHandle)) : (this._exceptionListenerHandle = handle.bind(this, !0, AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME), 
       this._rejectionListenerHandle = handle.bind(this, !1, void 0), process.on(AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle), 
       process.on(AutoCollectExceptions.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle));
      }
     } else this._exceptionListenerHandle && (AutoCollectExceptions._canUseUncaughtExceptionMonitor ? process.removeListener(AutoCollectExceptions.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME, this._exceptionListenerHandle) : (process.removeListener(AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle), 
     process.removeListener(AutoCollectExceptions.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle)), 
     this._exceptionListenerHandle = void 0, this._rejectionListenerHandle = void 0, 
     delete this._exceptionListenerHandle, delete this._rejectionListenerHandle);
    }, AutoCollectExceptions.prototype.dispose = function() {
     AutoCollectExceptions.INSTANCE = null, this.enable(!1), this._isInitialized = !1;
    }, AutoCollectExceptions.INSTANCE = null, AutoCollectExceptions.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME = "uncaughtExceptionMonitor", 
    AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME = "uncaughtException", AutoCollectExceptions.UNHANDLED_REJECTION_HANDLER_NAME = "unhandledRejection", 
    AutoCollectExceptions._RETHROW_EXIT_MESSAGE = "Application Insights Rethrow Exception Handler", 
    AutoCollectExceptions._FALLBACK_ERROR_MESSAGE = "A promise was rejected without providing an error. Application Insights generated this error stack for you.", 
    AutoCollectExceptions._canUseUncaughtExceptionMonitor = !1, AutoCollectExceptions;
   }();
   module.exports = AutoCollectExceptions;
  },
  38975: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var crypto = __webpack_require__(6113), os = __webpack_require__(22037), Constants = __webpack_require__(63580), Context = __webpack_require__(54470), HeartBeat = function() {
    function HeartBeat(client) {
     this._collectionInterval = 9e5, HeartBeat.INSTANCE || (HeartBeat.INSTANCE = this), 
     this._isInitialized = !1, this._client = client;
    }
    return HeartBeat.prototype.enable = function(isEnabled) {
     var _this = this;
     this._isEnabled = isEnabled, this._isEnabled && !this._isInitialized && (this._isInitialized = !0), 
     isEnabled ? this._handle || (this._handle = setInterval((function() {
      return _this.trackHeartBeat(_this._client.config, (function() {}));
     }), this._collectionInterval), this._handle.unref()) : this._handle && (clearInterval(this._handle), 
     this._handle = null);
    }, HeartBeat.prototype.isInitialized = function() {
     return this._isInitialized;
    }, HeartBeat.isEnabled = function() {
     return HeartBeat.INSTANCE && HeartBeat.INSTANCE._isEnabled;
    }, HeartBeat.prototype.trackHeartBeat = function(config, callback) {
     var properties = {}, sdkVersion = Context.sdkVersion;
     properties.sdkVersion = sdkVersion, properties.osType = os.type(), properties.osVersion = os.release(), 
     this._uniqueProcessId || (this._uniqueProcessId = crypto.randomBytes(16).toString("hex")), 
     properties.processSessionId = this._uniqueProcessId, process.env.WEBSITE_SITE_NAME && (properties.appSrv_SiteName = process.env.WEBSITE_SITE_NAME), 
     process.env.WEBSITE_HOME_STAMPNAME && (properties.appSrv_wsStamp = process.env.WEBSITE_HOME_STAMPNAME), 
     process.env.WEBSITE_HOSTNAME && (properties.appSrv_wsHost = process.env.WEBSITE_HOSTNAME), 
     process.env.WEBSITE_OWNER_NAME && (properties.appSrv_wsOwner = process.env.WEBSITE_OWNER_NAME), 
     process.env.WEBSITE_RESOURCE_GROUP && (properties.appSrv_ResourceGroup = process.env.WEBSITE_RESOURCE_GROUP), 
     process.env.WEBSITE_SLOT_NAME && (properties.appSrv_SlotName = process.env.WEBSITE_SLOT_NAME), 
     this._client.trackMetric({
      name: Constants.HeartBeatMetricName,
      value: 0,
      properties
     }), callback();
    }, HeartBeat.prototype.dispose = function() {
     HeartBeat.INSTANCE = null, this.enable(!1), this._isInitialized = !1;
    }, HeartBeat;
   }();
   module.exports = HeartBeat;
  },
  88723: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var __spreadArrays = this && this.__spreadArrays || function() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    var r = Array(s), k = 0;
    for (i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, 
    k++) r[k] = a[j];
    return r;
   }, http = __webpack_require__(13685), https = __webpack_require__(95687), Logging = __webpack_require__(95282), Util = __webpack_require__(25740), RequestResponseHeaders = __webpack_require__(59036), HttpDependencyParser = __webpack_require__(48339), CorrelationContextManager_1 = __webpack_require__(70894), Traceparent = __webpack_require__(58090), DiagChannel = __webpack_require__(87396), CorrelationIdManager = __webpack_require__(29962), AutoCollectHttpDependencies = function() {
    function AutoCollectHttpDependencies(client) {
     if (AutoCollectHttpDependencies.INSTANCE) throw new Error("Client request tracking should be configured from the applicationInsights object");
     AutoCollectHttpDependencies.INSTANCE = this, this._client = client;
    }
    return AutoCollectHttpDependencies.prototype.enable = function(isEnabled) {
     this._isEnabled = isEnabled, this._isEnabled && !this._isInitialized && this._initialize(), 
     DiagChannel.IsInitialized && (__webpack_require__(89879).wp(isEnabled, this._client), 
     __webpack_require__(67886).wp(isEnabled, this._client), __webpack_require__(34777).wp(isEnabled, this._client), 
     __webpack_require__(85071).wp(isEnabled, this._client), __webpack_require__(31227).wp(isEnabled, this._client));
    }, AutoCollectHttpDependencies.prototype.isInitialized = function() {
     return this._isInitialized;
    }, AutoCollectHttpDependencies.prototype._initialize = function() {
     var _this = this;
     this._isInitialized = !0;
     var originalRequest = http.request, originalHttpsRequest = https.request, clientRequestPatch = function(request, options) {
      try {
       var shouldCollect = !options[AutoCollectHttpDependencies.disableCollectionRequestOption] && !request[AutoCollectHttpDependencies.alreadyAutoCollectedFlag], userAgentHeader = null;
       if (options.headers && (userAgentHeader = options.headers["User-Agent"] || options.headers["user-agent"]) && -1 !== userAgentHeader.toString().indexOf("azsdk-js") && (shouldCollect = !1), 
       request && options && shouldCollect && (CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(request), 
       _this._isEnabled)) if (request[AutoCollectHttpDependencies.alreadyAutoCollectedFlag] = !0, 
       CorrelationContextManager_1.CorrelationContextManager.getCurrentContext()) AutoCollectHttpDependencies.trackRequest(_this._client, {
        options,
        request
       }); else {
        var operationId = null;
        if (CorrelationIdManager.w3cEnabled) {
         operationId = (new Traceparent).traceId;
        } else {
         var requestId = CorrelationIdManager.generateRequestId(null);
         operationId = CorrelationIdManager.getRootId(requestId);
        }
        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.generateContextObject(operationId);
        CorrelationContextManager_1.CorrelationContextManager.runWithContext(correlationContext, (function() {
         AutoCollectHttpDependencies.trackRequest(_this._client, {
          options,
          request
         });
        }));
       }
      } catch (err) {
       Logging.warn("Failed to generate dependency telemetry.", Util.dumpObj(err));
      }
     };
     http.request = function(options) {
      for (var requestArgs = [], _i = 1; _i < arguments.length; _i++) requestArgs[_i - 1] = arguments[_i];
      var request = originalRequest.call.apply(originalRequest, __spreadArrays([ http, options ], requestArgs));
      return clientRequestPatch(request, options), request;
     }, https.request = function(options) {
      for (var requestArgs = [], _i = 1; _i < arguments.length; _i++) requestArgs[_i - 1] = arguments[_i];
      var request = originalHttpsRequest.call.apply(originalHttpsRequest, __spreadArrays([ https, options ], requestArgs));
      return clientRequestPatch(request, options), request;
     }, http.get = function(options) {
      for (var _a, requestArgs = [], _i = 1; _i < arguments.length; _i++) requestArgs[_i - 1] = arguments[_i];
      var request = (_a = http.request).call.apply(_a, __spreadArrays([ http, options ], requestArgs));
      return request.end(), request;
     }, https.get = function(options) {
      for (var _a, requestArgs = [], _i = 1; _i < arguments.length; _i++) requestArgs[_i - 1] = arguments[_i];
      var request = (_a = https.request).call.apply(_a, __spreadArrays([ https, options ], requestArgs));
      return request.end(), request;
     };
    }, AutoCollectHttpDependencies.trackRequest = function(client, telemetry) {
     if (telemetry.options && telemetry.request && client) {
      var uniqueRequestId, uniqueTraceparent, requestParser = new HttpDependencyParser(telemetry.options, telemetry.request), currentContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
      if (currentContext && currentContext.operation && currentContext.operation.traceparent && Traceparent.isValidTraceId(currentContext.operation.traceparent.traceId)) currentContext.operation.traceparent.updateSpanId(), 
      uniqueRequestId = currentContext.operation.traceparent.getBackCompatRequestId(); else if (CorrelationIdManager.w3cEnabled) {
       uniqueTraceparent = (traceparent = new Traceparent).toString(), uniqueRequestId = traceparent.getBackCompatRequestId();
      } else uniqueRequestId = currentContext && currentContext.operation && currentContext.operation.parentId + AutoCollectHttpDependencies.requestNumber++ + ".";
      if (Util.canIncludeCorrelationHeader(client, requestParser.getUrl()) && telemetry.request.getHeader && telemetry.request.setHeader && client.config && client.config.correlationId) {
       var correlationHeader = telemetry.request.getHeader(RequestResponseHeaders.requestContextHeader);
       try {
        Util.safeIncludeCorrelationHeader(client, telemetry.request, correlationHeader);
       } catch (err) {
        Logging.warn("Request-Context header could not be set. Correlation of requests may be lost", err);
       }
       if (currentContext && currentContext.operation) try {
        if (telemetry.request.setHeader(RequestResponseHeaders.requestIdHeader, uniqueRequestId), 
        client.config.ignoreLegacyHeaders || (telemetry.request.setHeader(RequestResponseHeaders.parentIdHeader, currentContext.operation.id), 
        telemetry.request.setHeader(RequestResponseHeaders.rootIdHeader, uniqueRequestId)), 
        uniqueTraceparent || currentContext.operation.traceparent) telemetry.request.setHeader(RequestResponseHeaders.traceparentHeader, uniqueTraceparent || currentContext.operation.traceparent.toString()); else if (CorrelationIdManager.w3cEnabled) {
         var traceparent = (new Traceparent).toString();
         telemetry.request.setHeader(RequestResponseHeaders.traceparentHeader, traceparent);
        }
        if (currentContext.operation.tracestate) {
         var tracestate = currentContext.operation.tracestate.toString();
         tracestate && telemetry.request.setHeader(RequestResponseHeaders.traceStateHeader, tracestate);
        }
        var correlationContextHeader = currentContext.customProperties.serializeToHeader();
        correlationContextHeader && telemetry.request.setHeader(RequestResponseHeaders.correlationContextHeader, correlationContextHeader);
       } catch (err) {
        Logging.warn("Correlation headers could not be set. Correlation of requests may be lost.", err);
       }
      }
      telemetry.request.on && (telemetry.request.on("response", (function(response) {
       if (!telemetry.isProcessed) {
        telemetry.isProcessed = !0, requestParser.onResponse(response);
        var dependencyTelemetry = requestParser.getDependencyTelemetry(telemetry, uniqueRequestId);
        dependencyTelemetry.contextObjects = dependencyTelemetry.contextObjects || {}, dependencyTelemetry.contextObjects["http.RequestOptions"] = telemetry.options, 
        dependencyTelemetry.contextObjects["http.ClientRequest"] = telemetry.request, dependencyTelemetry.contextObjects["http.ClientResponse"] = response, 
        client.trackDependency(dependencyTelemetry);
       }
      })), telemetry.request.on("error", (function(error) {
       if (!telemetry.isProcessed) {
        telemetry.isProcessed = !0, requestParser.onError(error);
        var dependencyTelemetry = requestParser.getDependencyTelemetry(telemetry, uniqueRequestId);
        dependencyTelemetry.contextObjects = dependencyTelemetry.contextObjects || {}, dependencyTelemetry.contextObjects["http.RequestOptions"] = telemetry.options, 
        dependencyTelemetry.contextObjects["http.ClientRequest"] = telemetry.request, dependencyTelemetry.contextObjects.Error = error, 
        client.trackDependency(dependencyTelemetry);
       }
      })), telemetry.request.on("abort", (function() {
       if (!telemetry.isProcessed) {
        telemetry.isProcessed = !0, requestParser.onError(new Error("The request has been aborted and the network socket has closed."));
        var dependencyTelemetry = requestParser.getDependencyTelemetry(telemetry, uniqueRequestId);
        dependencyTelemetry.contextObjects = dependencyTelemetry.contextObjects || {}, dependencyTelemetry.contextObjects["http.RequestOptions"] = telemetry.options, 
        dependencyTelemetry.contextObjects["http.ClientRequest"] = telemetry.request, client.trackDependency(dependencyTelemetry);
       }
      })));
     } else Logging.info("AutoCollectHttpDependencies.trackRequest was called with invalid parameters: ", !telemetry.options, !telemetry.request, !client);
    }, AutoCollectHttpDependencies.prototype.dispose = function() {
     AutoCollectHttpDependencies.INSTANCE = null, this.enable(!1), this._isInitialized = !1;
    }, AutoCollectHttpDependencies.disableCollectionRequestOption = "disableAppInsightsAutoCollection", 
    AutoCollectHttpDependencies.requestNumber = 1, AutoCollectHttpDependencies.alreadyAutoCollectedFlag = "_appInsightsAutoCollected", 
    AutoCollectHttpDependencies;
   }();
   module.exports = AutoCollectHttpDependencies;
  },
  48339: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var extendStatics, __extends = this && this.__extends || (extendStatics = function(d, b) {
    return extendStatics = Object.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
    }, extendStatics(d, b);
   }, function(d, b) {
    function __() {
     this.constructor = d;
    }
    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
    new __);
   }), url = __webpack_require__(57310), Contracts = __webpack_require__(55290), Util = __webpack_require__(25740), RequestResponseHeaders = __webpack_require__(59036), RequestParser = __webpack_require__(13054), CorrelationIdManager = __webpack_require__(29962), HttpDependencyParser = function(_super) {
    function HttpDependencyParser(requestOptions, request) {
     var _this = _super.call(this) || this;
     return request && request.method && requestOptions && (_this.method = request.method, 
     _this.url = HttpDependencyParser._getUrlFromRequestOptions(requestOptions, request), 
     _this.startTime = +new Date), _this;
    }
    return __extends(HttpDependencyParser, _super), HttpDependencyParser.prototype.onError = function(error) {
     this._setStatus(void 0, error);
    }, HttpDependencyParser.prototype.onResponse = function(response) {
     this._setStatus(response.statusCode, void 0), this.correlationId = Util.getCorrelationContextTarget(response, RequestResponseHeaders.requestContextTargetKey);
    }, HttpDependencyParser.prototype.getDependencyTelemetry = function(baseTelemetry, dependencyId) {
     var dependencyName = this.method.toUpperCase(), remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_HTTP, remoteDependencyTarget = "";
     try {
      var urlObject = new url.URL(this.url);
      urlObject.search = void 0, urlObject.hash = void 0, dependencyName += " " + urlObject.pathname, 
      remoteDependencyTarget = urlObject.hostname, urlObject.port && (remoteDependencyTarget += ":" + urlObject.port);
     } catch (ex) {}
     this.correlationId ? (remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_AI, 
     this.correlationId !== CorrelationIdManager.correlationIdPrefix && (remoteDependencyTarget += " | " + this.correlationId)) : remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_HTTP;
     var dependencyTelemetry = {
      id: dependencyId,
      name: dependencyName,
      data: this.url,
      duration: this.duration,
      success: this._isSuccess(),
      resultCode: this.statusCode ? this.statusCode.toString() : null,
      properties: this.properties || {},
      dependencyTypeName: remoteDependencyType,
      target: remoteDependencyTarget
     };
     if (baseTelemetry && baseTelemetry.time ? dependencyTelemetry.time = baseTelemetry.time : this.startTime && (dependencyTelemetry.time = new Date(this.startTime)), 
     baseTelemetry) {
      for (var key in baseTelemetry) dependencyTelemetry[key] || (dependencyTelemetry[key] = baseTelemetry[key]);
      if (baseTelemetry.properties) for (var key in baseTelemetry.properties) dependencyTelemetry.properties[key] = baseTelemetry.properties[key];
     }
     return dependencyTelemetry;
    }, HttpDependencyParser._getUrlFromRequestOptions = function(options, request) {
     if ("string" == typeof options) if (0 === options.indexOf("http://") || 0 === options.indexOf("https://")) try {
      options = new url.URL(options);
     } catch (ex) {} else try {
      var parsed = new url.URL("http://" + options);
      options = "443" === parsed.port ? new url.URL("https://" + options) : new url.URL("http://" + options);
     } catch (ex) {} else {
      if (options && "function" == typeof url.URL && options instanceof url.URL) return url.format(options);
      var originalOptions_1 = options;
      options = {}, originalOptions_1 && Object.keys(originalOptions_1).forEach((function(key) {
       options[key] = originalOptions_1[key];
      }));
     }
     if (options.path && options.host) try {
      var parsedQuery = new url.URL(options.path, "http://" + options.host + options.path);
      options.pathname = parsedQuery.pathname, options.search = parsedQuery.search;
     } catch (ex) {}
     if (options.path && options.hostname && !options.host) try {
      parsedQuery = new url.URL(options.path, "http://" + options.hostname + options.path);
      options.pathname = parsedQuery.pathname, options.search = parsedQuery.search;
     } catch (ex) {}
     if (options.host && options.port) try {
      !new url.URL("http://" + options.host).port && options.port && (options.hostname = options.host, 
      delete options.host);
     } catch (ex) {}
     return options.protocol = options.protocol || request.agent && request.agent.protocol || request.protocol || void 0, 
     options.hostname = options.hostname || "localhost", url.format(options);
    }, HttpDependencyParser;
   }(RequestParser);
   module.exports = HttpDependencyParser;
  },
  86694: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var extendStatics, __extends = this && this.__extends || (extendStatics = function(d, b) {
    return extendStatics = Object.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
    }, extendStatics(d, b);
   }, function(d, b) {
    function __() {
     this.constructor = d;
    }
    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
    new __);
   }), url = __webpack_require__(57310), Contracts = __webpack_require__(55290), Util = __webpack_require__(25740), RequestResponseHeaders = __webpack_require__(59036), RequestParser = __webpack_require__(13054), CorrelationIdManager = __webpack_require__(29962), Tracestate = __webpack_require__(10420), Traceparent = __webpack_require__(58090), HttpRequestParser = function(_super) {
    function HttpRequestParser(request, requestId) {
     var _this = _super.call(this) || this;
     return request && (_this.method = request.method, _this.url = _this._getAbsoluteUrl(request), 
     _this.startTime = +new Date, _this.socketRemoteAddress = request.socket && request.socket.remoteAddress, 
     _this.parseHeaders(request, requestId), request.connection && (_this.connectionRemoteAddress = request.connection.remoteAddress, 
     _this.legacySocketRemoteAddress = request.connection.socket && request.connection.socket.remoteAddress)), 
     _this;
    }
    return __extends(HttpRequestParser, _super), HttpRequestParser.prototype.onError = function(error, ellapsedMilliseconds) {
     this._setStatus(void 0, error), ellapsedMilliseconds && (this.duration = ellapsedMilliseconds);
    }, HttpRequestParser.prototype.onResponse = function(response, ellapsedMilliseconds) {
     this._setStatus(response.statusCode, void 0), ellapsedMilliseconds && (this.duration = ellapsedMilliseconds);
    }, HttpRequestParser.prototype.getRequestTelemetry = function(baseTelemetry) {
     var name = this.method;
     try {
      name += " " + new url.URL(this.url).pathname;
     } catch (ex) {}
     var requestTelemetry = {
      id: this.requestId,
      name,
      url: this.url,
      source: this.sourceCorrelationId,
      duration: this.duration,
      resultCode: this.statusCode ? this.statusCode.toString() : null,
      success: this._isSuccess(),
      properties: this.properties
     };
     if (baseTelemetry && baseTelemetry.time ? requestTelemetry.time = baseTelemetry.time : this.startTime && (requestTelemetry.time = new Date(this.startTime)), 
     baseTelemetry) {
      for (var key in baseTelemetry) requestTelemetry[key] || (requestTelemetry[key] = baseTelemetry[key]);
      if (baseTelemetry.properties) for (var key in baseTelemetry.properties) requestTelemetry.properties[key] = baseTelemetry.properties[key];
     }
     return requestTelemetry;
    }, HttpRequestParser.prototype.getRequestTags = function(tags) {
     var newTags = {};
     for (var key in tags) newTags[key] = tags[key];
     return newTags[HttpRequestParser.keys.locationIp] = tags[HttpRequestParser.keys.locationIp] || this._getIp(), 
     newTags[HttpRequestParser.keys.sessionId] = tags[HttpRequestParser.keys.sessionId] || this._getId("ai_session"), 
     newTags[HttpRequestParser.keys.userId] = tags[HttpRequestParser.keys.userId] || this._getId("ai_user"), 
     newTags[HttpRequestParser.keys.userAuthUserId] = tags[HttpRequestParser.keys.userAuthUserId] || this._getId("ai_authUser"), 
     newTags[HttpRequestParser.keys.operationName] = this.getOperationName(tags), newTags[HttpRequestParser.keys.operationParentId] = this.getOperationParentId(tags), 
     newTags[HttpRequestParser.keys.operationId] = this.getOperationId(tags), newTags;
    }, HttpRequestParser.prototype.getOperationId = function(tags) {
     return tags[HttpRequestParser.keys.operationId] || this.operationId;
    }, HttpRequestParser.prototype.getOperationParentId = function(tags) {
     return tags[HttpRequestParser.keys.operationParentId] || this.parentId || this.getOperationId(tags);
    }, HttpRequestParser.prototype.getOperationName = function(tags) {
     if (tags[HttpRequestParser.keys.operationName]) return tags[HttpRequestParser.keys.operationName];
     var pathName = "";
     try {
      pathName = new url.URL(this.url).pathname;
     } catch (ex) {}
     var operationName = this.method;
     return pathName && (operationName += " " + pathName), operationName;
    }, HttpRequestParser.prototype.getRequestId = function() {
     return this.requestId;
    }, HttpRequestParser.prototype.getCorrelationContextHeader = function() {
     return this.correlationContextHeader;
    }, HttpRequestParser.prototype.getTraceparent = function() {
     return this.traceparent;
    }, HttpRequestParser.prototype.getTracestate = function() {
     return this.tracestate;
    }, HttpRequestParser.prototype.getLegacyRootId = function() {
     return this.legacyRootId;
    }, HttpRequestParser.prototype._getAbsoluteUrl = function(request) {
     if (!request.headers) return request.url;
     var protocol = (request.connection ? request.connection.encrypted : null) || "https" == request.headers["x-forwarded-proto"] ? "https" : "http", baseUrl = protocol + "://" + request.headers.host + "/", pathName = "", search = "";
     try {
      var requestUrl = new url.URL(request.url, baseUrl);
      pathName = requestUrl.pathname, search = requestUrl.search;
     } catch (ex) {}
     return url.format({
      protocol,
      host: request.headers.host,
      pathname: pathName,
      search
     });
    }, HttpRequestParser.prototype._getIp = function() {
     var ipMatch = /[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/, check = function(str) {
      var results = ipMatch.exec(str);
      if (results) return results[0];
     }, ip = check(this.rawHeaders["x-forwarded-for"]) || check(this.rawHeaders["x-client-ip"]) || check(this.rawHeaders["x-real-ip"]) || check(this.connectionRemoteAddress) || check(this.socketRemoteAddress) || check(this.legacySocketRemoteAddress);
     return !ip && this.connectionRemoteAddress && this.connectionRemoteAddress.substr && "::" === this.connectionRemoteAddress.substr(0, 2) && (ip = "127.0.0.1"), 
     ip;
    }, HttpRequestParser.prototype._getId = function(name) {
     var cookie = this.rawHeaders && this.rawHeaders.cookie && "string" == typeof this.rawHeaders.cookie && this.rawHeaders.cookie || "";
     return HttpRequestParser.parseId(Util.getCookie(name, cookie));
    }, HttpRequestParser.prototype.setBackCompatFromThisTraceContext = function() {
     this.operationId = this.traceparent.traceId, this.traceparent.legacyRootId && (this.legacyRootId = this.traceparent.legacyRootId), 
     this.parentId = this.traceparent.parentId, this.traceparent.updateSpanId(), this.requestId = this.traceparent.getBackCompatRequestId();
    }, HttpRequestParser.prototype.parseHeaders = function(request, requestId) {
     if (this.rawHeaders = request.headers || request.rawHeaders, this.userAgent = request.headers && request.headers["user-agent"], 
     this.sourceCorrelationId = Util.getCorrelationContextTarget(request, RequestResponseHeaders.requestContextSourceKey), 
     request.headers) {
      var tracestateHeader = request.headers[RequestResponseHeaders.traceStateHeader] ? request.headers[RequestResponseHeaders.traceStateHeader].toString() : null, traceparentHeader = request.headers[RequestResponseHeaders.traceparentHeader] ? request.headers[RequestResponseHeaders.traceparentHeader].toString() : null, requestIdHeader = request.headers[RequestResponseHeaders.requestIdHeader] ? request.headers[RequestResponseHeaders.requestIdHeader].toString() : null, legacy_parentId = request.headers[RequestResponseHeaders.parentIdHeader] ? request.headers[RequestResponseHeaders.parentIdHeader].toString() : null, legacy_rootId = request.headers[RequestResponseHeaders.rootIdHeader] ? request.headers[RequestResponseHeaders.rootIdHeader].toString() : null;
      this.correlationContextHeader = request.headers[RequestResponseHeaders.correlationContextHeader] ? request.headers[RequestResponseHeaders.correlationContextHeader].toString() : null, 
      CorrelationIdManager.w3cEnabled && (traceparentHeader || tracestateHeader) ? (this.traceparent = new Traceparent(traceparentHeader ? traceparentHeader.toString() : null), 
      this.tracestate = traceparentHeader && tracestateHeader && new Tracestate(tracestateHeader ? tracestateHeader.toString() : null), 
      this.setBackCompatFromThisTraceContext()) : requestIdHeader ? CorrelationIdManager.w3cEnabled ? (this.traceparent = new Traceparent(null, requestIdHeader), 
      this.setBackCompatFromThisTraceContext()) : (this.parentId = requestIdHeader, this.requestId = CorrelationIdManager.generateRequestId(this.parentId), 
      this.operationId = CorrelationIdManager.getRootId(this.requestId)) : CorrelationIdManager.w3cEnabled ? (this.traceparent = new Traceparent, 
      this.traceparent.parentId = legacy_parentId, this.traceparent.legacyRootId = legacy_rootId || legacy_parentId, 
      this.setBackCompatFromThisTraceContext()) : (this.parentId = legacy_parentId, this.requestId = CorrelationIdManager.generateRequestId(legacy_rootId || this.parentId), 
      this.correlationContextHeader = null, this.operationId = CorrelationIdManager.getRootId(this.requestId)), 
      requestId && (this.requestId = requestId, this.operationId = CorrelationIdManager.getRootId(this.requestId));
     }
    }, HttpRequestParser.parseId = function(cookieValue) {
     var cookieParts = cookieValue.split("|");
     return cookieParts.length > 0 ? cookieParts[0] : "";
    }, HttpRequestParser.keys = new Contracts.ContextTagKeys, HttpRequestParser;
   }(RequestParser);
   module.exports = HttpRequestParser;
  },
  40731: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var http = __webpack_require__(13685), https = __webpack_require__(95687), Logging = __webpack_require__(95282), Util = __webpack_require__(25740), RequestResponseHeaders = __webpack_require__(59036), HttpRequestParser = __webpack_require__(86694), CorrelationContextManager_1 = __webpack_require__(70894), AutoCollectPerformance = __webpack_require__(74350), AutoCollectHttpRequests = function() {
    function AutoCollectHttpRequests(client) {
     if (AutoCollectHttpRequests.INSTANCE) throw new Error("Server request tracking should be configured from the applicationInsights object");
     AutoCollectHttpRequests.INSTANCE = this, this._client = client;
    }
    return AutoCollectHttpRequests.prototype.enable = function(isEnabled) {
     this._isEnabled = isEnabled, (this._isAutoCorrelating || this._isEnabled || AutoCollectPerformance.isEnabled()) && !this._isInitialized && (this.useAutoCorrelation(this._isAutoCorrelating), 
     this._initialize());
    }, AutoCollectHttpRequests.prototype.useAutoCorrelation = function(isEnabled, forceClsHooked) {
     isEnabled && !this._isAutoCorrelating ? CorrelationContextManager_1.CorrelationContextManager.enable(forceClsHooked) : !isEnabled && this._isAutoCorrelating && CorrelationContextManager_1.CorrelationContextManager.disable(), 
     this._isAutoCorrelating = isEnabled;
    }, AutoCollectHttpRequests.prototype.isInitialized = function() {
     return this._isInitialized;
    }, AutoCollectHttpRequests.prototype.isAutoCorrelating = function() {
     return this._isAutoCorrelating;
    }, AutoCollectHttpRequests.prototype._generateCorrelationContext = function(requestParser) {
     if (this._isAutoCorrelating) return CorrelationContextManager_1.CorrelationContextManager.generateContextObject(requestParser.getOperationId(this._client.context.tags), requestParser.getRequestId(), requestParser.getOperationName(this._client.context.tags), requestParser.getCorrelationContextHeader(), requestParser.getTraceparent(), requestParser.getTracestate());
    }, AutoCollectHttpRequests.prototype._registerRequest = function(request, response, onRequest) {
     var _this = this, requestParser = new HttpRequestParser(request), correlationContext = this._generateCorrelationContext(requestParser);
     CorrelationContextManager_1.CorrelationContextManager.runWithContext(correlationContext, (function() {
      _this._isEnabled && (request[AutoCollectHttpRequests.alreadyAutoCollectedFlag] = !0, 
      AutoCollectHttpRequests.trackRequest(_this._client, {
       request,
       response
      }, requestParser)), "function" == typeof onRequest && onRequest(request, response);
     }));
    }, AutoCollectHttpRequests.prototype._initialize = function() {
     if (this._isInitialized = !0, !AutoCollectHttpRequests.HANDLER_READY) {
      AutoCollectHttpRequests.HANDLER_READY = !0;
      var wrapOnRequestHandler = function(onRequest) {
       if (onRequest) {
        if ("function" != typeof onRequest) throw new Error("onRequest handler must be a function");
        return function(request, response) {
         var _a;
         CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(request), CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(response);
         var shouldCollect = request && !request[AutoCollectHttpRequests.alreadyAutoCollectedFlag];
         request && shouldCollect ? null === (_a = AutoCollectHttpRequests.INSTANCE) || void 0 === _a || _a._registerRequest(request, response, onRequest) : "function" == typeof onRequest && onRequest(request, response);
        };
       }
      }, wrapServerEventHandler = function(server) {
       var originalAddListener = server.addListener.bind(server);
       server.addListener = function(eventType, eventHandler) {
        switch (eventType) {
        case "request":
        case "checkContinue":
         return originalAddListener(eventType, wrapOnRequestHandler(eventHandler));

        default:
         return originalAddListener(eventType, eventHandler);
        }
       }, server.on = server.addListener;
      }, originalHttpServer = http.createServer;
      http.createServer = function(param1, param2) {
       if (param2 && "function" == typeof param2) {
        var server = originalHttpServer(param1, wrapOnRequestHandler(param2));
        return wrapServerEventHandler(server), server;
       }
       server = originalHttpServer(wrapOnRequestHandler(param1));
       return wrapServerEventHandler(server), server;
      };
      var originalHttpsServer = https.createServer;
      https.createServer = function(options, onRequest) {
       var server = originalHttpsServer(options, wrapOnRequestHandler(onRequest));
       return wrapServerEventHandler(server), server;
      };
     }
    }, AutoCollectHttpRequests.trackRequestSync = function(client, telemetry) {
     if (telemetry.request && telemetry.response && client) {
      telemetry.isProcessed = !1, AutoCollectHttpRequests.addResponseCorrelationIdHeader(client, telemetry.response);
      var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext(), requestParser = new HttpRequestParser(telemetry.request, correlationContext && correlationContext.operation.parentId);
      correlationContext && (correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id, 
      correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name, 
      correlationContext.operation.parentId = requestParser.getRequestId() || correlationContext.operation.parentId, 
      correlationContext.customProperties.addHeaderData(requestParser.getCorrelationContextHeader())), 
      AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, telemetry.duration, telemetry.error);
     } else Logging.info("AutoCollectHttpRequests.trackRequestSync was called with invalid parameters: ", !telemetry.request, !telemetry.response, !client);
    }, AutoCollectHttpRequests.trackRequest = function(client, telemetry, _requestParser) {
     if (telemetry.request && telemetry.response && client) {
      telemetry.isProcessed = !1;
      var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext(), requestParser = _requestParser || new HttpRequestParser(telemetry.request, correlationContext && correlationContext.operation.parentId);
      Util.canIncludeCorrelationHeader(client, requestParser.getUrl()) && AutoCollectHttpRequests.addResponseCorrelationIdHeader(client, telemetry.response), 
      correlationContext && !_requestParser && (correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id, 
      correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name, 
      correlationContext.operation.parentId = requestParser.getOperationParentId(client.context.tags) || correlationContext.operation.parentId, 
      correlationContext.customProperties.addHeaderData(requestParser.getCorrelationContextHeader())), 
      telemetry.response.once && telemetry.response.once("finish", (function() {
       AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, null, null);
      })), telemetry.request.on && telemetry.request.on("error", (function(error) {
       AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, null, error);
      })), telemetry.request.on && telemetry.request.on("aborted", (function() {
       AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, null, "The request has been aborted and the network socket has closed.");
      }));
     } else Logging.info("AutoCollectHttpRequests.trackRequest was called with invalid parameters: ", !telemetry.request, !telemetry.response, !client);
    }, AutoCollectHttpRequests.addResponseCorrelationIdHeader = function(client, response) {
     if (client.config && client.config.correlationId && response.getHeader && response.setHeader && !response.headersSent) {
      var correlationHeader = response.getHeader(RequestResponseHeaders.requestContextHeader);
      Util.safeIncludeCorrelationHeader(client, response, correlationHeader);
     }
    }, AutoCollectHttpRequests.endRequest = function(client, requestParser, telemetry, ellapsedMilliseconds, error) {
     if (!telemetry.isProcessed) {
      telemetry.isProcessed = !0, error ? requestParser.onError(error, ellapsedMilliseconds) : requestParser.onResponse(telemetry.response, ellapsedMilliseconds);
      var requestTelemetry = requestParser.getRequestTelemetry(telemetry);
      if (requestTelemetry.tagOverrides = requestParser.getRequestTags(client.context.tags), 
      telemetry.tagOverrides) for (var key in telemetry.tagOverrides) requestTelemetry.tagOverrides[key] = telemetry.tagOverrides[key];
      var legacyRootId = requestParser.getLegacyRootId();
      legacyRootId && (requestTelemetry.properties.ai_legacyRootId = legacyRootId), requestTelemetry.contextObjects = requestTelemetry.contextObjects || {}, 
      requestTelemetry.contextObjects["http.ServerRequest"] = telemetry.request, requestTelemetry.contextObjects["http.ServerResponse"] = telemetry.response, 
      client.trackRequest(requestTelemetry);
     }
    }, AutoCollectHttpRequests.prototype.dispose = function() {
     AutoCollectHttpRequests.INSTANCE = null, this.enable(!1), this._isInitialized = !1, 
     CorrelationContextManager_1.CorrelationContextManager.disable(), this._isAutoCorrelating = !1;
    }, AutoCollectHttpRequests.HANDLER_READY = !1, AutoCollectHttpRequests.alreadyAutoCollectedFlag = "_appInsightsAutoCollected", 
    AutoCollectHttpRequests;
   }();
   module.exports = AutoCollectHttpRequests;
  },
  11629: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __assign = this && this.__assign || function() {
    return __assign = Object.assign || function(t) {
     for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
     return t;
    }, __assign.apply(this, arguments);
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.AutoCollectNativePerformance = void 0;
   var Context = __webpack_require__(54470), Logging = __webpack_require__(95282), AutoCollectNativePerformance = function() {
    function AutoCollectNativePerformance(client) {
     this._disabledMetrics = {}, AutoCollectNativePerformance.INSTANCE && AutoCollectNativePerformance.INSTANCE.dispose(), 
     AutoCollectNativePerformance.INSTANCE = this, this._client = client;
    }
    return AutoCollectNativePerformance.prototype.enable = function(isEnabled, disabledMetrics, collectionInterval) {
     var _this = this;
     if (void 0 === disabledMetrics && (disabledMetrics = {}), void 0 === collectionInterval && (collectionInterval = 6e4), 
     null == AutoCollectNativePerformance._metricsAvailable && isEnabled && !this._isInitialized) try {
      var NativeMetricsEmitters = __webpack_require__(32220);
      AutoCollectNativePerformance._emitter = new NativeMetricsEmitters, AutoCollectNativePerformance._metricsAvailable = !0, 
      Logging.info("Native metrics module successfully loaded!");
     } catch (err) {
      return void (AutoCollectNativePerformance._metricsAvailable = !1);
     }
     this._isEnabled = isEnabled, this._disabledMetrics = disabledMetrics, this._isEnabled && !this._isInitialized && (this._isInitialized = !0), 
     this._isEnabled && AutoCollectNativePerformance._emitter ? (AutoCollectNativePerformance._emitter.enable(!0, collectionInterval), 
     this._handle || (this._handle = setInterval((function() {
      return _this._trackNativeMetrics();
     }), collectionInterval), this._handle.unref())) : AutoCollectNativePerformance._emitter && (AutoCollectNativePerformance._emitter.enable(!1), 
     this._handle && (clearInterval(this._handle), this._handle = void 0));
    }, AutoCollectNativePerformance.prototype.dispose = function() {
     this.enable(!1);
    }, AutoCollectNativePerformance.parseEnabled = function(collectExtendedMetrics, customConfig) {
     var disableAll = customConfig.disableAllExtendedMetrics, individualOptOuts = customConfig.extendedMetricDisablers;
     if (disableAll) return {
      isEnabled: !1,
      disabledMetrics: {}
     };
     if (individualOptOuts) {
      var optOutsArr = individualOptOuts.split(","), disabledMetrics = {};
      if (optOutsArr.length > 0) for (var _i = 0, optOutsArr_1 = optOutsArr; _i < optOutsArr_1.length; _i++) {
       disabledMetrics[optOutsArr_1[_i]] = !0;
      }
      return "object" == typeof collectExtendedMetrics ? {
       isEnabled: !0,
       disabledMetrics: __assign(__assign({}, collectExtendedMetrics), disabledMetrics)
      } : {
       isEnabled: collectExtendedMetrics,
       disabledMetrics
      };
     }
     return "boolean" == typeof collectExtendedMetrics ? {
      isEnabled: collectExtendedMetrics,
      disabledMetrics: {}
     } : {
      isEnabled: !0,
      disabledMetrics: collectExtendedMetrics
     };
    }, AutoCollectNativePerformance.prototype._trackNativeMetrics = function() {
     var shouldSendAll = !0;
     "object" != typeof this._isEnabled && (shouldSendAll = this._isEnabled), shouldSendAll && (this._trackGarbageCollection(), 
     this._trackEventLoop(), this._trackHeapUsage());
    }, AutoCollectNativePerformance.prototype._trackGarbageCollection = function() {
     var _a;
     if (!this._disabledMetrics.gc) {
      var gcData = AutoCollectNativePerformance._emitter.getGCData();
      for (var gc in gcData) {
       var metrics = gcData[gc].metrics, name_1 = gc + " Garbage Collection Duration", stdDev = Math.sqrt(metrics.sumSquares / metrics.count - Math.pow(metrics.total / metrics.count, 2)) || 0;
       this._client.trackMetric({
        name: name_1,
        value: metrics.total,
        count: metrics.count,
        max: metrics.max,
        min: metrics.min,
        stdDev,
        tagOverrides: (_a = {}, _a[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion, 
        _a)
       });
      }
     }
    }, AutoCollectNativePerformance.prototype._trackEventLoop = function() {
     var _a;
     if (!this._disabledMetrics.loop) {
      var metrics = AutoCollectNativePerformance._emitter.getLoopData().loopUsage;
      if (0 != metrics.count) {
       var stdDev = Math.sqrt(metrics.sumSquares / metrics.count - Math.pow(metrics.total / metrics.count, 2)) || 0;
       this._client.trackMetric({
        name: "Event Loop CPU Time",
        value: metrics.total,
        count: metrics.count,
        min: metrics.min,
        max: metrics.max,
        stdDev,
        tagOverrides: (_a = {}, _a[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion, 
        _a)
       });
      }
     }
    }, AutoCollectNativePerformance.prototype._trackHeapUsage = function() {
     var _a, _b, _c;
     if (!this._disabledMetrics.heap) {
      var memoryUsage = process.memoryUsage(), heapUsed = memoryUsage.heapUsed, heapTotal = memoryUsage.heapTotal, rss = memoryUsage.rss;
      this._client.trackMetric({
       name: "Memory Usage (Heap)",
       value: heapUsed,
       count: 1,
       tagOverrides: (_a = {}, _a[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion, 
       _a)
      }), this._client.trackMetric({
       name: "Memory Total (Heap)",
       value: heapTotal,
       count: 1,
       tagOverrides: (_b = {}, _b[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion, 
       _b)
      }), this._client.trackMetric({
       name: "Memory Usage (Non-Heap)",
       value: rss - heapTotal,
       count: 1,
       tagOverrides: (_c = {}, _c[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion, 
       _c)
      });
     }
    }, AutoCollectNativePerformance;
   }();
   exports.AutoCollectNativePerformance = AutoCollectNativePerformance;
  },
  64555: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.NetworkStatsbeat = void 0;
   var NetworkStatsbeat = function(endpoint, host) {
    this.endpoint = endpoint, this.host = host, this.totalRequestCount = 0, this.totalSuccesfulRequestCount = 0, 
    this.totalFailedRequestCount = [], this.retryCount = [], this.exceptionCount = [], 
    this.throttleCount = [], this.intervalRequestExecutionTime = 0, this.lastIntervalRequestExecutionTime = 0, 
    this.lastTime = +new Date, this.lastRequestCount = 0;
   };
   exports.NetworkStatsbeat = NetworkStatsbeat;
  },
  74350: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var os = __webpack_require__(22037), Constants = __webpack_require__(63580), AutoCollectPerformance = function() {
    function AutoCollectPerformance(client, collectionInterval, enableLiveMetricsCounters) {
     void 0 === collectionInterval && (collectionInterval = 6e4), void 0 === enableLiveMetricsCounters && (enableLiveMetricsCounters = !1), 
     this._lastIntervalRequestExecutionTime = 0, this._lastIntervalDependencyExecutionTime = 0, 
     AutoCollectPerformance.INSTANCE || (AutoCollectPerformance.INSTANCE = this), this._lastRequests = {
      totalRequestCount: 0,
      totalFailedRequestCount: 0,
      time: 0
     }, this._lastDependencies = {
      totalDependencyCount: 0,
      totalFailedDependencyCount: 0,
      time: 0
     }, this._lastExceptions = {
      totalExceptionCount: 0,
      time: 0
     }, this._isInitialized = !1, this._client = client, this._collectionInterval = collectionInterval, 
     this._enableLiveMetricsCounters = enableLiveMetricsCounters;
    }
    return AutoCollectPerformance.prototype.enable = function(isEnabled, collectionInterval) {
     var _this = this;
     this._isEnabled = isEnabled, this._isEnabled && !this._isInitialized && (this._isInitialized = !0), 
     isEnabled ? this._handle || (this._lastCpus = os.cpus(), this._lastRequests = {
      totalRequestCount: AutoCollectPerformance._totalRequestCount,
      totalFailedRequestCount: AutoCollectPerformance._totalFailedRequestCount,
      time: +new Date
     }, this._lastDependencies = {
      totalDependencyCount: AutoCollectPerformance._totalDependencyCount,
      totalFailedDependencyCount: AutoCollectPerformance._totalFailedDependencyCount,
      time: +new Date
     }, this._lastExceptions = {
      totalExceptionCount: AutoCollectPerformance._totalExceptionCount,
      time: +new Date
     }, "function" == typeof process.cpuUsage && (this._lastAppCpuUsage = process.cpuUsage()), 
     this._lastHrtime = process.hrtime(), this._collectionInterval = collectionInterval || this._collectionInterval, 
     this._handle = setInterval((function() {
      return _this.trackPerformance();
     }), this._collectionInterval), this._handle.unref()) : this._handle && (clearInterval(this._handle), 
     this._handle = void 0);
    }, AutoCollectPerformance.countRequest = function(duration, success) {
     var durationMs;
     if (AutoCollectPerformance.isEnabled()) {
      if ("string" == typeof duration) durationMs = +new Date("1970-01-01T" + duration + "Z"); else {
       if ("number" != typeof duration) return;
       durationMs = duration;
      }
      AutoCollectPerformance._intervalRequestExecutionTime += durationMs, !1 === success && AutoCollectPerformance._totalFailedRequestCount++, 
      AutoCollectPerformance._totalRequestCount++;
     }
    }, AutoCollectPerformance.countException = function() {
     AutoCollectPerformance._totalExceptionCount++;
    }, AutoCollectPerformance.countDependency = function(duration, success) {
     var durationMs;
     if (AutoCollectPerformance.isEnabled()) {
      if ("string" == typeof duration) durationMs = +new Date("1970-01-01T" + duration + "Z"); else {
       if ("number" != typeof duration) return;
       durationMs = duration;
      }
      AutoCollectPerformance._intervalDependencyExecutionTime += durationMs, !1 === success && AutoCollectPerformance._totalFailedDependencyCount++, 
      AutoCollectPerformance._totalDependencyCount++;
     }
    }, AutoCollectPerformance.prototype.isInitialized = function() {
     return this._isInitialized;
    }, AutoCollectPerformance.isEnabled = function() {
     return AutoCollectPerformance.INSTANCE && AutoCollectPerformance.INSTANCE._isEnabled;
    }, AutoCollectPerformance.prototype.trackPerformance = function() {
     this._trackCpu(), this._trackMemory(), this._trackNetwork(), this._trackDependencyRate(), 
     this._trackExceptionRate();
    }, AutoCollectPerformance.prototype._trackCpu = function() {
     var cpus = os.cpus();
     if (cpus && cpus.length && this._lastCpus && cpus.length === this._lastCpus.length) {
      for (var totalUser = 0, totalSys = 0, totalNice = 0, totalIdle = 0, totalIrq = 0, i = 0; cpus && i < cpus.length; i++) {
       var cpu = cpus[i], lastCpu = this._lastCpus[i], times = (cpu.model, cpu.speed, cpu.times), lastTimes = lastCpu.times;
       totalUser += times.user - lastTimes.user || 0, totalSys += times.sys - lastTimes.sys || 0, 
       totalNice += times.nice - lastTimes.nice || 0, totalIdle += times.idle - lastTimes.idle || 0, 
       totalIrq += times.irq - lastTimes.irq || 0;
      }
      var appCpuPercent = void 0;
      if ("function" == typeof process.cpuUsage) {
       var appCpuUsage = process.cpuUsage(), hrtime = process.hrtime(), totalApp = appCpuUsage.user - this._lastAppCpuUsage.user + (appCpuUsage.system - this._lastAppCpuUsage.system) || 0;
       if (void 0 !== this._lastHrtime && 2 === this._lastHrtime.length) appCpuPercent = 100 * totalApp / ((1e6 * (hrtime[0] - this._lastHrtime[0]) + (hrtime[1] - this._lastHrtime[1]) / 1e3 || 0) * cpus.length);
       this._lastAppCpuUsage = appCpuUsage, this._lastHrtime = hrtime;
      }
      var combinedTotal = totalUser + totalSys + totalNice + totalIdle + totalIrq || 1;
      this._client.trackMetric({
       name: Constants.PerformanceCounter.PROCESSOR_TIME,
       value: (combinedTotal - totalIdle) / combinedTotal * 100
      }), this._client.trackMetric({
       name: Constants.PerformanceCounter.PROCESS_TIME,
       value: appCpuPercent || totalUser / combinedTotal * 100
      });
     }
     this._lastCpus = cpus;
    }, AutoCollectPerformance.prototype._trackMemory = function() {
     var freeMem = os.freemem(), usedMem = process.memoryUsage().rss, committedMemory = os.totalmem() - freeMem;
     this._client.trackMetric({
      name: Constants.PerformanceCounter.PRIVATE_BYTES,
      value: usedMem
     }), this._client.trackMetric({
      name: Constants.PerformanceCounter.AVAILABLE_BYTES,
      value: freeMem
     }), this._enableLiveMetricsCounters && this._client.trackMetric({
      name: Constants.QuickPulseCounter.COMMITTED_BYTES,
      value: committedMemory
     });
    }, AutoCollectPerformance.prototype._trackNetwork = function() {
     var lastRequests = this._lastRequests, requests = {
      totalRequestCount: AutoCollectPerformance._totalRequestCount,
      totalFailedRequestCount: AutoCollectPerformance._totalFailedRequestCount,
      time: +new Date
     }, intervalRequests = requests.totalRequestCount - lastRequests.totalRequestCount || 0, intervalFailedRequests = requests.totalFailedRequestCount - lastRequests.totalFailedRequestCount || 0, elapsedMs = requests.time - lastRequests.time, elapsedSeconds = elapsedMs / 1e3, averageRequestExecutionTime = (AutoCollectPerformance._intervalRequestExecutionTime - this._lastIntervalRequestExecutionTime) / intervalRequests || 0;
     if (this._lastIntervalRequestExecutionTime = AutoCollectPerformance._intervalRequestExecutionTime, 
     elapsedMs > 0) {
      var requestsPerSec = intervalRequests / elapsedSeconds, failedRequestsPerSec = intervalFailedRequests / elapsedSeconds;
      this._client.trackMetric({
       name: Constants.PerformanceCounter.REQUEST_RATE,
       value: requestsPerSec
      }), (!this._enableLiveMetricsCounters || intervalRequests > 0) && this._client.trackMetric({
       name: Constants.PerformanceCounter.REQUEST_DURATION,
       value: averageRequestExecutionTime
      }), this._enableLiveMetricsCounters && this._client.trackMetric({
       name: Constants.QuickPulseCounter.REQUEST_FAILURE_RATE,
       value: failedRequestsPerSec
      });
     }
     this._lastRequests = requests;
    }, AutoCollectPerformance.prototype._trackDependencyRate = function() {
     if (this._enableLiveMetricsCounters) {
      var lastDependencies = this._lastDependencies, dependencies = {
       totalDependencyCount: AutoCollectPerformance._totalDependencyCount,
       totalFailedDependencyCount: AutoCollectPerformance._totalFailedDependencyCount,
       time: +new Date
      }, intervalDependencies = dependencies.totalDependencyCount - lastDependencies.totalDependencyCount || 0, intervalFailedDependencies = dependencies.totalFailedDependencyCount - lastDependencies.totalFailedDependencyCount || 0, elapsedMs = dependencies.time - lastDependencies.time, elapsedSeconds = elapsedMs / 1e3, averageDependencyExecutionTime = (AutoCollectPerformance._intervalDependencyExecutionTime - this._lastIntervalDependencyExecutionTime) / intervalDependencies || 0;
      if (this._lastIntervalDependencyExecutionTime = AutoCollectPerformance._intervalDependencyExecutionTime, 
      elapsedMs > 0) {
       var dependenciesPerSec = intervalDependencies / elapsedSeconds, failedDependenciesPerSec = intervalFailedDependencies / elapsedSeconds;
       this._client.trackMetric({
        name: Constants.QuickPulseCounter.DEPENDENCY_RATE,
        value: dependenciesPerSec
       }), this._client.trackMetric({
        name: Constants.QuickPulseCounter.DEPENDENCY_FAILURE_RATE,
        value: failedDependenciesPerSec
       }), (!this._enableLiveMetricsCounters || intervalDependencies > 0) && this._client.trackMetric({
        name: Constants.QuickPulseCounter.DEPENDENCY_DURATION,
        value: averageDependencyExecutionTime
       });
      }
      this._lastDependencies = dependencies;
     }
    }, AutoCollectPerformance.prototype._trackExceptionRate = function() {
     if (this._enableLiveMetricsCounters) {
      var lastExceptions = this._lastExceptions, exceptions = {
       totalExceptionCount: AutoCollectPerformance._totalExceptionCount,
       time: +new Date
      }, intervalExceptions = exceptions.totalExceptionCount - lastExceptions.totalExceptionCount || 0, elapsedMs = exceptions.time - lastExceptions.time;
      if (elapsedMs > 0) {
       var exceptionsPerSec = intervalExceptions / (elapsedMs / 1e3);
       this._client.trackMetric({
        name: Constants.QuickPulseCounter.EXCEPTION_RATE,
        value: exceptionsPerSec
       });
      }
      this._lastExceptions = exceptions;
     }
    }, AutoCollectPerformance.prototype.dispose = function() {
     AutoCollectPerformance.INSTANCE = null, this.enable(!1), this._isInitialized = !1;
    }, AutoCollectPerformance._totalRequestCount = 0, AutoCollectPerformance._totalFailedRequestCount = 0, 
    AutoCollectPerformance._totalDependencyCount = 0, AutoCollectPerformance._totalFailedDependencyCount = 0, 
    AutoCollectPerformance._totalExceptionCount = 0, AutoCollectPerformance._intervalDependencyExecutionTime = 0, 
    AutoCollectPerformance._intervalRequestExecutionTime = 0, AutoCollectPerformance;
   }();
   module.exports = AutoCollectPerformance;
  },
  62309: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var __assign = this && this.__assign || function() {
    return __assign = Object.assign || function(t) {
     for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
     return t;
    }, __assign.apply(this, arguments);
   }, Constants = __webpack_require__(63580), AggregatedMetricCounters_1 = __webpack_require__(60521), AggregatedMetricDimensions_1 = __webpack_require__(77535), AutoCollectPreAggregatedMetrics = function() {
    function AutoCollectPreAggregatedMetrics(client, collectionInterval) {
     void 0 === collectionInterval && (collectionInterval = 6e4), AutoCollectPreAggregatedMetrics.INSTANCE || (AutoCollectPreAggregatedMetrics.INSTANCE = this), 
     this._isInitialized = !1, AutoCollectPreAggregatedMetrics._dependencyCountersCollection = [], 
     AutoCollectPreAggregatedMetrics._requestCountersCollection = [], AutoCollectPreAggregatedMetrics._exceptionCountersCollection = [], 
     AutoCollectPreAggregatedMetrics._traceCountersCollection = [], this._client = client, 
     this._collectionInterval = collectionInterval;
    }
    return AutoCollectPreAggregatedMetrics.prototype.enable = function(isEnabled, collectionInterval) {
     var _this = this;
     this._isEnabled = isEnabled, this._isEnabled && !this._isInitialized && (this._isInitialized = !0), 
     isEnabled ? this._handle || (this._collectionInterval = collectionInterval || this._collectionInterval, 
     this._handle = setInterval((function() {
      return _this.trackPreAggregatedMetrics();
     }), this._collectionInterval), this._handle.unref()) : this._handle && (clearInterval(this._handle), 
     this._handle = void 0);
    }, AutoCollectPreAggregatedMetrics.countException = function(dimensions) {
     AutoCollectPreAggregatedMetrics.isEnabled() && AutoCollectPreAggregatedMetrics._getAggregatedCounter(dimensions, this._exceptionCountersCollection).totalCount++;
    }, AutoCollectPreAggregatedMetrics.countTrace = function(dimensions) {
     AutoCollectPreAggregatedMetrics.isEnabled() && AutoCollectPreAggregatedMetrics._getAggregatedCounter(dimensions, this._traceCountersCollection).totalCount++;
    }, AutoCollectPreAggregatedMetrics.countRequest = function(duration, dimensions) {
     if (AutoCollectPreAggregatedMetrics.isEnabled()) {
      var durationMs, counter = AutoCollectPreAggregatedMetrics._getAggregatedCounter(dimensions, this._requestCountersCollection);
      if ("string" == typeof duration) durationMs = +new Date("1970-01-01T" + duration + "Z"); else {
       if ("number" != typeof duration) return;
       durationMs = duration;
      }
      counter.intervalExecutionTime += durationMs, counter.totalCount++;
     }
    }, AutoCollectPreAggregatedMetrics.countDependency = function(duration, dimensions) {
     if (AutoCollectPreAggregatedMetrics.isEnabled()) {
      var durationMs, counter = AutoCollectPreAggregatedMetrics._getAggregatedCounter(dimensions, this._dependencyCountersCollection);
      if ("string" == typeof duration) durationMs = +new Date("1970-01-01T" + duration + "Z"); else {
       if ("number" != typeof duration) return;
       durationMs = duration;
      }
      counter.intervalExecutionTime += durationMs, counter.totalCount++;
     }
    }, AutoCollectPreAggregatedMetrics.prototype.isInitialized = function() {
     return this._isInitialized;
    }, AutoCollectPreAggregatedMetrics.isEnabled = function() {
     return AutoCollectPreAggregatedMetrics.INSTANCE && AutoCollectPreAggregatedMetrics.INSTANCE._isEnabled;
    }, AutoCollectPreAggregatedMetrics.prototype.trackPreAggregatedMetrics = function() {
     this._trackRequestMetrics(), this._trackDependencyMetrics(), this._trackExceptionMetrics(), 
     this._trackTraceMetrics();
    }, AutoCollectPreAggregatedMetrics._getAggregatedCounter = function(dimensions, counterCollection) {
     for (var notMatch = !1, i = 0; i < counterCollection.length; i++) {
      if (dimensions === counterCollection[i].dimensions) return counterCollection[i];
      if (Object.keys(dimensions).length === Object.keys(counterCollection[i].dimensions).length) {
       for (var dim in dimensions) if (dimensions[dim] != counterCollection[i].dimensions[dim]) {
        notMatch = !0;
        break;
       }
       if (!notMatch) return counterCollection[i];
       notMatch = !1;
      }
     }
     var newCounter = new AggregatedMetricCounters_1.AggregatedMetricCounter(dimensions);
     return counterCollection.push(newCounter), newCounter;
    }, AutoCollectPreAggregatedMetrics.prototype._trackRequestMetrics = function() {
     for (var i = 0; i < AutoCollectPreAggregatedMetrics._requestCountersCollection.length; i++) {
      var currentCounter = AutoCollectPreAggregatedMetrics._requestCountersCollection[i];
      currentCounter.time = +new Date;
      var intervalRequests = currentCounter.totalCount - currentCounter.lastTotalCount || 0, elapsedMs = currentCounter.time - currentCounter.lastTime, averageRequestExecutionTime = (currentCounter.intervalExecutionTime - currentCounter.lastIntervalExecutionTime) / intervalRequests || 0;
      currentCounter.lastIntervalExecutionTime = currentCounter.intervalExecutionTime, 
      elapsedMs > 0 && intervalRequests > 0 && this._trackPreAggregatedMetric({
       name: "Server response time",
       dimensions: currentCounter.dimensions,
       value: averageRequestExecutionTime,
       count: intervalRequests,
       aggregationInterval: elapsedMs,
       metricType: Constants.MetricId.REQUESTS_DURATION
      }), currentCounter.lastTotalCount = currentCounter.totalCount, currentCounter.lastTime = currentCounter.time;
     }
    }, AutoCollectPreAggregatedMetrics.prototype._trackDependencyMetrics = function() {
     for (var i = 0; i < AutoCollectPreAggregatedMetrics._dependencyCountersCollection.length; i++) {
      var currentCounter = AutoCollectPreAggregatedMetrics._dependencyCountersCollection[i];
      currentCounter.time = +new Date;
      var intervalDependencies = currentCounter.totalCount - currentCounter.lastTotalCount || 0, elapsedMs = currentCounter.time - currentCounter.lastTime, averageDependencyExecutionTime = (currentCounter.intervalExecutionTime - currentCounter.lastIntervalExecutionTime) / intervalDependencies || 0;
      currentCounter.lastIntervalExecutionTime = currentCounter.intervalExecutionTime, 
      elapsedMs > 0 && intervalDependencies > 0 && this._trackPreAggregatedMetric({
       name: "Dependency duration",
       dimensions: currentCounter.dimensions,
       value: averageDependencyExecutionTime,
       count: intervalDependencies,
       aggregationInterval: elapsedMs,
       metricType: Constants.MetricId.DEPENDENCIES_DURATION
      }), currentCounter.lastTotalCount = currentCounter.totalCount, currentCounter.lastTime = currentCounter.time;
     }
    }, AutoCollectPreAggregatedMetrics.prototype._trackExceptionMetrics = function() {
     for (var i = 0; i < AutoCollectPreAggregatedMetrics._exceptionCountersCollection.length; i++) {
      var currentCounter = AutoCollectPreAggregatedMetrics._exceptionCountersCollection[i];
      currentCounter.time = +new Date;
      var intervalExceptions = currentCounter.totalCount - currentCounter.lastTotalCount || 0, elapsedMs = currentCounter.time - currentCounter.lastTime;
      elapsedMs > 0 && intervalExceptions > 0 && this._trackPreAggregatedMetric({
       name: "Exceptions",
       dimensions: currentCounter.dimensions,
       value: intervalExceptions,
       count: intervalExceptions,
       aggregationInterval: elapsedMs,
       metricType: Constants.MetricId.EXCEPTIONS_COUNT
      }), currentCounter.lastTotalCount = currentCounter.totalCount, currentCounter.lastTime = currentCounter.time;
     }
    }, AutoCollectPreAggregatedMetrics.prototype._trackTraceMetrics = function() {
     for (var i = 0; i < AutoCollectPreAggregatedMetrics._traceCountersCollection.length; i++) {
      var currentCounter = AutoCollectPreAggregatedMetrics._traceCountersCollection[i];
      currentCounter.time = +new Date;
      var intervalTraces = currentCounter.totalCount - currentCounter.lastTotalCount || 0, elapsedMs = currentCounter.time - currentCounter.lastTime;
      elapsedMs > 0 && intervalTraces > 0 && this._trackPreAggregatedMetric({
       name: "Traces",
       dimensions: currentCounter.dimensions,
       value: intervalTraces,
       count: intervalTraces,
       aggregationInterval: elapsedMs,
       metricType: Constants.MetricId.TRACES_COUNT
      }), currentCounter.lastTotalCount = currentCounter.totalCount, currentCounter.lastTime = currentCounter.time;
     }
    }, AutoCollectPreAggregatedMetrics.prototype._trackPreAggregatedMetric = function(metric) {
     var metricProperties = {};
     for (var dim in metric.dimensions) metricProperties[AggregatedMetricDimensions_1.PreaggregatedMetricPropertyNames[dim]] = metric.dimensions[dim];
     metricProperties = __assign(__assign({}, metricProperties), {
      "_MS.MetricId": metric.metricType,
      "_MS.AggregationIntervalMs": String(metric.aggregationInterval),
      "_MS.IsAutocollected": "True"
     });
     var telemetry = {
      name: metric.name,
      value: metric.value,
      count: metric.count,
      properties: metricProperties,
      kind: "Aggregation"
     };
     this._client.trackMetric(telemetry);
    }, AutoCollectPreAggregatedMetrics.prototype.dispose = function() {
     AutoCollectPreAggregatedMetrics.INSTANCE = null, this.enable(!1), this._isInitialized = !1;
    }, AutoCollectPreAggregatedMetrics;
   }();
   module.exports = AutoCollectPreAggregatedMetrics;
  },
  13054: module => {
   "use strict";
   var RequestParser = function() {
    function RequestParser() {}
    return RequestParser.prototype.getUrl = function() {
     return this.url;
    }, RequestParser.prototype.RequestParser = function() {
     this.startTime = +new Date;
    }, RequestParser.prototype._setStatus = function(status, error) {
     var endTime = +new Date;
     this.duration = endTime - this.startTime, this.statusCode = status;
     var properties = this.properties || {};
     if (error) if ("string" == typeof error) properties.error = error; else if (error instanceof Error) properties.error = error.message; else if ("object" == typeof error) for (var key in error) properties[key] = error[key] && error[key].toString && error[key].toString();
     this.properties = properties;
    }, RequestParser.prototype._isSuccess = function() {
     return 0 < this.statusCode && this.statusCode < 400;
    }, RequestParser;
   }();
   module.exports = RequestParser;
  },
  49004: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var __assign = this && this.__assign || function() {
    return __assign = Object.assign || function(t) {
     for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
     return t;
    }, __assign.apply(this, arguments);
   }, __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }, __generator = this && this.__generator || function(thisArg, body) {
    var f, y, t, g, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    };
    return g = {
     next: verb(0),
     throw: verb(1),
     return: verb(2)
    }, "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;_; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   }, os = __webpack_require__(22037), EnvelopeFactory = __webpack_require__(99813), Logging = __webpack_require__(95282), Sender = __webpack_require__(82588), Constants = __webpack_require__(63580), Contracts = __webpack_require__(55290), Vm = __webpack_require__(32713), Config = __webpack_require__(69253), Context = __webpack_require__(54470), Network = __webpack_require__(64555), Util = __webpack_require__(25740), Statsbeat = function() {
    function Statsbeat(config, context) {
     this._attach = Constants.StatsbeatAttach.sdk, this._feature = Constants.StatsbeatFeature.NONE, 
     this._instrumentation = Constants.StatsbeatInstrumentation.NONE, this._isInitialized = !1, 
     this._statbeatMetrics = [], this._networkStatsbeatCollection = [], this._config = config, 
     this._context = context || new Context;
     var statsbeatConnectionString = this._getConnectionString(config);
     this._statsbeatConfig = new Config(statsbeatConnectionString), this._statsbeatConfig.samplingPercentage = 100, 
     this._sender = new Sender(this._statsbeatConfig, null, null, null, null, !0, this._shutdownStatsbeat.bind(this));
    }
    return Statsbeat.prototype.enable = function(isEnabled) {
     var _this = this;
     this._isEnabled = isEnabled, this._isEnabled && !this._isInitialized && (this._getCustomProperties(), 
     this._isInitialized = !0), isEnabled ? (this._handle || (this._handle = setInterval((function() {
      _this.trackShortIntervalStatsbeats();
     }), Statsbeat.STATS_COLLECTION_SHORT_INTERVAL), this._handle.unref()), this._longHandle || (this.trackLongIntervalStatsbeats(), 
     this._longHandle = setInterval((function() {
      _this.trackLongIntervalStatsbeats();
     }), Statsbeat.STATS_COLLECTION_LONG_INTERVAL), this._longHandle.unref())) : (this._handle && (clearInterval(this._handle), 
     this._handle = null), this._longHandle && (clearInterval(this._longHandle), this._longHandle = null));
    }, Statsbeat.prototype.isInitialized = function() {
     return this._isInitialized;
    }, Statsbeat.prototype.isEnabled = function() {
     return this._isEnabled;
    }, Statsbeat.prototype.setCodelessAttach = function() {
     this._attach = Constants.StatsbeatAttach.codeless;
    }, Statsbeat.prototype.addFeature = function(feature) {
     this._feature |= feature;
    }, Statsbeat.prototype.removeFeature = function(feature) {
     this._feature &= ~feature;
    }, Statsbeat.prototype.addInstrumentation = function(instrumentation) {
     this._instrumentation |= instrumentation;
    }, Statsbeat.prototype.removeInstrumentation = function(instrumentation) {
     this._instrumentation &= ~instrumentation;
    }, Statsbeat.prototype.countRequest = function(endpoint, host, duration, success, statusCode) {
     if (this.isEnabled()) {
      var counter = this._getNetworkStatsbeatCounter(endpoint, host);
      if (counter.totalRequestCount++, counter.intervalRequestExecutionTime += duration, 
      !1 === success) {
       if (!statusCode) return;
       var currentStatusCounter = counter.totalFailedRequestCount.find((function(statusCounter) {
        return statusCode === statusCounter.statusCode;
       }));
       currentStatusCounter ? currentStatusCounter.count++ : counter.totalFailedRequestCount.push({
        statusCode,
        count: 1
       });
      } else counter.totalSuccesfulRequestCount++;
     }
    }, Statsbeat.prototype.countException = function(endpoint, host, exceptionType) {
     if (this.isEnabled()) {
      var counter = this._getNetworkStatsbeatCounter(endpoint, host), currentErrorCounter = counter.exceptionCount.find((function(exceptionCounter) {
       return exceptionType.name === exceptionCounter.exceptionType;
      }));
      currentErrorCounter ? currentErrorCounter.count++ : counter.exceptionCount.push({
       exceptionType: exceptionType.name,
       count: 1
      });
     }
    }, Statsbeat.prototype.countThrottle = function(endpoint, host, statusCode) {
     if (this.isEnabled()) {
      var counter = this._getNetworkStatsbeatCounter(endpoint, host), currentStatusCounter = counter.throttleCount.find((function(statusCounter) {
       return statusCode === statusCounter.statusCode;
      }));
      currentStatusCounter ? currentStatusCounter.count++ : counter.throttleCount.push({
       statusCode,
       count: 1
      });
     }
    }, Statsbeat.prototype.countRetry = function(endpoint, host, statusCode) {
     if (this.isEnabled()) {
      var counter = this._getNetworkStatsbeatCounter(endpoint, host), currentStatusCounter = counter.retryCount.find((function(statusCounter) {
       return statusCode === statusCounter.statusCode;
      }));
      currentStatusCounter ? currentStatusCounter.count++ : counter.retryCount.push({
       statusCode,
       count: 1
      });
     }
    }, Statsbeat.prototype.trackShortIntervalStatsbeats = function() {
     return __awaiter(this, void 0, void 0, (function() {
      var networkProperties, error_1;
      return __generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return _a.trys.push([ 0, 3, , 4 ]), [ 4, this._getResourceProvider() ];

       case 1:
        return _a.sent(), networkProperties = {
         os: this._os,
         rp: this._resourceProvider,
         cikey: this._cikey,
         runtimeVersion: this._runtimeVersion,
         language: this._language,
         version: this._sdkVersion,
         attach: this._attach
        }, this._trackRequestDuration(networkProperties), this._trackRequestsCount(networkProperties), 
        [ 4, this._sendStatsbeats() ];

       case 2:
        return _a.sent(), [ 3, 4 ];

       case 3:
        return error_1 = _a.sent(), Logging.info(Statsbeat.TAG, "Failed to send Statsbeat metrics: " + Util.dumpObj(error_1)), 
        [ 3, 4 ];

       case 4:
        return [ 2 ];
       }
      }));
     }));
    }, Statsbeat.prototype.trackLongIntervalStatsbeats = function() {
     return __awaiter(this, void 0, void 0, (function() {
      var commonProperties, attachProperties, instrumentationProperties, featureProperties, error_2;
      return __generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return _a.trys.push([ 0, 3, , 4 ]), [ 4, this._getResourceProvider() ];

       case 1:
        return _a.sent(), commonProperties = {
         os: this._os,
         rp: this._resourceProvider,
         cikey: this._cikey,
         runtimeVersion: this._runtimeVersion,
         language: this._language,
         version: this._sdkVersion,
         attach: this._attach
        }, attachProperties = Object.assign({
         rpId: this._resourceIdentifier
        }, commonProperties), this._statbeatMetrics.push({
         name: Constants.StatsbeatCounter.ATTACH,
         value: 1,
         properties: attachProperties
        }), this._instrumentation != Constants.StatsbeatInstrumentation.NONE && (instrumentationProperties = Object.assign({
         feature: this._instrumentation,
         type: Constants.StatsbeatFeatureType.Instrumentation
        }, commonProperties), this._statbeatMetrics.push({
         name: Constants.StatsbeatCounter.FEATURE,
         value: 1,
         properties: instrumentationProperties
        })), this._feature != Constants.StatsbeatFeature.NONE && (featureProperties = Object.assign({
         feature: this._feature,
         type: Constants.StatsbeatFeatureType.Feature
        }, commonProperties), this._statbeatMetrics.push({
         name: Constants.StatsbeatCounter.FEATURE,
         value: 1,
         properties: featureProperties
        })), [ 4, this._sendStatsbeats() ];

       case 2:
        return _a.sent(), [ 3, 4 ];

       case 3:
        return error_2 = _a.sent(), Logging.info(Statsbeat.TAG, "Failed to send Statsbeat metrics: " + Util.dumpObj(error_2)), 
        [ 3, 4 ];

       case 4:
        return [ 2 ];
       }
      }));
     }));
    }, Statsbeat.prototype._getNetworkStatsbeatCounter = function(endpoint, host) {
     for (var shortHost = this._getShortHost(host), i = 0; i < this._networkStatsbeatCollection.length; i++) if (endpoint === this._networkStatsbeatCollection[i].endpoint && shortHost === this._networkStatsbeatCollection[i].host) return this._networkStatsbeatCollection[i];
     var newCounter = new Network.NetworkStatsbeat(endpoint, shortHost);
     return this._networkStatsbeatCollection.push(newCounter), newCounter;
    }, Statsbeat.prototype._trackRequestDuration = function(commonProperties) {
     for (var i = 0; i < this._networkStatsbeatCollection.length; i++) {
      var currentCounter = this._networkStatsbeatCollection[i];
      currentCounter.time = +new Date;
      var intervalRequests = currentCounter.totalRequestCount - currentCounter.lastRequestCount || 0, totalRequestExecutionTime = currentCounter.intervalRequestExecutionTime - currentCounter.lastIntervalRequestExecutionTime, averageRequestExecutionTime = totalRequestExecutionTime > 0 && totalRequestExecutionTime / intervalRequests || 0;
      if (currentCounter.lastIntervalRequestExecutionTime = currentCounter.intervalRequestExecutionTime, 
      intervalRequests > 0) {
       var properties = Object.assign({
        endpoint: this._networkStatsbeatCollection[i].endpoint,
        host: this._networkStatsbeatCollection[i].host
       }, commonProperties);
       this._statbeatMetrics.push({
        name: Constants.StatsbeatCounter.REQUEST_DURATION,
        value: averageRequestExecutionTime,
        properties
       });
      }
      currentCounter.lastRequestCount = currentCounter.totalRequestCount, currentCounter.lastTime = currentCounter.time;
     }
    }, Statsbeat.prototype._getShortHost = function(originalHost) {
     var shortHost = originalHost;
     try {
      var res = new RegExp(/^https?:\/\/(?:www\.)?([^\/.-]+)/).exec(originalHost);
      null != res && res.length > 1 && (shortHost = res[1]), shortHost = shortHost.replace(".in.applicationinsights.azure.com", "");
     } catch (error) {}
     return shortHost;
    }, Statsbeat.prototype._trackRequestsCount = function(commonProperties) {
     for (var currentCounter, _this = this, _loop_1 = function(i) {
      currentCounter = this_1._networkStatsbeatCollection[i];
      var properties = Object.assign({
       endpoint: currentCounter.endpoint,
       host: currentCounter.host
      }, commonProperties);
      currentCounter.totalSuccesfulRequestCount > 0 && (this_1._statbeatMetrics.push({
       name: Constants.StatsbeatCounter.REQUEST_SUCCESS,
       value: currentCounter.totalSuccesfulRequestCount,
       properties
      }), currentCounter.totalSuccesfulRequestCount = 0), currentCounter.totalFailedRequestCount.length > 0 && (currentCounter.totalFailedRequestCount.forEach((function(currentCounter) {
       properties = Object.assign(__assign(__assign({}, properties), {
        statusCode: currentCounter.statusCode
       })), _this._statbeatMetrics.push({
        name: Constants.StatsbeatCounter.REQUEST_FAILURE,
        value: currentCounter.count,
        properties
       });
      })), currentCounter.totalFailedRequestCount = []), currentCounter.retryCount.length > 0 && (currentCounter.retryCount.forEach((function(currentCounter) {
       properties = Object.assign(__assign(__assign({}, properties), {
        statusCode: currentCounter.statusCode
       })), _this._statbeatMetrics.push({
        name: Constants.StatsbeatCounter.RETRY_COUNT,
        value: currentCounter.count,
        properties
       });
      })), currentCounter.retryCount = []), currentCounter.throttleCount.length > 0 && (currentCounter.throttleCount.forEach((function(currentCounter) {
       properties = Object.assign(__assign(__assign({}, properties), {
        statusCode: currentCounter.statusCode
       })), _this._statbeatMetrics.push({
        name: Constants.StatsbeatCounter.THROTTLE_COUNT,
        value: currentCounter.count,
        properties
       });
      })), currentCounter.throttleCount = []), currentCounter.exceptionCount.length > 0 && (currentCounter.exceptionCount.forEach((function(currentCounter) {
       properties = Object.assign(__assign(__assign({}, properties), {
        exceptionType: currentCounter.exceptionType
       })), _this._statbeatMetrics.push({
        name: Constants.StatsbeatCounter.EXCEPTION_COUNT,
        value: currentCounter.count,
        properties
       });
      })), currentCounter.exceptionCount = []);
     }, this_1 = this, i = 0; i < this._networkStatsbeatCollection.length; i++) _loop_1(i);
    }, Statsbeat.prototype._sendStatsbeats = function() {
     return __awaiter(this, void 0, void 0, (function() {
      var envelopes, i, statsbeat, envelope;
      return __generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        for (envelopes = [], i = 0; i < this._statbeatMetrics.length; i++) statsbeat = {
         name: this._statbeatMetrics[i].name,
         value: this._statbeatMetrics[i].value,
         properties: this._statbeatMetrics[i].properties
        }, (envelope = EnvelopeFactory.createEnvelope(statsbeat, Contracts.TelemetryType.Metric, null, this._context, this._statsbeatConfig)).name = Constants.StatsbeatTelemetryName, 
        envelopes.push(envelope);
        return this._statbeatMetrics = [], [ 4, this._sender.send(envelopes) ];

       case 1:
        return _a.sent(), [ 2 ];
       }
      }));
     }));
    }, Statsbeat.prototype._getCustomProperties = function() {
     this._language = "node", this._cikey = this._config.instrumentationKey, this._sdkVersion = Context.sdkVersion, 
     this._os = os.type(), this._runtimeVersion = process.version;
    }, Statsbeat.prototype._getResourceProvider = function() {
     var _this = this;
     return new Promise((function(resolve, reject) {
      var waiting = !1;
      _this._resourceProvider = Constants.StatsbeatResourceProvider.unknown, _this._resourceIdentifier = Constants.StatsbeatResourceProvider.unknown, 
      process.env.WEBSITE_SITE_NAME ? (_this._resourceProvider = Constants.StatsbeatResourceProvider.appsvc, 
      _this._resourceIdentifier = process.env.WEBSITE_SITE_NAME, process.env.WEBSITE_HOME_STAMPNAME && (_this._resourceIdentifier += "/" + process.env.WEBSITE_HOME_STAMPNAME)) : process.env.FUNCTIONS_WORKER_RUNTIME ? (_this._resourceProvider = Constants.StatsbeatResourceProvider.functions, 
      process.env.WEBSITE_HOSTNAME && (_this._resourceIdentifier = process.env.WEBSITE_HOSTNAME)) : _this._config && (void 0 === _this._isVM || 1 == _this._isVM ? (waiting = !0, 
      Vm.AzureVirtualMachine.getAzureComputeMetadata(_this._config, (function(vmInfo) {
       _this._isVM = vmInfo.isVM, _this._isVM && (_this._resourceProvider = Constants.StatsbeatResourceProvider.vm, 
       _this._resourceIdentifier = vmInfo.id + "/" + vmInfo.subscriptionId, vmInfo.osType && (_this._os = vmInfo.osType)), 
       resolve();
      }))) : _this._resourceProvider = Constants.StatsbeatResourceProvider.unknown), waiting || resolve();
     }));
    }, Statsbeat.prototype._shutdownStatsbeat = function() {
     this.enable(!1);
    }, Statsbeat.prototype._getConnectionString = function(config) {
     for (var currentEndpoint = config.endpointUrl, euEndpoints = [ "westeurope", "northeurope", "francecentral", "francesouth", "germanywestcentral", "norwayeast", "norwaywest", "swedencentral", "switzerlandnorth", "switzerlandwest", "uksouth", "ukwest" ], i = 0; i < euEndpoints.length; i++) if (currentEndpoint.indexOf(euEndpoints[i]) > -1) return Statsbeat.EU_CONNECTION_STRING;
     return Statsbeat.NON_EU_CONNECTION_STRING;
    }, Statsbeat.NON_EU_CONNECTION_STRING = "InstrumentationKey=c4a29126-a7cb-47e5-b348-11414998b11e;IngestionEndpoint=https://westus-0.in.applicationinsights.azure.com", 
    Statsbeat.EU_CONNECTION_STRING = "InstrumentationKey=7dc56bab-3c0c-4e9f-9ebb-d1acadee8d0f;IngestionEndpoint=https://westeurope-5.in.applicationinsights.azure.com", 
    Statsbeat.STATS_COLLECTION_SHORT_INTERVAL = 9e5, Statsbeat.STATS_COLLECTION_LONG_INTERVAL = 864e5, 
    Statsbeat.TAG = "Statsbeat", Statsbeat;
   }();
   module.exports = Statsbeat;
  },
  11918: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var http = __webpack_require__(13685), https = __webpack_require__(95687), zlib = __webpack_require__(59796), Logging = __webpack_require__(95282), snippetInjectionHelper = __webpack_require__(82570), prefixHelper = __webpack_require__(40095), Constants = __webpack_require__(63580), ConnectionStringParser = __webpack_require__(55158), applicationinsights_web_snippet_1 = __webpack_require__(40166), WebSnippet = function() {
    function WebSnippet(client) {
     var _a;
     if (this._isIkeyValid = !0, WebSnippet.INSTANCE) throw new Error("Web snippet injection should be configured from the applicationInsights object");
     WebSnippet.INSTANCE = this, WebSnippet._aiUrl = Constants.WEB_INSTRUMENTATION_DEFAULT_SOURCE, 
     WebSnippet._aiDeprecatedUrl = Constants.WEB_INSTRUMENTATION_DEPRECATED_SOURCE;
     var clientWebIkey = this._getWebSnippetIkey(null === (_a = client.config) || void 0 === _a ? void 0 : _a.webInstrumentationConnectionString);
     this._webInstrumentationIkey = clientWebIkey || client.config.instrumentationKey, 
     this._clientWebInstrumentationConfig = client.config.webInstrumentationConfig, this._clientWebInstrumentationSrc = client.config.webInstrumentationSrc, 
     this._statsbeat = client.getStatsbeat();
    }
    return WebSnippet.prototype.enable = function(isEnabled, webInstrumentationConnectionString) {
     this._isEnabled = isEnabled, this._webInstrumentationIkey = this._getWebSnippetIkey(webInstrumentationConnectionString) || this._webInstrumentationIkey, 
     WebSnippet._snippet = this._getWebInstrumentationReplacedStr(), this._isEnabled && !this._isInitialized && this._isIkeyValid ? (this._statsbeat && this._statsbeat.addFeature(Constants.StatsbeatFeature.WEB_SNIPPET), 
     this._initialize()) : this._isEnabled || this._statsbeat && this._statsbeat.removeFeature(Constants.StatsbeatFeature.WEB_SNIPPET);
    }, WebSnippet.prototype.isInitialized = function() {
     return this._isInitialized;
    }, WebSnippet.prototype._getWebSnippetIkey = function(connectionString) {
     var iKey = null;
     try {
      var iKeyCode = ConnectionStringParser.parse(connectionString).instrumentationkey || "";
      ConnectionStringParser.isIkeyValid(iKeyCode) ? (this._isIkeyValid = !0, iKey = iKeyCode) : (this._isIkeyValid = !1, 
      Logging.info("Invalid web Instrumentation connection string, web Instrumentation is not enabled."));
     } catch (err) {
      Logging.info("get web snippet ikey error: " + err);
     }
     return iKey;
    }, WebSnippet.prototype._getWebInstrumentationReplacedStr = function() {
     var configStr = this._getClientWebInstrumentationConfigStr(this._clientWebInstrumentationConfig), osStr = prefixHelper.getOsPrefix(), rpStr = prefixHelper.getResourceProvider(), snippetReplacedStr = this._webInstrumentationIkey + '",\r\n' + configStr + ' disableIkeyDeprecationMessage: true,\r\n sdkExtension: "' + rpStr + osStr + "d_n_", replacedSnippet = applicationinsights_web_snippet_1.webSnippet.replace("INSTRUMENTATION_KEY", snippetReplacedStr);
     return this._clientWebInstrumentationSrc ? replacedSnippet.replace(Constants.WEB_INSTRUMENTATION_DEFAULT_SOURCE + ".2.min.js", this._clientWebInstrumentationSrc) : replacedSnippet;
    }, WebSnippet.prototype._getClientWebInstrumentationConfigStr = function(config) {
     var configStr = "";
     try {
      null != config && config.length > 0 && config.forEach((function(item) {
       var key = item.name;
       if (void 0 !== key) {
        var val = item.value;
        switch (typeof val) {
        case "function":
        case "object":
         break;

        case "string":
         configStr += " " + key + ': "' + val + '",\r\n';
         break;

        default:
         configStr += " " + key + ": " + val + ",\r\n";
        }
       }
      }));
     } catch (e) {
      this._isEnabled = !1, Logging.info("Parse client web instrumentation error. Web Instrumentation is disabled");
     }
     return configStr;
    }, WebSnippet.prototype._initialize = function() {
     this._isInitialized = !0;
     var originalHttpServer = http.createServer, originalHttpsServer = https.createServer, isEnabled = this._isEnabled;
     http.createServer = function(requestListener) {
      var originalRequestListener = requestListener;
      return originalRequestListener && (requestListener = function(request, response) {
       var originalResponseWrite = response.write, isGetRequest = "GET" == request.method;
       response.write = function(a, b, c) {
        try {
         if (isEnabled && isGetRequest) {
          var headers = snippetInjectionHelper.getContentEncodingFromHeaders(response), writeBufferType = void 0;
          if ("string" == typeof b && (writeBufferType = b), null == headers) WebSnippet.INSTANCE.ValidateInjection(response, a) && (arguments[0] = WebSnippet.INSTANCE.InjectWebSnippet(response, a, void 0, writeBufferType)); else if (headers.length) {
           var encodeType = headers[0];
           arguments[0] = WebSnippet.INSTANCE.InjectWebSnippet(response, a, encodeType);
          }
         }
        } catch (err) {
         Logging.warn("Inject snippet error: " + err);
        }
        return originalResponseWrite.apply(response, arguments);
       };
       var originalResponseEnd = response.end;
       return response.end = function(a, b, c) {
        if (isEnabled && isGetRequest) try {
         if (isEnabled && isGetRequest) {
          var headers = snippetInjectionHelper.getContentEncodingFromHeaders(response), endBufferType = void 0;
          if ("string" == typeof b && (endBufferType = b), null == headers) WebSnippet.INSTANCE.ValidateInjection(response, a) && (arguments[0] = WebSnippet.INSTANCE.InjectWebSnippet(response, a, void 0, endBufferType)); else if (headers.length) {
           var encodeType = headers[0];
           arguments[0] = WebSnippet.INSTANCE.InjectWebSnippet(response, a, encodeType);
          }
         }
        } catch (err) {
         Logging.warn("Inject snipet error: " + err);
        }
        return originalResponseEnd.apply(response, arguments);
       }, originalRequestListener(request, response);
      }), originalHttpServer(requestListener);
     }, https.createServer = function(options, httpsRequestListener) {
      var originalHttpsRequestListener = httpsRequestListener;
      if (originalHttpsRequestListener) return httpsRequestListener = function(req, res) {
       var isGetHttpsRequest = "GET" == req.method, originalHttpsResponseWrite = res.write, originalHttpsResponseEnd = res.end;
       return res.write = function(a, b, c) {
        try {
         if (isEnabled && isGetHttpsRequest) {
          var headers = snippetInjectionHelper.getContentEncodingFromHeaders(res), writeBufferType = void 0;
          if ("string" == typeof b && (writeBufferType = b), null == headers) WebSnippet.INSTANCE.ValidateInjection(res, a) && (arguments[0] = this.InjectWebSnippet(res, a, void 0, writeBufferType)); else if (headers.length) {
           var encodeType = headers[0];
           arguments[0] = WebSnippet.INSTANCE.InjectWebSnippet(res, a, encodeType);
          }
         }
        } catch (err) {
         Logging.warn("Inject snippet error: " + err);
        }
        return originalHttpsResponseWrite.apply(res, arguments);
       }, res.end = function(a, b, c) {
        try {
         if (isEnabled && isGetHttpsRequest) {
          var headers = snippetInjectionHelper.getContentEncodingFromHeaders(res), endBufferType = void 0;
          if ("string" == typeof b && (endBufferType = b), null == headers) WebSnippet.INSTANCE.ValidateInjection(res, a) && (arguments[0] = WebSnippet.INSTANCE.InjectWebSnippet(res, a, void 0, endBufferType)); else if (headers.length) {
           var encodeType = headers[0];
           arguments[0] = WebSnippet.INSTANCE.InjectWebSnippet(res, a, encodeType);
          }
         }
        } catch (err) {
         Logging.warn("Inject snippet error: " + err);
        }
        return originalHttpsResponseEnd.apply(res, arguments);
       }, originalHttpsRequestListener(req, res);
      }, originalHttpsServer(options, httpsRequestListener);
     };
    }, WebSnippet.prototype.ValidateInjection = function(response, input) {
     try {
      if (!response || !input || 200 != response.statusCode) return !1;
      if (!snippetInjectionHelper.isContentTypeHeaderHtml(response)) return !1;
      var inputStr = input.slice().toString();
      if (inputStr.indexOf("<head>") >= 0 && inputStr.indexOf("</head>") >= 0 && inputStr.indexOf(WebSnippet._aiUrl) < 0 && inputStr.indexOf(WebSnippet._aiDeprecatedUrl) < 0) return !0;
     } catch (err) {
      Logging.info("validate injections error: " + err);
     }
     return !1;
    }, WebSnippet.prototype.InjectWebSnippet = function(response, input, encodeType, bufferEncodeType) {
     try {
      if (!!encodeType) response.removeHeader("Content-Length"), input = this._getInjectedCompressBuffer(response, input, encodeType), 
      response.setHeader("Content-Length", input.length); else {
       var html = input.toString(), index = html.indexOf("</head>");
       if (index < 0) return input;
       var newHtml = snippetInjectionHelper.insertSnippetByIndex(index, html, WebSnippet._snippet);
       if ("string" == typeof input) response.removeHeader("Content-Length"), input = newHtml, 
       response.setHeader("Content-Length", Buffer.byteLength(input)); else if (Buffer.isBuffer(input)) {
        var bufferType = bufferEncodeType || "utf8";
        if (snippetInjectionHelper.isBufferType(input, bufferType)) {
         response.removeHeader("Content-Length");
         var encodedString = Buffer.from(newHtml).toString(bufferType);
         input = Buffer.from(encodedString, bufferType), response.setHeader("Content-Length", input.length);
        }
       }
      }
     } catch (ex) {
      Logging.warn("Failed to inject web snippet and change content-lenght headers. Exception:" + ex);
     }
     return input;
    }, WebSnippet.prototype._getInjectedCompressBuffer = function(response, input, encodeType) {
     try {
      switch (encodeType) {
      case snippetInjectionHelper.contentEncodingMethod.GZIP:
       var gunzipBuffer = zlib.gunzipSync(input);
       if (this.ValidateInjection(response, gunzipBuffer)) {
        var injectedGunzipBuffer = this.InjectWebSnippet(response, gunzipBuffer);
        input = zlib.gzipSync(injectedGunzipBuffer);
       }
       break;

      case snippetInjectionHelper.contentEncodingMethod.DEFLATE:
       var inflateBuffer = zlib.inflateSync(input);
       if (this.ValidateInjection(response, inflateBuffer)) {
        var injectedInflateBuffer = this.InjectWebSnippet(response, inflateBuffer);
        input = zlib.deflateSync(injectedInflateBuffer);
       }
       break;

      case snippetInjectionHelper.contentEncodingMethod.BR:
       var BrotliDecompressSync = snippetInjectionHelper.getBrotliDecompressSync(zlib), BrotliCompressSync = snippetInjectionHelper.getBrotliCompressSync(zlib);
       if (BrotliDecompressSync && BrotliCompressSync) {
        var decompressBuffer = BrotliDecompressSync(input);
        if (this.ValidateInjection(response, decompressBuffer)) input = BrotliCompressSync(this.InjectWebSnippet(response, decompressBuffer));
        break;
       }
      }
     } catch (err) {
      Logging.info("get web injection compress buffer error: " + err);
     }
     return input;
    }, WebSnippet.prototype.dispose = function() {
     WebSnippet.INSTANCE = null, this.enable(!1), this._isInitialized = !1;
    }, WebSnippet;
   }();
   module.exports = WebSnippet;
  },
  60211: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __assign = this && this.__assign || function() {
    return __assign = Object.assign || function(t) {
     for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
     return t;
    }, __assign.apply(this, arguments);
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.parseEventHubSpan = void 0;
   var api_1 = __webpack_require__(94284), core_1 = __webpack_require__(47593), semantic_conventions_1 = __webpack_require__(47480), Constants_1 = __webpack_require__(63580);
   exports.parseEventHubSpan = function(span, telemetry) {
    var _a, namespace = span.attributes[Constants_1.AzNamespace], peerAddress = (span.attributes[semantic_conventions_1.SemanticAttributes.NET_PEER_NAME] || span.attributes["peer.address"] || "unknown").replace(/\/$/g, ""), messageBusDestination = span.attributes[Constants_1.MessageBusDestination] || "unknown";
    switch (span.kind) {
    case api_1.SpanKind.CLIENT:
     telemetry.dependencyTypeName = namespace, telemetry.target = peerAddress + "/" + messageBusDestination;
     break;

    case api_1.SpanKind.PRODUCER:
     telemetry.dependencyTypeName = Constants_1.DependencyTypeName.QueueMessage + " | " + namespace, 
     telemetry.target = peerAddress + "/" + messageBusDestination;
     break;

    case api_1.SpanKind.CONSUMER:
     telemetry.source = peerAddress + "/" + messageBusDestination, telemetry.measurements = __assign(__assign({}, telemetry.measurements), ((_a = {})[Constants_1.TIME_SINCE_ENQUEUED] = function(span) {
      var countEnqueueDiffs = 0, sumEnqueueDiffs = 0, startTimeMs = core_1.hrTimeToMilliseconds(span.startTime);
      return span.links.forEach((function(_a) {
       var attributes = _a.attributes, enqueuedTime = null == attributes ? void 0 : attributes[Constants_1.ENQUEUED_TIME];
       enqueuedTime && (countEnqueueDiffs += 1, sumEnqueueDiffs += startTimeMs - (parseFloat(enqueuedTime.toString()) || 0));
      })), Math.max(sumEnqueueDiffs / (countEnqueueDiffs || 1), 0);
     }(span), _a));
    }
   };
  },
  65946: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.spanToTelemetryContract = void 0;
   var url_1 = __webpack_require__(57310), api_1 = __webpack_require__(94284), semantic_conventions_1 = __webpack_require__(47480), Constants = __webpack_require__(63580), EventHub_1 = __webpack_require__(60211), Util = __webpack_require__(25740);
   function getUrl(span) {
    if (span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_METHOD]) {
     var httpUrl = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_URL];
     if (httpUrl) return String(httpUrl);
     var httpScheme = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_SCHEME], httpTarget = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_TARGET];
     if (httpScheme && httpTarget) {
      var httpHost = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_HOST];
      if (httpHost) return httpScheme + "://" + httpHost + httpTarget;
      var netPeerPort = span.attributes[semantic_conventions_1.SemanticAttributes.NET_PEER_PORT];
      if (netPeerPort) {
       var netPeerName = span.attributes[semantic_conventions_1.SemanticAttributes.NET_PEER_NAME];
       if (netPeerName) return httpScheme + "://" + netPeerName + ":" + netPeerPort + httpTarget;
       var netPeerIp = span.attributes[semantic_conventions_1.SemanticAttributes.NET_PEER_IP];
       if (netPeerIp) return httpScheme + "://" + netPeerIp + ":" + netPeerPort + httpTarget;
      }
     }
    }
    return "";
   }
   function getDependencyTarget(span) {
    var peerService = span.attributes[semantic_conventions_1.SemanticAttributes.PEER_SERVICE], httpHost = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_HOST], httpUrl = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_URL], netPeerName = span.attributes[semantic_conventions_1.SemanticAttributes.NET_PEER_NAME], netPeerIp = span.attributes[semantic_conventions_1.SemanticAttributes.NET_PEER_IP];
    return peerService ? String(peerService) : httpHost ? String(httpHost) : httpUrl ? String(httpUrl) : netPeerName ? String(netPeerName) : netPeerIp ? String(netPeerIp) : "";
   }
   function createDependencyData(span) {
    var remoteDependency = {
     name: span.name,
     success: span.status.code != api_1.SpanStatusCode.ERROR,
     resultCode: "0",
     duration: 0,
     data: "",
     dependencyTypeName: ""
    };
    span.kind === api_1.SpanKind.PRODUCER && (remoteDependency.dependencyTypeName = Constants.DependencyTypeName.QueueMessage), 
    span.kind === api_1.SpanKind.INTERNAL && span.parentSpanId && (remoteDependency.dependencyTypeName = Constants.DependencyTypeName.InProc);
    var httpMethod = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_METHOD], dbSystem = span.attributes[semantic_conventions_1.SemanticAttributes.DB_SYSTEM], rpcSystem = span.attributes[semantic_conventions_1.SemanticAttributes.RPC_SYSTEM];
    if (httpMethod) {
     remoteDependency.dependencyTypeName = Constants.DependencyTypeName.Http;
     var httpUrl = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_URL];
     if (httpUrl) {
      var pathName = "";
      try {
       pathName = new url_1.URL(String(httpUrl)).pathname;
      } catch (ex) {}
      remoteDependency.name = httpMethod + " " + pathName;
     }
     remoteDependency.data = getUrl(span);
     var httpStatusCode = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_STATUS_CODE];
     if (httpStatusCode && (remoteDependency.resultCode = String(httpStatusCode)), target = getDependencyTarget(span)) {
      try {
       var res = new RegExp(/(https?)(:\/\/.*)(:\d+)(\S*)/).exec(target);
       if (null != res) {
        var protocol = res[1], port = res[3];
        ("https" == protocol && ":443" == port || "http" == protocol && ":80" == port) && (target = res[1] + res[2] + res[4]);
       }
      } catch (error) {}
      remoteDependency.target = "" + target;
     }
    } else if (dbSystem) {
     String(dbSystem) === semantic_conventions_1.DbSystemValues.MYSQL ? remoteDependency.dependencyTypeName = "mysql" : String(dbSystem) === semantic_conventions_1.DbSystemValues.POSTGRESQL ? remoteDependency.dependencyTypeName = "postgresql" : String(dbSystem) === semantic_conventions_1.DbSystemValues.MONGODB ? remoteDependency.dependencyTypeName = "mongodb" : String(dbSystem) === semantic_conventions_1.DbSystemValues.REDIS ? remoteDependency.dependencyTypeName = "redis" : !function(dbSystem) {
      return dbSystem === semantic_conventions_1.DbSystemValues.DB2 || dbSystem === semantic_conventions_1.DbSystemValues.DERBY || dbSystem === semantic_conventions_1.DbSystemValues.MARIADB || dbSystem === semantic_conventions_1.DbSystemValues.MSSQL || dbSystem === semantic_conventions_1.DbSystemValues.ORACLE || dbSystem === semantic_conventions_1.DbSystemValues.SQLITE || dbSystem === semantic_conventions_1.DbSystemValues.OTHER_SQL || dbSystem === semantic_conventions_1.DbSystemValues.HSQLDB || dbSystem === semantic_conventions_1.DbSystemValues.H2;
     }(String(dbSystem)) ? remoteDependency.dependencyTypeName = String(dbSystem) : remoteDependency.dependencyTypeName = "SQL";
     var dbStatement = span.attributes[semantic_conventions_1.SemanticAttributes.DB_STATEMENT], dbOperation = span.attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION];
     dbStatement ? remoteDependency.data = String(dbStatement) : dbOperation && (remoteDependency.data = String(dbOperation));
     var target = getDependencyTarget(span), dbName = span.attributes[semantic_conventions_1.SemanticAttributes.DB_NAME];
     remoteDependency.target = target ? dbName ? target + "|" + dbName : "" + target : dbName ? "" + dbName : "" + dbSystem;
    } else if (rpcSystem) {
     remoteDependency.dependencyTypeName = Constants.DependencyTypeName.Grpc;
     var grpcStatusCode = span.attributes[semantic_conventions_1.SemanticAttributes.RPC_GRPC_STATUS_CODE];
     grpcStatusCode && (remoteDependency.resultCode = String(grpcStatusCode)), (target = getDependencyTarget(span)) ? remoteDependency.target = "" + target : rpcSystem && (remoteDependency.target = String(rpcSystem));
    }
    return remoteDependency;
   }
   exports.spanToTelemetryContract = function(span) {
    var telemetry;
    switch (span.kind) {
    case api_1.SpanKind.CLIENT:
    case api_1.SpanKind.PRODUCER:
    case api_1.SpanKind.INTERNAL:
     telemetry = createDependencyData(span);
     break;

    case api_1.SpanKind.SERVER:
    case api_1.SpanKind.CONSUMER:
     telemetry = function(span) {
      var requestData = {
       name: span.name,
       success: span.status.code != api_1.SpanStatusCode.ERROR,
       resultCode: "0",
       duration: 0,
       url: "",
       source: void 0
      }, httpMethod = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_METHOD], grpcStatusCode = span.attributes[semantic_conventions_1.SemanticAttributes.RPC_GRPC_STATUS_CODE];
      if (httpMethod) {
       if (span.kind == api_1.SpanKind.SERVER) {
        var httpRoute = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_ROUTE], httpUrl = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_URL];
        if (httpRoute) requestData.name = httpMethod + " " + httpRoute; else if (httpUrl) try {
         var url = new url_1.URL(String(httpUrl));
         requestData.name = httpMethod + " " + url.pathname;
        } catch (ex) {}
       }
       requestData.url = getUrl(span);
       var httpStatusCode = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_STATUS_CODE];
       httpStatusCode && (requestData.resultCode = String(httpStatusCode));
      } else grpcStatusCode && (requestData.resultCode = String(grpcStatusCode));
      return requestData;
     }(span);
    }
    var id = "" + (span.spanContext ? span.spanContext() : span.context()).spanId, duration = Math.round(1e3 * span.duration[0] + span.duration[1] / 1e6);
    return telemetry.id = id, telemetry.duration = duration, telemetry.properties = function(span) {
     for (var properties = {}, _i = 0, _a = Object.keys(span.attributes); _i < _a.length; _i++) {
      var key = _a[_i];
      key.startsWith("http.") || key.startsWith("rpc.") || key.startsWith("db.") || key.startsWith("peer.") || key.startsWith("net.") || (properties[key] = span.attributes[key]);
     }
     var links = span.links.map((function(link) {
      return {
       operation_Id: link.context.traceId,
       id: link.context.spanId
      };
     }));
     return links.length > 0 && (properties["_MS.links"] = Util.stringify(links)), properties;
    }(span), span.attributes[Constants.AzNamespace] && (span.kind === api_1.SpanKind.INTERNAL && (telemetry.dependencyTypeName = Constants.DependencyTypeName.InProc + " | " + span.attributes[Constants.AzNamespace]), 
    span.attributes[Constants.AzNamespace] === Constants.MicrosoftEventHub && EventHub_1.parseEventHubSpan(span, telemetry)), 
    telemetry;
   };
  },
  89879: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   exports.wp = exports.qP = void 0;
   var api_1 = __webpack_require__(94284), Constants_1 = __webpack_require__(63580), diagnostic_channel_1 = __webpack_require__(84953), SpanParser = __webpack_require__(65946), AsyncHooksScopeManager_1 = __webpack_require__(20699), clients = [];
   exports.qP = function(event) {
    try {
     var span_1 = event.data, telemetry_1 = SpanParser.spanToTelemetryContract(span_1);
     AsyncHooksScopeManager_1.AsyncScopeManager.with(span_1, (function() {
      clients.forEach((function(client) {
       span_1.kind === api_1.SpanKind.SERVER || span_1.kind === api_1.SpanKind.CONSUMER ? client.trackRequest(telemetry_1) : span_1.kind !== api_1.SpanKind.CLIENT && span_1.kind !== api_1.SpanKind.INTERNAL && span_1.kind !== api_1.SpanKind.PRODUCER || client.trackDependency(telemetry_1);
      }));
     }));
    } catch (err) {}
   }, exports.wp = function(enabled, client) {
    if (enabled) {
     if (clients.find((function(c) {
      return c == client;
     }))) return;
     0 === clients.length && diagnostic_channel_1.channel.subscribe("azure-coretracing", exports.qP, diagnostic_channel_1.trueFilter, (function(module, version) {
      var statsbeat = client.getStatsbeat();
      statsbeat && statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.AZURE_CORE_TRACING);
     })), clients.push(client);
    } else 0 === (clients = clients.filter((function(c) {
     return c != client;
    }))).length && diagnostic_channel_1.channel.unsubscribe("azure-coretracing", exports.qP);
   };
  },
  35823: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   exports.wp = void 0;
   var Contracts_1 = __webpack_require__(55290), Constants_1 = __webpack_require__(63580), diagnostic_channel_1 = __webpack_require__(84953), clients = [], bunyanToAILevelMap = {
    10: Contracts_1.SeverityLevel.Verbose,
    20: Contracts_1.SeverityLevel.Verbose,
    30: Contracts_1.SeverityLevel.Information,
    40: Contracts_1.SeverityLevel.Warning,
    50: Contracts_1.SeverityLevel.Error,
    60: Contracts_1.SeverityLevel.Critical
   }, subscriber = function(event) {
    var message = event.data.result, AIlevel = bunyanToAILevelMap[event.data.level];
    clients.forEach((function(client) {
     try {
      var log = JSON.parse(message);
      if (log.err) {
       var bunyanError = new Error(log.err.message);
       return bunyanError.name = log.err.name, bunyanError.stack = log.err.stack, client.config.enableLoggerErrorToTrace ? void client.trackTrace({
        message,
        severity: AIlevel
       }) : void client.trackException({
        exception: bunyanError
       });
      }
     } catch (err) {}
     client.trackTrace({
      message,
      severity: AIlevel
     });
    }));
   };
   exports.wp = function(enabled, client) {
    if (enabled) {
     if (clients.find((function(c) {
      return c == client;
     }))) return;
     0 === clients.length && diagnostic_channel_1.channel.subscribe("bunyan", subscriber, diagnostic_channel_1.trueFilter, (function(module, version) {
      var statsbeat = client.getStatsbeat();
      statsbeat && statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.BUNYAN);
     })), clients.push(client);
    } else 0 === (clients = clients.filter((function(c) {
     return c != client;
    }))).length && diagnostic_channel_1.channel.unsubscribe("bunyan", subscriber);
   };
  },
  14309: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   exports.wp = void 0;
   var Contracts_1 = __webpack_require__(55290), Constants_1 = __webpack_require__(63580), diagnostic_channel_1 = __webpack_require__(84953), clients = [], subscriber = function(event) {
    var message = event.data.message;
    clients.forEach((function(client) {
     message instanceof Error && !client.config.enableLoggerErrorToTrace ? client.trackException({
      exception: message
     }) : message instanceof Error ? client.trackTrace({
      message: message.toString(),
      severity: event.data.stderr ? Contracts_1.SeverityLevel.Error : Contracts_1.SeverityLevel.Information
     }) : (message.lastIndexOf("\n") == message.length - 1 && (message = message.substring(0, message.length - 1)), 
     client.trackTrace({
      message,
      severity: event.data.stderr ? Contracts_1.SeverityLevel.Warning : Contracts_1.SeverityLevel.Information
     }));
    }));
   };
   exports.wp = function(enabled, client) {
    if (enabled) {
     if (clients.find((function(c) {
      return c == client;
     }))) return;
     0 === clients.length && diagnostic_channel_1.channel.subscribe("console", subscriber, diagnostic_channel_1.trueFilter, (function(module, version) {
      var statsbeat = client.getStatsbeat();
      statsbeat && statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.CONSOLE);
     })), clients.push(client);
    } else 0 === (clients = clients.filter((function(c) {
     return c != client;
    }))).length && diagnostic_channel_1.channel.unsubscribe("console", subscriber);
   };
  },
  87396: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.registerContextPreservation = exports.IsInitialized = void 0;
   var Logging = __webpack_require__(95282), JsonConfig_1 = __webpack_require__(3063);
   exports.IsInitialized = !JsonConfig_1.JsonConfig.getInstance().noDiagnosticChannel;
   var TAG = "DiagnosticChannel";
   if (exports.IsInitialized) {
    var publishers = __webpack_require__(4106), unpatchedModules = JsonConfig_1.JsonConfig.getInstance().noPatchModules.split(","), modules = {
     bunyan: publishers.bunyan,
     console: publishers.console,
     mongodb: publishers.mongodb,
     mongodbCore: publishers.mongodbCore,
     mysql: publishers.mysql,
     redis: publishers.redis,
     pg: publishers.pg,
     pgPool: publishers.pgPool,
     winston: publishers.winston,
     azuresdk: publishers.azuresdk
    };
    for (var mod in modules) -1 === unpatchedModules.indexOf(mod) && (modules[mod].enable(), 
    Logging.info(TAG, "Subscribed to " + mod + " events"));
    unpatchedModules.length > 0 && Logging.info(TAG, "Some modules will not be patched", unpatchedModules);
   } else Logging.info(TAG, "Not subscribing to dependency autocollection because APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL was set");
   exports.registerContextPreservation = function(cb) {
    exports.IsInitialized && __webpack_require__(84953).channel.addContextPreservation(cb);
   };
  },
  67886: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   exports.wp = exports.qP = void 0;
   var Constants_1 = __webpack_require__(63580), diagnostic_channel_1 = __webpack_require__(84953), clients = [];
   exports.qP = function(event) {
    "ismaster" !== event.data.event.commandName && clients.forEach((function(client) {
     var dbName = event.data.startedData && event.data.startedData.databaseName || "Unknown database";
     client.trackDependency({
      target: dbName,
      data: event.data.event.commandName,
      name: event.data.event.commandName,
      duration: event.data.event.duration,
      success: event.data.succeeded,
      resultCode: event.data.succeeded ? "0" : "1",
      time: event.data.startedData.time,
      dependencyTypeName: "mongodb"
     });
    }));
   }, exports.wp = function(enabled, client) {
    if (enabled) {
     if (clients.find((function(c) {
      return c == client;
     }))) return;
     0 === clients.length && diagnostic_channel_1.channel.subscribe("mongodb", exports.qP, diagnostic_channel_1.trueFilter, (function(module, version) {
      var statsbeat = client.getStatsbeat();
      statsbeat && statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.MONGODB);
     })), clients.push(client);
    } else 0 === (clients = clients.filter((function(c) {
     return c != client;
    }))).length && diagnostic_channel_1.channel.unsubscribe("mongodb", exports.qP);
   };
  },
  34777: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   exports.wp = exports.qP = void 0;
   var Constants_1 = __webpack_require__(63580), diagnostic_channel_1 = __webpack_require__(84953), clients = [];
   exports.qP = function(event) {
    clients.forEach((function(client) {
     var queryObj = event.data.query || {}, sqlString = queryObj.sql || "Unknown query", success = !event.data.err, connectionConfig = (queryObj._connection || {}).config || {}, dbName = connectionConfig.socketPath ? connectionConfig.socketPath : (connectionConfig.host || "localhost") + ":" + connectionConfig.port;
     client.trackDependency({
      target: dbName,
      data: sqlString,
      name: sqlString,
      duration: event.data.duration,
      success,
      resultCode: success ? "0" : "1",
      time: event.data.time,
      dependencyTypeName: "mysql"
     });
    }));
   }, exports.wp = function(enabled, client) {
    if (enabled) {
     if (clients.find((function(c) {
      return c == client;
     }))) return;
     0 === clients.length && diagnostic_channel_1.channel.subscribe("mysql", exports.qP, diagnostic_channel_1.trueFilter, (function(module, version) {
      var statsbeat = client.getStatsbeat();
      statsbeat && statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.MYSQL);
     })), clients.push(client);
    } else 0 === (clients = clients.filter((function(c) {
     return c != client;
    }))).length && diagnostic_channel_1.channel.unsubscribe("mysql", exports.qP);
   };
  },
  31227: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   exports.wp = exports.qP = void 0;
   var Constants_1 = __webpack_require__(63580), diagnostic_channel_1 = __webpack_require__(84953), clients = [];
   exports.qP = function(event) {
    clients.forEach((function(client) {
     var q = event.data.query, sql = q.preparable && q.preparable.text || q.plan || q.text || "unknown query", success = !event.data.error, conn = event.data.database.host + ":" + event.data.database.port;
     client.trackDependency({
      target: conn,
      data: sql,
      name: sql,
      duration: event.data.duration,
      success,
      resultCode: success ? "0" : "1",
      time: event.data.time,
      dependencyTypeName: "postgres"
     });
    }));
   }, exports.wp = function(enabled, client) {
    if (enabled) {
     if (clients.find((function(c) {
      return c == client;
     }))) return;
     0 === clients.length && diagnostic_channel_1.channel.subscribe("postgres", exports.qP, diagnostic_channel_1.trueFilter, (function(module, version) {
      var statsbeat = client.getStatsbeat();
      statsbeat && statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.POSTGRES);
     })), clients.push(client);
    } else 0 === (clients = clients.filter((function(c) {
     return c != client;
    }))).length && diagnostic_channel_1.channel.unsubscribe("postgres", exports.qP);
   };
  },
  85071: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   exports.wp = exports.qP = void 0;
   var Constants_1 = __webpack_require__(63580), diagnostic_channel_1 = __webpack_require__(84953), clients = [];
   exports.qP = function(event) {
    clients.forEach((function(client) {
     "info" !== event.data.commandObj.command && client.trackDependency({
      target: event.data.address,
      name: event.data.commandObj.command,
      data: event.data.commandObj.command,
      duration: event.data.duration,
      success: !event.data.err,
      resultCode: event.data.err ? "1" : "0",
      time: event.data.time,
      dependencyTypeName: "redis"
     });
    }));
   }, exports.wp = function(enabled, client) {
    if (enabled) {
     if (clients.find((function(c) {
      return c == client;
     }))) return;
     0 === clients.length && diagnostic_channel_1.channel.subscribe("redis", exports.qP, diagnostic_channel_1.trueFilter, (function(module, version) {
      var statsbeat = client.getStatsbeat();
      statsbeat && statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.REDIS);
     })), clients.push(client);
    } else 0 === (clients = clients.filter((function(c) {
     return c != client;
    }))).length && diagnostic_channel_1.channel.unsubscribe("redis", exports.qP);
   };
  },
  30454: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   exports.wp = void 0;
   var Constants_1 = __webpack_require__(63580), Contracts_1 = __webpack_require__(55290), diagnostic_channel_1 = __webpack_require__(84953), clients = [], winstonToAILevelMap = {
    syslog: function(og) {
     var map = {
      emerg: Contracts_1.SeverityLevel.Critical,
      alert: Contracts_1.SeverityLevel.Critical,
      crit: Contracts_1.SeverityLevel.Critical,
      error: Contracts_1.SeverityLevel.Error,
      warning: Contracts_1.SeverityLevel.Warning,
      notice: Contracts_1.SeverityLevel.Information,
      info: Contracts_1.SeverityLevel.Information,
      debug: Contracts_1.SeverityLevel.Verbose
     };
     return void 0 === map[og] ? Contracts_1.SeverityLevel.Information : map[og];
    },
    npm: function(og) {
     var map = {
      error: Contracts_1.SeverityLevel.Error,
      warn: Contracts_1.SeverityLevel.Warning,
      info: Contracts_1.SeverityLevel.Information,
      verbose: Contracts_1.SeverityLevel.Verbose,
      debug: Contracts_1.SeverityLevel.Verbose,
      silly: Contracts_1.SeverityLevel.Verbose
     };
     return void 0 === map[og] ? Contracts_1.SeverityLevel.Information : map[og];
    },
    unknown: function(og) {
     return Contracts_1.SeverityLevel.Information;
    }
   }, subscriber = function(event) {
    var message = event.data.message, AIlevel = winstonToAILevelMap[event.data.levelKind](event.data.level);
    clients.forEach((function(client) {
     message instanceof Error && !client.config.enableLoggerErrorToTrace ? client.trackException({
      exception: message,
      properties: event.data.meta
     }) : message instanceof Error ? client.trackTrace({
      message: message.toString(),
      severity: AIlevel,
      properties: event.data.meta
     }) : client.trackTrace({
      message,
      severity: AIlevel,
      properties: event.data.meta
     });
    }));
   };
   exports.wp = function(enabled, client) {
    if (enabled) {
     if (clients.find((function(c) {
      return c == client;
     }))) return;
     0 === clients.length && diagnostic_channel_1.channel.subscribe("winston", subscriber, diagnostic_channel_1.trueFilter, (function(module, version) {
      var statsbeat = client.getStatsbeat();
      statsbeat && statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.WINSTON);
     })), clients.push(client);
    } else 0 === (clients = clients.filter((function(c) {
     return c != client;
    }))).length && diagnostic_channel_1.channel.unsubscribe("winston", subscriber);
   };
  },
  63580: (__unused_webpack_module, exports) => {
   "use strict";
   var _a, QuickPulseCounter, PerformanceCounter;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.WEB_INSTRUMENTATION_DEPRECATED_SOURCE = exports.WEB_INSTRUMENTATION_DEFAULT_SOURCE = exports.TIME_SINCE_ENQUEUED = exports.ENQUEUED_TIME = exports.MessageBusDestination = exports.MicrosoftEventHub = exports.AzNamespace = exports.StatsbeatNetworkCategory = exports.StatsbeatFeatureType = exports.StatsbeatInstrumentation = exports.StatsbeatFeature = exports.StatsbeatCounter = exports.StatsbeatAttach = exports.StatsbeatResourceProvider = exports.StatsbeatTelemetryName = exports.HeartBeatMetricName = exports.DependencyTypeName = exports.TelemetryTypeStringToQuickPulseDocumentType = exports.TelemetryTypeStringToQuickPulseType = exports.QuickPulseType = exports.QuickPulseDocumentType = exports.PerformanceToQuickPulseCounter = exports.MetricId = exports.PerformanceCounter = exports.QuickPulseCounter = exports.DEFAULT_LIVEMETRICS_HOST = exports.DEFAULT_LIVEMETRICS_ENDPOINT = exports.DEFAULT_BREEZE_ENDPOINT = exports.APPLICATION_INSIGHTS_SDK_VERSION = void 0, 
   exports.APPLICATION_INSIGHTS_SDK_VERSION = "2.7.3", exports.DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com", 
   exports.DEFAULT_LIVEMETRICS_ENDPOINT = "https://rt.services.visualstudio.com", exports.DEFAULT_LIVEMETRICS_HOST = "rt.services.visualstudio.com", 
   function(QuickPulseCounter) {
    QuickPulseCounter.COMMITTED_BYTES = "\\Memory\\Committed Bytes", QuickPulseCounter.PROCESSOR_TIME = "\\Processor(_Total)\\% Processor Time", 
    QuickPulseCounter.REQUEST_RATE = "\\ApplicationInsights\\Requests/Sec", QuickPulseCounter.REQUEST_FAILURE_RATE = "\\ApplicationInsights\\Requests Failed/Sec", 
    QuickPulseCounter.REQUEST_DURATION = "\\ApplicationInsights\\Request Duration", 
    QuickPulseCounter.DEPENDENCY_RATE = "\\ApplicationInsights\\Dependency Calls/Sec", 
    QuickPulseCounter.DEPENDENCY_FAILURE_RATE = "\\ApplicationInsights\\Dependency Calls Failed/Sec", 
    QuickPulseCounter.DEPENDENCY_DURATION = "\\ApplicationInsights\\Dependency Call Duration", 
    QuickPulseCounter.EXCEPTION_RATE = "\\ApplicationInsights\\Exceptions/Sec";
   }(QuickPulseCounter = exports.QuickPulseCounter || (exports.QuickPulseCounter = {})), 
   function(PerformanceCounter) {
    PerformanceCounter.PRIVATE_BYTES = "\\Process(??APP_WIN32_PROC??)\\Private Bytes", 
    PerformanceCounter.AVAILABLE_BYTES = "\\Memory\\Available Bytes", PerformanceCounter.PROCESSOR_TIME = "\\Processor(_Total)\\% Processor Time", 
    PerformanceCounter.PROCESS_TIME = "\\Process(??APP_WIN32_PROC??)\\% Processor Time", 
    PerformanceCounter.REQUEST_RATE = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Requests/Sec", 
    PerformanceCounter.REQUEST_DURATION = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Request Execution Time";
   }(PerformanceCounter = exports.PerformanceCounter || (exports.PerformanceCounter = {})), 
   function(MetricId) {
    MetricId.REQUESTS_DURATION = "requests/duration", MetricId.DEPENDENCIES_DURATION = "dependencies/duration", 
    MetricId.EXCEPTIONS_COUNT = "exceptions/count", MetricId.TRACES_COUNT = "traces/count";
   }(exports.MetricId || (exports.MetricId = {})), exports.PerformanceToQuickPulseCounter = ((_a = {})[PerformanceCounter.PROCESSOR_TIME] = QuickPulseCounter.PROCESSOR_TIME, 
   _a[PerformanceCounter.REQUEST_RATE] = QuickPulseCounter.REQUEST_RATE, _a[PerformanceCounter.REQUEST_DURATION] = QuickPulseCounter.REQUEST_DURATION, 
   _a[QuickPulseCounter.COMMITTED_BYTES] = QuickPulseCounter.COMMITTED_BYTES, _a[QuickPulseCounter.REQUEST_FAILURE_RATE] = QuickPulseCounter.REQUEST_FAILURE_RATE, 
   _a[QuickPulseCounter.DEPENDENCY_RATE] = QuickPulseCounter.DEPENDENCY_RATE, _a[QuickPulseCounter.DEPENDENCY_FAILURE_RATE] = QuickPulseCounter.DEPENDENCY_FAILURE_RATE, 
   _a[QuickPulseCounter.DEPENDENCY_DURATION] = QuickPulseCounter.DEPENDENCY_DURATION, 
   _a[QuickPulseCounter.EXCEPTION_RATE] = QuickPulseCounter.EXCEPTION_RATE, _a), exports.QuickPulseDocumentType = {
    Event: "Event",
    Exception: "Exception",
    Trace: "Trace",
    Metric: "Metric",
    Request: "Request",
    Dependency: "RemoteDependency",
    Availability: "Availability",
    PageView: "PageView"
   }, exports.QuickPulseType = {
    Event: "EventTelemetryDocument",
    Exception: "ExceptionTelemetryDocument",
    Trace: "TraceTelemetryDocument",
    Metric: "MetricTelemetryDocument",
    Request: "RequestTelemetryDocument",
    Dependency: "DependencyTelemetryDocument",
    Availability: "AvailabilityTelemetryDocument",
    PageView: "PageViewTelemetryDocument"
   }, exports.TelemetryTypeStringToQuickPulseType = {
    EventData: exports.QuickPulseType.Event,
    ExceptionData: exports.QuickPulseType.Exception,
    MessageData: exports.QuickPulseType.Trace,
    MetricData: exports.QuickPulseType.Metric,
    RequestData: exports.QuickPulseType.Request,
    RemoteDependencyData: exports.QuickPulseType.Dependency,
    AvailabilityData: exports.QuickPulseType.Availability,
    PageViewData: exports.QuickPulseType.PageView
   }, exports.TelemetryTypeStringToQuickPulseDocumentType = {
    EventData: exports.QuickPulseDocumentType.Event,
    ExceptionData: exports.QuickPulseDocumentType.Exception,
    MessageData: exports.QuickPulseDocumentType.Trace,
    MetricData: exports.QuickPulseDocumentType.Metric,
    RequestData: exports.QuickPulseDocumentType.Request,
    RemoteDependencyData: exports.QuickPulseDocumentType.Dependency,
    AvailabilityData: exports.QuickPulseDocumentType.Availability,
    PageViewData: exports.QuickPulseDocumentType.PageView
   }, exports.DependencyTypeName = {
    Grpc: "GRPC",
    Http: "HTTP",
    InProc: "InProc",
    Sql: "SQL",
    QueueMessage: "Queue Message"
   }, exports.HeartBeatMetricName = "HeartbeatState", exports.StatsbeatTelemetryName = "Statsbeat", 
   exports.StatsbeatResourceProvider = {
    appsvc: "appsvc",
    functions: "functions",
    vm: "vm",
    unknown: "unknown"
   }, exports.StatsbeatAttach = {
    codeless: "codeless",
    sdk: "sdk"
   }, exports.StatsbeatCounter = {
    REQUEST_SUCCESS: "Request Success Count",
    REQUEST_FAILURE: "Request Failure Count",
    REQUEST_DURATION: "Request Duration",
    RETRY_COUNT: "Retry Count",
    THROTTLE_COUNT: "Throttle Count",
    EXCEPTION_COUNT: "Exception Count",
    ATTACH: "Attach",
    FEATURE: "Feature"
   }, function(StatsbeatFeature) {
    StatsbeatFeature[StatsbeatFeature.NONE = 0] = "NONE", StatsbeatFeature[StatsbeatFeature.DISK_RETRY = 1] = "DISK_RETRY", 
    StatsbeatFeature[StatsbeatFeature.AAD_HANDLING = 2] = "AAD_HANDLING", StatsbeatFeature[StatsbeatFeature.WEB_SNIPPET = 4] = "WEB_SNIPPET";
   }(exports.StatsbeatFeature || (exports.StatsbeatFeature = {})), function(StatsbeatInstrumentation) {
    StatsbeatInstrumentation[StatsbeatInstrumentation.NONE = 0] = "NONE", StatsbeatInstrumentation[StatsbeatInstrumentation.AZURE_CORE_TRACING = 1] = "AZURE_CORE_TRACING", 
    StatsbeatInstrumentation[StatsbeatInstrumentation.MONGODB = 2] = "MONGODB", StatsbeatInstrumentation[StatsbeatInstrumentation.MYSQL = 4] = "MYSQL", 
    StatsbeatInstrumentation[StatsbeatInstrumentation.REDIS = 8] = "REDIS", StatsbeatInstrumentation[StatsbeatInstrumentation.POSTGRES = 16] = "POSTGRES", 
    StatsbeatInstrumentation[StatsbeatInstrumentation.BUNYAN = 32] = "BUNYAN", StatsbeatInstrumentation[StatsbeatInstrumentation.WINSTON = 64] = "WINSTON", 
    StatsbeatInstrumentation[StatsbeatInstrumentation.CONSOLE = 128] = "CONSOLE";
   }(exports.StatsbeatInstrumentation || (exports.StatsbeatInstrumentation = {})), 
   function(StatsbeatFeatureType) {
    StatsbeatFeatureType[StatsbeatFeatureType.Feature = 0] = "Feature", StatsbeatFeatureType[StatsbeatFeatureType.Instrumentation = 1] = "Instrumentation";
   }(exports.StatsbeatFeatureType || (exports.StatsbeatFeatureType = {})), function(StatsbeatNetworkCategory) {
    StatsbeatNetworkCategory[StatsbeatNetworkCategory.Breeze = 0] = "Breeze", StatsbeatNetworkCategory[StatsbeatNetworkCategory.Quickpulse = 1] = "Quickpulse";
   }(exports.StatsbeatNetworkCategory || (exports.StatsbeatNetworkCategory = {})), 
   exports.AzNamespace = "az.namespace", exports.MicrosoftEventHub = "Microsoft.EventHub", 
   exports.MessageBusDestination = "message_bus.destination", exports.ENQUEUED_TIME = "enqueuedTime", 
   exports.TIME_SINCE_ENQUEUED = "timeSinceEnqueued", exports.WEB_INSTRUMENTATION_DEFAULT_SOURCE = "https://js.monitor.azure.com/scripts/b/ai", 
   exports.WEB_INSTRUMENTATION_DEPRECATED_SOURCE = "https://az416426.vo.msecnd.net/scripts/b/ai";
  },
  69382: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.domainSupportsProperties = exports.RemoteDependencyDataConstants = void 0;
   var Generated_1 = __webpack_require__(99958), RemoteDependencyDataConstants = function() {
    function RemoteDependencyDataConstants() {}
    return RemoteDependencyDataConstants.TYPE_HTTP = "Http", RemoteDependencyDataConstants.TYPE_AI = "Http (tracked component)", 
    RemoteDependencyDataConstants;
   }();
   exports.RemoteDependencyDataConstants = RemoteDependencyDataConstants, exports.domainSupportsProperties = function(domain) {
    return "properties" in domain || domain instanceof Generated_1.EventData || domain instanceof Generated_1.ExceptionData || domain instanceof Generated_1.MessageData || domain instanceof Generated_1.MetricData || domain instanceof Generated_1.PageViewData || domain instanceof Generated_1.RemoteDependencyData || domain instanceof Generated_1.RequestData;
   };
  },
  27220: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var extendStatics, __extends = this && this.__extends || (extendStatics = function(d, b) {
    return extendStatics = Object.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
    }, extendStatics(d, b);
   }, function(d, b) {
    function __() {
     this.constructor = d;
    }
    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
    new __);
   }), AvailabilityData = function(_super) {
    function AvailabilityData() {
     var _this = _super.call(this) || this;
     return _this.ver = 2, _this.properties = {}, _this.measurements = {}, _this;
    }
    return __extends(AvailabilityData, _super), AvailabilityData;
   }(__webpack_require__(78934));
   module.exports = AvailabilityData;
  },
  64101: module => {
   "use strict";
   var Base = function() {};
   module.exports = Base;
  },
  69871: module => {
   "use strict";
   var ContextTagKeys = function() {
    this.applicationVersion = "ai.application.ver", this.deviceId = "ai.device.id", 
    this.deviceLocale = "ai.device.locale", this.deviceModel = "ai.device.model", this.deviceOEMName = "ai.device.oemName", 
    this.deviceOSVersion = "ai.device.osVersion", this.deviceType = "ai.device.type", 
    this.locationIp = "ai.location.ip", this.operationId = "ai.operation.id", this.operationName = "ai.operation.name", 
    this.operationParentId = "ai.operation.parentId", this.operationSyntheticSource = "ai.operation.syntheticSource", 
    this.operationCorrelationVector = "ai.operation.correlationVector", this.sessionId = "ai.session.id", 
    this.sessionIsFirst = "ai.session.isFirst", this.userAccountId = "ai.user.accountId", 
    this.userId = "ai.user.id", this.userAuthUserId = "ai.user.authUserId", this.cloudRole = "ai.cloud.role", 
    this.cloudRoleInstance = "ai.cloud.roleInstance", this.internalSdkVersion = "ai.internal.sdkVersion", 
    this.internalAgentVersion = "ai.internal.agentVersion", this.internalNodeName = "ai.internal.nodeName";
   };
   module.exports = ContextTagKeys;
  },
  320: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var extendStatics, __extends = this && this.__extends || (extendStatics = function(d, b) {
    return extendStatics = Object.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
    }, extendStatics(d, b);
   }, function(d, b) {
    function __() {
     this.constructor = d;
    }
    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
    new __);
   }), Data = function(_super) {
    function Data() {
     return _super.call(this) || this;
    }
    return __extends(Data, _super), Data;
   }(__webpack_require__(64101));
   module.exports = Data;
  },
  78602: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var DataPointType = __webpack_require__(80495), DataPoint = function() {
    this.kind = DataPointType.Measurement;
   };
   module.exports = DataPoint;
  },
  80495: module => {
   "use strict";
   var DataPointType;
   !function(DataPointType) {
    DataPointType[DataPointType.Measurement = 0] = "Measurement", DataPointType[DataPointType.Aggregation = 1] = "Aggregation";
   }(DataPointType || (DataPointType = {})), module.exports = DataPointType;
  },
  78934: module => {
   "use strict";
   var Domain = function() {};
   module.exports = Domain;
  },
  37300: module => {
   "use strict";
   var Envelope = function() {
    this.ver = 1, this.sampleRate = 100, this.tags = {};
   };
   module.exports = Envelope;
  },
  44526: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var extendStatics, __extends = this && this.__extends || (extendStatics = function(d, b) {
    return extendStatics = Object.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
    }, extendStatics(d, b);
   }, function(d, b) {
    function __() {
     this.constructor = d;
    }
    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
    new __);
   }), EventData = function(_super) {
    function EventData() {
     var _this = _super.call(this) || this;
     return _this.ver = 2, _this.properties = {}, _this.measurements = {}, _this;
    }
    return __extends(EventData, _super), EventData;
   }(__webpack_require__(78934));
   module.exports = EventData;
  },
  40935: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var extendStatics, __extends = this && this.__extends || (extendStatics = function(d, b) {
    return extendStatics = Object.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
    }, extendStatics(d, b);
   }, function(d, b) {
    function __() {
     this.constructor = d;
    }
    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
    new __);
   }), ExceptionData = function(_super) {
    function ExceptionData() {
     var _this = _super.call(this) || this;
     return _this.ver = 2, _this.exceptions = [], _this.properties = {}, _this.measurements = {}, 
     _this;
    }
    return __extends(ExceptionData, _super), ExceptionData;
   }(__webpack_require__(78934));
   module.exports = ExceptionData;
  },
  18082: module => {
   "use strict";
   var ExceptionDetails = function() {
    this.hasFullStack = !0, this.parsedStack = [];
   };
   module.exports = ExceptionDetails;
  },
  10901: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var extendStatics, __extends = this && this.__extends || (extendStatics = function(d, b) {
    return extendStatics = Object.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
    }, extendStatics(d, b);
   }, function(d, b) {
    function __() {
     this.constructor = d;
    }
    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
    new __);
   }), MessageData = function(_super) {
    function MessageData() {
     var _this = _super.call(this) || this;
     return _this.ver = 2, _this.properties = {}, _this;
    }
    return __extends(MessageData, _super), MessageData;
   }(__webpack_require__(78934));
   module.exports = MessageData;
  },
  33092: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var extendStatics, __extends = this && this.__extends || (extendStatics = function(d, b) {
    return extendStatics = Object.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
    }, extendStatics(d, b);
   }, function(d, b) {
    function __() {
     this.constructor = d;
    }
    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
    new __);
   }), MetricData = function(_super) {
    function MetricData() {
     var _this = _super.call(this) || this;
     return _this.ver = 2, _this.metrics = [], _this.properties = {}, _this;
    }
    return __extends(MetricData, _super), MetricData;
   }(__webpack_require__(78934));
   module.exports = MetricData;
  },
  56279: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var extendStatics, __extends = this && this.__extends || (extendStatics = function(d, b) {
    return extendStatics = Object.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
    }, extendStatics(d, b);
   }, function(d, b) {
    function __() {
     this.constructor = d;
    }
    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
    new __);
   }), PageViewData = function(_super) {
    function PageViewData() {
     var _this = _super.call(this) || this;
     return _this.ver = 2, _this.properties = {}, _this.measurements = {}, _this;
    }
    return __extends(PageViewData, _super), PageViewData;
   }(__webpack_require__(44526));
   module.exports = PageViewData;
  },
  86290: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var extendStatics, __extends = this && this.__extends || (extendStatics = function(d, b) {
    return extendStatics = Object.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
    }, extendStatics(d, b);
   }, function(d, b) {
    function __() {
     this.constructor = d;
    }
    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
    new __);
   }), RemoteDependencyData = function(_super) {
    function RemoteDependencyData() {
     var _this = _super.call(this) || this;
     return _this.ver = 2, _this.success = !0, _this.properties = {}, _this.measurements = {}, 
     _this;
    }
    return __extends(RemoteDependencyData, _super), RemoteDependencyData;
   }(__webpack_require__(78934));
   module.exports = RemoteDependencyData;
  },
  7339: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var extendStatics, __extends = this && this.__extends || (extendStatics = function(d, b) {
    return extendStatics = Object.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
    }, extendStatics(d, b);
   }, function(d, b) {
    function __() {
     this.constructor = d;
    }
    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
    new __);
   }), RequestData = function(_super) {
    function RequestData() {
     var _this = _super.call(this) || this;
     return _this.ver = 2, _this.properties = {}, _this.measurements = {}, _this;
    }
    return __extends(RequestData, _super), RequestData;
   }(__webpack_require__(78934));
   module.exports = RequestData;
  },
  39697: module => {
   "use strict";
   var SeverityLevel;
   !function(SeverityLevel) {
    SeverityLevel[SeverityLevel.Verbose = 0] = "Verbose", SeverityLevel[SeverityLevel.Information = 1] = "Information", 
    SeverityLevel[SeverityLevel.Warning = 2] = "Warning", SeverityLevel[SeverityLevel.Error = 3] = "Error", 
    SeverityLevel[SeverityLevel.Critical = 4] = "Critical";
   }(SeverityLevel || (SeverityLevel = {})), module.exports = SeverityLevel;
  },
  76376: module => {
   "use strict";
   var StackFrame = function() {};
   module.exports = StackFrame;
  },
  99958: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.AvailabilityData = __webpack_require__(27220), exports.Base = __webpack_require__(64101), 
   exports.ContextTagKeys = __webpack_require__(69871), exports.Data = __webpack_require__(320), 
   exports.DataPoint = __webpack_require__(78602), exports.DataPointType = __webpack_require__(80495), 
   exports.Domain = __webpack_require__(78934), exports.Envelope = __webpack_require__(37300), 
   exports.EventData = __webpack_require__(44526), exports.ExceptionData = __webpack_require__(40935), 
   exports.ExceptionDetails = __webpack_require__(18082), exports.MessageData = __webpack_require__(10901), 
   exports.MetricData = __webpack_require__(33092), exports.PageViewData = __webpack_require__(56279), 
   exports.RemoteDependencyData = __webpack_require__(86290), exports.RequestData = __webpack_require__(7339), 
   exports.SeverityLevel = __webpack_require__(39697), exports.StackFrame = __webpack_require__(76376);
  },
  76522: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  40532: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  84429: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  8937: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  49003: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  15323: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  89477: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  6647: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  85977: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), Object.defineProperty(o, k2, {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    });
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), __exportStar(__webpack_require__(89477), exports), __exportStar(__webpack_require__(84429), exports), 
   __exportStar(__webpack_require__(40532), exports), __exportStar(__webpack_require__(49003), exports), 
   __exportStar(__webpack_require__(15323), exports), __exportStar(__webpack_require__(76522), exports), 
   __exportStar(__webpack_require__(6647), exports), __exportStar(__webpack_require__(8937), exports);
  },
  93382: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  31727: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  16375: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  78010: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  62637: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  34381: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  71143: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  42166: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  74013: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  72334: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  18836: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  75481: (__unused_webpack_module, exports) => {
   "use strict";
   var TelemetryType;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.TelemetryType = exports.TelemetryTypeString = exports.baseTypeToTelemetryType = exports.telemetryTypeToBaseType = void 0, 
   exports.telemetryTypeToBaseType = function(type) {
    switch (type) {
    case TelemetryType.Event:
     return "EventData";

    case TelemetryType.Exception:
     return "ExceptionData";

    case TelemetryType.Trace:
     return "MessageData";

    case TelemetryType.Metric:
     return "MetricData";

    case TelemetryType.Request:
     return "RequestData";

    case TelemetryType.Dependency:
     return "RemoteDependencyData";

    case TelemetryType.Availability:
     return "AvailabilityData";

    case TelemetryType.PageView:
     return "PageViewData";
    }
   }, exports.baseTypeToTelemetryType = function(baseType) {
    switch (baseType) {
    case "EventData":
     return TelemetryType.Event;

    case "ExceptionData":
     return TelemetryType.Exception;

    case "MessageData":
     return TelemetryType.Trace;

    case "MetricData":
     return TelemetryType.Metric;

    case "RequestData":
     return TelemetryType.Request;

    case "RemoteDependencyData":
     return TelemetryType.Dependency;

    case "AvailabilityData":
     return TelemetryType.Availability;

    case "PageViewData":
     return TelemetryType.PageView;
    }
   }, exports.TelemetryTypeString = {
    Event: "EventData",
    Exception: "ExceptionData",
    Trace: "MessageData",
    Metric: "MetricData",
    Request: "RequestData",
    Dependency: "RemoteDependencyData",
    Availability: "AvailabilityData",
    PageView: "PageViewData"
   }, function(TelemetryType) {
    TelemetryType[TelemetryType.Event = 0] = "Event", TelemetryType[TelemetryType.Exception = 1] = "Exception", 
    TelemetryType[TelemetryType.Trace = 2] = "Trace", TelemetryType[TelemetryType.Metric = 3] = "Metric", 
    TelemetryType[TelemetryType.Request = 4] = "Request", TelemetryType[TelemetryType.Dependency = 5] = "Dependency", 
    TelemetryType[TelemetryType.Availability = 6] = "Availability", TelemetryType[TelemetryType.PageView = 7] = "PageView";
   }(TelemetryType = exports.TelemetryType || (exports.TelemetryType = {}));
  },
  35539: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  62626: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), Object.defineProperty(o, k2, {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    });
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), __exportStar(__webpack_require__(31727), exports), __exportStar(__webpack_require__(78010), exports), 
   __exportStar(__webpack_require__(62637), exports), __exportStar(__webpack_require__(34381), exports), 
   __exportStar(__webpack_require__(72334), exports), __exportStar(__webpack_require__(35539), exports), 
   __exportStar(__webpack_require__(18836), exports), __exportStar(__webpack_require__(71143), exports), 
   __exportStar(__webpack_require__(42166), exports), __exportStar(__webpack_require__(93382), exports), 
   __exportStar(__webpack_require__(74013), exports), __exportStar(__webpack_require__(16375), exports), 
   __exportStar(__webpack_require__(75481), exports);
  },
  55290: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), Object.defineProperty(o, k2, {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    });
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), __exportStar(__webpack_require__(69382), exports), __exportStar(__webpack_require__(99958), exports), 
   __exportStar(__webpack_require__(62626), exports), __exportStar(__webpack_require__(85977), exports);
  },
  60521: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.AggregatedMetricCounter = void 0;
   var AggregatedMetricCounter = function(dimensions) {
    this.dimensions = dimensions, this.totalCount = 0, this.lastTotalCount = 0, this.intervalExecutionTime = 0, 
    this.lastTime = +new Date, this.lastIntervalExecutionTime = 0;
   };
   exports.AggregatedMetricCounter = AggregatedMetricCounter;
  },
  77535: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.PreaggregatedMetricPropertyNames = void 0, exports.PreaggregatedMetricPropertyNames = {
    cloudRoleInstance: "cloud/roleInstance",
    cloudRoleName: "cloud/roleName",
    operationSynthetic: "operation/synthetic",
    requestSuccess: "Request.Success",
    requestResultCode: "request/resultCode",
    dependencyType: "Dependency.Type",
    dependencyTarget: "dependency/target",
    dependencySuccess: "Dependency.Success",
    dependencyResultCode: "dependency/resultCode",
    traceSeverityLevel: "trace/severityLevel"
   };
  },
  80287: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }, __generator = this && this.__generator || function(thisArg, body) {
    var f, y, t, g, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    };
    return g = {
     next: verb(0),
     throw: verb(1),
     return: verb(2)
    }, "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;_; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   }, azureCore = __webpack_require__(71044);
   function emptySendRequest(_request) {
    return null;
   }
   var AuthorizationHandler = function() {
    function AuthorizationHandler(credential) {
     var scopes = [ "https://monitor.azure.com//.default" ];
     this._azureTokenPolicy = azureCore.bearerTokenAuthenticationPolicy({
      credential,
      scopes
     });
    }
    return AuthorizationHandler.prototype.addAuthorizationHeader = function(requestOptions) {
     return __awaiter(this, void 0, void 0, (function() {
      var authHeaderName, webResource;
      return __generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return authHeaderName = "authorization", webResource = azureCore.createPipelineRequest({
         url: "https://"
        }), [ 4, this._azureTokenPolicy.sendRequest(webResource, emptySendRequest) ];

       case 1:
        return _a.sent(), requestOptions.headers[authHeaderName] = webResource.headers.get(authHeaderName), 
        [ 2 ];
       }
      }));
     }));
    }, AuthorizationHandler;
   }();
   module.exports = AuthorizationHandler;
  },
  32713: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.AzureVirtualMachine = void 0;
   var Logging = __webpack_require__(95282), Util = __webpack_require__(25740), AutoCollectHttpDependencies = __webpack_require__(88723), AzureVirtualMachine = function() {
    function AzureVirtualMachine() {}
    return AzureVirtualMachine.getAzureComputeMetadata = function(config, callback) {
     var _a, _this = this, vmInfo = {}, requestOptions = ((_a = {
      method: "GET"
     })[AutoCollectHttpDependencies.disableCollectionRequestOption] = !0, _a.headers = {
      Metadata: "True"
     }, _a), req = Util.makeRequest(config, "http://169.254.169.254/metadata/instance/compute?api-version=2017-12-01&format=json", requestOptions, (function(res) {
      if (200 === res.statusCode) {
       vmInfo.isVM = !0;
       var virtualMachineData_1 = "";
       res.on("data", (function(data) {
        virtualMachineData_1 += data;
       })), res.on("end", (function() {
        try {
         var data = JSON.parse(virtualMachineData_1);
         vmInfo.id = data.vmId || "", vmInfo.subscriptionId = data.subscriptionId || "", 
         vmInfo.osType = data.osType || "";
        } catch (error) {
         Logging.info(AzureVirtualMachine.TAG, error);
        }
        callback(vmInfo);
       }));
      } else callback(vmInfo);
     }), !1, !1);
     req && (setTimeout((function() {
      _this._requestTimedOut = !0, req.abort();
     }), AzureVirtualMachine.HTTP_TIMEOUT), req.on("error", (function(error) {
      _this._requestTimedOut && error && (error.name = "telemetry timeout", error.message = "telemetry request timed out"), 
      error && error.message && error.message.indexOf("UNREACH") > -1 ? vmInfo.isVM = !1 : Logging.info(AzureVirtualMachine.TAG, error), 
      callback(vmInfo);
     })), req.end());
    }, AzureVirtualMachine.HTTP_TIMEOUT = 2500, AzureVirtualMachine.TAG = "AzureVirtualMachine", 
    AzureVirtualMachine;
   }();
   exports.AzureVirtualMachine = AzureVirtualMachine;
  },
  3504: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var Logging = __webpack_require__(95282), Util = __webpack_require__(25740), Channel = function() {
    function Channel(isDisabled, getBatchSize, getBatchIntervalMs, sender) {
     this._buffer = [], this._lastSend = 0, this._isDisabled = isDisabled, this._getBatchSize = getBatchSize, 
     this._getBatchIntervalMs = getBatchIntervalMs, this._sender = sender;
    }
    return Channel.prototype.setUseDiskRetryCaching = function(value, resendInterval, maxBytesOnDisk) {
     this._sender.setDiskRetryMode(value, resendInterval, maxBytesOnDisk);
    }, Channel.prototype.send = function(envelope) {
     var _this = this;
     this._isDisabled() || (envelope ? (this._buffer.push(envelope), this._buffer.length >= this._getBatchSize() ? this.triggerSend(!1) : !this._timeoutHandle && this._buffer.length > 0 && (this._timeoutHandle = setTimeout((function() {
      _this._timeoutHandle = null, _this.triggerSend(!1);
     }), this._getBatchIntervalMs()))) : Logging.warn("Cannot send null/undefined telemetry"));
    }, Channel.prototype.triggerSend = function(isNodeCrashing, callback) {
     var bufferIsEmpty = this._buffer.length < 1;
     bufferIsEmpty || (isNodeCrashing || Util.isNodeExit ? (this._sender.saveOnCrash(this._buffer), 
     "function" == typeof callback && callback("data saved on crash")) : this._sender.send(this._buffer, callback)), 
     this._lastSend = +new Date, this._buffer = [], clearTimeout(this._timeoutHandle), 
     this._timeoutHandle = null, bufferIsEmpty && "function" == typeof callback && callback("no data to send");
    }, Channel;
   }();
   module.exports = Channel;
  },
  69253: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var CorrelationIdManager = __webpack_require__(29962), ConnectionStringParser = __webpack_require__(55158), Logging = __webpack_require__(95282), Constants = __webpack_require__(63580), url = __webpack_require__(57310), JsonConfig_1 = __webpack_require__(3063), Config = function() {
    function Config(setupString) {
     this._endpointBase = Constants.DEFAULT_BREEZE_ENDPOINT, this._mergeConfig();
     var connectionStringEnv = this._connectionString, csCode = ConnectionStringParser.parse(setupString), csEnv = ConnectionStringParser.parse(connectionStringEnv), iKeyCode = !csCode.instrumentationkey && Object.keys(csCode).length > 0 ? null : setupString, instrumentationKeyEnv = this._instrumentationKey;
     this.instrumentationKey = csCode.instrumentationkey || iKeyCode || csEnv.instrumentationkey || instrumentationKeyEnv;
     var endpoint = "" + (this.endpointUrl || csCode.ingestionendpoint || csEnv.ingestionendpoint || this._endpointBase);
     endpoint.endsWith("/") && (endpoint = endpoint.slice(0, -1)), this.endpointUrl = endpoint + "/v2.1/track", 
     this.maxBatchSize = this.maxBatchSize || 250, this.maxBatchIntervalMs = this.maxBatchIntervalMs || 15e3, 
     this.disableAppInsights = this.disableAppInsights || !1, this.samplingPercentage = this.samplingPercentage || 100, 
     this.correlationIdRetryIntervalMs = this.correlationIdRetryIntervalMs || 3e4, this.enableWebInstrumentation = this.enableWebInstrumentation || this.enableAutoWebSnippetInjection || !1, 
     this.webInstrumentationConfig = this.webInstrumentationConfig || null, this.enableAutoWebSnippetInjection = this.enableWebInstrumentation, 
     this.correlationHeaderExcludedDomains = this.correlationHeaderExcludedDomains || [ "*.core.windows.net", "*.core.chinacloudapi.cn", "*.core.cloudapi.de", "*.core.usgovcloudapi.net", "*.core.microsoft.scloud", "*.core.eaglex.ic.gov" ], 
     this.ignoreLegacyHeaders = this.ignoreLegacyHeaders || !1, this.profileQueryEndpoint = csCode.ingestionendpoint || csEnv.ingestionendpoint || process.env[Config.ENV_profileQueryEndpoint] || this._endpointBase, 
     this.quickPulseHost = this.quickPulseHost || csCode.liveendpoint || csEnv.liveendpoint || process.env[Config.ENV_quickPulseHost] || Constants.DEFAULT_LIVEMETRICS_HOST, 
     this.webInstrumentationConnectionString = this.webInstrumentationConnectionString || this._webInstrumentationConnectionString || "", 
     this.webSnippetConnectionString = this.webInstrumentationConnectionString, this.quickPulseHost.match(/^https?:\/\//) && (this.quickPulseHost = new url.URL(this.quickPulseHost).host);
    }
    return Object.defineProperty(Config.prototype, "profileQueryEndpoint", {
     get: function() {
      return this._profileQueryEndpoint;
     },
     set: function(endpoint) {
      this._profileQueryEndpoint = endpoint, this.correlationId = CorrelationIdManager.correlationIdPrefix;
     },
     enumerable: !1,
     configurable: !0
    }), Object.defineProperty(Config.prototype, "instrumentationKey", {
     get: function() {
      return this._instrumentationKey;
     },
     set: function(iKey) {
      Config._validateInstrumentationKey(iKey) || Logging.warn("An invalid instrumentation key was provided. There may be resulting telemetry loss", this.instrumentationKey), 
      this._instrumentationKey = iKey;
     },
     enumerable: !1,
     configurable: !0
    }), Object.defineProperty(Config.prototype, "webSnippetConnectionString", {
     get: function() {
      return this._webInstrumentationConnectionString;
     },
     set: function(connectionString) {
      this._webInstrumentationConnectionString = connectionString;
     },
     enumerable: !1,
     configurable: !0
    }), Object.defineProperty(Config.prototype, "webInstrumentationConnectionString", {
     get: function() {
      return this._webInstrumentationConnectionString;
     },
     set: function(connectionString) {
      this._webInstrumentationConnectionString = connectionString;
     },
     enumerable: !1,
     configurable: !0
    }), Config.prototype._mergeConfig = function() {
     var jsonConfig = JsonConfig_1.JsonConfig.getInstance();
     this._connectionString = jsonConfig.connectionString, this._instrumentationKey = jsonConfig.instrumentationKey, 
     this.correlationHeaderExcludedDomains = jsonConfig.correlationHeaderExcludedDomains, 
     this.correlationIdRetryIntervalMs = jsonConfig.correlationIdRetryIntervalMs, this.disableAllExtendedMetrics = jsonConfig.disableAllExtendedMetrics, 
     this.disableAppInsights = jsonConfig.disableAppInsights, this.disableStatsbeat = jsonConfig.disableStatsbeat, 
     this.distributedTracingMode = jsonConfig.distributedTracingMode, this.enableAutoCollectConsole = jsonConfig.enableAutoCollectConsole, 
     this.enableLoggerErrorToTrace = jsonConfig.enableLoggerErrorToTrace, this.enableAutoCollectDependencies = jsonConfig.enableAutoCollectDependencies, 
     this.enableAutoCollectIncomingRequestAzureFunctions = jsonConfig.enableAutoCollectIncomingRequestAzureFunctions, 
     this.enableAutoCollectExceptions = jsonConfig.enableAutoCollectExceptions, this.enableAutoCollectExtendedMetrics = jsonConfig.enableAutoCollectExtendedMetrics, 
     this.enableAutoCollectExternalLoggers = jsonConfig.enableAutoCollectExternalLoggers, 
     this.enableAutoCollectHeartbeat = jsonConfig.enableAutoCollectHeartbeat, this.enableAutoCollectPerformance = jsonConfig.enableAutoCollectPerformance, 
     this.enableAutoCollectPreAggregatedMetrics = jsonConfig.enableAutoCollectPreAggregatedMetrics, 
     this.enableAutoCollectRequests = jsonConfig.enableAutoCollectRequests, this.enableAutoDependencyCorrelation = jsonConfig.enableAutoDependencyCorrelation, 
     this.enableInternalDebugLogging = jsonConfig.enableInternalDebugLogging, this.enableInternalWarningLogging = jsonConfig.enableInternalWarningLogging, 
     this.enableResendInterval = jsonConfig.enableResendInterval, this.enableMaxBytesOnDisk = jsonConfig.enableMaxBytesOnDisk, 
     this.enableSendLiveMetrics = jsonConfig.enableSendLiveMetrics, this.enableUseAsyncHooks = jsonConfig.enableUseAsyncHooks, 
     this.enableUseDiskRetryCaching = jsonConfig.enableUseDiskRetryCaching, this.endpointUrl = jsonConfig.endpointUrl, 
     this.extendedMetricDisablers = jsonConfig.extendedMetricDisablers, this.ignoreLegacyHeaders = jsonConfig.ignoreLegacyHeaders, 
     this.maxBatchIntervalMs = jsonConfig.maxBatchIntervalMs, this.maxBatchSize = jsonConfig.maxBatchSize, 
     this.proxyHttpUrl = jsonConfig.proxyHttpUrl, this.proxyHttpsUrl = jsonConfig.proxyHttpsUrl, 
     this.quickPulseHost = jsonConfig.quickPulseHost, this.samplingPercentage = jsonConfig.samplingPercentage, 
     this.enableWebInstrumentation = jsonConfig.enableWebInstrumentation, this._webInstrumentationConnectionString = jsonConfig.webInstrumentationConnectionString, 
     this.webInstrumentationConfig = jsonConfig.webInstrumentationConfig, this.webInstrumentationSrc = jsonConfig.webInstrumentationSrc;
    }, Config._validateInstrumentationKey = function(iKey) {
     return new RegExp("^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$").test(iKey);
    }, Config.ENV_azurePrefix = "APPSETTING_", Config.ENV_iKey = "APPINSIGHTS_INSTRUMENTATIONKEY", 
    Config.legacy_ENV_iKey = "APPINSIGHTS_INSTRUMENTATION_KEY", Config.ENV_profileQueryEndpoint = "APPINSIGHTS_PROFILE_QUERY_ENDPOINT", 
    Config.ENV_quickPulseHost = "APPINSIGHTS_QUICKPULSE_HOST", Config;
   }();
   module.exports = Config;
  },
  55158: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var Constants = __webpack_require__(63580), ConnectionStringParser = function() {
    function ConnectionStringParser() {}
    return ConnectionStringParser.parse = function(connectionString) {
     if (!connectionString) return {};
     var result = connectionString.split(ConnectionStringParser._FIELDS_SEPARATOR).reduce((function(fields, kv) {
      var kvParts = kv.split(ConnectionStringParser._FIELD_KEY_VALUE_SEPARATOR);
      if (2 === kvParts.length) {
       var key = kvParts[0].toLowerCase(), value = kvParts[1];
       fields[key] = value;
      }
      return fields;
     }), {});
     if (Object.keys(result).length > 0) {
      if (result.endpointsuffix) {
       var locationPrefix = result.location ? result.location + "." : "";
       result.ingestionendpoint = result.ingestionendpoint || "https://" + locationPrefix + "dc." + result.endpointsuffix, 
       result.liveendpoint = result.liveendpoint || "https://" + locationPrefix + "live." + result.endpointsuffix;
      }
      result.ingestionendpoint = result.ingestionendpoint || Constants.DEFAULT_BREEZE_ENDPOINT, 
      result.liveendpoint = result.liveendpoint || Constants.DEFAULT_LIVEMETRICS_ENDPOINT;
     }
     return result;
    }, ConnectionStringParser.isIkeyValid = function(iKey) {
     if (!iKey || "" == iKey) return !1;
     return new RegExp("^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$").test(iKey);
    }, ConnectionStringParser._FIELDS_SEPARATOR = ";", ConnectionStringParser._FIELD_KEY_VALUE_SEPARATOR = "=", 
    ConnectionStringParser;
   }();
   module.exports = ConnectionStringParser;
  },
  54470: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var os = __webpack_require__(22037), fs = __webpack_require__(57147), path = __webpack_require__(71017), Contracts = __webpack_require__(55290), Constants_1 = __webpack_require__(63580), Logging = __webpack_require__(95282), Context = function() {
    function Context(packageJsonPath) {
     this.keys = new Contracts.ContextTagKeys, this.tags = {}, this._loadApplicationContext(packageJsonPath), 
     this._loadDeviceContext(), this._loadInternalContext();
    }
    return Context.prototype._loadApplicationContext = function(packageJsonPath) {
     try {
      if (packageJsonPath = packageJsonPath || path.resolve(__dirname, "../../../../package.json"), 
      !Context.appVersion[packageJsonPath]) {
       Context.appVersion[packageJsonPath] = "unknown";
       var packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));
       packageJson && "string" == typeof packageJson.version && (Context.appVersion[packageJsonPath] = packageJson.version);
      }
      this.tags[this.keys.applicationVersion] = Context.appVersion[packageJsonPath];
     } catch (exception) {
      Logging.info("Failed to read app version: ", exception);
     }
    }, Context.prototype._loadDeviceContext = function() {
     var cloudRoleInstance = os && os.hostname(), cloudRole = Context.DefaultRoleName;
     process.env.WEBSITE_SITE_NAME && (cloudRole = process.env.WEBSITE_SITE_NAME), process.env.WEBSITE_INSTANCE_ID && (cloudRoleInstance = process.env.WEBSITE_INSTANCE_ID), 
     this.tags[this.keys.deviceId] = "", this.tags[this.keys.cloudRoleInstance] = cloudRoleInstance, 
     this.tags[this.keys.deviceOSVersion] = os && os.type() + " " + os.release(), this.tags[this.keys.cloudRole] = cloudRole, 
     this.tags["ai.device.osArchitecture"] = os && os.arch(), this.tags["ai.device.osPlatform"] = os && os.platform();
    }, Context.prototype._loadInternalContext = function() {
     Context.sdkVersion = Constants_1.APPLICATION_INSIGHTS_SDK_VERSION, this.tags[this.keys.internalSdkVersion] = "node:" + Context.sdkVersion;
    }, Context.DefaultRoleName = "Web", Context.appVersion = {}, Context.sdkVersion = null, 
    Context;
   }();
   module.exports = Context;
  },
  29962: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var Util = __webpack_require__(25740), CorrelationIdManager = function() {
    function CorrelationIdManager() {}
    return CorrelationIdManager.queryCorrelationId = function(config, callback) {}, 
    CorrelationIdManager.cancelCorrelationIdQuery = function(config, callback) {}, CorrelationIdManager.generateRequestId = function(parentId) {
     if (parentId) {
      "." !== (parentId = "|" == parentId[0] ? parentId : "|" + parentId)[parentId.length - 1] && (parentId += ".");
      var suffix = (CorrelationIdManager.currentRootId++).toString(16);
      return CorrelationIdManager.appendSuffix(parentId, suffix, "_");
     }
     return CorrelationIdManager.generateRootId();
    }, CorrelationIdManager.getRootId = function(id) {
     var endIndex = id.indexOf(".");
     endIndex < 0 && (endIndex = id.length);
     var startIndex = "|" === id[0] ? 1 : 0;
     return id.substring(startIndex, endIndex);
    }, CorrelationIdManager.generateRootId = function() {
     return "|" + Util.w3cTraceId() + ".";
    }, CorrelationIdManager.appendSuffix = function(parentId, suffix, delimiter) {
     if (parentId.length + suffix.length < CorrelationIdManager.requestIdMaxLength) return parentId + suffix + delimiter;
     var trimPosition = CorrelationIdManager.requestIdMaxLength - 9;
     if (parentId.length > trimPosition) for (;trimPosition > 1; --trimPosition) {
      var c = parentId[trimPosition - 1];
      if ("." === c || "_" === c) break;
     }
     if (trimPosition <= 1) return CorrelationIdManager.generateRootId();
     for (suffix = Util.randomu32().toString(16); suffix.length < 8; ) suffix = "0" + suffix;
     return parentId.substring(0, trimPosition) + suffix + "#";
    }, CorrelationIdManager.correlationIdPrefix = "cid-v1:", CorrelationIdManager.w3cEnabled = !0, 
    CorrelationIdManager.HTTP_TIMEOUT = 2500, CorrelationIdManager.requestIdMaxLength = 1024, 
    CorrelationIdManager.currentRootId = Util.randomu32(), CorrelationIdManager;
   }();
   module.exports = CorrelationIdManager;
  },
  99813: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var Contracts = __webpack_require__(55290), Util = __webpack_require__(25740), CorrelationContextManager_1 = __webpack_require__(70894), Logging = __webpack_require__(95282), EnvelopeFactory = function() {
    function EnvelopeFactory() {}
    return EnvelopeFactory.createEnvelope = function(telemetry, telemetryType, commonProperties, context, config) {
     var data = null;
     switch (telemetryType) {
     case Contracts.TelemetryType.Trace:
      data = EnvelopeFactory.createTraceData(telemetry);
      break;

     case Contracts.TelemetryType.Dependency:
      data = EnvelopeFactory.createDependencyData(telemetry);
      break;

     case Contracts.TelemetryType.Event:
      data = EnvelopeFactory.createEventData(telemetry);
      break;

     case Contracts.TelemetryType.Exception:
      data = EnvelopeFactory.createExceptionData(telemetry);
      break;

     case Contracts.TelemetryType.Request:
      data = EnvelopeFactory.createRequestData(telemetry);
      break;

     case Contracts.TelemetryType.Metric:
      data = EnvelopeFactory.createMetricData(telemetry);
      break;

     case Contracts.TelemetryType.Availability:
      data = EnvelopeFactory.createAvailabilityData(telemetry);
      break;

     case Contracts.TelemetryType.PageView:
      data = EnvelopeFactory.createPageViewData(telemetry);
     }
     if (data && data.baseData && Contracts.domainSupportsProperties(data.baseData)) {
      if (commonProperties) if (data.baseData.properties) for (var name in commonProperties) data.baseData.properties[name] || (data.baseData.properties[name] = commonProperties[name]); else data.baseData.properties = commonProperties;
      EnvelopeFactory.addAzureFunctionsCorrelationProperties(data.baseData.properties), 
      data.baseData.properties && (data.baseData.properties = Util.validateStringMap(data.baseData.properties));
     }
     var iKey = config && config.instrumentationKey || "", envelope = new Contracts.Envelope;
     return envelope.data = data, envelope.iKey = iKey, envelope.name = "Microsoft.ApplicationInsights." + iKey.replace(/-/g, "") + "." + data.baseType.substr(0, data.baseType.length - 4), 
     envelope.tags = this.getTags(context, telemetry.tagOverrides), envelope.time = (new Date).toISOString(), 
     envelope.ver = 1, envelope.sampleRate = config ? config.samplingPercentage : 100, 
     telemetryType === Contracts.TelemetryType.Metric && (envelope.sampleRate = 100), 
     envelope;
    }, EnvelopeFactory.addAzureFunctionsCorrelationProperties = function(properties) {
     var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
     if (correlationContext && correlationContext.customProperties && correlationContext.customProperties.getProperty instanceof Function) {
      properties = properties || {};
      var property = correlationContext.customProperties.getProperty("InvocationId");
      property && (properties.InvocationId = property), (property = correlationContext.customProperties.getProperty("ProcessId")) && (properties.ProcessId = property), 
      (property = correlationContext.customProperties.getProperty("LogLevel")) && (properties.LogLevel = property), 
      (property = correlationContext.customProperties.getProperty("Category")) && (properties.Category = property), 
      (property = correlationContext.customProperties.getProperty("HostInstanceId")) && (properties.HostInstanceId = property), 
      (property = correlationContext.customProperties.getProperty("AzFuncLiveLogsSessionId")) && (properties.AzFuncLiveLogsSessionId = property);
     }
    }, EnvelopeFactory.truncateProperties = function(telemetry) {
     if (telemetry.properties) try {
      for (var properties = {}, propertiesKeys = Object.keys(telemetry.properties), propertiesValues = Object.values(telemetry.properties), i = 0; i < propertiesKeys.length; i++) propertiesKeys[i].length <= 150 && (Util.isDate(propertiesValues[i]) || (null == propertiesValues[i] && (propertiesValues[i] = ""), 
      "object" == typeof propertiesValues[i] && (propertiesValues[i] = Util.stringify(propertiesValues[i])), 
      properties[propertiesKeys[i]] = String(propertiesValues[i]).substring(0, 8192)), 
      properties[propertiesKeys[i]] = propertiesValues[i]);
      return properties;
     } catch (error) {
      Logging.warn("Failed to properly truncate telemetry properties: ", error);
     }
    }, EnvelopeFactory.createTraceData = function(telemetry) {
     var _a, trace = new Contracts.MessageData;
     trace.message = null === (_a = telemetry.message) || void 0 === _a ? void 0 : _a.substring(0, 32768), 
     trace.properties = this.truncateProperties(telemetry), isNaN(telemetry.severity) ? trace.severityLevel = Contracts.SeverityLevel.Information : trace.severityLevel = telemetry.severity;
     var data = new Contracts.Data;
     return data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Trace), 
     data.baseData = trace, data;
    }, EnvelopeFactory.createDependencyData = function(telemetry) {
     var _a, _b, _c, remoteDependency = new Contracts.RemoteDependencyData;
     remoteDependency.name = null === (_a = telemetry.name) || void 0 === _a ? void 0 : _a.substring(0, 1024), 
     remoteDependency.data = null === (_b = telemetry.data) || void 0 === _b ? void 0 : _b.substring(0, 8192), 
     remoteDependency.target = null === (_c = telemetry.target) || void 0 === _c ? void 0 : _c.substring(0, 1024), 
     remoteDependency.duration = Util.msToTimeSpan(telemetry.duration), remoteDependency.success = telemetry.success, 
     remoteDependency.type = telemetry.dependencyTypeName, remoteDependency.properties = this.truncateProperties(telemetry), 
     remoteDependency.resultCode = telemetry.resultCode ? telemetry.resultCode.toString() : "0", 
     telemetry.id ? remoteDependency.id = telemetry.id : remoteDependency.id = Util.w3cTraceId();
     var data = new Contracts.Data;
     return data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Dependency), 
     data.baseData = remoteDependency, data;
    }, EnvelopeFactory.createEventData = function(telemetry) {
     var _a, event = new Contracts.EventData;
     event.name = null === (_a = telemetry.name) || void 0 === _a ? void 0 : _a.substring(0, 512), 
     event.properties = this.truncateProperties(telemetry), event.measurements = telemetry.measurements;
     var data = new Contracts.Data;
     return data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Event), 
     data.baseData = event, data;
    }, EnvelopeFactory.createExceptionData = function(telemetry) {
     var _a, _b, exception = new Contracts.ExceptionData;
     exception.properties = this.truncateProperties(telemetry), isNaN(telemetry.severity) ? exception.severityLevel = Contracts.SeverityLevel.Error : exception.severityLevel = telemetry.severity, 
     exception.measurements = telemetry.measurements, exception.exceptions = [];
     var stack = telemetry.exception.stack, exceptionDetails = new Contracts.ExceptionDetails;
     exceptionDetails.message = null === (_a = telemetry.exception.message) || void 0 === _a ? void 0 : _a.substring(0, 32768), 
     exceptionDetails.typeName = null === (_b = telemetry.exception.name) || void 0 === _b ? void 0 : _b.substring(0, 1024), 
     exceptionDetails.parsedStack = this.parseStack(stack), exceptionDetails.hasFullStack = Util.isArray(exceptionDetails.parsedStack) && exceptionDetails.parsedStack.length > 0, 
     exception.exceptions.push(exceptionDetails);
     var data = new Contracts.Data;
     return data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Exception), 
     data.baseData = exception, data;
    }, EnvelopeFactory.createRequestData = function(telemetry) {
     var _a, _b, _c, _d, requestData = new Contracts.RequestData;
     telemetry.id ? requestData.id = telemetry.id : requestData.id = Util.w3cTraceId(), 
     requestData.name = null === (_a = telemetry.name) || void 0 === _a ? void 0 : _a.substring(0, 1024), 
     requestData.url = null === (_b = telemetry.url) || void 0 === _b ? void 0 : _b.substring(0, 2048), 
     requestData.source = null === (_c = telemetry.source) || void 0 === _c ? void 0 : _c.substring(0, 1024), 
     requestData.duration = Util.msToTimeSpan(telemetry.duration), requestData.responseCode = null === (_d = telemetry.resultCode ? telemetry.resultCode.toString() : "0") || void 0 === _d ? void 0 : _d.substring(0, 1024), 
     requestData.success = telemetry.success, requestData.properties = this.truncateProperties(telemetry), 
     requestData.measurements = telemetry.measurements;
     var data = new Contracts.Data;
     return data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Request), 
     data.baseData = requestData, data;
    }, EnvelopeFactory.createMetricData = function(telemetry) {
     var _a, metrics = new Contracts.MetricData;
     metrics.metrics = [];
     var metric = new Contracts.DataPoint;
     metric.count = isNaN(telemetry.count) ? 1 : telemetry.count, metric.kind = Contracts.DataPointType.Aggregation, 
     metric.max = isNaN(telemetry.max) ? telemetry.value : telemetry.max, metric.min = isNaN(telemetry.min) ? telemetry.value : telemetry.min, 
     metric.name = null === (_a = telemetry.name) || void 0 === _a ? void 0 : _a.substring(0, 1024), 
     metric.stdDev = isNaN(telemetry.stdDev) ? 0 : telemetry.stdDev, metric.value = telemetry.value, 
     metric.ns = telemetry.namespace, metrics.metrics.push(metric), metrics.properties = this.truncateProperties(telemetry);
     var data = new Contracts.Data;
     return data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Metric), 
     data.baseData = metrics, data;
    }, EnvelopeFactory.createAvailabilityData = function(telemetry) {
     var _a, _b, availabilityData = new Contracts.AvailabilityData;
     telemetry.id ? availabilityData.id = telemetry.id : availabilityData.id = Util.w3cTraceId(), 
     availabilityData.name = null === (_a = telemetry.name) || void 0 === _a ? void 0 : _a.substring(0, 1024), 
     availabilityData.duration = Util.msToTimeSpan(telemetry.duration), availabilityData.success = telemetry.success, 
     availabilityData.runLocation = telemetry.runLocation, availabilityData.message = null === (_b = telemetry.message) || void 0 === _b ? void 0 : _b.substring(0, 8192), 
     availabilityData.measurements = telemetry.measurements, availabilityData.properties = this.truncateProperties(telemetry);
     var data = new Contracts.Data;
     return data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Availability), 
     data.baseData = availabilityData, data;
    }, EnvelopeFactory.createPageViewData = function(telemetry) {
     var _a, _b, pageViewData = new Contracts.PageViewData;
     pageViewData.name = null === (_a = telemetry.name) || void 0 === _a ? void 0 : _a.substring(0, 1024), 
     pageViewData.duration = Util.msToTimeSpan(telemetry.duration), pageViewData.url = null === (_b = telemetry.url) || void 0 === _b ? void 0 : _b.substring(0, 2048), 
     pageViewData.measurements = telemetry.measurements, pageViewData.properties = this.truncateProperties(telemetry);
     var data = new Contracts.Data;
     return data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.PageView), 
     data.baseData = pageViewData, data;
    }, EnvelopeFactory.getTags = function(context, tagOverrides) {
     var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext(), newTags = {};
     if (context && context.tags) for (var key in context.tags) newTags[key] = context.tags[key];
     if (tagOverrides) for (var key in tagOverrides) newTags[key] = tagOverrides[key];
     return correlationContext && (newTags[context.keys.operationId] = newTags[context.keys.operationId] || correlationContext.operation.id, 
     newTags[context.keys.operationName] = newTags[context.keys.operationName] || correlationContext.operation.name, 
     newTags[context.keys.operationParentId] = newTags[context.keys.operationParentId] || correlationContext.operation.parentId), 
     newTags;
    }, EnvelopeFactory.parseStack = function(stack) {
     var parsedStack = void 0;
     if ("string" == typeof stack) {
      var frames = stack.split("\n");
      parsedStack = [];
      for (var level = 0, totalSizeInBytes = 0, i = 0; i <= frames.length; i++) {
       var frame = frames[i];
       if (_StackFrame.regex.test(frame)) {
        var parsedFrame = new _StackFrame(frames[i], level++);
        totalSizeInBytes += parsedFrame.sizeInBytes, parsedStack.push(parsedFrame);
       }
      }
      if (totalSizeInBytes > 32768) for (var left = 0, right = parsedStack.length - 1, size = 0, acceptedLeft = left, acceptedRight = right; left < right; ) {
       if ((size += parsedStack[left].sizeInBytes + parsedStack[right].sizeInBytes) > 32768) {
        var howMany = acceptedRight - acceptedLeft + 1;
        parsedStack.splice(acceptedLeft, howMany);
        break;
       }
       acceptedLeft = left, acceptedRight = right, left++, right--;
      }
     }
     return parsedStack;
    }, EnvelopeFactory;
   }(), _StackFrame = function() {
    function _StackFrame(frame, level) {
     this.sizeInBytes = 0, this.level = level, this.method = "<no_method>", this.assembly = Util.trim(frame);
     var matches = frame.match(_StackFrame.regex);
     matches && matches.length >= 5 && (this.method = Util.trim(matches[2]) || this.method, 
     this.fileName = Util.trim(matches[4]) || "<no_filename>", this.line = parseInt(matches[5]) || 0), 
     this.sizeInBytes += this.method.length, this.sizeInBytes += this.fileName.length, 
     this.sizeInBytes += this.assembly.length, this.sizeInBytes += _StackFrame.baseSize, 
     this.sizeInBytes += this.level.toString().length, this.sizeInBytes += this.line.toString().length;
    }
    return _StackFrame.regex = /^(\s+at)?(.*?)(\@|\s\(|\s)([^\(\n]+):(\d+):(\d+)(\)?)$/, 
    _StackFrame.baseSize = 58, _StackFrame;
   }();
   module.exports = EnvelopeFactory;
  },
  12640: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }, __generator = this && this.__generator || function(thisArg, body) {
    var f, y, t, g, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    };
    return g = {
     next: verb(0),
     throw: verb(1),
     return: verb(2)
    }, "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;_; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.FileAccessControl = void 0;
   var fs = __webpack_require__(57147), os = __webpack_require__(22037), child_process = __webpack_require__(32081), Logging = __webpack_require__(95282), FileAccessControl = function() {
    function FileAccessControl() {}
    return FileAccessControl.checkFileProtection = function() {
     if (!FileAccessControl.OS_PROVIDES_FILE_PROTECTION && !FileAccessControl.OS_FILE_PROTECTION_CHECKED) if (FileAccessControl.OS_FILE_PROTECTION_CHECKED = !0, 
     FileAccessControl.USE_ICACLS) {
      try {
       FileAccessControl.OS_PROVIDES_FILE_PROTECTION = fs.existsSync(FileAccessControl.ICACLS_PATH);
      } catch (e) {}
      FileAccessControl.OS_PROVIDES_FILE_PROTECTION || Logging.warn(FileAccessControl.TAG, "Could not find ICACLS in expected location! This is necessary to use disk retry mode on Windows.");
     } else FileAccessControl.OS_PROVIDES_FILE_PROTECTION = !0;
    }, FileAccessControl.applyACLRules = function(directory) {
     return __awaiter(this, void 0, void 0, (function() {
      var identity, ex_1;
      return __generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        if (!FileAccessControl.USE_ICACLS) return [ 3, 7 ];
        if (void 0 !== FileAccessControl.ACLED_DIRECTORIES[directory]) return [ 3, 6 ];
        FileAccessControl.ACLED_DIRECTORIES[directory] = !1, _a.label = 1;

       case 1:
        return _a.trys.push([ 1, 4, , 5 ]), [ 4, this._getACLIdentity() ];

       case 2:
        return identity = _a.sent(), [ 4, this._runICACLS(this._getACLArguments(directory, identity)) ];

       case 3:
        return _a.sent(), FileAccessControl.ACLED_DIRECTORIES[directory] = !0, [ 3, 5 ];

       case 4:
        throw ex_1 = _a.sent(), FileAccessControl.ACLED_DIRECTORIES[directory] = !1, ex_1;

       case 5:
        return [ 3, 7 ];

       case 6:
        if (!FileAccessControl.ACLED_DIRECTORIES[directory]) throw new Error("Setting ACL restrictions did not succeed (cached result)");
        _a.label = 7;

       case 7:
        return [ 2 ];
       }
      }));
     }));
    }, FileAccessControl.applyACLRulesSync = function(directory) {
     if (FileAccessControl.USE_ICACLS) {
      if (void 0 === FileAccessControl.ACLED_DIRECTORIES[directory]) return this._runICACLSSync(this._getACLArguments(directory, this._getACLIdentitySync())), 
      void (FileAccessControl.ACLED_DIRECTORIES[directory] = !0);
      if (!FileAccessControl.ACLED_DIRECTORIES[directory]) throw new Error("Setting ACL restrictions did not succeed (cached result)");
     }
    }, FileAccessControl._runICACLS = function(args) {
     return new Promise((function(resolve, reject) {
      var aclProc = child_process.spawn(FileAccessControl.ICACLS_PATH, args, {
       windowsHide: !0
      });
      aclProc.on("error", (function(e) {
       return reject(e);
      })), aclProc.on("close", (function(code, signal) {
       0 === code ? resolve() : reject(new Error("Setting ACL restrictions did not succeed (ICACLS returned code " + code + ")"));
      }));
     }));
    }, FileAccessControl._runICACLSSync = function(args) {
     if (!child_process.spawnSync) throw new Error("Could not synchronously call ICACLS under current version of Node.js");
     var aclProc = child_process.spawnSync(FileAccessControl.ICACLS_PATH, args, {
      windowsHide: !0
     });
     if (aclProc.error) throw aclProc.error;
     if (0 !== aclProc.status) throw new Error("Setting ACL restrictions did not succeed (ICACLS returned code " + aclProc.status + ")");
    }, FileAccessControl._getACLIdentity = function() {
     return new Promise((function(resolve, reject) {
      FileAccessControl.ACL_IDENTITY && resolve(FileAccessControl.ACL_IDENTITY);
      var psProc = child_process.spawn(FileAccessControl.POWERSHELL_PATH, [ "-Command", "[System.Security.Principal.WindowsIdentity]::GetCurrent().Name" ], {
       windowsHide: !0,
       stdio: [ "ignore", "pipe", "pipe" ]
      }), data = "";
      psProc.stdout.on("data", (function(d) {
       return data += d;
      })), psProc.on("error", (function(e) {
       return reject(e);
      })), psProc.on("close", (function(code, signal) {
       FileAccessControl.ACL_IDENTITY = data && data.trim(), 0 === code ? resolve(FileAccessControl.ACL_IDENTITY) : reject(new Error("Getting ACL identity did not succeed (PS returned code " + code + ")"));
      }));
     }));
    }, FileAccessControl._getACLIdentitySync = function() {
     if (FileAccessControl.ACL_IDENTITY) return FileAccessControl.ACL_IDENTITY;
     if (child_process.spawnSync) {
      var psProc = child_process.spawnSync(FileAccessControl.POWERSHELL_PATH, [ "-Command", "[System.Security.Principal.WindowsIdentity]::GetCurrent().Name" ], {
       windowsHide: !0,
       stdio: [ "ignore", "pipe", "pipe" ]
      });
      if (psProc.error) throw psProc.error;
      if (0 !== psProc.status) throw new Error("Getting ACL identity did not succeed (PS returned code " + psProc.status + ")");
      return FileAccessControl.ACL_IDENTITY = psProc.stdout && psProc.stdout.toString().trim(), 
      FileAccessControl.ACL_IDENTITY;
     }
     throw new Error("Could not synchronously get ACL identity under current version of Node.js");
    }, FileAccessControl._getACLArguments = function(directory, identity) {
     return [ directory, "/grant", "*S-1-5-32-544:(OI)(CI)F", "/grant", identity + ":(OI)(CI)F", "/inheritance:r" ];
    }, FileAccessControl.TAG = "FileAccessControl", FileAccessControl.ICACLS_PATH = process.env.systemdrive + "/windows/system32/icacls.exe", 
    FileAccessControl.POWERSHELL_PATH = process.env.systemdrive + "/windows/system32/windowspowershell/v1.0/powershell.exe", 
    FileAccessControl.ACLED_DIRECTORIES = {}, FileAccessControl.ACL_IDENTITY = null, 
    FileAccessControl.OS_FILE_PROTECTION_CHECKED = !1, FileAccessControl.OS_PROVIDES_FILE_PROTECTION = !1, 
    FileAccessControl.USE_ICACLS = "Windows_NT" === os.type(), FileAccessControl;
   }();
   exports.FileAccessControl = FileAccessControl;
  },
  30164: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }, __generator = this && this.__generator || function(thisArg, body) {
    var f, y, t, g, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    };
    return g = {
     next: verb(0),
     throw: verb(1),
     return: verb(2)
    }, "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;_; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.getShallowFileSize = exports.getShallowDirectorySizeSync = exports.getShallowDirectorySize = exports.confirmDirExists = exports.unlinkAsync = exports.readdirAsync = exports.readFileAsync = exports.writeFileAsync = exports.appendFileAsync = exports.accessAsync = exports.mkdirAsync = exports.lstatAsync = exports.statAsync = void 0;
   var fs = __webpack_require__(57147), path = __webpack_require__(71017), util_1 = __webpack_require__(73837);
   exports.statAsync = util_1.promisify(fs.stat), exports.lstatAsync = util_1.promisify(fs.lstat), 
   exports.mkdirAsync = util_1.promisify(fs.mkdir), exports.accessAsync = util_1.promisify(fs.access), 
   exports.appendFileAsync = util_1.promisify(fs.appendFile), exports.writeFileAsync = util_1.promisify(fs.writeFile), 
   exports.readFileAsync = util_1.promisify(fs.readFile), exports.readdirAsync = util_1.promisify(fs.readdir), 
   exports.unlinkAsync = util_1.promisify(fs.unlink);
   exports.confirmDirExists = function(directory) {
    return __awaiter(void 0, void 0, void 0, (function() {
     var err_1, mkdirErr_1;
     return __generator(this, (function(_a) {
      switch (_a.label) {
      case 0:
       return _a.trys.push([ 0, 2, , 7 ]), [ 4, exports.lstatAsync(directory) ];

      case 1:
       if (!_a.sent().isDirectory()) throw new Error("Path existed but was not a directory");
       return [ 3, 7 ];

      case 2:
       if (!(err_1 = _a.sent()) || "ENOENT" !== err_1.code) return [ 3, 6 ];
       _a.label = 3;

      case 3:
       return _a.trys.push([ 3, 5, , 6 ]), [ 4, exports.mkdirAsync(directory) ];

      case 4:
       return _a.sent(), [ 3, 6 ];

      case 5:
       if ((mkdirErr_1 = _a.sent()) && "EEXIST" !== mkdirErr_1.code) throw mkdirErr_1;
       return [ 3, 6 ];

      case 6:
       return [ 3, 7 ];

      case 7:
       return [ 2 ];
      }
     }));
    }));
   };
   exports.getShallowDirectorySize = function(directory) {
    return __awaiter(void 0, void 0, void 0, (function() {
     var files, totalSize, _i, files_1, file, fileStats;
     return __generator(this, (function(_a) {
      switch (_a.label) {
      case 0:
       return [ 4, exports.readdirAsync(directory) ];

      case 1:
       files = _a.sent(), totalSize = 0, _i = 0, files_1 = files, _a.label = 2;

      case 2:
       return _i < files_1.length ? (file = files_1[_i], [ 4, exports.statAsync(path.join(directory, file)) ]) : [ 3, 5 ];

      case 3:
       (fileStats = _a.sent()).isFile() && (totalSize += fileStats.size), _a.label = 4;

      case 4:
       return _i++, [ 3, 2 ];

      case 5:
       return [ 2, totalSize ];
      }
     }));
    }));
   };
   exports.getShallowDirectorySizeSync = function(directory) {
    for (var files = fs.readdirSync(directory), totalSize = 0, i = 0; i < files.length; i++) totalSize += fs.statSync(path.join(directory, files[i])).size;
    return totalSize;
   };
   exports.getShallowFileSize = function(filePath) {
    return __awaiter(void 0, void 0, void 0, (function() {
     var fileStats;
     return __generator(this, (function(_a) {
      switch (_a.label) {
      case 0:
       return [ 4, exports.statAsync(filePath) ];

      case 1:
       return (fileStats = _a.sent()).isFile() ? [ 2, fileStats.size ] : [ 2 ];
      }
     }));
    }));
   };
  },
  56761: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  23370: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }, __generator = this && this.__generator || function(thisArg, body) {
    var f, y, t, g, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    };
    return g = {
     next: verb(0),
     throw: verb(1),
     return: verb(2)
    }, "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;_; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   }, __spreadArrays = this && this.__spreadArrays || function() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    var r = Array(s), k = 0;
    for (i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, 
    k++) r[k] = a[j];
    return r;
   }, fs = __webpack_require__(57147), os = __webpack_require__(22037), path = __webpack_require__(71017), FileSystemHelper = __webpack_require__(30164), InternalAzureLogger = function() {
    function InternalAzureLogger() {
     var _this = this;
     this.TAG = "Logger", this._cleanupTimeOut = 18e5, this._tempDir = "", this._logFileName = "", 
     this._fileFullPath = "", this._backUpNameFormat = "", this._logToFile = !1, this._logToConsole = !0;
     var logDestination = process.env.APPLICATIONINSIGHTS_LOG_DESTINATION;
     "file+console" == logDestination && (this._logToFile = !0), "file" == logDestination && (this._logToFile = !0, 
     this._logToConsole = !1), this.maxSizeBytes = 5e4, this.maxHistory = 1, this._logFileName = "applicationinsights.log";
     var logFilePath = process.env.APPLICATIONINSIGHTS_LOGDIR;
     logFilePath ? path.isAbsolute(logFilePath) ? this._tempDir = logFilePath : this._tempDir = path.join(process.cwd(), logFilePath) : this._tempDir = path.join(os.tmpdir(), "appInsights-node"), 
     this._fileFullPath = path.join(this._tempDir, this._logFileName), this._backUpNameFormat = "." + this._logFileName, 
     this._logToFile && (InternalAzureLogger._fileCleanupTimer || (InternalAzureLogger._fileCleanupTimer = setInterval((function() {
      _this._fileCleanupTask();
     }), this._cleanupTimeOut), InternalAzureLogger._fileCleanupTimer.unref()));
    }
    return InternalAzureLogger.prototype.info = function(message) {
     for (var optionalParams = [], _i = 1; _i < arguments.length; _i++) optionalParams[_i - 1] = arguments[_i];
     var args = message ? __spreadArrays([ message ], optionalParams) : optionalParams;
     this._logToFile && this._storeToDisk(args), this._logToConsole && console.info.apply(console, args);
    }, InternalAzureLogger.prototype.warning = function(message) {
     for (var optionalParams = [], _i = 1; _i < arguments.length; _i++) optionalParams[_i - 1] = arguments[_i];
     var args = message ? __spreadArrays([ message ], optionalParams) : optionalParams;
     this._logToFile && this._storeToDisk(args), this._logToConsole && console.warn.apply(console, args);
    }, InternalAzureLogger.getInstance = function() {
     return InternalAzureLogger._instance || (InternalAzureLogger._instance = new InternalAzureLogger), 
     InternalAzureLogger._instance;
    }, InternalAzureLogger.prototype._storeToDisk = function(args) {
     return __awaiter(this, void 0, void 0, (function() {
      var data, err_1, appendError_1, err_3;
      return __generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        data = args + "\r\n", _a.label = 1;

       case 1:
        return _a.trys.push([ 1, 3, , 4 ]), [ 4, FileSystemHelper.confirmDirExists(this._tempDir) ];

       case 2:
        return _a.sent(), [ 3, 4 ];

       case 3:
        return err_1 = _a.sent(), console.log(this.TAG, "Failed to create directory for log file: " + (err_1 && err_1.message)), 
        [ 2 ];

       case 4:
        return _a.trys.push([ 4, 6, , 11 ]), [ 4, FileSystemHelper.accessAsync(this._fileFullPath, fs.constants.F_OK) ];

       case 5:
        return _a.sent(), [ 3, 11 ];

       case 6:
        appendError_1 = _a.sent(), _a.label = 7;

       case 7:
        return _a.trys.push([ 7, 9, , 10 ]), [ 4, FileSystemHelper.appendFileAsync(this._fileFullPath, data) ];

       case 8:
        return _a.sent(), [ 2 ];

       case 9:
        return _a.sent(), console.log(this.TAG, "Failed to put log into file: " + (appendError_1 && appendError_1.message)), 
        [ 2 ];

       case 10:
        return [ 3, 11 ];

       case 11:
        return _a.trys.push([ 11, 17, , 18 ]), [ 4, FileSystemHelper.getShallowFileSize(this._fileFullPath) ];

       case 12:
        return _a.sent() > this.maxSizeBytes ? [ 4, this._createBackupFile(data) ] : [ 3, 14 ];

       case 13:
        return _a.sent(), [ 3, 16 ];

       case 14:
        return [ 4, FileSystemHelper.appendFileAsync(this._fileFullPath, data) ];

       case 15:
        _a.sent(), _a.label = 16;

       case 16:
        return [ 3, 18 ];

       case 17:
        return err_3 = _a.sent(), console.log(this.TAG, "Failed to create backup file: " + (err_3 && err_3.message)), 
        [ 3, 18 ];

       case 18:
        return [ 2 ];
       }
      }));
     }));
    }, InternalAzureLogger.prototype._createBackupFile = function(data) {
     return __awaiter(this, void 0, void 0, (function() {
      var buffer, backupPath, err_4;
      return __generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return _a.trys.push([ 0, 3, 4, 5 ]), [ 4, FileSystemHelper.readFileAsync(this._fileFullPath) ];

       case 1:
        return buffer = _a.sent(), backupPath = path.join(this._tempDir, (new Date).getTime() + "." + this._logFileName), 
        [ 4, FileSystemHelper.writeFileAsync(backupPath, buffer) ];

       case 2:
        return _a.sent(), [ 3, 5 ];

       case 3:
        return err_4 = _a.sent(), console.log("Failed to generate backup log file", err_4), 
        [ 3, 5 ];

       case 4:
        return FileSystemHelper.writeFileAsync(this._fileFullPath, data), [ 7 ];

       case 5:
        return [ 2 ];
       }
      }));
     }));
    }, InternalAzureLogger.prototype._fileCleanupTask = function() {
     return __awaiter(this, void 0, void 0, (function() {
      var files, totalFiles, i, pathToDelete, err_5, _this = this;
      return __generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return _a.trys.push([ 0, 6, , 7 ]), [ 4, FileSystemHelper.readdirAsync(this._tempDir) ];

       case 1:
        (files = (files = _a.sent()).filter((function(f) {
         return path.basename(f).indexOf(_this._backUpNameFormat) > -1;
        }))).sort((function(a, b) {
         var aCreationDate = new Date(parseInt(a.split(_this._backUpNameFormat)[0])), bCreationDate = new Date(parseInt(b.split(_this._backUpNameFormat)[0]));
         return aCreationDate < bCreationDate ? -1 : aCreationDate >= bCreationDate ? 1 : void 0;
        })), totalFiles = files.length, i = 0, _a.label = 2;

       case 2:
        return i < totalFiles - this.maxHistory ? (pathToDelete = path.join(this._tempDir, files[i]), 
        [ 4, FileSystemHelper.unlinkAsync(pathToDelete) ]) : [ 3, 5 ];

       case 3:
        _a.sent(), _a.label = 4;

       case 4:
        return i++, [ 3, 2 ];

       case 5:
        return [ 3, 7 ];

       case 6:
        return err_5 = _a.sent(), console.log(this.TAG, "Failed to cleanup log files: " + (err_5 && err_5.message)), 
        [ 3, 7 ];

       case 7:
        return [ 2 ];
       }
      }));
     }));
    }, InternalAzureLogger._fileCleanupTimer = null, InternalAzureLogger;
   }();
   module.exports = InternalAzureLogger;
  },
  3063: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.JsonConfig = void 0;
   var fs = __webpack_require__(57147), path = __webpack_require__(71017), Logging = __webpack_require__(95282), JsonConfig = function() {
    function JsonConfig() {
     this.connectionString = process.env.APPLICATIONINSIGHTS_CONNECTION_STRING, this.instrumentationKey = process.env.APPINSIGHTS_INSTRUMENTATIONKEY || process.env.APPSETTING_APPINSIGHTS_INSTRUMENTATIONKEY || process.env.APPINSIGHTS_INSTRUMENTATION_KEY || process.env.APPSETTING_APPINSIGHTS_INSTRUMENTATION_KEY, 
     !this.connectionString && this.instrumentationKey && Logging.warn("APPINSIGHTS_INSTRUMENTATIONKEY is in path of deprecation, please use APPLICATIONINSIGHTS_CONNECTION_STRING env variable to setup the SDK."), 
     this.disableAllExtendedMetrics = !!process.env.APPLICATION_INSIGHTS_DISABLE_ALL_EXTENDED_METRICS, 
     this.extendedMetricDisablers = process.env.APPLICATION_INSIGHTS_DISABLE_EXTENDED_METRIC, 
     this.proxyHttpUrl = process.env.http_proxy, this.proxyHttpsUrl = process.env.https_proxy, 
     this.noDiagnosticChannel = !!process.env.APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL, 
     this.disableStatsbeat = !!process.env.APPLICATION_INSIGHTS_NO_STATSBEAT, this.noHttpAgentKeepAlive = !!process.env.APPLICATION_INSIGHTS_NO_HTTP_AGENT_KEEP_ALIVE, 
     this.noPatchModules = process.env.APPLICATION_INSIGHTS_NO_PATCH_MODULES || "", this.enableWebInstrumentation = !!process.env.APPLICATIONINSIGHTS_WEB_INSTRUMENTATION_ENABLED || !!process.env.APPLICATIONINSIGHTS_WEB_SNIPPET_ENABLED, 
     this.webInstrumentationSrc = process.env.APPLICATIONINSIGHTS_WEB_INSTRUMENTATION_SOURCE || "", 
     this.webInstrumentationConnectionString = process.env.APPLICATIONINSIGHTS_WEB_INSTRUMENTATION_CONNECTION_STRING || process.env.APPLICATIONINSIGHTS_WEB_SNIPPET_CONNECTION_STRING || "", 
     this.enableAutoWebSnippetInjection = this.enableWebInstrumentation, this.webSnippetConnectionString = this.webInstrumentationConnectionString, 
     this._loadJsonFile();
    }
    return JsonConfig.getInstance = function() {
     return JsonConfig._instance || (JsonConfig._instance = new JsonConfig), JsonConfig._instance;
    }, JsonConfig.prototype._loadJsonFile = function() {
     var jsonString = "", contentJsonConfig = process.env.APPLICATIONINSIGHTS_CONFIGURATION_CONTENT;
     if (contentJsonConfig) jsonString = contentJsonConfig; else {
      var rootPath = path.join(__dirname, "../../"), tempDir = path.join(rootPath, "applicationinsights.json"), configFile = process.env.APPLICATIONINSIGHTS_CONFIGURATION_FILE;
      configFile && (tempDir = path.isAbsolute(configFile) ? configFile : path.join(rootPath, configFile));
      try {
       jsonString = fs.readFileSync(tempDir, "utf8");
      } catch (err) {
       Logging.info("Failed to read JSON config file: ", err);
      }
     }
     try {
      var jsonConfig = JSON.parse(jsonString);
      null != jsonConfig.disableStatsbeat && (this.disableStatsbeat = jsonConfig.disableStatsbeat), 
      null != jsonConfig.disableAllExtendedMetrics && (this.disableAllExtendedMetrics = jsonConfig.disableStatsbeat), 
      null != jsonConfig.noDiagnosticChannel && (this.noDiagnosticChannel = jsonConfig.noDiagnosticChannel), 
      null != jsonConfig.noHttpAgentKeepAlive && (this.noHttpAgentKeepAlive = jsonConfig.noHttpAgentKeepAlive), 
      null != jsonConfig.connectionString && (this.connectionString = jsonConfig.connectionString), 
      null != jsonConfig.extendedMetricDisablers && (this.extendedMetricDisablers = jsonConfig.extendedMetricDisablers), 
      null != jsonConfig.noDiagnosticChannel && (this.noDiagnosticChannel = jsonConfig.noDiagnosticChannel), 
      null != jsonConfig.proxyHttpUrl && (this.proxyHttpUrl = jsonConfig.proxyHttpUrl), 
      null != jsonConfig.proxyHttpsUrl && (this.proxyHttpsUrl = jsonConfig.proxyHttpsUrl), 
      null != jsonConfig.proxyHttpsUrl && (this.proxyHttpsUrl = jsonConfig.proxyHttpsUrl), 
      null != jsonConfig.noPatchModules && (this.noPatchModules = jsonConfig.noPatchModules), 
      null != jsonConfig.enableAutoWebSnippetInjection && (this.enableWebInstrumentation = jsonConfig.enableAutoWebSnippetInjection, 
      this.enableAutoWebSnippetInjection = this.enableWebInstrumentation), null != jsonConfig.enableWebInstrumentation && (this.enableWebInstrumentation = jsonConfig.enableWebInstrumentation, 
      this.enableAutoWebSnippetInjection = this.enableWebInstrumentation), null != jsonConfig.webSnippetConnectionString && (this.webInstrumentationConnectionString = jsonConfig.webSnippetConnectionString, 
      this.webSnippetConnectionString = this.webInstrumentationConnectionString), null != jsonConfig.webInstrumentationConnectionString && (this.webInstrumentationConnectionString = jsonConfig.webInstrumentationConnectionString, 
      this.webSnippetConnectionString = this.webInstrumentationConnectionString), null != jsonConfig.webInstrumentationConfig && (this.webInstrumentationConfig = jsonConfig.webInstrumentationConfig), 
      null != jsonConfig.webInstrumentationSrc && (this.webInstrumentationSrc = jsonConfig.webInstrumentationSrc), 
      null != jsonConfig.enableLoggerErrorToTrace && (this.enableLoggerErrorToTrace = jsonConfig.enableLoggerErrorToTrace), 
      this.endpointUrl = jsonConfig.endpointUrl, this.maxBatchSize = jsonConfig.maxBatchSize, 
      this.maxBatchIntervalMs = jsonConfig.maxBatchIntervalMs, this.disableAppInsights = jsonConfig.disableAppInsights, 
      this.samplingPercentage = jsonConfig.samplingPercentage, this.correlationIdRetryIntervalMs = jsonConfig.correlationIdRetryIntervalMs, 
      this.correlationHeaderExcludedDomains = jsonConfig.correlationHeaderExcludedDomains, 
      this.ignoreLegacyHeaders = jsonConfig.ignoreLegacyHeaders, this.distributedTracingMode = jsonConfig.distributedTracingMode, 
      this.enableAutoCollectExternalLoggers = jsonConfig.enableAutoCollectExternalLoggers, 
      this.enableAutoCollectConsole = jsonConfig.enableAutoCollectConsole, this.enableLoggerErrorToTrace = jsonConfig.enableLoggerErrorToTrace, 
      this.enableAutoCollectExceptions = jsonConfig.enableAutoCollectExceptions, this.enableAutoCollectPerformance = jsonConfig.enableAutoCollectPerformance, 
      this.enableAutoCollectExtendedMetrics = jsonConfig.enableAutoCollectExtendedMetrics, 
      this.enableAutoCollectPreAggregatedMetrics = jsonConfig.enableAutoCollectPreAggregatedMetrics, 
      this.enableAutoCollectHeartbeat = jsonConfig.enableAutoCollectHeartbeat, this.enableAutoCollectRequests = jsonConfig.enableAutoCollectRequests, 
      this.enableAutoCollectDependencies = jsonConfig.enableAutoCollectDependencies, this.enableAutoDependencyCorrelation = jsonConfig.enableAutoDependencyCorrelation, 
      this.enableAutoCollectIncomingRequestAzureFunctions = jsonConfig.enableAutoCollectIncomingRequestAzureFunctions, 
      this.enableUseAsyncHooks = jsonConfig.enableUseAsyncHooks, this.enableUseDiskRetryCaching = jsonConfig.enableUseDiskRetryCaching, 
      this.enableResendInterval = jsonConfig.enableResendInterval, this.enableMaxBytesOnDisk = jsonConfig.enableMaxBytesOnDisk, 
      this.enableInternalDebugLogging = jsonConfig.enableInternalDebugLogging, this.enableInternalWarningLogging = jsonConfig.enableInternalWarningLogging, 
      this.enableSendLiveMetrics = jsonConfig.enableSendLiveMetrics, this.quickPulseHost = jsonConfig.quickPulseHost;
     } catch (err) {
      Logging.info("Invalid JSON config file: ", err);
     }
    }, JsonConfig;
   }();
   exports.JsonConfig = JsonConfig;
  },
  95282: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var InternalAzureLogger = __webpack_require__(23370), Logging = function() {
    function Logging() {}
    return Logging.info = function(message) {
     for (var optionalParams = [], _i = 1; _i < arguments.length; _i++) optionalParams[_i - 1] = arguments[_i];
     this.enableDebug && InternalAzureLogger.getInstance().info(this.TAG + message, optionalParams);
    }, Logging.warn = function(message) {
     for (var optionalParams = [], _i = 1; _i < arguments.length; _i++) optionalParams[_i - 1] = arguments[_i];
     this.disableWarnings || InternalAzureLogger.getInstance().warning(this.TAG + message, optionalParams);
    }, Logging.enableDebug = !1, Logging.disableWarnings = !1, Logging.TAG = "ApplicationInsights:", 
    Logging;
   }();
   module.exports = Logging;
  },
  1259: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var extendStatics, __extends = this && this.__extends || (extendStatics = function(d, b) {
    return extendStatics = Object.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
    }, extendStatics(d, b);
   }, function(d, b) {
    function __() {
     this.constructor = d;
    }
    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
    new __);
   }), TelemetryClient = __webpack_require__(67625), ServerRequestTracking = __webpack_require__(40731), ClientRequestTracking = __webpack_require__(88723), Logging = __webpack_require__(95282), NodeClient = function(_super) {
    function NodeClient() {
     return null !== _super && _super.apply(this, arguments) || this;
    }
    return __extends(NodeClient, _super), NodeClient.prototype.trackNodeHttpRequestSync = function(telemetry) {
     telemetry && telemetry.request && telemetry.response && telemetry.duration ? ServerRequestTracking.trackRequestSync(this, telemetry) : Logging.warn("trackNodeHttpRequestSync requires NodeHttpRequestTelemetry object with request, response and duration specified.");
    }, NodeClient.prototype.trackNodeHttpRequest = function(telemetry) {
     (telemetry.duration || telemetry.error) && Logging.warn("trackNodeHttpRequest will ignore supplied duration and error parameters. These values are collected from the request and response objects."), 
     telemetry && telemetry.request && telemetry.response ? ServerRequestTracking.trackRequest(this, telemetry) : Logging.warn("trackNodeHttpRequest requires NodeHttpRequestTelemetry object with request and response specified.");
    }, NodeClient.prototype.trackNodeHttpDependency = function(telemetry) {
     telemetry && telemetry.request ? ClientRequestTracking.trackRequest(this, telemetry) : Logging.warn("trackNodeHttpDependency requires NodeHttpDependencyTelemetry object with request specified.");
    }, NodeClient;
   }(TelemetryClient);
   module.exports = NodeClient;
  },
  40095: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.getResourceProvider = exports.getOsPrefix = exports.isFunctionApp = exports.isWebApp = exports.isLinux = exports.isWindows = void 0;
   exports.isWindows = function() {
    return "win32" === process.platform;
   };
   exports.isLinux = function() {
    return "linux" === process.platform;
   };
   exports.isWebApp = function() {
    return !!process.env.WEBSITE_SITE_NAME;
   };
   exports.isFunctionApp = function() {
    return !!process.env.FUNCTIONS_WORKER_RUNTIME;
   };
   exports.getOsPrefix = function() {
    return exports.isWindows() ? "w" : exports.isLinux() ? "l" : "u";
   };
   exports.getResourceProvider = function() {
    return exports.isWebApp() ? "a" : exports.isFunctionApp() ? "f" : "u";
   };
  },
  87148: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var __assign = this && this.__assign || function() {
    return __assign = Object.assign || function(t) {
     for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
     return t;
    }, __assign.apply(this, arguments);
   }, os = __webpack_require__(22037), Contracts = __webpack_require__(55290), Constants = __webpack_require__(63580), Util = __webpack_require__(25740), Logging = __webpack_require__(95282), StreamId = Util.w3cTraceId(), QuickPulseEnvelopeFactory = function() {
    function QuickPulseEnvelopeFactory() {}
    return QuickPulseEnvelopeFactory.createQuickPulseEnvelope = function(metrics, documents, config, context) {
     var machineName = os && "function" == typeof os.hostname && os.hostname() || "Unknown", instance = context.tags && context.keys && context.keys.cloudRoleInstance && context.tags[context.keys.cloudRoleInstance] || machineName, roleName = context.tags && context.keys && context.keys.cloudRole && context.tags[context.keys.cloudRole] || null;
     return {
      Documents: documents.length > 0 ? documents : null,
      InstrumentationKey: config.instrumentationKey || "",
      Metrics: metrics.length > 0 ? metrics : null,
      InvariantVersion: 1,
      Timestamp: "/Date(" + Date.now() + ")/",
      Version: context.tags[context.keys.internalSdkVersion],
      StreamId,
      MachineName: machineName,
      Instance: instance,
      RoleName: roleName
     };
    }, QuickPulseEnvelopeFactory.createQuickPulseMetric = function(telemetry) {
     return {
      Name: telemetry.name,
      Value: telemetry.value,
      Weight: telemetry.count || 1
     };
    }, QuickPulseEnvelopeFactory.telemetryEnvelopeToQuickPulseDocument = function(envelope) {
     switch (envelope.data.baseType) {
     case Contracts.TelemetryTypeString.Event:
      return QuickPulseEnvelopeFactory.createQuickPulseEventDocument(envelope);

     case Contracts.TelemetryTypeString.Exception:
      return QuickPulseEnvelopeFactory.createQuickPulseExceptionDocument(envelope);

     case Contracts.TelemetryTypeString.Trace:
      return QuickPulseEnvelopeFactory.createQuickPulseTraceDocument(envelope);

     case Contracts.TelemetryTypeString.Dependency:
      return QuickPulseEnvelopeFactory.createQuickPulseDependencyDocument(envelope);

     case Contracts.TelemetryTypeString.Request:
      return QuickPulseEnvelopeFactory.createQuickPulseRequestDocument(envelope);
     }
     return null;
    }, QuickPulseEnvelopeFactory.createQuickPulseEventDocument = function(envelope) {
     var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope), name = envelope.data.baseData.name;
     return __assign(__assign({}, document), {
      Name: name
     });
    }, QuickPulseEnvelopeFactory.createQuickPulseTraceDocument = function(envelope) {
     var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope), severityLevel = envelope.data.baseData.severityLevel || 0;
     return __assign(__assign({}, document), {
      Message: envelope.data.baseData.message,
      SeverityLevel: Contracts.SeverityLevel[severityLevel]
     });
    }, QuickPulseEnvelopeFactory.createQuickPulseExceptionDocument = function(envelope) {
     var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope), exceptionDetails = envelope.data.baseData.exceptions, exception = "", exceptionMessage = "", exceptionType = "";
     return exceptionDetails && exceptionDetails.length > 0 && (exceptionDetails[0].parsedStack && exceptionDetails[0].parsedStack.length > 0 ? exceptionDetails[0].parsedStack.forEach((function(err) {
      exception += err.assembly + "\n";
     })) : exceptionDetails[0].stack && exceptionDetails[0].stack.length > 0 && (exception = exceptionDetails[0].stack), 
     exceptionMessage = exceptionDetails[0].message, exceptionType = exceptionDetails[0].typeName), 
     __assign(__assign({}, document), {
      Exception: exception,
      ExceptionMessage: exceptionMessage,
      ExceptionType: exceptionType
     });
    }, QuickPulseEnvelopeFactory.createQuickPulseRequestDocument = function(envelope) {
     var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope), baseData = envelope.data.baseData;
     return __assign(__assign({}, document), {
      Name: baseData.name,
      Success: baseData.success,
      Duration: baseData.duration,
      ResponseCode: baseData.responseCode,
      OperationName: baseData.name
     });
    }, QuickPulseEnvelopeFactory.createQuickPulseDependencyDocument = function(envelope) {
     var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope), baseData = envelope.data.baseData;
     return __assign(__assign({}, document), {
      Name: baseData.name,
      Target: baseData.target,
      Success: baseData.success,
      Duration: baseData.duration,
      ResultCode: baseData.resultCode,
      CommandName: baseData.data,
      OperationName: document.OperationId,
      DependencyTypeName: baseData.type
     });
    }, QuickPulseEnvelopeFactory.createQuickPulseDocument = function(envelope) {
     var documentType, __type;
     return envelope.data.baseType ? (__type = Constants.TelemetryTypeStringToQuickPulseType[envelope.data.baseType], 
     documentType = Constants.TelemetryTypeStringToQuickPulseDocumentType[envelope.data.baseType]) : Logging.warn("Document type invalid; not sending live metric document", envelope.data.baseType), 
     {
      DocumentType: documentType,
      __type,
      OperationId: envelope.tags[QuickPulseEnvelopeFactory.keys.operationId],
      Version: "1.0",
      Properties: QuickPulseEnvelopeFactory.aggregateProperties(envelope)
     };
    }, QuickPulseEnvelopeFactory.aggregateProperties = function(envelope) {
     var properties = [], meas = envelope.data.baseData.measurements || {};
     for (var key in meas) if (meas.hasOwnProperty(key)) {
      var property = {
       key,
       value: meas[key]
      };
      properties.push(property);
     }
     var props = envelope.data.baseData.properties || {};
     for (var key in props) if (props.hasOwnProperty(key)) {
      property = {
       key,
       value: props[key]
      };
      properties.push(property);
     }
     return properties;
    }, QuickPulseEnvelopeFactory.keys = new Contracts.ContextTagKeys, QuickPulseEnvelopeFactory;
   }();
   module.exports = QuickPulseEnvelopeFactory;
  },
  59184: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }, __generator = this && this.__generator || function(thisArg, body) {
    var f, y, t, g, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    };
    return g = {
     next: verb(0),
     throw: verb(1),
     return: verb(2)
    }, "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;_; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   }, https = __webpack_require__(95687), AutoCollectHttpDependencies = __webpack_require__(88723), Logging = __webpack_require__(95282), QuickPulseUtil = __webpack_require__(3751), Util = __webpack_require__(25740), url = __webpack_require__(57310), QuickPulseConfig_method = "POST", QuickPulseConfig_time = "x-ms-qps-transmission-time", QuickPulseConfig_pollingIntervalHint = "x-ms-qps-service-polling-interval-hint", QuickPulseConfig_endpointRedirect = "x-ms-qps-service-endpoint-redirect-v2", QuickPulseConfig_instanceName = "x-ms-qps-instance-name", QuickPulseConfig_streamId = "x-ms-qps-stream-id", QuickPulseConfig_machineName = "x-ms-qps-machine-name", QuickPulseConfig_roleName = "x-ms-qps-role-name", QuickPulseConfig_invariantVersion = "x-ms-qps-invariant-version", QuickPulseConfig_subscribed = "x-ms-qps-subscribed", QuickPulseSender = function() {
    function QuickPulseSender(config, getAuthorizationHandler) {
     this._config = config, this._consecutiveErrors = 0, this._getAuthorizationHandler = getAuthorizationHandler;
    }
    return QuickPulseSender.prototype.ping = function(envelope, redirectedHostEndpoint, done) {
     var pingHeaders = [ {
      name: QuickPulseConfig_streamId,
      value: envelope.StreamId
     }, {
      name: QuickPulseConfig_machineName,
      value: envelope.MachineName
     }, {
      name: QuickPulseConfig_roleName,
      value: envelope.RoleName
     }, {
      name: QuickPulseConfig_instanceName,
      value: envelope.Instance
     }, {
      name: QuickPulseConfig_invariantVersion,
      value: envelope.InvariantVersion.toString()
     } ];
     this._submitData(envelope, redirectedHostEndpoint, done, "ping", pingHeaders);
    }, QuickPulseSender.prototype.post = function(envelope, redirectedHostEndpoint, done) {
     return __awaiter(this, void 0, void 0, (function() {
      return __generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return [ 4, this._submitData([ envelope ], redirectedHostEndpoint, done, "post") ];

       case 1:
        return _a.sent(), [ 2 ];
       }
      }));
     }));
    }, QuickPulseSender.prototype._submitData = function(envelope, redirectedHostEndpoint, done, postOrPing, additionalHeaders) {
     return __awaiter(this, void 0, void 0, (function() {
      var payload, options, authHandler, authError_1, req, _a, _b, _this = this;
      return __generator(this, (function(_c) {
       switch (_c.label) {
       case 0:
        if (payload = Util.stringify(envelope), (_a = {})[AutoCollectHttpDependencies.disableCollectionRequestOption] = !0, 
        _a.host = redirectedHostEndpoint && redirectedHostEndpoint.length > 0 ? redirectedHostEndpoint : this._config.quickPulseHost, 
        _a.method = QuickPulseConfig_method, _a.path = "/QuickPulseService.svc/" + postOrPing + "?ikey=" + this._config.instrumentationKey, 
        _a.headers = ((_b = {
         Expect: "100-continue"
        })[QuickPulseConfig_time] = QuickPulseUtil.getTransmissionTime(), _b["Content-Type"] = "application/json", 
        _b["Content-Length"] = Buffer.byteLength(payload), _b), options = _a, additionalHeaders && additionalHeaders.length > 0 && additionalHeaders.forEach((function(header) {
         return options.headers[header.name] = header.value;
        })), "post" !== postOrPing) return [ 3, 4 ];
        if (!(authHandler = this._getAuthorizationHandler ? this._getAuthorizationHandler(this._config) : null)) return [ 3, 4 ];
        _c.label = 1;

       case 1:
        return _c.trys.push([ 1, 3, , 4 ]), [ 4, authHandler.addAuthorizationHeader(options) ];

       case 2:
        return _c.sent(), [ 3, 4 ];

       case 3:
        return authError_1 = _c.sent(), "Failed to get AAD bearer token for the Application. Error:", 
        Logging.info(QuickPulseSender.TAG, "Failed to get AAD bearer token for the Application. Error:", authError_1), 
        [ 2 ];

       case 4:
        return this._config.httpsAgent ? options.agent = this._config.httpsAgent : options.agent = Util.tlsRestrictedAgent, 
        (req = https.request(options, (function(res) {
         if (200 == res.statusCode) {
          var shouldPOSTData = "true" === res.headers[QuickPulseConfig_subscribed], redirectHeader = null;
          try {
           redirectHeader = res.headers[QuickPulseConfig_endpointRedirect] ? new url.URL(res.headers[QuickPulseConfig_endpointRedirect].toString()).host : null;
          } catch (error) {
           _this._onError("Failed to parse redirect header from QuickPulse: " + Util.dumpObj(error));
          }
          var pollingIntervalHint = res.headers[QuickPulseConfig_pollingIntervalHint] ? parseInt(res.headers[QuickPulseConfig_pollingIntervalHint].toString()) : null;
          _this._consecutiveErrors = 0, done(shouldPOSTData, res, redirectHeader, pollingIntervalHint);
         } else _this._onError("StatusCode:" + res.statusCode + " StatusMessage:" + res.statusMessage), 
         done();
        }))).on("error", (function(error) {
         _this._onError(error), done();
        })), req.write(payload), req.end(), [ 2 ];
       }
      }));
     }));
    }, QuickPulseSender.prototype._onError = function(error) {
     this._consecutiveErrors++;
     var notice = "Transient error connecting to the Live Metrics endpoint. This packet will not appear in your Live Metrics Stream. Error:";
     this._consecutiveErrors % QuickPulseSender.MAX_QPS_FAILURES_BEFORE_WARN == 0 ? (notice = "Live Metrics endpoint could not be reached " + this._consecutiveErrors + " consecutive times. Most recent error:", 
     Logging.warn(QuickPulseSender.TAG, notice, error)) : Logging.info(QuickPulseSender.TAG, notice, error);
    }, QuickPulseSender.TAG = "QuickPulseSender", QuickPulseSender.MAX_QPS_FAILURES_BEFORE_WARN = 25, 
    QuickPulseSender;
   }();
   module.exports = QuickPulseSender;
  },
  83668: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }, __generator = this && this.__generator || function(thisArg, body) {
    var f, y, t, g, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    };
    return g = {
     next: verb(0),
     throw: verb(1),
     return: verb(2)
    }, "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;_; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   }, Logging = __webpack_require__(95282), QuickPulseEnvelopeFactory = __webpack_require__(87148), QuickPulseSender = __webpack_require__(59184), Constants = __webpack_require__(63580), Context = __webpack_require__(54470), QuickPulseStateManager = function() {
    function QuickPulseStateManager(config, context, getAuthorizationHandler) {
     this._isCollectingData = !1, this._lastSuccessTime = Date.now(), this._lastSendSucceeded = !0, 
     this._metrics = {}, this._documents = [], this._collectors = [], this._redirectedHost = null, 
     this._pollingIntervalHint = -1, this.config = config, this.context = context || new Context, 
     this._sender = new QuickPulseSender(this.config, getAuthorizationHandler), this._isEnabled = !1;
    }
    return QuickPulseStateManager.prototype.addCollector = function(collector) {
     this._collectors.push(collector);
    }, QuickPulseStateManager.prototype.trackMetric = function(telemetry) {
     this._addMetric(telemetry);
    }, QuickPulseStateManager.prototype.addDocument = function(envelope) {
     if (this._isCollectingData) {
      var document_1 = QuickPulseEnvelopeFactory.telemetryEnvelopeToQuickPulseDocument(envelope);
      document_1 && this._documents.push(document_1);
     }
    }, QuickPulseStateManager.prototype.enable = function(isEnabled) {
     isEnabled && !this._isEnabled ? (this._isEnabled = !0, this._goQuickPulse()) : !isEnabled && this._isEnabled && (this._isEnabled = !1, 
     clearTimeout(this._handle), this._handle = void 0);
    }, QuickPulseStateManager.prototype.enableCollectors = function(enable) {
     this._collectors.forEach((function(collector) {
      collector.enable(enable);
     }));
    }, QuickPulseStateManager.prototype._addMetric = function(telemetry) {
     var value = telemetry.value, count = telemetry.count || 1, name = Constants.PerformanceToQuickPulseCounter[telemetry.name];
     name && (this._metrics[name] ? (this._metrics[name].Value = (this._metrics[name].Value * this._metrics[name].Weight + value * count) / (this._metrics[name].Weight + count), 
     this._metrics[name].Weight += count) : (this._metrics[name] = QuickPulseEnvelopeFactory.createQuickPulseMetric(telemetry), 
     this._metrics[name].Name = name, this._metrics[name].Weight = 1));
    }, QuickPulseStateManager.prototype._resetQuickPulseBuffer = function() {
     delete this._metrics, this._metrics = {}, this._documents.length = 0;
    }, QuickPulseStateManager.prototype._goQuickPulse = function() {
     return __awaiter(this, void 0, void 0, (function() {
      var metrics, envelope, pingInterval, currentTimeout, _this = this;
      return __generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return metrics = Object.keys(this._metrics).map((function(k) {
         return _this._metrics[k];
        })), envelope = QuickPulseEnvelopeFactory.createQuickPulseEnvelope(metrics, this._documents.slice(), this.config, this.context), 
        this._resetQuickPulseBuffer(), this._isCollectingData ? [ 4, this._post(envelope) ] : [ 3, 2 ];

       case 1:
        return _a.sent(), [ 3, 3 ];

       case 2:
        this._ping(envelope), _a.label = 3;

       case 3:
        return pingInterval = this._pollingIntervalHint > 0 ? this._pollingIntervalHint : QuickPulseStateManager.PING_INTERVAL, 
        currentTimeout = this._isCollectingData ? QuickPulseStateManager.POST_INTERVAL : pingInterval, 
        this._isCollectingData && Date.now() - this._lastSuccessTime >= QuickPulseStateManager.MAX_POST_WAIT_TIME && !this._lastSendSucceeded ? (this._isCollectingData = !1, 
        currentTimeout = QuickPulseStateManager.FALLBACK_INTERVAL) : !this._isCollectingData && Date.now() - this._lastSuccessTime >= QuickPulseStateManager.MAX_PING_WAIT_TIME && !this._lastSendSucceeded && (currentTimeout = QuickPulseStateManager.FALLBACK_INTERVAL), 
        this._lastSendSucceeded = null, this._handle = setTimeout(this._goQuickPulse.bind(this), currentTimeout), 
        this._handle.unref(), [ 2 ];
       }
      }));
     }));
    }, QuickPulseStateManager.prototype._ping = function(envelope) {
     this._sender.ping(envelope, this._redirectedHost, this._quickPulseDone.bind(this));
    }, QuickPulseStateManager.prototype._post = function(envelope) {
     return __awaiter(this, void 0, void 0, (function() {
      return __generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return [ 4, this._sender.post(envelope, this._redirectedHost, this._quickPulseDone.bind(this)) ];

       case 1:
        return _a.sent(), [ 2 ];
       }
      }));
     }));
    }, QuickPulseStateManager.prototype._quickPulseDone = function(shouldPOST, res, redirectedHost, pollingIntervalHint) {
     null != shouldPOST ? (this._isCollectingData !== shouldPOST && (Logging.info("Live Metrics sending data", shouldPOST), 
     this.enableCollectors(shouldPOST)), this._isCollectingData = shouldPOST, redirectedHost && redirectedHost.length > 0 && (this._redirectedHost = redirectedHost, 
     Logging.info("Redirecting endpoint to: ", redirectedHost)), pollingIntervalHint && pollingIntervalHint > 0 && (this._pollingIntervalHint = pollingIntervalHint), 
     res && res.statusCode < 300 && res.statusCode >= 200 ? (this._lastSuccessTime = Date.now(), 
     this._lastSendSucceeded = !0) : this._lastSendSucceeded = !1) : this._lastSendSucceeded = !1;
    }, QuickPulseStateManager.MAX_POST_WAIT_TIME = 2e4, QuickPulseStateManager.MAX_PING_WAIT_TIME = 6e4, 
    QuickPulseStateManager.FALLBACK_INTERVAL = 6e4, QuickPulseStateManager.PING_INTERVAL = 5e3, 
    QuickPulseStateManager.POST_INTERVAL = 1e3, QuickPulseStateManager;
   }();
   module.exports = QuickPulseStateManager;
  },
  3751: module => {
   "use strict";
   module.exports = {
    getTransmissionTime: function() {
     return 1e4 * (Date.now() + 621355968e5);
    }
   };
  },
  59036: module => {
   "use strict";
   module.exports = {
    requestContextHeader: "request-context",
    requestContextSourceKey: "appId",
    requestContextTargetKey: "appId",
    requestIdHeader: "request-id",
    parentIdHeader: "x-ms-request-id",
    rootIdHeader: "x-ms-request-root-id",
    correlationContextHeader: "correlation-context",
    traceparentHeader: "traceparent",
    traceStateHeader: "tracestate"
   };
  },
  82588: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }, __generator = this && this.__generator || function(thisArg, body) {
    var f, y, t, g, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    };
    return g = {
     next: verb(0),
     throw: verb(1),
     return: verb(2)
    }, "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;_; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   }, fs = __webpack_require__(57147), os = __webpack_require__(22037), path = __webpack_require__(71017), zlib = __webpack_require__(59796), Constants = __webpack_require__(63580), AutoCollectHttpDependencies = __webpack_require__(88723), FileSystemHelper = __webpack_require__(30164), Util = __webpack_require__(25740), url_1 = __webpack_require__(57310), Logging = __webpack_require__(95282), FileAccessControl_1 = __webpack_require__(12640), RESPONSE_CODES_INDICATING_REACHED_BREEZE = [ 200, 206, 402, 408, 429, 439, 500 ], Sender = function() {
    function Sender(config, getAuthorizationHandler, onSuccess, onError, statsbeat, isStatsbeatSender, shutdownStatsbeat) {
     this._redirectedHost = null, this._config = config, this._onSuccess = onSuccess, 
     this._onError = onError, this._statsbeat = statsbeat, this._enableDiskRetryMode = !1, 
     this._resendInterval = Sender.WAIT_BETWEEN_RESEND, this._maxBytesOnDisk = Sender.MAX_BYTES_ON_DISK, 
     this._numConsecutiveFailures = 0, this._numConsecutiveRedirects = 0, this._resendTimer = null, 
     this._getAuthorizationHandler = getAuthorizationHandler, this._fileCleanupTimer = null, 
     this._tempDir = path.join(os.tmpdir(), Sender.TEMPDIR_PREFIX + this._config.instrumentationKey), 
     this._isStatsbeatSender = isStatsbeatSender || !1, this._shutdownStatsbeat = shutdownStatsbeat, 
     this._failedToIngestCounter = 0, this._statsbeatHasReachedIngestionAtLeastOnce = !1;
    }
    return Sender.prototype.setDiskRetryMode = function(value, resendInterval, maxBytesOnDisk) {
     var _this = this;
     value && FileAccessControl_1.FileAccessControl.checkFileProtection(), this._enableDiskRetryMode = FileAccessControl_1.FileAccessControl.OS_PROVIDES_FILE_PROTECTION && value, 
     "number" == typeof resendInterval && resendInterval >= 0 && (this._resendInterval = Math.floor(resendInterval)), 
     "number" == typeof maxBytesOnDisk && maxBytesOnDisk >= 0 && (this._maxBytesOnDisk = Math.floor(maxBytesOnDisk)), 
     value && !FileAccessControl_1.FileAccessControl.OS_PROVIDES_FILE_PROTECTION && (this._enableDiskRetryMode = !1, 
     this._logWarn("Ignoring request to enable disk retry mode. Sufficient file protection capabilities were not detected.")), 
     this._enableDiskRetryMode ? (this._statsbeat && this._statsbeat.addFeature(Constants.StatsbeatFeature.DISK_RETRY), 
     this._fileCleanupTimer || (this._fileCleanupTimer = setTimeout((function() {
      _this._fileCleanupTask();
     }), Sender.CLEANUP_TIMEOUT), this._fileCleanupTimer.unref())) : (this._statsbeat && this._statsbeat.removeFeature(Constants.StatsbeatFeature.DISK_RETRY), 
     this._fileCleanupTimer && clearTimeout(this._fileCleanupTimer));
    }, Sender.prototype.send = function(envelopes, callback) {
     return __awaiter(this, void 0, void 0, (function() {
      var endpointUrl, endpointHost, options, authHandler, authError_1, errorMsg, batch_1, payload_1, _this = this;
      return __generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        if (!envelopes) return [ 3, 5 ];
        if (endpointUrl = this._redirectedHost || this._config.endpointUrl, endpointHost = new url_1.URL(endpointUrl).hostname, 
        options = {
         method: "POST",
         withCredentials: !1,
         headers: {
          "Content-Type": "application/x-json-stream"
         }
        }, !(authHandler = this._getAuthorizationHandler ? this._getAuthorizationHandler(this._config) : null)) return [ 3, 4 ];
        this._statsbeat && this._statsbeat.addFeature(Constants.StatsbeatFeature.AAD_HANDLING), 
        _a.label = 1;

       case 1:
        return _a.trys.push([ 1, 3, , 4 ]), [ 4, authHandler.addAuthorizationHeader(options) ];

       case 2:
        return _a.sent(), [ 3, 4 ];

       case 3:
        return authError_1 = _a.sent(), errorMsg = "Failed to get AAD bearer token for the Application.", 
        this._enableDiskRetryMode && (errorMsg += "This batch of telemetry items will be retried. ", 
        this._storeToDisk(envelopes)), errorMsg += "Error:" + authError_1.toString(), this._logWarn(errorMsg), 
        "function" == typeof callback && callback(errorMsg), [ 2 ];

       case 4:
        batch_1 = "", envelopes.forEach((function(envelope) {
         var payload = Util.stringify(envelope);
         "string" == typeof payload && (batch_1 += payload + "\n");
        })), batch_1.length > 0 && (batch_1 = batch_1.substring(0, batch_1.length - 1)), 
        payload_1 = Buffer.from ? Buffer.from(batch_1) : new Buffer(batch_1), zlib.gzip(payload_1, (function(err, buffer) {
         var dataToSend = buffer;
         err ? (_this._logWarn(Util.dumpObj(err)), dataToSend = payload_1, options.headers["Content-Length"] = payload_1.length.toString()) : (options.headers["Content-Encoding"] = "gzip", 
         options.headers["Content-Length"] = buffer.length.toString()), _this._logInfo(Util.dumpObj(options)), 
         options[AutoCollectHttpDependencies.disableCollectionRequestOption] = !0;
         var startTime = +new Date, req = Util.makeRequest(_this._config, endpointUrl, options, (function(res) {
          res.setEncoding("utf-8");
          var responseString = "";
          res.on("data", (function(data) {
           responseString += data;
          })), res.on("end", (function() {
           var duration = +new Date - startTime;
           if (_this._numConsecutiveFailures = 0, _this._isStatsbeatSender && !_this._statsbeatHasReachedIngestionAtLeastOnce && (RESPONSE_CODES_INDICATING_REACHED_BREEZE.includes(res.statusCode) ? _this._statsbeatHasReachedIngestionAtLeastOnce = !0 : _this._statsbeatFailedToIngest()), 
           _this._statsbeat && (402 == res.statusCode || 439 == res.statusCode ? _this._statsbeat.countThrottle(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, res.statusCode) : _this._statsbeat.countRequest(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, duration, 200 === res.statusCode, res.statusCode)), 
           _this._enableDiskRetryMode) if (200 === res.statusCode) _this._resendTimer || (_this._resendTimer = setTimeout((function() {
            _this._resendTimer = null, _this._sendFirstFileOnDisk();
           }), _this._resendInterval), _this._resendTimer.unref()); else if (_this._isRetriable(res.statusCode)) try {
            _this._statsbeat && _this._statsbeat.countRetry(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, res.statusCode);
            var breezeResponse = JSON.parse(responseString), filteredEnvelopes_1 = [];
            breezeResponse.errors && (breezeResponse.errors.forEach((function(error) {
             429 != error.statusCode && 500 != error.statusCode && 503 != error.statusCode || filteredEnvelopes_1.push(envelopes[error.index]);
            })), filteredEnvelopes_1.length > 0 && _this._storeToDisk(filteredEnvelopes_1));
           } catch (ex) {
            _this._storeToDisk(envelopes);
           }
           if (307 === res.statusCode || 308 === res.statusCode) if (_this._numConsecutiveRedirects++, 
           _this._numConsecutiveRedirects < 10) {
            var locationHeader = res.headers.location ? res.headers.location.toString() : null;
            locationHeader && (_this._redirectedHost = locationHeader, _this.send(envelopes, callback));
           } else {
            _this._statsbeat && _this._statsbeat.countException(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, {
             name: "Circular Redirect",
             message: "Error sending telemetry because of circular redirects."
            }), "function" == typeof callback && callback("Error sending telemetry because of circular redirects.");
           } else _this._numConsecutiveRedirects = 0, "function" == typeof callback && callback(responseString), 
           _this._logInfo(responseString), "function" == typeof _this._onSuccess && _this._onSuccess(responseString);
          }));
         }));
         req.setTimeout(Sender.HTTP_TIMEOUT, (function() {
          _this._requestTimedOut = !0, req.abort();
         })), req.on("error", (function(error) {
          if (_this._isStatsbeatSender && !_this._statsbeatHasReachedIngestionAtLeastOnce && _this._statsbeatFailedToIngest(), 
          _this._numConsecutiveFailures++, _this._statsbeat && _this._statsbeat.countException(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, error), 
          !_this._enableDiskRetryMode || _this._numConsecutiveFailures > 0 && _this._numConsecutiveFailures % Sender.MAX_CONNECTION_FAILURES_BEFORE_WARN == 0) {
           var notice = "Ingestion endpoint could not be reached. This batch of telemetry items has been lost. Use Disk Retry Caching to enable resending of failed telemetry. Error:";
           _this._enableDiskRetryMode && (notice = "Ingestion endpoint could not be reached " + _this._numConsecutiveFailures + " consecutive times. There may be resulting telemetry loss. Most recent error:"), 
           _this._logWarn(notice, Util.dumpObj(error));
          } else {
           notice = "Transient failure to reach ingestion endpoint. This batch of telemetry items will be retried. Error:";
           _this._logInfo(notice, Util.dumpObj(error));
          }
          _this._onErrorHelper(error), "function" == typeof callback && (error ? (_this._requestTimedOut && (error.name = "telemetry timeout", 
          error.message = "telemetry request timed out"), callback(Util.dumpObj(error))) : callback("Error sending telemetry")), 
          _this._enableDiskRetryMode && _this._storeToDisk(envelopes);
         })), req.write(dataToSend), req.end();
        })), _a.label = 5;

       case 5:
        return [ 2 ];
       }
      }));
     }));
    }, Sender.prototype.saveOnCrash = function(envelopes) {
     this._enableDiskRetryMode && this._storeToDiskSync(Util.stringify(envelopes));
    }, Sender.prototype._isRetriable = function(statusCode) {
     return 206 === statusCode || 401 === statusCode || 403 === statusCode || 408 === statusCode || 429 === statusCode || 500 === statusCode || 502 === statusCode || 503 === statusCode || 504 === statusCode;
    }, Sender.prototype._logInfo = function(message) {
     for (var optionalParams = [], _i = 1; _i < arguments.length; _i++) optionalParams[_i - 1] = arguments[_i];
     this._isStatsbeatSender || Logging.info(Sender.TAG, message, optionalParams);
    }, Sender.prototype._logWarn = function(message) {
     for (var optionalParams = [], _i = 1; _i < arguments.length; _i++) optionalParams[_i - 1] = arguments[_i];
     this._isStatsbeatSender || Logging.warn(Sender.TAG, message, optionalParams);
    }, Sender.prototype._statsbeatFailedToIngest = function() {
     this._shutdownStatsbeat && (this._failedToIngestCounter++, this._failedToIngestCounter >= 3 && this._shutdownStatsbeat());
    }, Sender.prototype._storeToDisk = function(envelopes) {
     return __awaiter(this, void 0, void 0, (function() {
      var ex_1, ex_2, size, ex_3, fileName, fileFullPath, ex_4;
      return __generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return _a.trys.push([ 0, 2, , 3 ]), this._logInfo("Checking existence of data storage directory: " + this._tempDir), 
        [ 4, FileSystemHelper.confirmDirExists(this._tempDir) ];

       case 1:
        return _a.sent(), [ 3, 3 ];

       case 2:
        return ex_1 = _a.sent(), this._logWarn("Failed to create folder to put telemetry: " + Util.dumpObj(ex_1)), 
        this._onErrorHelper(ex_1), [ 2 ];

       case 3:
        return _a.trys.push([ 3, 5, , 6 ]), [ 4, FileAccessControl_1.FileAccessControl.applyACLRules(this._tempDir) ];

       case 4:
        return _a.sent(), [ 3, 6 ];

       case 5:
        return ex_2 = _a.sent(), this._logWarn("Failed to apply file access control to folder: " + Util.dumpObj(ex_2)), 
        this._onErrorHelper(ex_2), [ 2 ];

       case 6:
        return _a.trys.push([ 6, 8, , 9 ]), [ 4, FileSystemHelper.getShallowDirectorySize(this._tempDir) ];

       case 7:
        return (size = _a.sent()) > this._maxBytesOnDisk ? (this._logWarn("Not saving data due to max size limit being met. Directory size in bytes is: " + size), 
        [ 2 ]) : [ 3, 9 ];

       case 8:
        return ex_3 = _a.sent(), this._logWarn("Failed to read directory for retriable telemetry: " + Util.dumpObj(ex_3)), 
        this._onErrorHelper(ex_3), [ 2 ];

       case 9:
        return _a.trys.push([ 9, 11, , 12 ]), fileName = (new Date).getTime() + ".ai.json", 
        fileFullPath = path.join(this._tempDir, fileName), this._logInfo("saving data to disk at: " + fileFullPath), 
        [ 4, FileSystemHelper.writeFileAsync(fileFullPath, Util.stringify(envelopes), {
         mode: 384
        }) ];

       case 10:
        return _a.sent(), [ 3, 12 ];

       case 11:
        return ex_4 = _a.sent(), this._logWarn("Failed to persist telemetry to disk: " + Util.dumpObj(ex_4)), 
        this._onErrorHelper(ex_4), [ 2 ];

       case 12:
        return [ 2 ];
       }
      }));
     }));
    }, Sender.prototype._storeToDiskSync = function(payload) {
     try {
      this._logInfo("Checking existence of data storage directory: " + this._tempDir), 
      fs.existsSync(this._tempDir) || fs.mkdirSync(this._tempDir), FileAccessControl_1.FileAccessControl.applyACLRulesSync(this._tempDir);
      var dirSize = FileSystemHelper.getShallowDirectorySizeSync(this._tempDir);
      if (dirSize > this._maxBytesOnDisk) return void this._logInfo("Not saving data due to max size limit being met. Directory size in bytes is: " + dirSize);
      var fileName = (new Date).getTime() + ".ai.json", fileFullPath = path.join(this._tempDir, fileName);
      this._logInfo("saving data before crash to disk at: " + fileFullPath), fs.writeFileSync(fileFullPath, payload, {
       mode: 384
      });
     } catch (error) {
      this._logWarn("Error while saving data to disk: " + Util.dumpObj(error)), this._onErrorHelper(error);
     }
    }, Sender.prototype._sendFirstFileOnDisk = function() {
     return __awaiter(this, void 0, void 0, (function() {
      var files, firstFile, filePath, buffer, envelopes, err_1;
      return __generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return _a.trys.push([ 0, 6, , 7 ]), [ 4, FileSystemHelper.readdirAsync(this._tempDir) ];

       case 1:
        return (files = (files = _a.sent()).filter((function(f) {
         return path.basename(f).indexOf(".ai.json") > -1;
        }))).length > 0 ? (firstFile = files[0], filePath = path.join(this._tempDir, firstFile), 
        [ 4, FileSystemHelper.readFileAsync(filePath) ]) : [ 3, 5 ];

       case 2:
        return buffer = _a.sent(), [ 4, FileSystemHelper.unlinkAsync(filePath) ];

       case 3:
        return _a.sent(), envelopes = JSON.parse(buffer.toString()), [ 4, this.send(envelopes) ];

       case 4:
        _a.sent(), _a.label = 5;

       case 5:
        return [ 3, 7 ];

       case 6:
        return err_1 = _a.sent(), this._onErrorHelper(err_1), [ 3, 7 ];

       case 7:
        return [ 2 ];
       }
      }));
     }));
    }, Sender.prototype._onErrorHelper = function(error) {
     "function" == typeof this._onError && this._onError(error);
    }, Sender.prototype._fileCleanupTask = function() {
     return __awaiter(this, void 0, void 0, (function() {
      var files, i, fileCreationDate, filePath, err_2, _this = this;
      return __generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return _a.trys.push([ 0, 6, , 7 ]), [ 4, FileSystemHelper.readdirAsync(this._tempDir) ];

       case 1:
        if (!((files = (files = _a.sent()).filter((function(f) {
         return path.basename(f).indexOf(".ai.json") > -1;
        }))).length > 0)) return [ 3, 5 ];
        i = 0, _a.label = 2;

       case 2:
        return i < files.length ? (fileCreationDate = new Date(parseInt(files[i].split(".ai.json")[0])), 
        new Date(+new Date - Sender.FILE_RETEMPTION_PERIOD) > fileCreationDate ? (filePath = path.join(this._tempDir, files[i]), 
        [ 4, FileSystemHelper.unlinkAsync(filePath).catch((function(err) {
         _this._onErrorHelper(err);
        })) ]) : [ 3, 4 ]) : [ 3, 5 ];

       case 3:
        _a.sent(), _a.label = 4;

       case 4:
        return i++, [ 3, 2 ];

       case 5:
        return [ 3, 7 ];

       case 6:
        return "ENOENT" != (err_2 = _a.sent()).code && this._onErrorHelper(err_2), [ 3, 7 ];

       case 7:
        return [ 2 ];
       }
      }));
     }));
    }, Sender.TAG = "Sender", Sender.WAIT_BETWEEN_RESEND = 6e4, Sender.MAX_BYTES_ON_DISK = 52428800, 
    Sender.MAX_CONNECTION_FAILURES_BEFORE_WARN = 5, Sender.CLEANUP_TIMEOUT = 36e5, Sender.FILE_RETEMPTION_PERIOD = 6048e5, 
    Sender.TEMPDIR_PREFIX = "appInsights-node", Sender.HTTP_TIMEOUT = 2e4, Sender;
   }();
   module.exports = Sender;
  },
  82570: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.isContentTypeHeaderHtml = exports.insertSnippetByIndex = exports.getContentEncodingFromHeaders = exports.isSupportedContentEncoding = exports.findBufferEncodingType = exports.isBufferType = exports.getBrotliDecompressSync = exports.getBrotliDecompressAsync = exports.getBrotliCompressSync = exports.getBrotliCompressAsync = exports.inflateAsync = exports.deflateAsync = exports.gunzipAsync = exports.gzipAsync = exports.isBrotliSupperted = exports.bufferEncodingTypes = exports.contentEncodingMethod = void 0;
   var contentEncodingMethod, zlib = __webpack_require__(59796), util_1 = __webpack_require__(73837);
   !function(contentEncodingMethod) {
    contentEncodingMethod.GZIP = "gzip", contentEncodingMethod.DEFLATE = "deflate", 
    contentEncodingMethod.BR = "br";
   }(contentEncodingMethod = exports.contentEncodingMethod || (exports.contentEncodingMethod = {})), 
   exports.bufferEncodingTypes = [ "utf8", "utf16le", "latin1", "base64", "hex", "ascii", "binary", "ucs2" ];
   exports.isBrotliSupperted = function() {
    var majVer = process.versions.node.split(".")[0];
    return parseInt(majVer) >= 10;
   }, exports.gzipAsync = util_1.promisify(zlib.gzip), exports.gunzipAsync = util_1.promisify(zlib.gunzip), 
   exports.deflateAsync = util_1.promisify(zlib.deflate), exports.inflateAsync = util_1.promisify(zlib.inflate);
   exports.getBrotliCompressAsync = function(zlibObject) {
    return exports.isBrotliSupperted() && "function" == typeof zlibObject.brotliCompress ? util_1.promisify(zlibObject.brotliCompress) : null;
   };
   exports.getBrotliCompressSync = function(zlibObject) {
    return exports.isBrotliSupperted() && "function" == typeof zlibObject.brotliCompressSync ? zlibObject.brotliCompressSync : null;
   };
   exports.getBrotliDecompressAsync = function(zlibObject) {
    return exports.isBrotliSupperted() && "function" == typeof zlibObject.brotliDecompress ? util_1.promisify(zlibObject.brotliDecompress) : null;
   };
   exports.getBrotliDecompressSync = function(zlibObject) {
    return exports.isBrotliSupperted() && "function" == typeof zlibObject.brotliDecompressSync ? zlibObject.brotliDecompressSync : null;
   };
   exports.isBufferType = function(buffer, type) {
    var encodingType = type || "utf8", result = !1;
    Buffer.isEncoding(encodingType) && (result = Buffer.from(buffer.toString(encodingType), encodingType).toJSON().data.toString() === buffer.toJSON().data.toString());
    return result;
   };
   exports.findBufferEncodingType = function(buffer) {
    var bufferType = null;
    for (var key in exports.bufferEncodingTypes) {
     var type = exports.bufferEncodingTypes[key];
     if (Buffer.isEncoding(type) && exports.isBufferType(buffer, type)) {
      bufferType = type;
      break;
     }
    }
    return bufferType;
   };
   exports.isSupportedContentEncoding = function(encodingMethod) {
    var encodingType = null;
    switch (encodingMethod) {
    case "gzip":
     encodingType = contentEncodingMethod.GZIP;
     break;

    case "br":
     encodingType = contentEncodingMethod.BR;
     break;

    case "deflate":
     encodingType = contentEncodingMethod.DEFLATE;
    }
    return encodingType;
   };
   exports.getContentEncodingFromHeaders = function(response) {
    var headers = [], contentEncodingHeaders = response.getHeader("Content-Encoding");
    if (!contentEncodingHeaders) return null;
    if ("string" == typeof contentEncodingHeaders) {
     var supportedContentEncoding = exports.isSupportedContentEncoding(contentEncodingHeaders);
     supportedContentEncoding && headers.push(supportedContentEncoding);
    }
    return headers;
   };
   exports.insertSnippetByIndex = function(index, html, snippet) {
    if (index < 0) return null;
    return html.substring(0, index) + '<script type="text/javascript">' + snippet + "<\/script>" + html.substring(index);
   };
   exports.isContentTypeHeaderHtml = function(response) {
    var isHtml = !1, contentType = response.getHeader("Content-Type");
    return contentType && (isHtml = "string" == typeof contentType ? contentType.indexOf("html") >= 0 : contentType.toString().indexOf("html") >= 0), 
    isHtml;
   };
  },
  67625: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var url = __webpack_require__(57310), Config = __webpack_require__(69253), AuthorizationHandler = __webpack_require__(80287), Context = __webpack_require__(54470), Contracts = __webpack_require__(55290), Channel = __webpack_require__(3504), TelemetryProcessors = __webpack_require__(59428), CorrelationContextManager_1 = __webpack_require__(70894), Statsbeat = __webpack_require__(49004), Sender = __webpack_require__(82588), Util = __webpack_require__(25740), Logging = __webpack_require__(95282), EnvelopeFactory = __webpack_require__(99813), TelemetryClient = function() {
    function TelemetryClient(setupString) {
     this._telemetryProcessors = [];
     var config = new Config(setupString);
     if (this.config = config, !this.config.instrumentationKey || "" == this.config.instrumentationKey) throw new Error("Instrumentation key not found, please provide a connection string before starting Application Insights SDK.");
     this.context = new Context, this.commonProperties = {}, this.authorizationHandler = null, 
     this.config.disableStatsbeat || (this._statsbeat = new Statsbeat(this.config, this.context), 
     this._statsbeat.enable(!0));
     var sender = new Sender(this.config, this.getAuthorizationHandler, null, null, this._statsbeat);
     this.channel = new Channel((function() {
      return config.disableAppInsights;
     }), (function() {
      return config.maxBatchSize;
     }), (function() {
      return config.maxBatchIntervalMs;
     }), sender);
    }
    return TelemetryClient.prototype.trackAvailability = function(telemetry) {
     this.track(telemetry, Contracts.TelemetryType.Availability);
    }, TelemetryClient.prototype.trackPageView = function(telemetry) {
     this.track(telemetry, Contracts.TelemetryType.PageView);
    }, TelemetryClient.prototype.trackTrace = function(telemetry) {
     this.track(telemetry, Contracts.TelemetryType.Trace);
    }, TelemetryClient.prototype.trackMetric = function(telemetry) {
     this.track(telemetry, Contracts.TelemetryType.Metric);
    }, TelemetryClient.prototype.trackException = function(telemetry) {
     telemetry && telemetry.exception && !Util.isError(telemetry.exception) && (telemetry.exception = new Error(telemetry.exception.toString())), 
     this.track(telemetry, Contracts.TelemetryType.Exception);
    }, TelemetryClient.prototype.trackEvent = function(telemetry) {
     this.track(telemetry, Contracts.TelemetryType.Event);
    }, TelemetryClient.prototype.trackRequest = function(telemetry) {
     this.track(telemetry, Contracts.TelemetryType.Request);
    }, TelemetryClient.prototype.trackDependency = function(telemetry) {
     if (telemetry && !telemetry.target && telemetry.data) try {
      telemetry.target = new url.URL(telemetry.data).host;
     } catch (error) {
      telemetry.target = null, Logging.warn(TelemetryClient.TAG, "The URL object is failed to create.", error);
     }
     this.track(telemetry, Contracts.TelemetryType.Dependency);
    }, TelemetryClient.prototype.flush = function(options) {
     this.channel.triggerSend(!!options && !!options.isAppCrashing, options ? options.callback : void 0);
    }, TelemetryClient.prototype.track = function(telemetry, telemetryType) {
     if (telemetry && Contracts.telemetryTypeToBaseType(telemetryType)) {
      var envelope = EnvelopeFactory.createEnvelope(telemetry, telemetryType, this.commonProperties, this.context, this.config);
      telemetry.time && (envelope.time = telemetry.time.toISOString());
      var accepted = this.runTelemetryProcessors(envelope, telemetry.contextObjects);
      accepted = accepted && TelemetryProcessors.samplingTelemetryProcessor(envelope, {
       correlationContext: CorrelationContextManager_1.CorrelationContextManager.getCurrentContext()
      }), TelemetryProcessors.preAggregatedMetricsTelemetryProcessor(envelope, this.context), 
      accepted && (TelemetryProcessors.performanceMetricsTelemetryProcessor(envelope, this.quickPulseClient), 
      this.channel.send(envelope));
     } else Logging.warn(TelemetryClient.TAG, "track() requires telemetry object and telemetryType to be specified.");
    }, TelemetryClient.prototype.setAutoPopulateAzureProperties = function(value) {}, 
    TelemetryClient.prototype.getAuthorizationHandler = function(config) {
     return config && config.aadTokenCredential ? (this.authorizationHandler || (Logging.info(TelemetryClient.TAG, "Adding authorization handler"), 
     this.authorizationHandler = new AuthorizationHandler(config.aadTokenCredential)), 
     this.authorizationHandler) : null;
    }, TelemetryClient.prototype.addTelemetryProcessor = function(telemetryProcessor) {
     this._telemetryProcessors.push(telemetryProcessor);
    }, TelemetryClient.prototype.clearTelemetryProcessors = function() {
     this._telemetryProcessors = [];
    }, TelemetryClient.prototype.runTelemetryProcessors = function(envelope, contextObjects) {
     var accepted = !0, telemetryProcessorsCount = this._telemetryProcessors.length;
     if (0 === telemetryProcessorsCount) return accepted;
     (contextObjects = contextObjects || {}).correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
     for (var i = 0; i < telemetryProcessorsCount; ++i) try {
      var processor = this._telemetryProcessors[i];
      if (processor && !1 === processor.apply(null, [ envelope, contextObjects ])) {
       accepted = !1;
       break;
      }
     } catch (error) {
      accepted = !0, Logging.warn(TelemetryClient.TAG, "One of telemetry processors failed, telemetry item will be sent.", error, envelope);
     }
     return accepted && (envelope && envelope.tags && (envelope.tags = Util.validateStringMap(envelope.tags)), 
     envelope && envelope.data && envelope.data.baseData && envelope.data.baseData.properties && (envelope.data.baseData.properties = Util.validateStringMap(envelope.data.baseData.properties))), 
     accepted;
    }, TelemetryClient.prototype.getStatsbeat = function() {
     return this._statsbeat;
    }, TelemetryClient.TAG = "TelemetryClient", TelemetryClient;
   }();
   module.exports = TelemetryClient;
  },
  58090: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var Util = __webpack_require__(25740), CorrelationIdManager = __webpack_require__(29962), Traceparent = function() {
    function Traceparent(traceparent, parentId) {
     if (this.traceFlag = Traceparent.DEFAULT_TRACE_FLAG, this.version = Traceparent.DEFAULT_VERSION, 
     traceparent && "string" == typeof traceparent) if (traceparent.split(",").length > 1) this.traceId = Util.w3cTraceId(), 
     this.spanId = Util.w3cTraceId().substr(0, 16); else {
      var traceparentArr = traceparent.trim().split("-"), len = traceparentArr.length;
      len >= 4 ? (this.version = traceparentArr[0], this.traceId = traceparentArr[1], 
      this.spanId = traceparentArr[2], this.traceFlag = traceparentArr[3]) : (this.traceId = Util.w3cTraceId(), 
      this.spanId = Util.w3cTraceId().substr(0, 16)), this.version.match(/^[0-9a-f]{2}$/g) || (this.version = Traceparent.DEFAULT_VERSION, 
      this.traceId = Util.w3cTraceId()), "00" === this.version && 4 !== len && (this.traceId = Util.w3cTraceId(), 
      this.spanId = Util.w3cTraceId().substr(0, 16)), "ff" === this.version && (this.version = Traceparent.DEFAULT_VERSION, 
      this.traceId = Util.w3cTraceId(), this.spanId = Util.w3cTraceId().substr(0, 16)), 
      this.version.match(/^0[0-9a-f]$/g) || (this.version = Traceparent.DEFAULT_VERSION), 
      this.traceFlag.match(/^[0-9a-f]{2}$/g) || (this.traceFlag = Traceparent.DEFAULT_TRACE_FLAG, 
      this.traceId = Util.w3cTraceId()), Traceparent.isValidTraceId(this.traceId) || (this.traceId = Util.w3cTraceId()), 
      Traceparent.isValidSpanId(this.spanId) || (this.spanId = Util.w3cTraceId().substr(0, 16), 
      this.traceId = Util.w3cTraceId()), this.parentId = this.getBackCompatRequestId();
     } else if (parentId) {
      this.parentId = parentId.slice();
      var operationId = CorrelationIdManager.getRootId(parentId);
      Traceparent.isValidTraceId(operationId) || (this.legacyRootId = operationId, operationId = Util.w3cTraceId()), 
      -1 !== parentId.indexOf("|") && (parentId = parentId.substring(1 + parentId.substring(0, parentId.length - 1).lastIndexOf("."), parentId.length - 1)), 
      this.traceId = operationId, this.spanId = parentId;
     } else this.traceId = Util.w3cTraceId(), this.spanId = Util.w3cTraceId().substr(0, 16);
    }
    return Traceparent.isValidTraceId = function(id) {
     return id.match(/^[0-9a-f]{32}$/) && "00000000000000000000000000000000" !== id;
    }, Traceparent.isValidSpanId = function(id) {
     return id.match(/^[0-9a-f]{16}$/) && "0000000000000000" !== id;
    }, Traceparent.formatOpenTelemetryTraceFlags = function(traceFlags) {
     var formattedFlags = "0" + traceFlags.toString(16);
     return formattedFlags.substring(formattedFlags.length - 2);
    }, Traceparent.prototype.getBackCompatRequestId = function() {
     return "|" + this.traceId + "." + this.spanId + ".";
    }, Traceparent.prototype.toString = function() {
     return this.version + "-" + this.traceId + "-" + this.spanId + "-" + this.traceFlag;
    }, Traceparent.prototype.updateSpanId = function() {
     this.spanId = Util.w3cTraceId().substr(0, 16);
    }, Traceparent.DEFAULT_TRACE_FLAG = "01", Traceparent.DEFAULT_VERSION = "00", Traceparent;
   }();
   module.exports = Traceparent;
  },
  10420: module => {
   "use strict";
   var Tracestate = function() {
    function Tracestate(id) {
     this.fieldmap = [], id && (this.fieldmap = this.parseHeader(id));
    }
    return Tracestate.prototype.toString = function() {
     var fieldarr = this.fieldmap;
     return fieldarr && 0 != fieldarr.length ? fieldarr.join(", ") : null;
    }, Tracestate.validateKeyChars = function(key) {
     var keyParts = key.split("@");
     if (2 == keyParts.length) {
      var tenant = keyParts[0].trim(), vendor = keyParts[1].trim(), tenantValid = Boolean(tenant.match(/^[\ ]?[a-z0-9\*\-\_/]{1,241}$/)), vendorValid = Boolean(vendor.match(/^[\ ]?[a-z0-9\*\-\_/]{1,14}$/));
      return tenantValid && vendorValid;
     }
     return 1 == keyParts.length && Boolean(key.match(/^[\ ]?[a-z0-9\*\-\_/]{1,256}$/));
    }, Tracestate.prototype.parseHeader = function(id) {
     var res = [], keydeduper = {}, parts = id.split(",");
     if (parts.length > 32) return null;
     for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
      var part = parts_1[_i].trim();
      if (0 !== part.length) {
       var pair = part.split("=");
       if (2 !== pair.length) return null;
       if (!Tracestate.validateKeyChars(pair[0])) return null;
       if (keydeduper[pair[0]]) return null;
       keydeduper[pair[0]] = !0, res.push(part);
      }
     }
     return res;
    }, Tracestate.strict = !0, Tracestate;
   }();
   module.exports = Tracestate;
  },
  25740: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var __assign = this && this.__assign || function() {
    return __assign = Object.assign || function(t) {
     for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
     return t;
    }, __assign.apply(this, arguments);
   }, http = __webpack_require__(13685), https = __webpack_require__(95687), url = __webpack_require__(57310), constants = __webpack_require__(22057), Logging = __webpack_require__(95282), RequestResponseHeaders = __webpack_require__(59036), JsonConfig_1 = __webpack_require__(3063), Util = function() {
    function Util() {
     Util._addCloseHandler();
    }
    return Util.getCookie = function(name, cookie) {
     var value = "";
     if (name && name.length && "string" == typeof cookie) for (var cookieName = name + "=", cookies = cookie.split(";"), i = 0; i < cookies.length; i++) {
      cookie = cookies[i];
      if ((cookie = Util.trim(cookie)) && 0 === cookie.indexOf(cookieName)) {
       value = cookie.substring(cookieName.length, cookies[i].length);
       break;
      }
     }
     return value;
    }, Util.trim = function(str) {
     return "string" == typeof str ? str.replace(/^\s+|\s+$/g, "") : "";
    }, Util.int32ArrayToBase64 = function(array) {
     var toChar = function(v, i) {
      return String.fromCharCode(v >> i & 255);
     }, x = array.map((function(v) {
      return toChar(v, 24) + toChar(v, 16) + toChar(v, 8) + toChar(v, 0);
     })).join(""), s = (Buffer.from ? Buffer.from(x, "binary") : new Buffer(x, "binary")).toString("base64");
     return s.substr(0, s.indexOf("="));
    }, Util.random32 = function() {
     return 4294967296 * Math.random() | 0;
    }, Util.randomu32 = function() {
     return Util.random32() + 2147483648;
    }, Util.w3cTraceId = function() {
     for (var tmp, hexValues = [ "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f" ], oct = "", a = 0; a < 4; a++) oct += hexValues[15 & (tmp = Util.random32())] + hexValues[tmp >> 4 & 15] + hexValues[tmp >> 8 & 15] + hexValues[tmp >> 12 & 15] + hexValues[tmp >> 16 & 15] + hexValues[tmp >> 20 & 15] + hexValues[tmp >> 24 & 15] + hexValues[tmp >> 28 & 15];
     var clockSequenceHi = hexValues[8 + 4 * Math.random() | 0];
     return oct.substr(0, 8) + oct.substr(9, 4) + "4" + oct.substr(13, 3) + clockSequenceHi + oct.substr(16, 3) + oct.substr(19, 12);
    }, Util.w3cSpanId = function() {
     return Util.w3cTraceId().substring(16);
    }, Util.isValidW3CId = function(id) {
     return 32 === id.length && "00000000000000000000000000000000" !== id;
    }, Util.isArray = function(obj) {
     return "[object Array]" === Object.prototype.toString.call(obj);
    }, Util.isError = function(obj) {
     return "[object Error]" === Object.prototype.toString.call(obj);
    }, Util.isPrimitive = function(input) {
     var propType = typeof input;
     return "string" === propType || "number" === propType || "boolean" === propType;
    }, Util.isDate = function(obj) {
     return "[object Date]" === Object.prototype.toString.call(obj);
    }, Util.msToTimeSpan = function(totalms) {
     (isNaN(totalms) || totalms < 0) && (totalms = 0);
     var sec = (totalms / 1e3 % 60).toFixed(7).replace(/0{0,4}$/, ""), min = "" + Math.floor(totalms / 6e4) % 60, hour = "" + Math.floor(totalms / 36e5) % 24, days = Math.floor(totalms / 864e5);
     return sec = sec.indexOf(".") < 2 ? "0" + sec : sec, min = min.length < 2 ? "0" + min : min, 
     (days > 0 ? days + "." : "") + (hour = hour.length < 2 ? "0" + hour : hour) + ":" + min + ":" + sec;
    }, Util.extractError = function(err) {
     var looseError = err;
     return {
      message: err.message,
      code: looseError.code || looseError.id || ""
     };
    }, Util.extractObject = function(origProperty) {
     return origProperty instanceof Error ? Util.extractError(origProperty) : "function" == typeof origProperty.toJSON ? origProperty.toJSON() : origProperty;
    }, Util.validateStringMap = function(obj) {
     if ("object" == typeof obj) {
      var map = {};
      for (var field in obj) {
       var property = "", origProperty = obj[field], propType = typeof origProperty;
       if (Util.isPrimitive(origProperty)) property = origProperty.toString(); else if (null === origProperty || "undefined" === propType) property = ""; else {
        if ("function" === propType) {
         Logging.info("key: " + field + " was function; will not serialize");
         continue;
        }
        var stringTarget = Util.isArray(origProperty) ? origProperty : Util.extractObject(origProperty);
        try {
         property = Util.isPrimitive(stringTarget) ? stringTarget : JSON.stringify(stringTarget);
        } catch (e) {
         property = origProperty.constructor.name.toString() + " (Error: " + e.message + ")", 
         Logging.info("key: " + field + ", could not be serialized");
        }
       }
       map[field] = property.substring(0, Util.MAX_PROPERTY_LENGTH);
      }
      return map;
     }
     Logging.info("Invalid properties dropped from payload");
    }, Util.canIncludeCorrelationHeader = function(client, requestUrl) {
     var excludedDomains = client && client.config && client.config.correlationHeaderExcludedDomains;
     if (!excludedDomains || 0 == excludedDomains.length || !requestUrl) return !0;
     for (var i = 0; i < excludedDomains.length; i++) {
      var regex = new RegExp(excludedDomains[i].replace(/\./g, ".").replace(/\*/g, ".*"));
      try {
       if (regex.test(new url.URL(requestUrl).hostname)) return !1;
      } catch (ex) {}
     }
     return !0;
    }, Util.getCorrelationContextTarget = function(response, key) {
     var contextHeaders = response.headers && response.headers[RequestResponseHeaders.requestContextHeader];
     if (contextHeaders) for (var keyValues = contextHeaders.split(","), i = 0; i < keyValues.length; ++i) {
      var keyValue = keyValues[i].split("=");
      if (2 == keyValue.length && keyValue[0] == key) return keyValue[1];
     }
    }, Util.makeRequest = function(config, requestUrl, requestOptions, requestCallback, useProxy, useAgent) {
     void 0 === useProxy && (useProxy = !0), void 0 === useAgent && (useAgent = !0), 
     requestUrl && 0 === requestUrl.indexOf("//") && (requestUrl = "https:" + requestUrl);
     var requestUrlParsed = new url.URL(requestUrl), options = __assign(__assign({}, requestOptions), {
      host: requestUrlParsed.hostname,
      port: requestUrlParsed.port,
      path: requestUrlParsed.pathname
     }), proxyUrl = void 0;
     if (useProxy && ("https:" === requestUrlParsed.protocol && (proxyUrl = config.proxyHttpsUrl || void 0), 
     "http:" === requestUrlParsed.protocol && (proxyUrl = config.proxyHttpUrl || void 0), 
     proxyUrl)) {
      0 === proxyUrl.indexOf("//") && (proxyUrl = "http:" + proxyUrl);
      try {
       var proxyUrlParsed = new url.URL(proxyUrl);
       "https:" === proxyUrlParsed.protocol ? (Logging.info("Proxies that use HTTPS are not supported"), 
       proxyUrl = void 0) : options = __assign(__assign({}, options), {
        host: proxyUrlParsed.hostname,
        port: proxyUrlParsed.port || "80",
        path: requestUrl,
        headers: __assign(__assign({}, options.headers), {
         Host: requestUrlParsed.hostname
        })
       });
      } catch (err) {
       Logging.warn("Wrong proxy URL provided");
      }
     }
     var isHttps = "https:" === requestUrlParsed.protocol && !proxyUrl;
     return useAgent && (isHttps && void 0 !== config.httpsAgent ? options.agent = config.httpsAgent : isHttps || void 0 === config.httpAgent ? isHttps && (options.agent = Util._useKeepAlive ? Util.keepAliveAgent : Util.tlsRestrictedAgent) : options.agent = config.httpAgent), 
     isHttps ? https.request(options, requestCallback) : http.request(options, requestCallback);
    }, Util.safeIncludeCorrelationHeader = function(client, request, correlationHeader) {
     var header;
     if ("string" == typeof correlationHeader) header = correlationHeader; else if (correlationHeader instanceof Array) header = correlationHeader.join(","); else if (correlationHeader && "function" == typeof correlationHeader.toString) try {
      header = correlationHeader.toString();
     } catch (err) {
      Logging.warn("Outgoing request-context header could not be read. Correlation of requests may be lost.", err, correlationHeader);
     }
     header ? Util.addCorrelationIdHeaderFromString(client, request, header) : request.setHeader(RequestResponseHeaders.requestContextHeader, RequestResponseHeaders.requestContextSourceKey + "=" + client.config.correlationId);
    }, Util.dumpObj = function(object) {
     if (object) try {
      var objectTypeDump = Object.prototype.toString.call(object);
      return objectTypeDump + ("[object Error]" === objectTypeDump ? "{ stack: '" + object.stack + "', message: '" + object.message + "', name: '" + object.name + "'" : this.stringify(object));
     } catch (ex) {
      return object.toString();
     }
    }, Util.stringify = function(payload) {
     try {
      return JSON.stringify(payload);
     } catch (error) {
      Logging.warn("Failed to serialize payload", error, payload);
     }
    }, Util.addCorrelationIdHeaderFromString = function(client, response, correlationHeader) {
     var components = correlationHeader.split(","), key = RequestResponseHeaders.requestContextSourceKey + "=";
     components.some((function(value) {
      return value.substring(0, key.length) === key;
     })) || response.setHeader(RequestResponseHeaders.requestContextHeader, correlationHeader + "," + RequestResponseHeaders.requestContextSourceKey + "=" + client.config.correlationId);
    }, Util._addCloseHandler = function() {
     Util._listenerAttached || (process.on("exit", (function() {
      Util.isNodeExit = !0, Util._useKeepAlive = !1;
     })), Util._listenerAttached = !0);
    }, Util._useKeepAlive = !JsonConfig_1.JsonConfig.getInstance().noHttpAgentKeepAlive, 
    Util._listenerAttached = !1, Util.MAX_PROPERTY_LENGTH = 8192, Util.keepAliveAgent = new https.Agent({
     keepAlive: !0,
     maxSockets: 25,
     secureOptions: constants.SSL_OP_NO_SSLv2 | constants.SSL_OP_NO_SSLv3 | constants.SSL_OP_NO_TLSv1 | constants.SSL_OP_NO_TLSv1_1
    }), Util.tlsRestrictedAgent = new https.Agent({
     secureOptions: constants.SSL_OP_NO_SSLv2 | constants.SSL_OP_NO_SSLv3 | constants.SSL_OP_NO_TLSv1 | constants.SSL_OP_NO_TLSv1_1
    }), Util.isNodeExit = !1, Util;
   }();
   module.exports = Util;
  },
  67334: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.azureRoleEnvironmentTelemetryProcessor = void 0, exports.azureRoleEnvironmentTelemetryProcessor = function(envelope, context) {};
  },
  84127: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.performanceMetricsTelemetryProcessor = void 0;
   var AutoCollectPerformance = __webpack_require__(74350), TelemetryType = __webpack_require__(55290);
   exports.performanceMetricsTelemetryProcessor = function(envelope, client) {
    switch (client && client.addDocument(envelope), envelope.data.baseType) {
    case TelemetryType.TelemetryTypeString.Exception:
     AutoCollectPerformance.countException();
     break;

    case TelemetryType.TelemetryTypeString.Request:
     var requestData = envelope.data.baseData;
     AutoCollectPerformance.countRequest(requestData.duration, requestData.success);
     break;

    case TelemetryType.TelemetryTypeString.Dependency:
     var remoteDependencyData = envelope.data.baseData;
     AutoCollectPerformance.countDependency(remoteDependencyData.duration, remoteDependencyData.success);
    }
    return !0;
   };
  },
  36798: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __assign = this && this.__assign || function() {
    return __assign = Object.assign || function(t) {
     for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
     return t;
    }, __assign.apply(this, arguments);
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.preAggregatedMetricsTelemetryProcessor = void 0;
   var Contracts = __webpack_require__(55290), AutoCollecPreAggregatedMetrics = __webpack_require__(62309), TelemetryType = __webpack_require__(55290);
   exports.preAggregatedMetricsTelemetryProcessor = function(envelope, context) {
    if (AutoCollecPreAggregatedMetrics.isEnabled()) switch (envelope.data.baseType) {
    case TelemetryType.TelemetryTypeString.Exception:
     var exceptionData = envelope.data.baseData;
     exceptionData.properties = __assign(__assign({}, exceptionData.properties), {
      "_MS.ProcessedByMetricExtractors": "(Name:'Exceptions', Ver:'1.1')"
     });
     var exceptionDimensions = {
      cloudRoleInstance: envelope.tags[context.keys.cloudRoleInstance],
      cloudRoleName: envelope.tags[context.keys.cloudRole]
     };
     AutoCollecPreAggregatedMetrics.countException(exceptionDimensions);
     break;

    case TelemetryType.TelemetryTypeString.Trace:
     var traceData = envelope.data.baseData;
     traceData.properties = __assign(__assign({}, traceData.properties), {
      "_MS.ProcessedByMetricExtractors": "(Name:'Traces', Ver:'1.1')"
     });
     var traceDimensions = {
      cloudRoleInstance: envelope.tags[context.keys.cloudRoleInstance],
      cloudRoleName: envelope.tags[context.keys.cloudRole],
      traceSeverityLevel: Contracts.SeverityLevel[traceData.severity]
     };
     AutoCollecPreAggregatedMetrics.countTrace(traceDimensions);
     break;

    case TelemetryType.TelemetryTypeString.Request:
     var requestData = envelope.data.baseData;
     requestData.properties = __assign(__assign({}, requestData.properties), {
      "_MS.ProcessedByMetricExtractors": "(Name:'Requests', Ver:'1.1')"
     });
     var requestDimensions = {
      cloudRoleInstance: envelope.tags[context.keys.cloudRoleInstance],
      cloudRoleName: envelope.tags[context.keys.cloudRole],
      operationSynthetic: envelope.tags[context.keys.operationSyntheticSource],
      requestSuccess: requestData.success,
      requestResultCode: requestData.responseCode
     };
     AutoCollecPreAggregatedMetrics.countRequest(requestData.duration, requestDimensions);
     break;

    case TelemetryType.TelemetryTypeString.Dependency:
     var remoteDependencyData = envelope.data.baseData;
     remoteDependencyData.properties = __assign(__assign({}, remoteDependencyData.properties), {
      "_MS.ProcessedByMetricExtractors": "(Name:'Dependencies', Ver:'1.1')"
     });
     var dependencyDimensions = {
      cloudRoleInstance: envelope.tags[context.keys.cloudRoleInstance],
      cloudRoleName: envelope.tags[context.keys.cloudRole],
      operationSynthetic: envelope.tags[context.keys.operationSyntheticSource],
      dependencySuccess: remoteDependencyData.success,
      dependencyType: remoteDependencyData.type,
      dependencyTarget: remoteDependencyData.target,
      dependencyResultCode: remoteDependencyData.resultCode
     };
     AutoCollecPreAggregatedMetrics.countDependency(remoteDependencyData.duration, dependencyDimensions);
    }
    return !0;
   };
  },
  20608: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.getSamplingHashCode = exports.samplingTelemetryProcessor = void 0;
   var Contracts = __webpack_require__(55290);
   function getSamplingHashCode(input) {
    var hash = 5381;
    if (!input) return 0;
    for (;input.length < 8; ) input += input;
    for (var i = 0; i < input.length; i++) hash = ((hash << 5) + hash | 0) + input.charCodeAt(i) | 0;
    return (hash = hash <= -2147483648 ? 2147483647 : Math.abs(hash)) / 2147483647 * 100;
   }
   exports.samplingTelemetryProcessor = function(envelope, contextObjects) {
    var samplingPercentage = envelope.sampleRate;
    return null == samplingPercentage || samplingPercentage >= 100 || (!(!envelope.data || Contracts.TelemetryType.Metric !== Contracts.baseTypeToTelemetryType(envelope.data.baseType)) || (contextObjects.correlationContext && contextObjects.correlationContext.operation ? getSamplingHashCode(contextObjects.correlationContext.operation.id) < samplingPercentage : 100 * Math.random() < samplingPercentage));
   }, exports.getSamplingHashCode = getSamplingHashCode;
  },
  59428: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), Object.defineProperty(o, k2, {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    });
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), __exportStar(__webpack_require__(67334), exports), __exportStar(__webpack_require__(20608), exports), 
   __exportStar(__webpack_require__(84127), exports), __exportStar(__webpack_require__(36798), exports);
  },
  9574: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.dispose = exports.Configuration = exports.wrapWithCorrelationContext = exports.startOperation = exports.getCorrelationContext = exports.start = exports.setup = exports.liveMetricsClient = exports.defaultClient = exports.DistributedTracingModes = void 0;
   var DistributedTracingModes, CorrelationContextManager = __webpack_require__(70894), AutoCollectConsole = __webpack_require__(66281), AutoCollectExceptions = __webpack_require__(6639), AutoCollectPerformance = __webpack_require__(74350), AutoCollecPreAggregatedMetrics = __webpack_require__(62309), HeartBeat = __webpack_require__(38975), WebSnippet = __webpack_require__(11918), AutoCollectHttpDependencies = __webpack_require__(88723), AutoCollectHttpRequests = __webpack_require__(40731), CorrelationIdManager = __webpack_require__(29962), Logging = __webpack_require__(95282), QuickPulseClient = __webpack_require__(83668), NativePerformance_1 = __webpack_require__(11629), AzureFunctionsHook_1 = __webpack_require__(81162);
   exports.TelemetryClient = __webpack_require__(1259), exports.Contracts = __webpack_require__(55290), 
   exports.azureFunctionsTypes = __webpack_require__(56761), function(DistributedTracingModes) {
    DistributedTracingModes[DistributedTracingModes.AI = 0] = "AI", DistributedTracingModes[DistributedTracingModes.AI_AND_W3C = 1] = "AI_AND_W3C";
   }(DistributedTracingModes = exports.DistributedTracingModes || (exports.DistributedTracingModes = {}));
   var _forceClsHooked, _disabledExtendedMetrics, defaultConfig = {
    isConsole: function() {
     return !0;
    },
    isConsoleLog: function() {
     return !1;
    },
    isExceptions: function() {
     return !0;
    },
    isPerformance: function() {
     return !0;
    },
    isPreAggregatedMetrics: function() {
     return !0;
    },
    isHeartBeat: function() {
     return !1;
    },
    isRequests: function() {
     return !0;
    },
    isDependencies: function() {
     return !0;
    },
    isDiskRetry: function() {
     return !0;
    },
    isCorrelating: function() {
     return !0;
    },
    isSendingLiveMetrics: function() {
     return !1;
    },
    isNativePerformance: function() {
     return !0;
    },
    isSnippetInjection: function() {
     return !1;
    },
    isAzureFunctions: function() {
     return !1;
    },
    isLoggerErrorToTrace: function() {
     return !1;
    }
   }, _isConsole = defaultConfig.isConsole(), _isConsoleLog = defaultConfig.isConsoleLog(), _isLoggerErrorToTrace = defaultConfig.isLoggerErrorToTrace(), _isExceptions = defaultConfig.isExceptions(), _isPerformance = defaultConfig.isPerformance(), _isPreAggregatedMetrics = defaultConfig.isPreAggregatedMetrics(), _isHeartBeat = defaultConfig.isHeartBeat(), _isRequests = defaultConfig.isRequests(), _isDependencies = defaultConfig.isDependencies(), _isDiskRetry = defaultConfig.isDiskRetry(), _isCorrelating = defaultConfig.isCorrelating(), _isSendingLiveMetrics = defaultConfig.isSendingLiveMetrics(), _isNativePerformance = defaultConfig.isNativePerformance(), _isSnippetInjection = defaultConfig.isSnippetInjection(), _isAzureFunctions = defaultConfig.isAzureFunctions();
   var _console, _exceptions, _performance, _preAggregatedMetrics, _heartbeat, _webSnippet, _nativePerformance, _serverRequests, _clientRequests, _azureFunctions, _performanceLiveMetrics, _diskRetryInterval = void 0, _diskRetryMaxBytes = void 0, _webSnippetConnectionString = void 0, _isStarted = !1;
   function start() {
    return exports.defaultClient ? (_isStarted = !0, _console.enable(_isConsole, _isConsoleLog), 
    _exceptions.enable(_isExceptions), _performance.enable(_isPerformance), _preAggregatedMetrics.enable(_isPreAggregatedMetrics), 
    _heartbeat.enable(_isHeartBeat), _nativePerformance.enable(_isNativePerformance, _disabledExtendedMetrics), 
    _serverRequests.useAutoCorrelation(_isCorrelating, _forceClsHooked), _serverRequests.enable(_isRequests), 
    _clientRequests.enable(_isDependencies), _webSnippet.enable(_isSnippetInjection, _webSnippetConnectionString), 
    exports.liveMetricsClient && _isSendingLiveMetrics && exports.liveMetricsClient.enable(_isSendingLiveMetrics), 
    _azureFunctions.enable(_isAzureFunctions)) : Logging.warn("Start cannot be called before setup"), 
    Configuration;
   }
   exports.setup = function(setupString) {
    return exports.defaultClient ? Logging.info("The default client is already setup") : (exports.defaultClient = new exports.TelemetryClient(setupString), 
    function() {
     _isConsole = void 0 !== exports.defaultClient.config.enableAutoCollectExternalLoggers ? exports.defaultClient.config.enableAutoCollectExternalLoggers : _isConsole, 
     _isConsoleLog = void 0 !== exports.defaultClient.config.enableAutoCollectConsole ? exports.defaultClient.config.enableAutoCollectConsole : _isConsoleLog, 
     _isLoggerErrorToTrace = void 0 !== exports.defaultClient.config.enableLoggerErrorToTrace ? exports.defaultClient.config.enableLoggerErrorToTrace : _isLoggerErrorToTrace, 
     _isExceptions = void 0 !== exports.defaultClient.config.enableAutoCollectExceptions ? exports.defaultClient.config.enableAutoCollectExceptions : _isExceptions, 
     _isPerformance = void 0 !== exports.defaultClient.config.enableAutoCollectPerformance ? exports.defaultClient.config.enableAutoCollectPerformance : _isPerformance, 
     _isPreAggregatedMetrics = void 0 !== exports.defaultClient.config.enableAutoCollectPreAggregatedMetrics ? exports.defaultClient.config.enableAutoCollectPreAggregatedMetrics : _isPreAggregatedMetrics, 
     _isHeartBeat = void 0 !== exports.defaultClient.config.enableAutoCollectHeartbeat ? exports.defaultClient.config.enableAutoCollectHeartbeat : _isHeartBeat, 
     _isRequests = void 0 !== exports.defaultClient.config.enableAutoCollectRequests ? exports.defaultClient.config.enableAutoCollectRequests : _isRequests, 
     _isDependencies = void 0 !== exports.defaultClient.config.enableAutoDependencyCorrelation ? exports.defaultClient.config.enableAutoDependencyCorrelation : _isDependencies, 
     _isDiskRetry = void 0 !== exports.defaultClient.config.enableUseDiskRetryCaching ? exports.defaultClient.config.enableUseDiskRetryCaching : _isDiskRetry, 
     _isCorrelating = void 0 !== exports.defaultClient.config.enableAutoDependencyCorrelation ? exports.defaultClient.config.enableAutoDependencyCorrelation : _isCorrelating, 
     _forceClsHooked = void 0 !== exports.defaultClient.config.enableUseAsyncHooks ? exports.defaultClient.config.enableUseAsyncHooks : _forceClsHooked, 
     _isSendingLiveMetrics = void 0 !== exports.defaultClient.config.enableSendLiveMetrics ? exports.defaultClient.config.enableSendLiveMetrics : _isSendingLiveMetrics, 
     _isSnippetInjection = !0 === exports.defaultClient.config.enableAutoWebSnippetInjection || _isSnippetInjection, 
     _isAzureFunctions = void 0 !== exports.defaultClient.config.enableAutoCollectIncomingRequestAzureFunctions ? exports.defaultClient.config.enableAutoCollectIncomingRequestAzureFunctions : _isAzureFunctions;
     var extendedMetricsConfig = NativePerformance_1.AutoCollectNativePerformance.parseEnabled(exports.defaultClient.config.enableAutoCollectExtendedMetrics, exports.defaultClient.config);
     _isNativePerformance = extendedMetricsConfig.isEnabled, _disabledExtendedMetrics = extendedMetricsConfig.disabledMetrics;
    }(), _console = new AutoCollectConsole(exports.defaultClient), _exceptions = new AutoCollectExceptions(exports.defaultClient), 
    _performance = new AutoCollectPerformance(exports.defaultClient), _preAggregatedMetrics = new AutoCollecPreAggregatedMetrics(exports.defaultClient), 
    _heartbeat = new HeartBeat(exports.defaultClient), _webSnippet = new WebSnippet(exports.defaultClient), 
    _serverRequests = new AutoCollectHttpRequests(exports.defaultClient), _clientRequests = new AutoCollectHttpDependencies(exports.defaultClient), 
    _nativePerformance || (_nativePerformance = new NativePerformance_1.AutoCollectNativePerformance(exports.defaultClient)), 
    _azureFunctions = new AzureFunctionsHook_1.AzureFunctionsHook(exports.defaultClient)), 
    exports.defaultClient && exports.defaultClient.channel && exports.defaultClient.channel.setUseDiskRetryCaching(_isDiskRetry, _diskRetryInterval, _diskRetryMaxBytes), 
    Configuration;
   }, exports.start = start, exports.getCorrelationContext = function() {
    return _isCorrelating ? CorrelationContextManager.CorrelationContextManager.getCurrentContext() : null;
   }, exports.startOperation = function(context, request) {
    return CorrelationContextManager.CorrelationContextManager.startOperation(context, request);
   }, exports.wrapWithCorrelationContext = function(fn, context) {
    return CorrelationContextManager.CorrelationContextManager.wrapCallback(fn, context);
   };
   var Configuration = function() {
    function Configuration() {}
    return Configuration.setDistributedTracingMode = function(value) {
     return CorrelationIdManager.w3cEnabled = value === DistributedTracingModes.AI_AND_W3C, 
     Configuration;
    }, Configuration.setAutoCollectConsole = function(value, collectConsoleLog) {
     return void 0 === collectConsoleLog && (collectConsoleLog = !1), _isConsole = value, 
     _isConsoleLog = collectConsoleLog, _isStarted && _console.enable(value, collectConsoleLog), 
     Configuration;
    }, Configuration.setAutoCollectExceptions = function(value) {
     return _isExceptions = value, _isStarted && _exceptions.enable(value), Configuration;
    }, Configuration.setAutoCollectPerformance = function(value, collectExtendedMetrics) {
     void 0 === collectExtendedMetrics && (collectExtendedMetrics = !0), _isPerformance = value;
     var extendedMetricsConfig = NativePerformance_1.AutoCollectNativePerformance.parseEnabled(collectExtendedMetrics, exports.defaultClient.config);
     return _isNativePerformance = extendedMetricsConfig.isEnabled, _disabledExtendedMetrics = extendedMetricsConfig.disabledMetrics, 
     _isStarted && (_performance.enable(value), _nativePerformance.enable(extendedMetricsConfig.isEnabled, extendedMetricsConfig.disabledMetrics)), 
     Configuration;
    }, Configuration.setAutoCollectPreAggregatedMetrics = function(value) {
     return _isPreAggregatedMetrics = value, _isStarted && _preAggregatedMetrics.enable(value), 
     Configuration;
    }, Configuration.setAutoCollectHeartbeat = function(value) {
     return _isHeartBeat = value, _isStarted && _heartbeat.enable(value), Configuration;
    }, Configuration.enableAutoWebSnippetInjection = function(value, WebSnippetConnectionString) {
     return _isSnippetInjection = value, _webSnippetConnectionString = WebSnippetConnectionString, 
     _isStarted && _webSnippet.enable(value, _webSnippetConnectionString), Configuration;
    }, Configuration.enableWebInstrumentation = function(value, WebSnippetConnectionString) {
     return _isSnippetInjection = value, _webSnippetConnectionString = WebSnippetConnectionString, 
     _isStarted && _webSnippet.enable(value, _webSnippetConnectionString), Configuration;
    }, Configuration.setAutoCollectRequests = function(value) {
     return _isRequests = value, _isStarted && _serverRequests.enable(value), Configuration;
    }, Configuration.setAutoCollectDependencies = function(value) {
     return _isDependencies = value, _isStarted && _clientRequests.enable(value), Configuration;
    }, Configuration.setAutoDependencyCorrelation = function(value, useAsyncHooks) {
     return _isCorrelating = value, _forceClsHooked = useAsyncHooks, _isStarted && _serverRequests.useAutoCorrelation(value, useAsyncHooks), 
     Configuration;
    }, Configuration.setUseDiskRetryCaching = function(value, resendInterval, maxBytesOnDisk) {
     return _isDiskRetry = value, _diskRetryInterval = resendInterval, _diskRetryMaxBytes = maxBytesOnDisk, 
     exports.defaultClient && exports.defaultClient.channel && exports.defaultClient.channel.setUseDiskRetryCaching(_isDiskRetry, _diskRetryInterval, _diskRetryMaxBytes), 
     Configuration;
    }, Configuration.setInternalLogging = function(enableDebugLogging, enableWarningLogging) {
     return void 0 === enableDebugLogging && (enableDebugLogging = !1), void 0 === enableWarningLogging && (enableWarningLogging = !0), 
     Logging.enableDebug = enableDebugLogging, Logging.disableWarnings = !enableWarningLogging, 
     Configuration;
    }, Configuration.setAutoCollectIncomingRequestAzureFunctions = function(value) {
     return _isAzureFunctions = value, _isStarted && _azureFunctions.enable(value), Configuration;
    }, Configuration.setSendLiveMetrics = function(enable) {
     return void 0 === enable && (enable = !1), exports.defaultClient ? (!exports.liveMetricsClient && enable ? (exports.liveMetricsClient = new QuickPulseClient(exports.defaultClient.config, exports.defaultClient.context, exports.defaultClient.getAuthorizationHandler), 
     _performanceLiveMetrics = new AutoCollectPerformance(exports.liveMetricsClient, 1e3, !0), 
     exports.liveMetricsClient.addCollector(_performanceLiveMetrics), exports.defaultClient.quickPulseClient = exports.liveMetricsClient) : exports.liveMetricsClient && exports.liveMetricsClient.enable(enable), 
     _isSendingLiveMetrics = enable, Configuration) : (Logging.warn("Live metrics client cannot be setup without the default client"), 
     Configuration);
    }, Configuration.start = start, Configuration;
   }();
   exports.Configuration = Configuration, exports.dispose = function() {
    CorrelationIdManager.w3cEnabled = !0, exports.defaultClient = null, _isStarted = !1, 
    _console && _console.dispose(), _exceptions && _exceptions.dispose(), _performance && _performance.dispose(), 
    _preAggregatedMetrics && _preAggregatedMetrics.dispose(), _heartbeat && _heartbeat.dispose(), 
    _webSnippet && _webSnippet.dispose(), _nativePerformance && _nativePerformance.dispose(), 
    _serverRequests && _serverRequests.dispose(), _clientRequests && _clientRequests.dispose(), 
    exports.liveMetricsClient && (exports.liveMetricsClient.enable(!1), _isSendingLiveMetrics = !1, 
    exports.liveMetricsClient = void 0), _azureFunctions && _azureFunctions.dispose();
   };
  },
  99822: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   const asyncWrap = process.binding("async_wrap"), TIMERWRAP = asyncWrap.Providers.TIMERWRAP, patchs = {
    nextTick: __webpack_require__(93269),
    promise: __webpack_require__(99565),
    timers: __webpack_require__(57190)
   }, ignoreUIDs = new Set;
   function State() {
    this.enabled = !1, this.counter = 0;
   }
   function Hooks() {
    const initFns = this.initFns = [], preFns = this.preFns = [], postFns = this.postFns = [], destroyFns = this.destroyFns = [];
    this.init = function(uid, provider, parentUid, parentHandle) {
     if (provider !== TIMERWRAP) for (const hook of initFns) hook(uid, this, provider, parentUid, parentHandle); else ignoreUIDs.add(uid);
    }, this.pre = function(uid) {
     if (!ignoreUIDs.has(uid)) for (const hook of preFns) hook(uid, this);
    }, this.post = function(uid, didThrow) {
     if (!ignoreUIDs.has(uid)) for (const hook of postFns) hook(uid, this, didThrow);
    }, this.destroy = function(uid) {
     if (ignoreUIDs.has(uid)) ignoreUIDs.delete(uid); else for (const hook of destroyFns) hook(uid);
    };
   }
   function removeElement(array, item) {
    const index = array.indexOf(item);
    -1 !== index && array.splice(index, 1);
   }
   function AsyncHook() {
    this._state = new State, this._hooks = new Hooks, this.version = __webpack_require__(26157).i8, 
    this.providers = asyncWrap.Providers;
    for (const key of Object.keys(patchs)) patchs[key].call(this);
    process.env.hasOwnProperty("NODE_ASYNC_HOOK_WARNING") && console.warn("warning: you are using async-hook-jl which is unstable."), 
    asyncWrap.setupHooks({
     init: this._hooks.init,
     pre: this._hooks.pre,
     post: this._hooks.post,
     destroy: this._hooks.destroy
    });
   }
   Hooks.prototype.add = function(hooks) {
    hooks.init && this.initFns.push(hooks.init), hooks.pre && this.preFns.push(hooks.pre), 
    hooks.post && this.postFns.push(hooks.post), hooks.destroy && this.destroyFns.push(hooks.destroy);
   }, Hooks.prototype.remove = function(hooks) {
    hooks.init && removeElement(this.initFns, hooks.init), hooks.pre && removeElement(this.preFns, hooks.pre), 
    hooks.post && removeElement(this.postFns, hooks.post), hooks.destroy && removeElement(this.destroyFns, hooks.destroy);
   }, module.exports = AsyncHook, AsyncHook.prototype.addHooks = function(hooks) {
    this._hooks.add(hooks);
   }, AsyncHook.prototype.removeHooks = function(hooks) {
    this._hooks.remove(hooks);
   }, AsyncHook.prototype.enable = function() {
    this._state.enabled = !0, asyncWrap.enable();
   }, AsyncHook.prototype.disable = function() {
    this._state.enabled = !1, asyncWrap.disable();
   };
  },
  73223: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   const AsyncHook = __webpack_require__(99822);
   if (global._asyncHook) {
    if (global._asyncHook.version !== __webpack_require__(26157).i8) throw new Error("Conflicting version of async-hook-jl found");
    module.exports = global._asyncHook;
   } else {
    __webpack_require__(92512).filter.attach((function(error, frames) {
     return frames.filter((function(callSite) {
      const filename = callSite.getFileName();
      return !(filename && filename.slice(0, __dirname.length) === __dirname);
     }));
    })), module.exports = global._asyncHook = new AsyncHook;
   }
  },
  93269: module => {
   "use strict";
   function NextTickWrap() {}
   module.exports = function() {
    const hooks = this._hooks, state = this._state, oldNextTick = process.nextTick;
    process.nextTick = function() {
     if (!state.enabled) return oldNextTick.apply(process, arguments);
     const args = new Array(arguments.length);
     for (let i = 0; i < arguments.length; i++) args[i] = arguments[i];
     const callback = args[0];
     if ("function" != typeof callback) throw new TypeError("callback is not a function");
     const handle = new NextTickWrap, uid = --state.counter;
     return hooks.init.call(handle, uid, 0, null, null), args[0] = function() {
      hooks.pre.call(handle, uid);
      let didThrow = !0;
      try {
       callback.apply(this, arguments), didThrow = !1;
      } finally {
       didThrow && process.listenerCount("uncaughtException") > 0 && process.once("uncaughtException", (function() {
        hooks.post.call(handle, uid, !0), hooks.destroy.call(null, uid);
       }));
      }
      hooks.post.call(handle, uid, !1), hooks.destroy.call(null, uid);
     }, oldNextTick.apply(process, args);
    };
   };
  },
  99565: module => {
   "use strict";
   function PromiseWrap() {}
   module.exports = function() {
    const hooks = this._hooks, state = this._state, Promise = global.Promise, oldThen = Promise.prototype.then;
    function makeWrappedHandler(fn, handle, uid, isOnFulfilled) {
     return "function" != typeof fn ? isOnFulfilled ? function(uid) {
      return function(val) {
       return hooks.destroy.call(null, uid), val;
      };
     }(uid) : function(uid) {
      return function(val) {
       throw hooks.destroy.call(null, uid), val;
      };
     }(uid) : function() {
      hooks.pre.call(handle, uid);
      try {
       return fn.apply(this, arguments);
      } finally {
       hooks.post.call(handle, uid, !1), hooks.destroy.call(null, uid);
      }
     };
    }
    Promise.prototype.then = function(onFulfilled, onRejected) {
     if (!state.enabled) return oldThen.call(this, onFulfilled, onRejected);
     const handle = new PromiseWrap, uid = --state.counter;
     return hooks.init.call(handle, uid, 0, null, null), oldThen.call(this, makeWrappedHandler(onFulfilled, handle, uid, !0), makeWrappedHandler(onRejected, handle, uid, !1));
    };
   };
  },
  57190: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   const timers = __webpack_require__(39512);
   function TimeoutWrap() {}
   function IntervalWrap() {}
   function ImmediateWrap() {}
   const timeoutMap = new Map, intervalMap = new Map, ImmediateMap = new Map;
   let activeCallback = null, clearedInCallback = !1;
   function patchTimer(hooks, state, setFn, clearFn, Handle, timerMap, singleCall) {
    const oldSetFn = timers[setFn], oldClearFn = timers[clearFn];
    timers[setFn] = function() {
     if (!state.enabled) return oldSetFn.apply(timers, arguments);
     const args = new Array(arguments.length);
     for (let i = 0; i < arguments.length; i++) args[i] = arguments[i];
     const callback = args[0];
     if ("function" != typeof callback) throw new TypeError('"callback" argument must be a function');
     const handle = new Handle, uid = --state.counter;
     let timerId;
     return hooks.init.call(handle, uid, 0, null, null), args[0] = function() {
      activeCallback = timerId, hooks.pre.call(handle, uid);
      let didThrow = !0;
      try {
       callback.apply(this, arguments), didThrow = !1;
      } finally {
       didThrow && process.listenerCount("uncaughtException") > 0 && process.once("uncaughtException", (function() {
        hooks.post.call(handle, uid, !0), timerMap.delete(timerId), hooks.destroy.call(null, uid);
       }));
      }
      hooks.post.call(handle, uid, !1), activeCallback = null, (singleCall || clearedInCallback) && (clearedInCallback = !1, 
      timerMap.delete(timerId), hooks.destroy.call(null, uid));
     }, timerId = oldSetFn.apply(timers, args), timerMap.set(timerId, uid), timerId;
    }, timers[clearFn] = function(timerId) {
     if (activeCallback === timerId && null !== timerId) clearedInCallback = !0; else if (timerMap.has(timerId)) {
      const uid = timerMap.get(timerId);
      timerMap.delete(timerId), hooks.destroy.call(null, uid);
     }
     oldClearFn.apply(timers, arguments);
    };
   }
   module.exports = function() {
    patchTimer(this._hooks, this._state, "setTimeout", "clearTimeout", TimeoutWrap, timeoutMap, !0), 
    patchTimer(this._hooks, this._state, "setInterval", "clearInterval", IntervalWrap, intervalMap, !1), 
    patchTimer(this._hooks, this._state, "setImmediate", "clearImmediate", ImmediateWrap, ImmediateMap, !0), 
    global.setTimeout = timers.setTimeout, global.setInterval = timers.setInterval, 
    global.setImmediate = timers.setImmediate, global.clearTimeout = timers.clearTimeout, 
    global.clearInterval = timers.clearInterval, global.clearImmediate = timers.clearImmediate;
   };
  },
  68286: module => {
   "use strict";
   module.exports = (Promise, ensureAslWrapper) => class extends Promise {
    constructor(executor) {
     var context, args;
     super((function(resolve, reject) {
      context = this, args = [ function(val) {
       return ensureAslWrapper(promise, !1), resolve(val);
      }, function(val) {
       return ensureAslWrapper(promise, !1), reject(val);
      } ];
     }));
     var promise = this;
     try {
      executor.apply(context, args);
     } catch (err) {
      args[1](err);
     }
     return promise;
    }
   };
  },
  89090: (module, __unused_webpack_exports, __webpack_require__) => {
   var asyncCatcher, asyncWrap, wrap = __webpack_require__(76372).wrap, HAS_CREATE_AL = 1, HAS_BEFORE_AL = 2, HAS_AFTER_AL = 4, HAS_ERROR_AL = 8, listeners = [], uid = 0, inAsyncTick = !1, listenerStack = [];
   function union(dest, added) {
    var destLength = dest.length, addedLength = added.length, returned = [];
    if (0 === destLength && 0 === addedLength) return returned;
    for (var j = 0; j < destLength; j++) returned[j] = dest[j];
    if (0 === addedLength) return returned;
    for (var i = 0; i < addedLength; i++) {
     var missing = !0;
     for (j = 0; j < destLength; j++) if (dest[j].uid === added[i].uid) {
      missing = !1;
      break;
     }
     missing && returned.push(added[i]);
    }
    return returned;
   }
   if (process._fatalException) {
    var errorValues, inErrorTick = !1;
    asyncCatcher = function(er) {
     var length = listeners.length;
     if (inErrorTick || 0 === length) return !1;
     var handled = !1;
     inErrorTick = !0;
     for (var i = 0; i < length; ++i) {
      var listener = listeners[i];
      if (0 != (listener.flags & HAS_ERROR_AL)) {
       var value = errorValues && errorValues[listener.uid];
       handled = listener.error(value, er) || handled;
      }
     }
     return inErrorTick = !1, listenerStack.length > 0 && (listeners = listenerStack.pop()), 
     errorValues = void 0, handled && !inAsyncTick;
    }, asyncWrap = function(original, list, length) {
     var values = [];
     inAsyncTick = !0;
     for (var i = 0; i < length; ++i) {
      var listener = list[i];
      if (values[listener.uid] = listener.data, 0 != (listener.flags & HAS_CREATE_AL)) {
       var value = listener.create(listener.data);
       void 0 !== value && (values[listener.uid] = value);
      }
     }
     return inAsyncTick = !1, function() {
      errorValues = values, listenerStack.push(listeners), listeners = union(list, listeners), 
      inAsyncTick = !0;
      for (var i = 0; i < length; ++i) (list[i].flags & HAS_BEFORE_AL) > 0 && list[i].before(this, values[list[i].uid]);
      inAsyncTick = !1;
      var returned = original.apply(this, arguments);
      for (inAsyncTick = !0, i = 0; i < length; ++i) (list[i].flags & HAS_AFTER_AL) > 0 && list[i].after(this, values[list[i].uid]);
      return inAsyncTick = !1, listeners = listenerStack.pop(), errorValues = void 0, 
      returned;
     };
    }, wrap(process, "_fatalException", (function(_fatalException) {
     return function(er) {
      return asyncCatcher(er) || _fatalException(er);
     };
    }));
   } else {
    var errorThrew = !1;
    asyncCatcher = function(er) {
     if (errorThrew) throw er;
     for (var handled = !1, length = listeners.length, i = 0; i < length; ++i) {
      var listener = listeners[i];
      0 != (listener.flags & HAS_ERROR_AL) && (handled = listener.error(null, er) || handled);
     }
     if (!handled && inAsyncTick) throw er;
    }, asyncWrap = function(original, list, length) {
     var values = [];
     inAsyncTick = !0;
     for (var i = 0; i < length; ++i) {
      var listener = list[i];
      if (values[listener.uid] = listener.data, 0 != (listener.flags & HAS_CREATE_AL)) {
       var value = listener.create(listener.data);
       void 0 !== value && (values[listener.uid] = value);
      }
     }
     return inAsyncTick = !1, function() {
      var returned, threw = !1, handled = !1;
      listenerStack.push(listeners), listeners = union(list, listeners), inAsyncTick = !0;
      for (var i = 0; i < length; ++i) (list[i].flags & HAS_BEFORE_AL) > 0 && list[i].before(this, values[list[i].uid]);
      inAsyncTick = !1;
      try {
       returned = original.apply(this, arguments);
      } catch (er) {
       threw = !0;
       for (i = 0; i < length; ++i) if (0 != (listeners[i].flags & HAS_ERROR_AL)) try {
        handled = listeners[i].error(values[list[i].uid], er) || handled;
       } catch (x) {
        throw errorThrew = !0, x;
       }
       if (!handled) throw process.removeListener("uncaughtException", asyncCatcher), process._originalNextTick((function() {
        process.addListener("uncaughtException", asyncCatcher);
       })), er;
      } finally {
       if (!threw || handled) {
        for (inAsyncTick = !0, i = 0; i < length; ++i) (list[i].flags & HAS_AFTER_AL) > 0 && list[i].after(this, values[list[i].uid]);
        inAsyncTick = !1;
       }
       listeners = listenerStack.pop();
      }
      return returned;
     };
    }, process.addListener("uncaughtException", asyncCatcher);
   }
   function AsyncListener(callbacks, data) {
    "function" == typeof callbacks.create && (this.create = callbacks.create, this.flags |= HAS_CREATE_AL), 
    "function" == typeof callbacks.before && (this.before = callbacks.before, this.flags |= HAS_BEFORE_AL), 
    "function" == typeof callbacks.after && (this.after = callbacks.after, this.flags |= HAS_AFTER_AL), 
    "function" == typeof callbacks.error && (this.error = callbacks.error, this.flags |= HAS_ERROR_AL), 
    this.uid = ++uid, this.data = void 0 === data ? null : data;
   }
   function createAsyncListener(callbacks, data) {
    if ("object" != typeof callbacks || !callbacks) throw new TypeError("callbacks argument must be an object");
    return callbacks instanceof AsyncListener ? callbacks : new AsyncListener(callbacks, data);
   }
   AsyncListener.prototype.create = void 0, AsyncListener.prototype.before = void 0, 
   AsyncListener.prototype.after = void 0, AsyncListener.prototype.error = void 0, 
   AsyncListener.prototype.data = void 0, AsyncListener.prototype.uid = 0, AsyncListener.prototype.flags = 0, 
   process.createAsyncListener = createAsyncListener, process.addAsyncListener = function(callbacks, data) {
    var listener;
    listener = callbacks instanceof AsyncListener ? callbacks : createAsyncListener(callbacks, data);
    for (var registered = !1, i = 0; i < listeners.length; i++) if (listener === listeners[i]) {
     registered = !0;
     break;
    }
    return registered || listeners.push(listener), listener;
   }, process.removeAsyncListener = function(listener) {
    for (var i = 0; i < listeners.length; i++) if (listener === listeners[i]) {
     listeners.splice(i, 1);
     break;
    }
   }, module.exports = function(original) {
    var length = listeners.length;
    if (0 === length) return original;
    for (var list = listeners.slice(), i = 0; i < length; ++i) if (list[i].flags > 0) return asyncWrap(original, list, length);
    return function(original, list, length) {
     inAsyncTick = !0;
     for (var i = 0; i < length; ++i) {
      var listener = list[i];
      listener.create && listener.create(listener.data);
     }
     return inAsyncTick = !1, function() {
      listenerStack.push(listeners), listeners = union(list, listeners);
      var returned = original.apply(this, arguments);
      return listeners = listenerStack.pop(), returned;
     };
    }(original, list, length);
   };
  },
  67645: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   if (process.addAsyncListener) throw new Error("Don't require polyfill unless needed");
   var shimmer = __webpack_require__(76372), semver = __webpack_require__(42249), wrap = shimmer.wrap, massWrap = shimmer.massWrap, wrapCallback = __webpack_require__(89090), util = __webpack_require__(73837), v6plus = semver.gte(process.version, "6.0.0"), v7plus = semver.gte(process.version, "7.0.0"), v8plus = semver.gte(process.version, "8.0.0"), v11plus = semver.gte(process.version, "11.0.0"), net = __webpack_require__(41808);
   function wrapSetUpListenHandle(original) {
    return function() {
     this.on("connection", (function(socket) {
      socket._handle && (socket._handle.onread = wrapCallback(socket._handle.onread));
     }));
     try {
      return original.apply(this, arguments);
     } finally {
      this._handle && this._handle.onconnection && (this._handle.onconnection = wrapCallback(this._handle.onconnection));
     }
    };
   }
   function patchOnRead(ctx) {
    if (ctx && ctx._handle) {
     var handle = ctx._handle;
     handle._originalOnread || (handle._originalOnread = handle.onread), handle.onread = wrapCallback(handle._originalOnread);
    }
   }
   v7plus && !net._normalizeArgs ? net._normalizeArgs = function(args) {
    if (0 === args.length) return [ {}, null ];
    var s, x, arg0 = args[0], options = {};
    "object" == typeof arg0 && null !== arg0 ? options = arg0 : "string" == typeof (s = arg0) && !1 === (x = s, 
    (x = Number(x)) >= 0 && x) ? options.path = arg0 : (options.port = arg0, args.length > 1 && "string" == typeof args[1] && (options.host = args[1]));
    var cb = args[args.length - 1];
    return "function" != typeof cb ? [ options, null ] : [ options, cb ];
   } : v7plus || net._normalizeConnectArgs || (net._normalizeConnectArgs = function(args) {
    var x, options = {};
    "object" == typeof args[0] && null !== args[0] ? options = args[0] : "string" == typeof args[0] && !1 === (x = args[0], 
    (x = Number(x)) >= 0 && x) ? options.path = args[0] : (options.port = args[0], "string" == typeof args[1] && (options.host = args[1]));
    var cb = args[args.length - 1];
    return "function" == typeof cb ? [ options, cb ] : [ options ];
   }), "_setUpListenHandle" in net.Server.prototype ? wrap(net.Server.prototype, "_setUpListenHandle", wrapSetUpListenHandle) : wrap(net.Server.prototype, "_listen2", wrapSetUpListenHandle), 
   wrap(net.Socket.prototype, "connect", (function(original) {
    return function() {
     var args;
     (args = v8plus && Array.isArray(arguments[0]) && Object.getOwnPropertySymbols(arguments[0]).length > 0 ? arguments[0] : v7plus ? net._normalizeArgs(arguments) : net._normalizeConnectArgs(arguments))[1] && (args[1] = wrapCallback(args[1]));
     var result = original.apply(this, args);
     return patchOnRead(this), result;
    };
   }));
   var http = __webpack_require__(13685);
   wrap(http.Agent.prototype, "addRequest", (function(original) {
    return function(req) {
     var onSocket = req.onSocket;
     return req.onSocket = wrapCallback((function(socket) {
      return patchOnRead(socket), onSocket.apply(this, arguments);
     })), original.apply(this, arguments);
    };
   }));
   var childProcess = __webpack_require__(32081);
   function wrapChildProcess(child) {
    Array.isArray(child.stdio) && child.stdio.forEach((function(socket) {
     socket && socket._handle && (socket._handle.onread = wrapCallback(socket._handle.onread), 
     wrap(socket._handle, "close", activatorFirst));
    })), child._handle && (child._handle.onexit = wrapCallback(child._handle.onexit));
   }
   childProcess.ChildProcess ? wrap(childProcess.ChildProcess.prototype, "spawn", (function(original) {
    return function() {
     var result = original.apply(this, arguments);
     return wrapChildProcess(this), result;
    };
   })) : massWrap(childProcess, [ "execFile", "fork", "spawn" ], (function(original) {
    return function() {
     var result = original.apply(this, arguments);
     return wrapChildProcess(result), result;
    };
   })), process._fatalException || (process._originalNextTick = process.nextTick);
   var processors = [];
   process._nextDomainTick && processors.push("_nextDomainTick"), process._tickDomainCallback && processors.push("_tickDomainCallback"), 
   massWrap(process, processors, activator), wrap(process, "nextTick", activatorFirst);
   var asynchronizers = [ "setTimeout", "setInterval" ];
   global.setImmediate && asynchronizers.push("setImmediate");
   var timers = __webpack_require__(39512), patchGlobalTimers = global.setTimeout === timers.setTimeout;
   massWrap(timers, asynchronizers, activatorFirst), patchGlobalTimers && massWrap(global, asynchronizers, activatorFirst);
   var dns = __webpack_require__(9523);
   massWrap(dns, [ "lookup", "resolve", "resolve4", "resolve6", "resolveCname", "resolveMx", "resolveNs", "resolveTxt", "resolveSrv", "reverse" ], activator), 
   dns.resolveNaptr && wrap(dns, "resolveNaptr", activator);
   var zlib, crypto, fs = __webpack_require__(57147);
   massWrap(fs, [ "watch", "rename", "truncate", "chown", "fchown", "chmod", "fchmod", "stat", "lstat", "fstat", "link", "symlink", "readlink", "realpath", "unlink", "rmdir", "mkdir", "readdir", "close", "open", "utimes", "futimes", "fsync", "write", "read", "readFile", "writeFile", "appendFile", "watchFile", "unwatchFile", "exists" ], activator), 
   fs.lchown && wrap(fs, "lchown", activator), fs.lchmod && wrap(fs, "lchmod", activator), 
   fs.ftruncate && wrap(fs, "ftruncate", activator);
   try {
    zlib = __webpack_require__(59796);
   } catch (err) {}
   if (zlib && zlib.Deflate && zlib.Deflate.prototype) {
    var proto = Object.getPrototypeOf(zlib.Deflate.prototype);
    proto._transform ? wrap(proto, "_transform", activator) : proto.write && proto.flush && proto.end && massWrap(proto, [ "write", "flush", "end" ], activator);
   }
   try {
    crypto = __webpack_require__(6113);
   } catch (err) {}
   if (crypto) {
    var toWrap = [ "pbkdf2", "randomBytes" ];
    v11plus || toWrap.push("pseudoRandomBytes"), massWrap(crypto, toWrap, activator);
   }
   var instrumentPromise = !!global.Promise && "function Promise() { [native code] }" === Promise.toString() && "function toString() { [native code] }" === Promise.toString.toString();
   if (instrumentPromise) {
    var promiseListener = process.addAsyncListener({
     create: function() {
      instrumentPromise = !1;
     }
    });
    global.Promise.resolve(!0).then((function() {
     instrumentPromise = !1;
    })), process.removeAsyncListener(promiseListener);
   }
   function activator(fn) {
    var fallback = function() {
     var args, cbIdx = arguments.length - 1;
     if ("function" == typeof arguments[cbIdx]) {
      args = Array(arguments.length);
      for (var i = 0; i < arguments.length - 1; i++) args[i] = arguments[i];
      args[cbIdx] = wrapCallback(arguments[cbIdx]);
     }
     return fn.apply(this, args || arguments);
    };
    switch (fn.length) {
    case 1:
     return function(cb) {
      return 1 !== arguments.length ? fallback.apply(this, arguments) : ("function" == typeof cb && (cb = wrapCallback(cb)), 
      fn.call(this, cb));
     };

    case 2:
     return function(a, cb) {
      return 2 !== arguments.length ? fallback.apply(this, arguments) : ("function" == typeof cb && (cb = wrapCallback(cb)), 
      fn.call(this, a, cb));
     };

    case 3:
     return function(a, b, cb) {
      return 3 !== arguments.length ? fallback.apply(this, arguments) : ("function" == typeof cb && (cb = wrapCallback(cb)), 
      fn.call(this, a, b, cb));
     };

    case 4:
     return function(a, b, c, cb) {
      return 4 !== arguments.length ? fallback.apply(this, arguments) : ("function" == typeof cb && (cb = wrapCallback(cb)), 
      fn.call(this, a, b, c, cb));
     };

    case 5:
     return function(a, b, c, d, cb) {
      return 5 !== arguments.length ? fallback.apply(this, arguments) : ("function" == typeof cb && (cb = wrapCallback(cb)), 
      fn.call(this, a, b, c, d, cb));
     };

    case 6:
     return function(a, b, c, d, e, cb) {
      return 6 !== arguments.length ? fallback.apply(this, arguments) : ("function" == typeof cb && (cb = wrapCallback(cb)), 
      fn.call(this, a, b, c, d, e, cb));
     };

    default:
     return fallback;
    }
   }
   function activatorFirst(fn) {
    var fallback = function() {
     var args;
     if ("function" == typeof arguments[0]) {
      (args = Array(arguments.length))[0] = wrapCallback(arguments[0]);
      for (var i = 1; i < arguments.length; i++) args[i] = arguments[i];
     }
     return fn.apply(this, args || arguments);
    };
    switch (fn.length) {
    case 1:
     return function(cb) {
      return 1 !== arguments.length ? fallback.apply(this, arguments) : ("function" == typeof cb && (cb = wrapCallback(cb)), 
      fn.call(this, cb));
     };

    case 2:
     return function(cb, a) {
      return 2 !== arguments.length ? fallback.apply(this, arguments) : ("function" == typeof cb && (cb = wrapCallback(cb)), 
      fn.call(this, cb, a));
     };

    case 3:
     return function(cb, a, b) {
      return 3 !== arguments.length ? fallback.apply(this, arguments) : ("function" == typeof cb && (cb = wrapCallback(cb)), 
      fn.call(this, cb, a, b));
     };

    case 4:
     return function(cb, a, b, c) {
      return 4 !== arguments.length ? fallback.apply(this, arguments) : ("function" == typeof cb && (cb = wrapCallback(cb)), 
      fn.call(this, cb, a, b, c));
     };

    case 5:
     return function(cb, a, b, c, d) {
      return 5 !== arguments.length ? fallback.apply(this, arguments) : ("function" == typeof cb && (cb = wrapCallback(cb)), 
      fn.call(this, cb, a, b, c, d));
     };

    case 6:
     return function(cb, a, b, c, d, e) {
      return 6 !== arguments.length ? fallback.apply(this, arguments) : ("function" == typeof cb && (cb = wrapCallback(cb)), 
      fn.call(this, cb, a, b, c, d, e));
     };

    default:
     return fallback;
    }
   }
   instrumentPromise && function() {
    var Promise = global.Promise;
    function wrappedPromise(executor) {
     if (!(this instanceof wrappedPromise)) return Promise(executor);
     if ("function" != typeof executor) return new Promise(executor);
     var context, args, promise = new Promise(wrappedExecutor);
     promise.__proto__ = wrappedPromise.prototype;
     try {
      executor.apply(context, args);
     } catch (err) {
      args[1](err);
     }
     return promise;
     function wrappedExecutor(resolve, reject) {
      function wrappedResolve(val) {
       return ensureAslWrapper(promise, !1), resolve(val);
      }
      function wrappedReject(val) {
       return ensureAslWrapper(promise, !1), reject(val);
      }
      context = this, args = [ wrappedResolve, wrappedReject ];
     }
    }
    util.inherits(wrappedPromise, Promise), wrap(Promise.prototype, "then", wrapThen), 
    Promise.prototype.chain && wrap(Promise.prototype, "chain", wrapThen);
    if (v6plus) global.Promise = __webpack_require__(68286)(Promise, ensureAslWrapper); else {
     [ "all", "race", "reject", "resolve", "accept", "defer" ].forEach((function(key) {
      "function" == typeof Promise[key] && (wrappedPromise[key] = Promise[key]);
     })), global.Promise = wrappedPromise;
    }
    function ensureAslWrapper(promise, overwrite) {
     promise.__asl_wrapper && !overwrite || (promise.__asl_wrapper = wrapCallback(propagateAslWrapper));
    }
    function propagateAslWrapper(ctx, fn, result, next) {
     var nextResult;
     try {
      return {
       returnVal: nextResult = fn.call(ctx, result),
       error: !1
      };
     } catch (err) {
      return {
       errorVal: err,
       error: !0
      };
     } finally {
      nextResult instanceof Promise ? next.__asl_wrapper = function() {
       return (nextResult.__asl_wrapper || propagateAslWrapper).apply(this, arguments);
      } : ensureAslWrapper(next, !0);
     }
    }
    function wrapThen(original) {
     return function() {
      var promise = this, next = original.apply(promise, Array.prototype.map.call(arguments, bind));
      return next.__asl_wrapper = function(ctx, fn, val, last) {
       return promise.__asl_wrapper ? (promise.__asl_wrapper(ctx, (function() {}), null, next), 
       next.__asl_wrapper(ctx, fn, val, last)) : propagateAslWrapper(ctx, fn, val, last);
      }, next;
      function bind(fn) {
       return "function" != typeof fn ? fn : wrapCallback((function(val) {
        var result = (promise.__asl_wrapper || propagateAslWrapper)(this, fn, val, next);
        if (result.error) throw result.errorVal;
        return result.returnVal;
       }));
      }
     };
    }
   }();
  },
  42249: (module, exports) => {
   var debug;
   exports = module.exports = SemVer, debug = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function() {
    var args = Array.prototype.slice.call(arguments, 0);
    args.unshift("SEMVER"), console.log.apply(console, args);
   } : function() {}, exports.SEMVER_SPEC_VERSION = "2.0.0";
   var MAX_LENGTH = 256, MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6, re = exports.re = [], safeRe = exports.safeRe = [], src = exports.src = [], R = 0, safeRegexReplacements = [ [ "\\s", 1 ], [ "\\d", MAX_LENGTH ], [ "[a-zA-Z0-9-]", MAX_SAFE_BUILD_LENGTH ] ];
   function makeSafeRe(value) {
    for (var i = 0; i < safeRegexReplacements.length; i++) {
     var token = safeRegexReplacements[i][0], max = safeRegexReplacements[i][1];
     value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
    }
    return value;
   }
   var NUMERICIDENTIFIER = R++;
   src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
   var NUMERICIDENTIFIERLOOSE = R++;
   src[NUMERICIDENTIFIERLOOSE] = "\\d+";
   var NONNUMERICIDENTIFIER = R++;
   src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
   var MAINVERSION = R++;
   src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
   var MAINVERSIONLOOSE = R++;
   src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
   var PRERELEASEIDENTIFIER = R++;
   src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
   var PRERELEASEIDENTIFIERLOOSE = R++;
   src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
   var PRERELEASE = R++;
   src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
   var PRERELEASELOOSE = R++;
   src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
   var BUILDIDENTIFIER = R++;
   src[BUILDIDENTIFIER] = "[a-zA-Z0-9-]+";
   var BUILD = R++;
   src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
   var FULL = R++, FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
   src[FULL] = "^" + FULLPLAIN + "$";
   var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?", LOOSE = R++;
   src[LOOSE] = "^" + LOOSEPLAIN + "$";
   var GTLT = R++;
   src[GTLT] = "((?:<|>)?=?)";
   var XRANGEIDENTIFIERLOOSE = R++;
   src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
   var XRANGEIDENTIFIER = R++;
   src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
   var XRANGEPLAIN = R++;
   src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
   var XRANGEPLAINLOOSE = R++;
   src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
   var XRANGE = R++;
   src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
   var XRANGELOOSE = R++;
   src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
   var COERCE = R++;
   src[COERCE] = "(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])";
   var LONETILDE = R++;
   src[LONETILDE] = "(?:~>?)";
   var TILDETRIM = R++;
   src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+", re[TILDETRIM] = new RegExp(src[TILDETRIM], "g"), 
   safeRe[TILDETRIM] = new RegExp(makeSafeRe(src[TILDETRIM]), "g");
   var TILDE = R++;
   src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
   var TILDELOOSE = R++;
   src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
   var LONECARET = R++;
   src[LONECARET] = "(?:\\^)";
   var CARETTRIM = R++;
   src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+", re[CARETTRIM] = new RegExp(src[CARETTRIM], "g"), 
   safeRe[CARETTRIM] = new RegExp(makeSafeRe(src[CARETTRIM]), "g");
   var CARET = R++;
   src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
   var CARETLOOSE = R++;
   src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
   var COMPARATORLOOSE = R++;
   src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
   var COMPARATOR = R++;
   src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
   var COMPARATORTRIM = R++;
   src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")", 
   re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g"), safeRe[COMPARATORTRIM] = new RegExp(makeSafeRe(src[COMPARATORTRIM]), "g");
   var HYPHENRANGE = R++;
   src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
   var HYPHENRANGELOOSE = R++;
   src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
   var STAR = R++;
   src[STAR] = "(<|>)?=?\\s*\\*";
   for (var i = 0; i < 35; i++) debug(i, src[i]), re[i] || (re[i] = new RegExp(src[i]), 
   safeRe[i] = new RegExp(makeSafeRe(src[i])));
   function parse(version, options) {
    if (options && "object" == typeof options || (options = {
     loose: !!options,
     includePrerelease: !1
    }), version instanceof SemVer) return version;
    if ("string" != typeof version) return null;
    if (version.length > MAX_LENGTH) return null;
    if (!(options.loose ? safeRe[LOOSE] : safeRe[FULL]).test(version)) return null;
    try {
     return new SemVer(version, options);
    } catch (er) {
     return null;
    }
   }
   function SemVer(version, options) {
    if (options && "object" == typeof options || (options = {
     loose: !!options,
     includePrerelease: !1
    }), version instanceof SemVer) {
     if (version.loose === options.loose) return version;
     version = version.version;
    } else if ("string" != typeof version) throw new TypeError("Invalid Version: " + version);
    if (version.length > MAX_LENGTH) throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    if (!(this instanceof SemVer)) return new SemVer(version, options);
    debug("SemVer", version, options), this.options = options, this.loose = !!options.loose;
    var m = version.trim().match(options.loose ? safeRe[LOOSE] : safeRe[FULL]);
    if (!m) throw new TypeError("Invalid Version: " + version);
    if (this.raw = version, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], 
    this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
    m[4] ? this.prerelease = m[4].split(".").map((function(id) {
     if (/^[0-9]+$/.test(id)) {
      var num = +id;
      if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
     }
     return id;
    })) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
   }
   exports.parse = parse, exports.valid = function(version, options) {
    var v = parse(version, options);
    return v ? v.version : null;
   }, exports.clean = function(version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
   }, exports.SemVer = SemVer, SemVer.prototype.format = function() {
    return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), 
    this.version;
   }, SemVer.prototype.toString = function() {
    return this.version;
   }, SemVer.prototype.compare = function(other) {
    return debug("SemVer.compare", this.version, this.options, other), other instanceof SemVer || (other = new SemVer(other, this.options)), 
    this.compareMain(other) || this.comparePre(other);
   }, SemVer.prototype.compareMain = function(other) {
    return other instanceof SemVer || (other = new SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
   }, SemVer.prototype.comparePre = function(other) {
    if (other instanceof SemVer || (other = new SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length) return -1;
    if (!this.prerelease.length && other.prerelease.length) return 1;
    if (!this.prerelease.length && !other.prerelease.length) return 0;
    var i = 0;
    do {
     var a = this.prerelease[i], b = other.prerelease[i];
     if (debug("prerelease compare", i, a, b), void 0 === a && void 0 === b) return 0;
     if (void 0 === b) return 1;
     if (void 0 === a) return -1;
     if (a !== b) return compareIdentifiers(a, b);
    } while (++i);
   }, SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
    case "premajor":
     this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier);
     break;

    case "preminor":
     this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier);
     break;

    case "prepatch":
     this.prerelease.length = 0, this.inc("patch", identifier), this.inc("pre", identifier);
     break;

    case "prerelease":
     0 === this.prerelease.length && this.inc("patch", identifier), this.inc("pre", identifier);
     break;

    case "major":
     0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, 
     this.minor = 0, this.patch = 0, this.prerelease = [];
     break;

    case "minor":
     0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, 
     this.prerelease = [];
     break;

    case "patch":
     0 === this.prerelease.length && this.patch++, this.prerelease = [];
     break;

    case "pre":
     if (0 === this.prerelease.length) this.prerelease = [ 0 ]; else {
      for (var i = this.prerelease.length; --i >= 0; ) "number" == typeof this.prerelease[i] && (this.prerelease[i]++, 
      i = -2);
      -1 === i && this.prerelease.push(0);
     }
     identifier && (this.prerelease[0] === identifier ? isNaN(this.prerelease[1]) && (this.prerelease = [ identifier, 0 ]) : this.prerelease = [ identifier, 0 ]);
     break;

    default:
     throw new Error("invalid increment argument: " + release);
    }
    return this.format(), this.raw = this.version, this;
   }, exports.inc = function(version, release, loose, identifier) {
    "string" == typeof loose && (identifier = loose, loose = void 0);
    try {
     return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
     return null;
    }
   }, exports.diff = function(version1, version2) {
    if (eq(version1, version2)) return null;
    var v1 = parse(version1), v2 = parse(version2), prefix = "";
    if (v1.prerelease.length || v2.prerelease.length) {
     prefix = "pre";
     var defaultResult = "prerelease";
    }
    for (var key in v1) if (("major" === key || "minor" === key || "patch" === key) && v1[key] !== v2[key]) return prefix + key;
    return defaultResult;
   }, exports.compareIdentifiers = compareIdentifiers;
   var numeric = /^[0-9]+$/;
   function compareIdentifiers(a, b) {
    var anum = numeric.test(a), bnum = numeric.test(b);
    return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
   }
   function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
   }
   function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
   }
   function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
   }
   function eq(a, b, loose) {
    return 0 === compare(a, b, loose);
   }
   function neq(a, b, loose) {
    return 0 !== compare(a, b, loose);
   }
   function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
   }
   function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
   }
   function cmp(a, op, b, loose) {
    switch (op) {
    case "===":
     return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), 
     a === b;

    case "!==":
     return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), 
     a !== b;

    case "":
    case "=":
    case "==":
     return eq(a, b, loose);

    case "!=":
     return neq(a, b, loose);

    case ">":
     return gt(a, b, loose);

    case ">=":
     return gte(a, b, loose);

    case "<":
     return lt(a, b, loose);

    case "<=":
     return lte(a, b, loose);

    default:
     throw new TypeError("Invalid operator: " + op);
    }
   }
   function Comparator(comp, options) {
    if (options && "object" == typeof options || (options = {
     loose: !!options,
     includePrerelease: !1
    }), comp instanceof Comparator) {
     if (comp.loose === !!options.loose) return comp;
     comp = comp.value;
    }
    if (!(this instanceof Comparator)) return new Comparator(comp, options);
    comp = comp.trim().split(/\s+/).join(" "), debug("comparator", comp, options), this.options = options, 
    this.loose = !!options.loose, this.parse(comp), this.semver === ANY ? this.value = "" : this.value = this.operator + this.semver.version, 
    debug("comp", this);
   }
   exports.rcompareIdentifiers = function(a, b) {
    return compareIdentifiers(b, a);
   }, exports.major = function(a, loose) {
    return new SemVer(a, loose).major;
   }, exports.minor = function(a, loose) {
    return new SemVer(a, loose).minor;
   }, exports.patch = function(a, loose) {
    return new SemVer(a, loose).patch;
   }, exports.compare = compare, exports.compareLoose = function(a, b) {
    return compare(a, b, !0);
   }, exports.rcompare = function(a, b, loose) {
    return compare(b, a, loose);
   }, exports.sort = function(list, loose) {
    return list.sort((function(a, b) {
     return exports.compare(a, b, loose);
    }));
   }, exports.rsort = function(list, loose) {
    return list.sort((function(a, b) {
     return exports.rcompare(a, b, loose);
    }));
   }, exports.gt = gt, exports.lt = lt, exports.eq = eq, exports.neq = neq, exports.gte = gte, 
   exports.lte = lte, exports.cmp = cmp, exports.Comparator = Comparator;
   var ANY = {};
   function Range(range, options) {
    if (options && "object" == typeof options || (options = {
     loose: !!options,
     includePrerelease: !1
    }), range instanceof Range) return range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease ? range : new Range(range.raw, options);
    if (range instanceof Comparator) return new Range(range.value, options);
    if (!(this instanceof Range)) return new Range(range, options);
    if (this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease, 
    this.raw = range.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((function(range) {
     return this.parseRange(range.trim());
    }), this).filter((function(c) {
     return c.length;
    })), !this.set.length) throw new TypeError("Invalid SemVer Range: " + this.raw);
    this.format();
   }
   function isX(id) {
    return !id || "x" === id.toLowerCase() || "*" === id;
   }
   function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    return ((from = isX(fM) ? "" : isX(fm) ? ">=" + fM + ".0.0" : isX(fp) ? ">=" + fM + "." + fm + ".0" : ">=" + from) + " " + (to = isX(tM) ? "" : isX(tm) ? "<" + (+tM + 1) + ".0.0" : isX(tp) ? "<" + tM + "." + (+tm + 1) + ".0" : tpr ? "<=" + tM + "." + tm + "." + tp + "-" + tpr : "<=" + to)).trim();
   }
   function testSet(set, version, options) {
    for (var i = 0; i < set.length; i++) if (!set[i].test(version)) return !1;
    if (version.prerelease.length && !options.includePrerelease) {
     for (i = 0; i < set.length; i++) if (debug(set[i].semver), set[i].semver !== ANY && set[i].semver.prerelease.length > 0) {
      var allowed = set[i].semver;
      if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return !0;
     }
     return !1;
    }
    return !0;
   }
   function satisfies(version, range, options) {
    try {
     range = new Range(range, options);
    } catch (er) {
     return !1;
    }
    return range.test(version);
   }
   function outside(version, range, hilo, options) {
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (version = new SemVer(version, options), range = new Range(range, options), 
    hilo) {
    case ">":
     gtfn = gt, ltefn = lte, ltfn = lt, comp = ">", ecomp = ">=";
     break;

    case "<":
     gtfn = lt, ltefn = gte, ltfn = gt, comp = "<", ecomp = "<=";
     break;

    default:
     throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) return !1;
    for (var i = 0; i < range.set.length; ++i) {
     var comparators = range.set[i], high = null, low = null;
     if (comparators.forEach((function(comparator) {
      comparator.semver === ANY && (comparator = new Comparator(">=0.0.0")), high = high || comparator, 
      low = low || comparator, gtfn(comparator.semver, high.semver, options) ? high = comparator : ltfn(comparator.semver, low.semver, options) && (low = comparator);
     })), high.operator === comp || high.operator === ecomp) return !1;
     if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) return !1;
     if (low.operator === ecomp && ltfn(version, low.semver)) return !1;
    }
    return !0;
   }
   Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR], m = comp.match(r);
    if (!m) throw new TypeError("Invalid comparator: " + comp);
    this.operator = m[1], "=" === this.operator && (this.operator = ""), m[2] ? this.semver = new SemVer(m[2], this.options.loose) : this.semver = ANY;
   }, Comparator.prototype.toString = function() {
    return this.value;
   }, Comparator.prototype.test = function(version) {
    return debug("Comparator.test", version, this.options.loose), this.semver === ANY || ("string" == typeof version && (version = new SemVer(version, this.options)), 
    cmp(version, this.operator, this.semver, this.options));
   }, Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) throw new TypeError("a Comparator is required");
    var rangeTmp;
    if (options && "object" == typeof options || (options = {
     loose: !!options,
     includePrerelease: !1
    }), "" === this.operator) return rangeTmp = new Range(comp.value, options), satisfies(this.value, rangeTmp, options);
    if ("" === comp.operator) return rangeTmp = new Range(this.value, options), satisfies(comp.semver, rangeTmp, options);
    var sameDirectionIncreasing = !(">=" !== this.operator && ">" !== this.operator || ">=" !== comp.operator && ">" !== comp.operator), sameDirectionDecreasing = !("<=" !== this.operator && "<" !== this.operator || "<=" !== comp.operator && "<" !== comp.operator), sameSemVer = this.semver.version === comp.semver.version, differentDirectionsInclusive = !(">=" !== this.operator && "<=" !== this.operator || ">=" !== comp.operator && "<=" !== comp.operator), oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (">=" === this.operator || ">" === this.operator) && ("<=" === comp.operator || "<" === comp.operator), oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ("<=" === this.operator || "<" === this.operator) && (">=" === comp.operator || ">" === comp.operator);
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
   }, exports.Range = Range, Range.prototype.format = function() {
    return this.range = this.set.map((function(comps) {
     return comps.join(" ").trim();
    })).join("||").trim(), this.range;
   }, Range.prototype.toString = function() {
    return this.range;
   }, Range.prototype.parseRange = function(range) {
    var loose = this.options.loose, hr = loose ? safeRe[HYPHENRANGELOOSE] : safeRe[HYPHENRANGE];
    range = range.replace(hr, hyphenReplace), debug("hyphen replace", range), range = range.replace(safeRe[COMPARATORTRIM], "$1$2$3"), 
    debug("comparator trim", range, safeRe[COMPARATORTRIM]), range = (range = range.replace(safeRe[TILDETRIM], "$1~")).replace(safeRe[CARETTRIM], "$1^");
    var compRe = loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR], set = range.split(" ").map((function(comp) {
     return function(comp, options) {
      return debug("comp", comp, options), comp = function(comp, options) {
       return comp.trim().split(/\s+/).map((function(comp) {
        return function(comp, options) {
         debug("caret", comp, options);
         var r = options.loose ? safeRe[CARETLOOSE] : safeRe[CARET];
         return comp.replace(r, (function(_, M, m, p, pr) {
          var ret;
          return debug("caret", comp, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? ret = "0" === M ? ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0" : pr ? (debug("replaceCaret pr", pr), 
          ret = "0" === M ? "0" === m ? ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1) : ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0" : ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0") : (debug("no pr"), 
          ret = "0" === M ? "0" === m ? ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1) : ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0" : ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0"), 
          debug("caret return", ret), ret;
         }));
        }(comp, options);
       })).join(" ");
      }(comp, options), debug("caret", comp), comp = function(comp, options) {
       return comp.trim().split(/\s+/).map((function(comp) {
        return function(comp, options) {
         var r = options.loose ? safeRe[TILDELOOSE] : safeRe[TILDE];
         return comp.replace(r, (function(_, M, m, p, pr) {
          var ret;
          return debug("tilde", comp, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : pr ? (debug("replaceTilde pr", pr), 
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0") : ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0", 
          debug("tilde return", ret), ret;
         }));
        }(comp, options);
       })).join(" ");
      }(comp, options), debug("tildes", comp), comp = function(comp, options) {
       return debug("replaceXRanges", comp, options), comp.split(/\s+/).map((function(comp) {
        return function(comp, options) {
         comp = comp.trim();
         var r = options.loose ? safeRe[XRANGELOOSE] : safeRe[XRANGE];
         return comp.replace(r, (function(ret, gtlt, M, m, p, pr) {
          debug("xRange", comp, ret, gtlt, M, m, p, pr);
          var xM = isX(M), xm = xM || isX(m), xp = xm || isX(p);
          return "=" === gtlt && xp && (gtlt = ""), xM ? ret = ">" === gtlt || "<" === gtlt ? "<0.0.0" : "*" : gtlt && xp ? (xm && (m = 0), 
          p = 0, ">" === gtlt ? (gtlt = ">=", xm ? (M = +M + 1, m = 0, p = 0) : (m = +m + 1, 
          p = 0)) : "<=" === gtlt && (gtlt = "<", xm ? M = +M + 1 : m = +m + 1), ret = gtlt + M + "." + m + "." + p) : xm ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : xp && (ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0"), 
          debug("xRange return", ret), ret;
         }));
        }(comp, options);
       })).join(" ");
      }(comp, options), debug("xrange", comp), comp = function(comp, options) {
       return debug("replaceStars", comp, options), comp.trim().replace(safeRe[STAR], "");
      }(comp, options), debug("stars", comp), comp;
     }(comp, this.options);
    }), this).join(" ").split(/\s+/);
    return this.options.loose && (set = set.filter((function(comp) {
     return !!comp.match(compRe);
    }))), set = set.map((function(comp) {
     return new Comparator(comp, this.options);
    }), this);
   }, Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) throw new TypeError("a Range is required");
    return this.set.some((function(thisComparators) {
     return thisComparators.every((function(thisComparator) {
      return range.set.some((function(rangeComparators) {
       return rangeComparators.every((function(rangeComparator) {
        return thisComparator.intersects(rangeComparator, options);
       }));
      }));
     }));
    }));
   }, exports.toComparators = function(range, options) {
    return new Range(range, options).set.map((function(comp) {
     return comp.map((function(c) {
      return c.value;
     })).join(" ").trim().split(" ");
    }));
   }, Range.prototype.test = function(version) {
    if (!version) return !1;
    "string" == typeof version && (version = new SemVer(version, this.options));
    for (var i = 0; i < this.set.length; i++) if (testSet(this.set[i], version, this.options)) return !0;
    return !1;
   }, exports.satisfies = satisfies, exports.maxSatisfying = function(versions, range, options) {
    var max = null, maxSV = null;
    try {
     var rangeObj = new Range(range, options);
    } catch (er) {
     return null;
    }
    return versions.forEach((function(v) {
     rangeObj.test(v) && (max && -1 !== maxSV.compare(v) || (maxSV = new SemVer(max = v, options)));
    })), max;
   }, exports.minSatisfying = function(versions, range, options) {
    var min = null, minSV = null;
    try {
     var rangeObj = new Range(range, options);
    } catch (er) {
     return null;
    }
    return versions.forEach((function(v) {
     rangeObj.test(v) && (min && 1 !== minSV.compare(v) || (minSV = new SemVer(min = v, options)));
    })), min;
   }, exports.minVersion = function(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) return minver;
    if (minver = new SemVer("0.0.0-0"), range.test(minver)) return minver;
    minver = null;
    for (var i = 0; i < range.set.length; ++i) {
     range.set[i].forEach((function(comparator) {
      var compver = new SemVer(comparator.semver.version);
      switch (comparator.operator) {
      case ">":
       0 === compver.prerelease.length ? compver.patch++ : compver.prerelease.push(0), 
       compver.raw = compver.format();

      case "":
      case ">=":
       minver && !gt(minver, compver) || (minver = compver);
       break;

      case "<":
      case "<=":
       break;

      default:
       throw new Error("Unexpected operation: " + comparator.operator);
      }
     }));
    }
    if (minver && range.test(minver)) return minver;
    return null;
   }, exports.validRange = function(range, options) {
    try {
     return new Range(range, options).range || "*";
    } catch (er) {
     return null;
    }
   }, exports.ltr = function(version, range, options) {
    return outside(version, range, "<", options);
   }, exports.gtr = function(version, range, options) {
    return outside(version, range, ">", options);
   }, exports.outside = outside, exports.prerelease = function(version, options) {
    var parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
   }, exports.intersects = function(r1, r2, options) {
    return r1 = new Range(r1, options), r2 = new Range(r2, options), r1.intersects(r2);
   }, exports.coerce = function(version) {
    if (version instanceof SemVer) return version;
    if ("string" != typeof version) return null;
    var match = version.match(safeRe[COERCE]);
    if (null == match) return null;
    return parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
   };
  },
  59118: (module, __unused_webpack_exports, __webpack_require__) => {
   module.exports = {
    parallel: __webpack_require__(19162),
    serial: __webpack_require__(31357),
    serialOrdered: __webpack_require__(69087)
   };
  },
  37651: module => {
   function clean(key) {
    "function" == typeof this.jobs[key] && this.jobs[key]();
   }
   module.exports = function(state) {
    Object.keys(state.jobs).forEach(clean.bind(state)), state.jobs = {};
   };
  },
  55912: (module, __unused_webpack_exports, __webpack_require__) => {
   var defer = __webpack_require__(9265);
   module.exports = function(callback) {
    var isAsync = !1;
    return defer((function() {
     isAsync = !0;
    })), function(err, result) {
     isAsync ? callback(err, result) : defer((function() {
      callback(err, result);
     }));
    };
   };
  },
  9265: module => {
   module.exports = function(fn) {
    var nextTick = "function" == typeof setImmediate ? setImmediate : "object" == typeof process && "function" == typeof process.nextTick ? process.nextTick : null;
    nextTick ? nextTick(fn) : setTimeout(fn, 0);
   };
  },
  97594: (module, __unused_webpack_exports, __webpack_require__) => {
   var async = __webpack_require__(55912), abort = __webpack_require__(37651);
   module.exports = function(list, iterator, state, callback) {
    var key = state.keyedList ? state.keyedList[state.index] : state.index;
    state.jobs[key] = function(iterator, key, item, callback) {
     var aborter;
     aborter = 2 == iterator.length ? iterator(item, async(callback)) : iterator(item, key, async(callback));
     return aborter;
    }(iterator, key, list[key], (function(error, output) {
     key in state.jobs && (delete state.jobs[key], error ? abort(state) : state.results[key] = output, 
     callback(error, state.results));
    }));
   };
  },
  94528: module => {
   module.exports = function(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
     index: 0,
     keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
     jobs: {},
     results: isNamedList ? {} : [],
     size: isNamedList ? Object.keys(list).length : list.length
    };
    sortMethod && initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
     return sortMethod(list[a], list[b]);
    });
    return initState;
   };
  },
  25353: (module, __unused_webpack_exports, __webpack_require__) => {
   var abort = __webpack_require__(37651), async = __webpack_require__(55912);
   module.exports = function(callback) {
    if (!Object.keys(this.jobs).length) return;
    this.index = this.size, abort(this), async(callback)(null, this.results);
   };
  },
  19162: (module, __unused_webpack_exports, __webpack_require__) => {
   var iterate = __webpack_require__(97594), initState = __webpack_require__(94528), terminator = __webpack_require__(25353);
   module.exports = function(list, iterator, callback) {
    var state = initState(list);
    for (;state.index < (state.keyedList || list).length; ) iterate(list, iterator, state, (function(error, result) {
     error ? callback(error, result) : 0 !== Object.keys(state.jobs).length || callback(null, state.results);
    })), state.index++;
    return terminator.bind(state, callback);
   };
  },
  31357: (module, __unused_webpack_exports, __webpack_require__) => {
   var serialOrdered = __webpack_require__(69087);
   module.exports = function(list, iterator, callback) {
    return serialOrdered(list, iterator, null, callback);
   };
  },
  69087: (module, __unused_webpack_exports, __webpack_require__) => {
   var iterate = __webpack_require__(97594), initState = __webpack_require__(94528), terminator = __webpack_require__(25353);
   function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
   }
   module.exports = function(list, iterator, sortMethod, callback) {
    var state = initState(list, sortMethod);
    return iterate(list, iterator, state, (function iteratorHandler(error, result) {
     error ? callback(error, result) : (state.index++, state.index < (state.keyedList || list).length ? iterate(list, iterator, state, iteratorHandler) : callback(null, state.results));
    })), terminator.bind(state, callback);
   }, module.exports.ascending = ascending, module.exports.descending = function(a, b) {
    return -1 * ascending(a, b);
   };
  },
  89846: module => {
   "use strict";
   module.exports = function(Promise) {
    var SomePromiseArray = Promise._SomePromiseArray;
    function any(promises) {
     var ret = new SomePromiseArray(promises), promise = ret.promise();
     return ret.setHowMany(1), ret.setUnwrap(), ret.init(), promise;
    }
    Promise.any = function(promises) {
     return any(promises);
    }, Promise.prototype.any = function() {
     return any(this);
    };
   };
  },
  4601: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var firstLineError;
   try {
    throw new Error;
   } catch (e) {
    firstLineError = e;
   }
   var schedule = __webpack_require__(10679), Queue = __webpack_require__(7824);
   function Async() {
    this._customScheduler = !1, this._isTickUsed = !1, this._lateQueue = new Queue(16), 
    this._normalQueue = new Queue(16), this._haveDrainedQueues = !1;
    var self = this;
    this.drainQueues = function() {
     self._drainQueues();
    }, this._schedule = schedule;
   }
   function _drainQueue(queue) {
    for (;queue.length() > 0; ) _drainQueueStep(queue);
   }
   function _drainQueueStep(queue) {
    var fn = queue.shift();
    if ("function" != typeof fn) fn._settlePromises(); else {
     var receiver = queue.shift(), arg = queue.shift();
     fn.call(receiver, arg);
    }
   }
   Async.prototype.setScheduler = function(fn) {
    var prev = this._schedule;
    return this._schedule = fn, this._customScheduler = !0, prev;
   }, Async.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
   }, Async.prototype.haveItemsQueued = function() {
    return this._isTickUsed || this._haveDrainedQueues;
   }, Async.prototype.fatalError = function(e, isNode) {
    isNode ? (process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n"), 
    process.exit(2)) : this.throwLater(e);
   }, Async.prototype.throwLater = function(fn, arg) {
    if (1 === arguments.length && (arg = fn, fn = function() {
     throw arg;
    }), "undefined" != typeof setTimeout) setTimeout((function() {
     fn(arg);
    }), 0); else try {
     this._schedule((function() {
      fn(arg);
     }));
    } catch (e) {
     throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
    }
   }, Async.prototype.invokeLater = function(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg), this._queueTick();
   }, Async.prototype.invoke = function(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg), this._queueTick();
   }, Async.prototype.settlePromises = function(promise) {
    this._normalQueue._pushOne(promise), this._queueTick();
   }, Async.prototype._drainQueues = function() {
    _drainQueue(this._normalQueue), this._reset(), this._haveDrainedQueues = !0, _drainQueue(this._lateQueue);
   }, Async.prototype._queueTick = function() {
    this._isTickUsed || (this._isTickUsed = !0, this._schedule(this.drainQueues));
   }, Async.prototype._reset = function() {
    this._isTickUsed = !1;
   }, module.exports = Async, module.exports.firstLineError = firstLineError;
  },
  23635: module => {
   "use strict";
   module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
    var calledBind = !1, rejectThis = function(_, e) {
     this._reject(e);
    }, targetRejected = function(e, context) {
     context.promiseRejectionQueued = !0, context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
    }, bindingResolved = function(thisArg, context) {
     0 == (50397184 & this._bitField) && this._resolveCallback(context.target);
    }, bindingRejected = function(e, context) {
     context.promiseRejectionQueued || this._reject(e);
    };
    Promise.prototype.bind = function(thisArg) {
     calledBind || (calledBind = !0, Promise.prototype._propagateFrom = debug.propagateFromFunction(), 
     Promise.prototype._boundValue = debug.boundValueFunction());
     var maybePromise = tryConvertToPromise(thisArg), ret = new Promise(INTERNAL);
     ret._propagateFrom(this, 1);
     var target = this._target();
     if (ret._setBoundTo(maybePromise), maybePromise instanceof Promise) {
      var context = {
       promiseRejectionQueued: !1,
       promise: ret,
       target,
       bindingPromise: maybePromise
      };
      target._then(INTERNAL, targetRejected, void 0, ret, context), maybePromise._then(bindingResolved, bindingRejected, void 0, ret, context), 
      ret._setOnCancel(maybePromise);
     } else ret._resolveCallback(target);
     return ret;
    }, Promise.prototype._setBoundTo = function(obj) {
     void 0 !== obj ? (this._bitField = 2097152 | this._bitField, this._boundTo = obj) : this._bitField = -2097153 & this._bitField;
    }, Promise.prototype._isBound = function() {
     return 2097152 == (2097152 & this._bitField);
    }, Promise.bind = function(thisArg, value) {
     return Promise.resolve(value).bind(thisArg);
    };
   };
  },
  93786: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var old;
   "undefined" != typeof Promise && (old = Promise);
   var bluebird = __webpack_require__(7502)();
   bluebird.noConflict = function() {
    try {
     Promise === bluebird && (Promise = old);
    } catch (e) {}
    return bluebird;
   }, module.exports = bluebird;
  },
  12293: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var cr = Object.create;
   if (cr) {
    var callerCache = cr(null), getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
   }
   module.exports = function(Promise) {
    var getMethodCaller, getGetter, util = __webpack_require__(75942), canEvaluate = util.canEvaluate, isIdentifier = util.isIdentifier, makeMethodCaller = function(methodName) {
     return new Function("ensureMethod", "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, methodName))(ensureMethod);
    }, makeGetter = function(propertyName) {
     return new Function("obj", "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace("propertyName", propertyName));
    }, getCompiled = function(name, compiler, cache) {
     var ret = cache[name];
     if ("function" != typeof ret) {
      if (!isIdentifier(name)) return null;
      if (ret = compiler(name), cache[name] = ret, cache[" size"]++, cache[" size"] > 512) {
       for (var keys = Object.keys(cache), i = 0; i < 256; ++i) delete cache[keys[i]];
       cache[" size"] = keys.length - 256;
      }
     }
     return ret;
    };
    function ensureMethod(obj, methodName) {
     var fn;
     if (null != obj && (fn = obj[methodName]), "function" != typeof fn) {
      var message = "Object " + util.classString(obj) + " has no method '" + util.toString(methodName) + "'";
      throw new Promise.TypeError(message);
     }
     return fn;
    }
    function caller(obj) {
     return ensureMethod(obj, this.pop()).apply(obj, this);
    }
    function namedGetter(obj) {
     return obj[this];
    }
    function indexedGetter(obj) {
     var index = +this;
     return index < 0 && (index = Math.max(0, index + obj.length)), obj[index];
    }
    getMethodCaller = function(name) {
     return getCompiled(name, makeMethodCaller, callerCache);
    }, getGetter = function(name) {
     return getCompiled(name, makeGetter, getterCache);
    }, Promise.prototype.call = function(methodName) {
     for (var $_len = arguments.length, args = new Array(Math.max($_len - 1, 0)), $_i = 1; $_i < $_len; ++$_i) args[$_i - 1] = arguments[$_i];
     if (canEvaluate) {
      var maybeCaller = getMethodCaller(methodName);
      if (null !== maybeCaller) return this._then(maybeCaller, void 0, void 0, args, void 0);
     }
     return args.push(methodName), this._then(caller, void 0, void 0, args, void 0);
    }, Promise.prototype.get = function(propertyName) {
     var getter;
     if ("number" == typeof propertyName) getter = indexedGetter; else if (canEvaluate) {
      var maybeGetter = getGetter(propertyName);
      getter = null !== maybeGetter ? maybeGetter : namedGetter;
     } else getter = namedGetter;
     return this._then(getter, void 0, void 0, propertyName, void 0);
    };
   };
  },
  11735: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, PromiseArray, apiRejection, debug) {
    var util = __webpack_require__(75942), tryCatch = util.tryCatch, errorObj = util.errorObj, async = Promise._async;
    Promise.prototype.break = Promise.prototype.cancel = function() {
     if (!debug.cancellation()) return this._warn("cancellation is disabled");
     for (var promise = this, child = promise; promise._isCancellable(); ) {
      if (!promise._cancelBy(child)) {
       child._isFollowing() ? child._followee().cancel() : child._cancelBranched();
       break;
      }
      var parent = promise._cancellationParent;
      if (null == parent || !parent._isCancellable()) {
       promise._isFollowing() ? promise._followee().cancel() : promise._cancelBranched();
       break;
      }
      promise._isFollowing() && promise._followee().cancel(), promise._setWillBeCancelled(), 
      child = promise, promise = parent;
     }
    }, Promise.prototype._branchHasCancelled = function() {
     this._branchesRemainingToCancel--;
    }, Promise.prototype._enoughBranchesHaveCancelled = function() {
     return void 0 === this._branchesRemainingToCancel || this._branchesRemainingToCancel <= 0;
    }, Promise.prototype._cancelBy = function(canceller) {
     return canceller === this ? (this._branchesRemainingToCancel = 0, this._invokeOnCancel(), 
     !0) : (this._branchHasCancelled(), !!this._enoughBranchesHaveCancelled() && (this._invokeOnCancel(), 
     !0));
    }, Promise.prototype._cancelBranched = function() {
     this._enoughBranchesHaveCancelled() && this._cancel();
    }, Promise.prototype._cancel = function() {
     this._isCancellable() && (this._setCancelled(), async.invoke(this._cancelPromises, this, void 0));
    }, Promise.prototype._cancelPromises = function() {
     this._length() > 0 && this._settlePromises();
    }, Promise.prototype._unsetOnCancel = function() {
     this._onCancelField = void 0;
    }, Promise.prototype._isCancellable = function() {
     return this.isPending() && !this._isCancelled();
    }, Promise.prototype.isCancellable = function() {
     return this.isPending() && !this.isCancelled();
    }, Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
     if (util.isArray(onCancelCallback)) for (var i = 0; i < onCancelCallback.length; ++i) this._doInvokeOnCancel(onCancelCallback[i], internalOnly); else if (void 0 !== onCancelCallback) if ("function" == typeof onCancelCallback) {
      if (!internalOnly) {
       var e = tryCatch(onCancelCallback).call(this._boundValue());
       e === errorObj && (this._attachExtraTrace(e.e), async.throwLater(e.e));
      }
     } else onCancelCallback._resultCancelled(this);
    }, Promise.prototype._invokeOnCancel = function() {
     var onCancelCallback = this._onCancel();
     this._unsetOnCancel(), async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
    }, Promise.prototype._invokeInternalOnCancel = function() {
     this._isCancellable() && (this._doInvokeOnCancel(this._onCancel(), !0), this._unsetOnCancel());
    }, Promise.prototype._resultCancelled = function() {
     this.cancel();
    };
   };
  },
  89976: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(NEXT_FILTER) {
    var util = __webpack_require__(75942), getKeys = __webpack_require__(89571).keys, tryCatch = util.tryCatch, errorObj = util.errorObj;
    return function(instances, cb, promise) {
     return function(e) {
      var boundTo = promise._boundValue();
      predicateLoop: for (var i = 0; i < instances.length; ++i) {
       var item = instances[i];
       if (item === Error || null != item && item.prototype instanceof Error) {
        if (e instanceof item) return tryCatch(cb).call(boundTo, e);
       } else if ("function" == typeof item) {
        var matchesPredicate = tryCatch(item).call(boundTo, e);
        if (matchesPredicate === errorObj) return matchesPredicate;
        if (matchesPredicate) return tryCatch(cb).call(boundTo, e);
       } else if (util.isObject(e)) {
        for (var keys = getKeys(item), j = 0; j < keys.length; ++j) {
         var key = keys[j];
         if (item[key] != e[key]) continue predicateLoop;
        }
        return tryCatch(cb).call(boundTo, e);
       }
      }
      return NEXT_FILTER;
     };
    };
   };
  },
  75910: module => {
   "use strict";
   module.exports = function(Promise) {
    var longStackTraces = !1, contextStack = [];
    function Context() {
     this._trace = new Context.CapturedTrace(peekContext());
    }
    function peekContext() {
     var lastIndex = contextStack.length - 1;
     if (lastIndex >= 0) return contextStack[lastIndex];
    }
    return Promise.prototype._promiseCreated = function() {}, Promise.prototype._pushContext = function() {}, 
    Promise.prototype._popContext = function() {
     return null;
    }, Promise._peekContext = Promise.prototype._peekContext = function() {}, Context.prototype._pushContext = function() {
     void 0 !== this._trace && (this._trace._promiseCreated = null, contextStack.push(this._trace));
    }, Context.prototype._popContext = function() {
     if (void 0 !== this._trace) {
      var trace = contextStack.pop(), ret = trace._promiseCreated;
      return trace._promiseCreated = null, ret;
     }
     return null;
    }, Context.CapturedTrace = null, Context.create = function() {
     if (longStackTraces) return new Context;
    }, Context.deactivateLongStackTraces = function() {}, Context.activateLongStackTraces = function() {
     var Promise_pushContext = Promise.prototype._pushContext, Promise_popContext = Promise.prototype._popContext, Promise_PeekContext = Promise._peekContext, Promise_peekContext = Promise.prototype._peekContext, Promise_promiseCreated = Promise.prototype._promiseCreated;
     Context.deactivateLongStackTraces = function() {
      Promise.prototype._pushContext = Promise_pushContext, Promise.prototype._popContext = Promise_popContext, 
      Promise._peekContext = Promise_PeekContext, Promise.prototype._peekContext = Promise_peekContext, 
      Promise.prototype._promiseCreated = Promise_promiseCreated, longStackTraces = !1;
     }, longStackTraces = !0, Promise.prototype._pushContext = Context.prototype._pushContext, 
     Promise.prototype._popContext = Context.prototype._popContext, Promise._peekContext = Promise.prototype._peekContext = peekContext, 
     Promise.prototype._promiseCreated = function() {
      var ctx = this._peekContext();
      ctx && null == ctx._promiseCreated && (ctx._promiseCreated = this);
     };
    }, Context;
   };
  },
  90461: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, Context, enableAsyncHooks, disableAsyncHooks) {
    var unhandledRejectionHandled, possiblyUnhandledRejection, printWarning, deferUnhandledRejectionCheck, async = Promise._async, Warning = __webpack_require__(57621).Warning, util = __webpack_require__(75942), es5 = __webpack_require__(89571), canAttachTrace = util.canAttachTrace, bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/, nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/, parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/, stackFramePattern = null, formatStack = null, indentStackFrames = !1, debugging = !(0 == util.env("BLUEBIRD_DEBUG") || !util.env("BLUEBIRD_DEBUG") && "development" !== util.env("NODE_ENV")), warnings = !(0 == util.env("BLUEBIRD_WARNINGS") || !debugging && !util.env("BLUEBIRD_WARNINGS")), longStackTraces = !(0 == util.env("BLUEBIRD_LONG_STACK_TRACES") || !debugging && !util.env("BLUEBIRD_LONG_STACK_TRACES")), wForgottenReturn = 0 != util.env("BLUEBIRD_W_FORGOTTEN_RETURN") && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
    !function() {
     var promises = [];
     function unhandledRejectionCheck() {
      for (var i = 0; i < promises.length; ++i) promises[i]._notifyUnhandledRejection();
      unhandledRejectionClear();
     }
     function unhandledRejectionClear() {
      promises.length = 0;
     }
     deferUnhandledRejectionCheck = function(promise) {
      promises.push(promise), setTimeout(unhandledRejectionCheck, 1);
     }, es5.defineProperty(Promise, "_unhandledRejectionCheck", {
      value: unhandledRejectionCheck
     }), es5.defineProperty(Promise, "_unhandledRejectionClear", {
      value: unhandledRejectionClear
     });
    }(), Promise.prototype.suppressUnhandledRejections = function() {
     var target = this._target();
     target._bitField = -1048577 & target._bitField | 524288;
    }, Promise.prototype._ensurePossibleRejectionHandled = function() {
     0 == (524288 & this._bitField) && (this._setRejectionIsUnhandled(), deferUnhandledRejectionCheck(this));
    }, Promise.prototype._notifyUnhandledRejectionIsHandled = function() {
     fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, void 0, this);
    }, Promise.prototype._setReturnedNonUndefined = function() {
     this._bitField = 268435456 | this._bitField;
    }, Promise.prototype._returnedNonUndefined = function() {
     return 0 != (268435456 & this._bitField);
    }, Promise.prototype._notifyUnhandledRejection = function() {
     if (this._isRejectionUnhandled()) {
      var reason = this._settledValue();
      this._setUnhandledRejectionIsNotified(), fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
     }
    }, Promise.prototype._setUnhandledRejectionIsNotified = function() {
     this._bitField = 262144 | this._bitField;
    }, Promise.prototype._unsetUnhandledRejectionIsNotified = function() {
     this._bitField = -262145 & this._bitField;
    }, Promise.prototype._isUnhandledRejectionNotified = function() {
     return (262144 & this._bitField) > 0;
    }, Promise.prototype._setRejectionIsUnhandled = function() {
     this._bitField = 1048576 | this._bitField;
    }, Promise.prototype._unsetRejectionIsUnhandled = function() {
     this._bitField = -1048577 & this._bitField, this._isUnhandledRejectionNotified() && (this._unsetUnhandledRejectionIsNotified(), 
     this._notifyUnhandledRejectionIsHandled());
    }, Promise.prototype._isRejectionUnhandled = function() {
     return (1048576 & this._bitField) > 0;
    }, Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
     return warn(message, shouldUseOwnTrace, promise || this);
    }, Promise.onPossiblyUnhandledRejection = function(fn) {
     var context = Promise._getContext();
     possiblyUnhandledRejection = util.contextBind(context, fn);
    }, Promise.onUnhandledRejectionHandled = function(fn) {
     var context = Promise._getContext();
     unhandledRejectionHandled = util.contextBind(context, fn);
    };
    var disableLongStackTraces = function() {};
    Promise.longStackTraces = function() {
     if (async.haveItemsQueued() && !config.longStackTraces) throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
     if (!config.longStackTraces && longStackTracesIsSupported()) {
      var Promise_captureStackTrace = Promise.prototype._captureStackTrace, Promise_attachExtraTrace = Promise.prototype._attachExtraTrace, Promise_dereferenceTrace = Promise.prototype._dereferenceTrace;
      config.longStackTraces = !0, disableLongStackTraces = function() {
       if (async.haveItemsQueued() && !config.longStackTraces) throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
       Promise.prototype._captureStackTrace = Promise_captureStackTrace, Promise.prototype._attachExtraTrace = Promise_attachExtraTrace, 
       Promise.prototype._dereferenceTrace = Promise_dereferenceTrace, Context.deactivateLongStackTraces(), 
       config.longStackTraces = !1;
      }, Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace, Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace, 
      Promise.prototype._dereferenceTrace = longStackTracesDereferenceTrace, Context.activateLongStackTraces();
     }
    }, Promise.hasLongStackTraces = function() {
     return config.longStackTraces && longStackTracesIsSupported();
    };
    var legacyHandlers = {
     unhandledrejection: {
      before: function() {
       var ret = util.global.onunhandledrejection;
       return util.global.onunhandledrejection = null, ret;
      },
      after: function(fn) {
       util.global.onunhandledrejection = fn;
      }
     },
     rejectionhandled: {
      before: function() {
       var ret = util.global.onrejectionhandled;
       return util.global.onrejectionhandled = null, ret;
      },
      after: function(fn) {
       util.global.onrejectionhandled = fn;
      }
     }
    }, fireDomEvent = function() {
     var dispatch = function(legacy, e) {
      if (!legacy) return !util.global.dispatchEvent(e);
      var fn;
      try {
       return fn = legacy.before(), !util.global.dispatchEvent(e);
      } finally {
       legacy.after(fn);
      }
     };
     try {
      if ("function" == typeof CustomEvent) {
       var event = new CustomEvent("CustomEvent");
       return util.global.dispatchEvent(event), function(name, event) {
        name = name.toLowerCase();
        var domEvent = new CustomEvent(name, {
         detail: event,
         cancelable: !0
        });
        return es5.defineProperty(domEvent, "promise", {
         value: event.promise
        }), es5.defineProperty(domEvent, "reason", {
         value: event.reason
        }), dispatch(legacyHandlers[name], domEvent);
       };
      }
      if ("function" == typeof Event) {
       event = new Event("CustomEvent");
       return util.global.dispatchEvent(event), function(name, event) {
        name = name.toLowerCase();
        var domEvent = new Event(name, {
         cancelable: !0
        });
        return domEvent.detail = event, es5.defineProperty(domEvent, "promise", {
         value: event.promise
        }), es5.defineProperty(domEvent, "reason", {
         value: event.reason
        }), dispatch(legacyHandlers[name], domEvent);
       };
      }
      return (event = document.createEvent("CustomEvent")).initCustomEvent("testingtheevent", !1, !0, {}), 
      util.global.dispatchEvent(event), function(name, event) {
       name = name.toLowerCase();
       var domEvent = document.createEvent("CustomEvent");
       return domEvent.initCustomEvent(name, !1, !0, event), dispatch(legacyHandlers[name], domEvent);
      };
     } catch (e) {}
     return function() {
      return !1;
     };
    }(), fireGlobalEvent = util.isNode ? function() {
     return process.emit.apply(process, arguments);
    } : util.global ? function(name) {
     var methodName = "on" + name.toLowerCase(), method = util.global[methodName];
     return !!method && (method.apply(util.global, [].slice.call(arguments, 1)), !0);
    } : function() {
     return !1;
    };
    function generatePromiseLifecycleEventObject(name, promise) {
     return {
      promise
     };
    }
    var eventToObjectGenerator = {
     promiseCreated: generatePromiseLifecycleEventObject,
     promiseFulfilled: generatePromiseLifecycleEventObject,
     promiseRejected: generatePromiseLifecycleEventObject,
     promiseResolved: generatePromiseLifecycleEventObject,
     promiseCancelled: generatePromiseLifecycleEventObject,
     promiseChained: function(name, promise, child) {
      return {
       promise,
       child
      };
     },
     warning: function(name, warning) {
      return {
       warning
      };
     },
     unhandledRejection: function(name, reason, promise) {
      return {
       reason,
       promise
      };
     },
     rejectionHandled: generatePromiseLifecycleEventObject
    }, activeFireEvent = function(name) {
     var globalEventFired = !1;
     try {
      globalEventFired = fireGlobalEvent.apply(null, arguments);
     } catch (e) {
      async.throwLater(e), globalEventFired = !0;
     }
     var domEventFired = !1;
     try {
      domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));
     } catch (e) {
      async.throwLater(e), domEventFired = !0;
     }
     return domEventFired || globalEventFired;
    };
    function defaultFireEvent() {
     return !1;
    }
    function cancellationExecute(executor, resolve, reject) {
     var promise = this;
     try {
      executor(resolve, reject, (function(onCancel) {
       if ("function" != typeof onCancel) throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
       promise._attachCancellationCallback(onCancel);
      }));
     } catch (e) {
      return e;
     }
    }
    function cancellationAttachCancellationCallback(onCancel) {
     if (!this._isCancellable()) return this;
     var previousOnCancel = this._onCancel();
     void 0 !== previousOnCancel ? util.isArray(previousOnCancel) ? previousOnCancel.push(onCancel) : this._setOnCancel([ previousOnCancel, onCancel ]) : this._setOnCancel(onCancel);
    }
    function cancellationOnCancel() {
     return this._onCancelField;
    }
    function cancellationSetOnCancel(onCancel) {
     this._onCancelField = onCancel;
    }
    function cancellationClearCancellationData() {
     this._cancellationParent = void 0, this._onCancelField = void 0;
    }
    function cancellationPropagateFrom(parent, flags) {
     if (0 != (1 & flags)) {
      this._cancellationParent = parent;
      var branchesRemainingToCancel = parent._branchesRemainingToCancel;
      void 0 === branchesRemainingToCancel && (branchesRemainingToCancel = 0), parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
     }
     0 != (2 & flags) && parent._isBound() && this._setBoundTo(parent._boundTo);
    }
    Promise.config = function(opts) {
     if ("longStackTraces" in (opts = Object(opts)) && (opts.longStackTraces ? Promise.longStackTraces() : !opts.longStackTraces && Promise.hasLongStackTraces() && disableLongStackTraces()), 
     "warnings" in opts) {
      var warningsOption = opts.warnings;
      config.warnings = !!warningsOption, wForgottenReturn = config.warnings, util.isObject(warningsOption) && "wForgottenReturn" in warningsOption && (wForgottenReturn = !!warningsOption.wForgottenReturn);
     }
     if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
      if (async.haveItemsQueued()) throw new Error("cannot enable cancellation after promises are in use");
      Promise.prototype._clearCancellationData = cancellationClearCancellationData, Promise.prototype._propagateFrom = cancellationPropagateFrom, 
      Promise.prototype._onCancel = cancellationOnCancel, Promise.prototype._setOnCancel = cancellationSetOnCancel, 
      Promise.prototype._attachCancellationCallback = cancellationAttachCancellationCallback, 
      Promise.prototype._execute = cancellationExecute, propagateFromFunction = cancellationPropagateFrom, 
      config.cancellation = !0;
     }
     if ("monitoring" in opts && (opts.monitoring && !config.monitoring ? (config.monitoring = !0, 
     Promise.prototype._fireEvent = activeFireEvent) : !opts.monitoring && config.monitoring && (config.monitoring = !1, 
     Promise.prototype._fireEvent = defaultFireEvent)), "asyncHooks" in opts && util.nodeSupportsAsyncResource) {
      var prev = config.asyncHooks, cur = !!opts.asyncHooks;
      prev !== cur && (config.asyncHooks = cur, cur ? enableAsyncHooks() : disableAsyncHooks());
     }
     return Promise;
    }, Promise.prototype._fireEvent = defaultFireEvent, Promise.prototype._execute = function(executor, resolve, reject) {
     try {
      executor(resolve, reject);
     } catch (e) {
      return e;
     }
    }, Promise.prototype._onCancel = function() {}, Promise.prototype._setOnCancel = function(handler) {}, 
    Promise.prototype._attachCancellationCallback = function(onCancel) {}, Promise.prototype._captureStackTrace = function() {}, 
    Promise.prototype._attachExtraTrace = function() {}, Promise.prototype._dereferenceTrace = function() {}, 
    Promise.prototype._clearCancellationData = function() {}, Promise.prototype._propagateFrom = function(parent, flags) {};
    var propagateFromFunction = function(parent, flags) {
     0 != (2 & flags) && parent._isBound() && this._setBoundTo(parent._boundTo);
    };
    function boundValueFunction() {
     var ret = this._boundTo;
     return void 0 !== ret && ret instanceof Promise ? ret.isFulfilled() ? ret.value() : void 0 : ret;
    }
    function longStackTracesCaptureStackTrace() {
     this._trace = new CapturedTrace(this._peekContext());
    }
    function longStackTracesAttachExtraTrace(error, ignoreSelf) {
     if (canAttachTrace(error)) {
      var trace = this._trace;
      if (void 0 !== trace && ignoreSelf && (trace = trace._parent), void 0 !== trace) trace.attachExtraTrace(error); else if (!error.__stackCleaned__) {
       var parsed = parseStackAndMessage(error);
       util.notEnumerableProp(error, "stack", parsed.message + "\n" + parsed.stack.join("\n")), 
       util.notEnumerableProp(error, "__stackCleaned__", !0);
      }
     }
    }
    function longStackTracesDereferenceTrace() {
     this._trace = void 0;
    }
    function warn(message, shouldUseOwnTrace, promise) {
     if (config.warnings) {
      var ctx, warning = new Warning(message);
      if (shouldUseOwnTrace) promise._attachExtraTrace(warning); else if (config.longStackTraces && (ctx = Promise._peekContext())) ctx.attachExtraTrace(warning); else {
       var parsed = parseStackAndMessage(warning);
       warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
      }
      activeFireEvent("warning", warning) || formatAndLogError(warning, "", !0);
     }
    }
    function cleanStack(stack) {
     for (var ret = [], i = 0; i < stack.length; ++i) {
      var line = stack[i], isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line), isInternalFrame = isTraceLine && shouldIgnore(line);
      isTraceLine && !isInternalFrame && (indentStackFrames && " " !== line.charAt(0) && (line = "    " + line), 
      ret.push(line));
     }
     return ret;
    }
    function parseStackAndMessage(error) {
     var stack = error.stack, message = error.toString();
     return stack = "string" == typeof stack && stack.length > 0 ? function(error) {
      for (var stack = error.stack.replace(/\s+$/g, "").split("\n"), i = 0; i < stack.length; ++i) {
       var line = stack[i];
       if ("    (No stack trace)" === line || stackFramePattern.test(line)) break;
      }
      return i > 0 && "SyntaxError" != error.name && (stack = stack.slice(i)), stack;
     }(error) : [ "    (No stack trace)" ], {
      message,
      stack: "SyntaxError" == error.name ? stack : cleanStack(stack)
     };
    }
    function formatAndLogError(error, title, isSoft) {
     if ("undefined" != typeof console) {
      var message;
      if (util.isObject(error)) {
       var stack = error.stack;
       message = title + formatStack(stack, error);
      } else message = title + String(error);
      "function" == typeof printWarning ? printWarning(message, isSoft) : "function" != typeof console.log && "object" != typeof console.log || console.log(message);
     }
    }
    function fireRejectionEvent(name, localHandler, reason, promise) {
     var localEventFired = !1;
     try {
      "function" == typeof localHandler && (localEventFired = !0, "rejectionHandled" === name ? localHandler(promise) : localHandler(reason, promise));
     } catch (e) {
      async.throwLater(e);
     }
     "unhandledRejection" === name ? activeFireEvent(name, reason, promise) || localEventFired || formatAndLogError(reason, "Unhandled rejection ") : activeFireEvent(name, promise);
    }
    function formatNonError(obj) {
     var str;
     if ("function" == typeof obj) str = "[function " + (obj.name || "anonymous") + "]"; else {
      str = obj && "function" == typeof obj.toString ? obj.toString() : util.toString(obj);
      if (/\[object [a-zA-Z0-9$_]+\]/.test(str)) try {
       str = JSON.stringify(obj);
      } catch (e) {}
      0 === str.length && (str = "(empty array)");
     }
     return "(<" + function(str) {
      var maxChars = 41;
      if (str.length < maxChars) return str;
      return str.substr(0, maxChars - 3) + "...";
     }(str) + ">, no stack trace)";
    }
    function longStackTracesIsSupported() {
     return "function" == typeof captureStackTrace;
    }
    var shouldIgnore = function() {
     return !1;
    }, parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function parseLineInfo(line) {
     var matches = line.match(parseLineInfoRegex);
     if (matches) return {
      fileName: matches[1],
      line: parseInt(matches[2], 10)
     };
    }
    function CapturedTrace(parent) {
     this._parent = parent, this._promisesCreated = 0;
     var length = this._length = 1 + (void 0 === parent ? 0 : parent._length);
     captureStackTrace(this, CapturedTrace), length > 32 && this.uncycle();
    }
    util.inherits(CapturedTrace, Error), Context.CapturedTrace = CapturedTrace, CapturedTrace.prototype.uncycle = function() {
     var length = this._length;
     if (!(length < 2)) {
      for (var nodes = [], stackToIndex = {}, i = 0, node = this; void 0 !== node; ++i) nodes.push(node), 
      node = node._parent;
      for (i = (length = this._length = i) - 1; i >= 0; --i) {
       var stack = nodes[i].stack;
       void 0 === stackToIndex[stack] && (stackToIndex[stack] = i);
      }
      for (i = 0; i < length; ++i) {
       var index = stackToIndex[nodes[i].stack];
       if (void 0 !== index && index !== i) {
        index > 0 && (nodes[index - 1]._parent = void 0, nodes[index - 1]._length = 1), 
        nodes[i]._parent = void 0, nodes[i]._length = 1;
        var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
        index < length - 1 ? (cycleEdgeNode._parent = nodes[index + 1], cycleEdgeNode._parent.uncycle(), 
        cycleEdgeNode._length = cycleEdgeNode._parent._length + 1) : (cycleEdgeNode._parent = void 0, 
        cycleEdgeNode._length = 1);
        for (var currentChildLength = cycleEdgeNode._length + 1, j = i - 2; j >= 0; --j) nodes[j]._length = currentChildLength, 
        currentChildLength++;
        return;
       }
      }
     }
    }, CapturedTrace.prototype.attachExtraTrace = function(error) {
     if (!error.__stackCleaned__) {
      this.uncycle();
      for (var parsed = parseStackAndMessage(error), message = parsed.message, stacks = [ parsed.stack ], trace = this; void 0 !== trace; ) stacks.push(cleanStack(trace.stack.split("\n"))), 
      trace = trace._parent;
      !function(stacks) {
       for (var current = stacks[0], i = 1; i < stacks.length; ++i) {
        for (var prev = stacks[i], currentLastIndex = current.length - 1, currentLastLine = current[currentLastIndex], commonRootMeetPoint = -1, j = prev.length - 1; j >= 0; --j) if (prev[j] === currentLastLine) {
         commonRootMeetPoint = j;
         break;
        }
        for (j = commonRootMeetPoint; j >= 0; --j) {
         var line = prev[j];
         if (current[currentLastIndex] !== line) break;
         current.pop(), currentLastIndex--;
        }
        current = prev;
       }
      }(stacks), function(stacks) {
       for (var i = 0; i < stacks.length; ++i) (0 === stacks[i].length || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) && (stacks.splice(i, 1), 
       i--);
      }(stacks), util.notEnumerableProp(error, "stack", function(message, stacks) {
       for (var i = 0; i < stacks.length - 1; ++i) stacks[i].push("From previous event:"), 
       stacks[i] = stacks[i].join("\n");
       return i < stacks.length && (stacks[i] = stacks[i].join("\n")), message + "\n" + stacks.join("\n");
      }(message, stacks)), util.notEnumerableProp(error, "__stackCleaned__", !0);
     }
    };
    var captureStackTrace = function() {
     var v8stackFramePattern = /^\s*at\s*/, v8stackFormatter = function(stack, error) {
      return "string" == typeof stack ? stack : void 0 !== error.name && void 0 !== error.message ? error.toString() : formatNonError(error);
     };
     if ("number" == typeof Error.stackTraceLimit && "function" == typeof Error.captureStackTrace) {
      Error.stackTraceLimit += 6, stackFramePattern = v8stackFramePattern, formatStack = v8stackFormatter;
      var captureStackTrace = Error.captureStackTrace;
      return shouldIgnore = function(line) {
       return bluebirdFramePattern.test(line);
      }, function(receiver, ignoreUntil) {
       Error.stackTraceLimit += 6, captureStackTrace(receiver, ignoreUntil), Error.stackTraceLimit -= 6;
      };
     }
     var hasStackAfterThrow, err = new Error;
     if ("string" == typeof err.stack && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) return stackFramePattern = /@/, 
     formatStack = v8stackFormatter, indentStackFrames = !0, function(o) {
      o.stack = (new Error).stack;
     };
     try {
      throw new Error;
     } catch (e) {
      hasStackAfterThrow = "stack" in e;
     }
     return !("stack" in err) && hasStackAfterThrow && "number" == typeof Error.stackTraceLimit ? (stackFramePattern = v8stackFramePattern, 
     formatStack = v8stackFormatter, function(o) {
      Error.stackTraceLimit += 6;
      try {
       throw new Error;
      } catch (e) {
       o.stack = e.stack;
      }
      Error.stackTraceLimit -= 6;
     }) : (formatStack = function(stack, error) {
      return "string" == typeof stack ? stack : "object" != typeof error && "function" != typeof error || void 0 === error.name || void 0 === error.message ? formatNonError(error) : error.toString();
     }, null);
    }();
    "undefined" != typeof console && void 0 !== console.warn && (printWarning = function(message) {
     console.warn(message);
    }, util.isNode && process.stderr.isTTY ? printWarning = function(message, isSoft) {
     var color = isSoft ? "[33m" : "[31m";
     console.warn(color + message + "[0m\n");
    } : util.isNode || "string" != typeof (new Error).stack || (printWarning = function(message, isSoft) {
     console.warn("%c" + message, isSoft ? "color: darkorange" : "color: red");
    }));
    var config = {
     warnings,
     longStackTraces: !1,
     cancellation: !1,
     monitoring: !1,
     asyncHooks: !1
    };
    return longStackTraces && Promise.longStackTraces(), {
     asyncHooks: function() {
      return config.asyncHooks;
     },
     longStackTraces: function() {
      return config.longStackTraces;
     },
     warnings: function() {
      return config.warnings;
     },
     cancellation: function() {
      return config.cancellation;
     },
     monitoring: function() {
      return config.monitoring;
     },
     propagateFromFunction: function() {
      return propagateFromFunction;
     },
     boundValueFunction: function() {
      return boundValueFunction;
     },
     checkForgottenReturns: function(returnValue, promiseCreated, name, promise, parent) {
      if (void 0 === returnValue && null !== promiseCreated && wForgottenReturn) {
       if (void 0 !== parent && parent._returnedNonUndefined()) return;
       if (0 == (65535 & promise._bitField)) return;
       name && (name += " ");
       var handlerLine = "", creatorLine = "";
       if (promiseCreated._trace) {
        for (var traceLines = promiseCreated._trace.stack.split("\n"), stack = cleanStack(traceLines), i = stack.length - 1; i >= 0; --i) {
         var line = stack[i];
         if (!nodeFramePattern.test(line)) {
          var lineMatches = line.match(parseLinePattern);
          lineMatches && (handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ");
          break;
         }
        }
        if (stack.length > 0) {
         var firstUserLine = stack[0];
         for (i = 0; i < traceLines.length; ++i) if (traceLines[i] === firstUserLine) {
          i > 0 && (creatorLine = "\n" + traceLines[i - 1]);
          break;
         }
        }
       }
       var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
       promise._warn(msg, !0, promiseCreated);
      }
     },
     setBounds: function(firstLineError, lastLineError) {
      if (longStackTracesIsSupported()) {
       for (var firstFileName, lastFileName, firstStackLines = (firstLineError.stack || "").split("\n"), lastStackLines = (lastLineError.stack || "").split("\n"), firstIndex = -1, lastIndex = -1, i = 0; i < firstStackLines.length; ++i) {
        if (result = parseLineInfo(firstStackLines[i])) {
         firstFileName = result.fileName, firstIndex = result.line;
         break;
        }
       }
       for (i = 0; i < lastStackLines.length; ++i) {
        var result;
        if (result = parseLineInfo(lastStackLines[i])) {
         lastFileName = result.fileName, lastIndex = result.line;
         break;
        }
       }
       firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex || (shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line)) return !0;
        var info = parseLineInfo(line);
        return !!(info && info.fileName === firstFileName && firstIndex <= info.line && info.line <= lastIndex);
       });
      }
     },
     warn,
     deprecated: function(name, replacement) {
      var message = name + " is deprecated and will be removed in a future version.";
      return replacement && (message += " Use " + replacement + " instead."), warn(message);
     },
     CapturedTrace,
     fireDomEvent,
     fireGlobalEvent
    };
   };
  },
  45632: module => {
   "use strict";
   module.exports = function(Promise) {
    function returner() {
     return this.value;
    }
    function thrower() {
     throw this.reason;
    }
    Promise.prototype.return = Promise.prototype.thenReturn = function(value) {
     return value instanceof Promise && value.suppressUnhandledRejections(), this._then(returner, void 0, void 0, {
      value
     }, void 0);
    }, Promise.prototype.throw = Promise.prototype.thenThrow = function(reason) {
     return this._then(thrower, void 0, void 0, {
      reason
     }, void 0);
    }, Promise.prototype.catchThrow = function(reason) {
     if (arguments.length <= 1) return this._then(void 0, thrower, void 0, {
      reason
     }, void 0);
     var _reason = arguments[1];
     return this.caught(reason, (function() {
      throw _reason;
     }));
    }, Promise.prototype.catchReturn = function(value) {
     if (arguments.length <= 1) return value instanceof Promise && value.suppressUnhandledRejections(), 
     this._then(void 0, returner, void 0, {
      value
     }, void 0);
     var _value = arguments[1];
     _value instanceof Promise && _value.suppressUnhandledRejections();
     return this.caught(value, (function() {
      return _value;
     }));
    };
   };
  },
  6574: module => {
   "use strict";
   module.exports = function(Promise, INTERNAL) {
    var PromiseReduce = Promise.reduce, PromiseAll = Promise.all;
    function promiseAllThis() {
     return PromiseAll(this);
    }
    Promise.prototype.each = function(fn) {
     return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
    }, Promise.prototype.mapSeries = function(fn) {
     return PromiseReduce(this, fn, INTERNAL, INTERNAL);
    }, Promise.each = function(promises, fn) {
     return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, promises, void 0);
    }, Promise.mapSeries = function(promises, fn) {
     return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
    };
   };
  },
  57621: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var _TypeError, _RangeError, es5 = __webpack_require__(89571), Objectfreeze = es5.freeze, util = __webpack_require__(75942), inherits = util.inherits, notEnumerableProp = util.notEnumerableProp;
   function subError(nameProperty, defaultMessage) {
    function SubError(message) {
     if (!(this instanceof SubError)) return new SubError(message);
     notEnumerableProp(this, "message", "string" == typeof message ? message : defaultMessage), 
     notEnumerableProp(this, "name", nameProperty), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : Error.call(this);
    }
    return inherits(SubError, Error), SubError;
   }
   var Warning = subError("Warning", "warning"), CancellationError = subError("CancellationError", "cancellation error"), TimeoutError = subError("TimeoutError", "timeout error"), AggregateError = subError("AggregateError", "aggregate error");
   try {
    _TypeError = TypeError, _RangeError = RangeError;
   } catch (e) {
    _TypeError = subError("TypeError", "type error"), _RangeError = subError("RangeError", "range error");
   }
   for (var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" "), i = 0; i < methods.length; ++i) "function" == typeof Array.prototype[methods[i]] && (AggregateError.prototype[methods[i]] = Array.prototype[methods[i]]);
   es5.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: !1,
    writable: !0,
    enumerable: !0
   }), AggregateError.prototype.isOperational = !0;
   var level = 0;
   function OperationalError(message) {
    if (!(this instanceof OperationalError)) return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError"), notEnumerableProp(this, "message", message), 
    this.cause = message, this.isOperational = !0, message instanceof Error ? (notEnumerableProp(this, "message", message.message), 
    notEnumerableProp(this, "stack", message.stack)) : Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
   }
   AggregateError.prototype.toString = function() {
    var indent = Array(4 * level + 1).join(" "), ret = "\n" + indent + "AggregateError of:\n";
    level++, indent = Array(4 * level + 1).join(" ");
    for (var i = 0; i < this.length; ++i) {
     for (var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "", lines = str.split("\n"), j = 0; j < lines.length; ++j) lines[j] = indent + lines[j];
     ret += (str = lines.join("\n")) + "\n";
    }
    return level--, ret;
   }, inherits(OperationalError, Error);
   var errorTypes = Error.__BluebirdErrorTypes__;
   errorTypes || (errorTypes = Objectfreeze({
    CancellationError,
    TimeoutError,
    OperationalError,
    RejectionError: OperationalError,
    AggregateError
   }), es5.defineProperty(Error, "__BluebirdErrorTypes__", {
    value: errorTypes,
    writable: !1,
    enumerable: !1,
    configurable: !1
   })), module.exports = {
    Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning
   };
  },
  89571: module => {
   var isES5 = function() {
    "use strict";
    return void 0 === this;
   }();
   if (isES5) module.exports = {
    freeze: Object.freeze,
    defineProperty: Object.defineProperty,
    getDescriptor: Object.getOwnPropertyDescriptor,
    keys: Object.keys,
    names: Object.getOwnPropertyNames,
    getPrototypeOf: Object.getPrototypeOf,
    isArray: Array.isArray,
    isES5,
    propertyIsWritable: function(obj, prop) {
     var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
     return !(descriptor && !descriptor.writable && !descriptor.set);
    }
   }; else {
    var has = {}.hasOwnProperty, str = {}.toString, proto = {}.constructor.prototype, ObjectKeys = function(o) {
     var ret = [];
     for (var key in o) has.call(o, key) && ret.push(key);
     return ret;
    };
    module.exports = {
     isArray: function(obj) {
      try {
       return "[object Array]" === str.call(obj);
      } catch (e) {
       return !1;
      }
     },
     keys: ObjectKeys,
     names: ObjectKeys,
     defineProperty: function(o, key, desc) {
      return o[key] = desc.value, o;
     },
     getDescriptor: function(o, key) {
      return {
       value: o[key]
      };
     },
     freeze: function(obj) {
      return obj;
     },
     getPrototypeOf: function(obj) {
      try {
       return Object(obj).constructor.prototype;
      } catch (e) {
       return proto;
      }
     },
     isES5,
     propertyIsWritable: function() {
      return !0;
     }
    };
   }
  },
  66777: module => {
   "use strict";
   module.exports = function(Promise, INTERNAL) {
    var PromiseMap = Promise.map;
    Promise.prototype.filter = function(fn, options) {
     return PromiseMap(this, fn, options, INTERNAL);
    }, Promise.filter = function(promises, fn, options) {
     return PromiseMap(promises, fn, options, INTERNAL);
    };
   };
  },
  87707: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, tryConvertToPromise, NEXT_FILTER) {
    var util = __webpack_require__(75942), CancellationError = Promise.CancellationError, errorObj = util.errorObj, catchFilter = __webpack_require__(89976)(NEXT_FILTER);
    function PassThroughHandlerContext(promise, type, handler) {
     this.promise = promise, this.type = type, this.handler = handler, this.called = !1, 
     this.cancelPromise = null;
    }
    function FinallyHandlerCancelReaction(finallyHandler) {
     this.finallyHandler = finallyHandler;
    }
    function checkCancel(ctx, reason) {
     return null != ctx.cancelPromise && (arguments.length > 1 ? ctx.cancelPromise._reject(reason) : ctx.cancelPromise._cancel(), 
     ctx.cancelPromise = null, !0);
    }
    function succeed() {
     return finallyHandler.call(this, this.promise._target()._settledValue());
    }
    function fail(reason) {
     if (!checkCancel(this, reason)) return errorObj.e = reason, errorObj;
    }
    function finallyHandler(reasonOrValue) {
     var promise = this.promise, handler = this.handler;
     if (!this.called) {
      this.called = !0;
      var ret = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
      if (ret === NEXT_FILTER) return ret;
      if (void 0 !== ret) {
       promise._setReturnedNonUndefined();
       var maybePromise = tryConvertToPromise(ret, promise);
       if (maybePromise instanceof Promise) {
        if (null != this.cancelPromise) {
         if (maybePromise._isCancelled()) {
          var reason = new CancellationError("late cancellation observer");
          return promise._attachExtraTrace(reason), errorObj.e = reason, errorObj;
         }
         maybePromise.isPending() && maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));
        }
        return maybePromise._then(succeed, fail, void 0, this, void 0);
       }
      }
     }
     return promise.isRejected() ? (checkCancel(this), errorObj.e = reasonOrValue, errorObj) : (checkCancel(this), 
     reasonOrValue);
    }
    return PassThroughHandlerContext.prototype.isFinallyHandler = function() {
     return 0 === this.type;
    }, FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
     checkCancel(this.finallyHandler);
    }, Promise.prototype._passThrough = function(handler, type, success, fail) {
     return "function" != typeof handler ? this.then() : this._then(success, fail, void 0, new PassThroughHandlerContext(this, type, handler), void 0);
    }, Promise.prototype.lastly = Promise.prototype.finally = function(handler) {
     return this._passThrough(handler, 0, finallyHandler, finallyHandler);
    }, Promise.prototype.tap = function(handler) {
     return this._passThrough(handler, 1, finallyHandler);
    }, Promise.prototype.tapCatch = function(handlerOrPredicate) {
     var len = arguments.length;
     if (1 === len) return this._passThrough(handlerOrPredicate, 1, void 0, finallyHandler);
     var i, catchInstances = new Array(len - 1), j = 0;
     for (i = 0; i < len - 1; ++i) {
      var item = arguments[i];
      if (!util.isObject(item)) return Promise.reject(new TypeError("tapCatch statement predicate: expecting an object but got " + util.classString(item)));
      catchInstances[j++] = item;
     }
     catchInstances.length = j;
     var handler = arguments[i];
     return this._passThrough(catchFilter(catchInstances, handler, this), 1, void 0, finallyHandler);
    }, PassThroughHandlerContext;
   };
  },
  60687: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
    var TypeError = __webpack_require__(57621).TypeError, util = __webpack_require__(75942), errorObj = util.errorObj, tryCatch = util.tryCatch, yieldHandlers = [];
    function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
     if (debug.cancellation()) {
      var internal = new Promise(INTERNAL), _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
      this._promise = internal.lastly((function() {
       return _finallyPromise;
      })), internal._captureStackTrace(), internal._setOnCancel(this);
     } else {
      (this._promise = new Promise(INTERNAL))._captureStackTrace();
     }
     this._stack = stack, this._generatorFunction = generatorFunction, this._receiver = receiver, 
     this._generator = void 0, this._yieldHandlers = "function" == typeof yieldHandler ? [ yieldHandler ].concat(yieldHandlers) : yieldHandlers, 
     this._yieldedPromise = null, this._cancellationPhase = !1;
    }
    util.inherits(PromiseSpawn, Proxyable), PromiseSpawn.prototype._isResolved = function() {
     return null === this._promise;
    }, PromiseSpawn.prototype._cleanup = function() {
     this._promise = this._generator = null, debug.cancellation() && null !== this._finallyPromise && (this._finallyPromise._fulfill(), 
     this._finallyPromise = null);
    }, PromiseSpawn.prototype._promiseCancelled = function() {
     if (!this._isResolved()) {
      var result;
      if (void 0 !== this._generator.return) this._promise._pushContext(), result = tryCatch(this._generator.return).call(this._generator, void 0), 
      this._promise._popContext(); else {
       var reason = new Promise.CancellationError("generator .return() sentinel");
       Promise.coroutine.returnSentinel = reason, this._promise._attachExtraTrace(reason), 
       this._promise._pushContext(), result = tryCatch(this._generator.throw).call(this._generator, reason), 
       this._promise._popContext();
      }
      this._cancellationPhase = !0, this._yieldedPromise = null, this._continue(result);
     }
    }, PromiseSpawn.prototype._promiseFulfilled = function(value) {
     this._yieldedPromise = null, this._promise._pushContext();
     var result = tryCatch(this._generator.next).call(this._generator, value);
     this._promise._popContext(), this._continue(result);
    }, PromiseSpawn.prototype._promiseRejected = function(reason) {
     this._yieldedPromise = null, this._promise._attachExtraTrace(reason), this._promise._pushContext();
     var result = tryCatch(this._generator.throw).call(this._generator, reason);
     this._promise._popContext(), this._continue(result);
    }, PromiseSpawn.prototype._resultCancelled = function() {
     if (this._yieldedPromise instanceof Promise) {
      var promise = this._yieldedPromise;
      this._yieldedPromise = null, promise.cancel();
     }
    }, PromiseSpawn.prototype.promise = function() {
     return this._promise;
    }, PromiseSpawn.prototype._run = function() {
     this._generator = this._generatorFunction.call(this._receiver), this._receiver = this._generatorFunction = void 0, 
     this._promiseFulfilled(void 0);
    }, PromiseSpawn.prototype._continue = function(result) {
     var promise = this._promise;
     if (result === errorObj) return this._cleanup(), this._cancellationPhase ? promise.cancel() : promise._rejectCallback(result.e, !1);
     var value = result.value;
     if (!0 === result.done) return this._cleanup(), this._cancellationPhase ? promise.cancel() : promise._resolveCallback(value);
     var maybePromise = tryConvertToPromise(value, this._promise);
     if (maybePromise instanceof Promise || (maybePromise = function(value, yieldHandlers, traceParent) {
      for (var i = 0; i < yieldHandlers.length; ++i) {
       traceParent._pushContext();
       var result = tryCatch(yieldHandlers[i])(value);
       if (traceParent._popContext(), result === errorObj) {
        traceParent._pushContext();
        var ret = Promise.reject(errorObj.e);
        return traceParent._popContext(), ret;
       }
       var maybePromise = tryConvertToPromise(result, traceParent);
       if (maybePromise instanceof Promise) return maybePromise;
      }
      return null;
     }(maybePromise, this._yieldHandlers, this._promise), null !== maybePromise)) {
      var bitField = (maybePromise = maybePromise._target())._bitField;
      0 == (50397184 & bitField) ? (this._yieldedPromise = maybePromise, maybePromise._proxy(this, null)) : 0 != (33554432 & bitField) ? Promise._async.invoke(this._promiseFulfilled, this, maybePromise._value()) : 0 != (16777216 & bitField) ? Promise._async.invoke(this._promiseRejected, this, maybePromise._reason()) : this._promiseCancelled();
     } else this._promiseRejected(new TypeError("A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", String(value)) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")));
    }, Promise.coroutine = function(generatorFunction, options) {
     if ("function" != typeof generatorFunction) throw new TypeError("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
     var yieldHandler = Object(options).yieldHandler, PromiseSpawn$ = PromiseSpawn, stack = (new Error).stack;
     return function() {
      var generator = generatorFunction.apply(this, arguments), spawn = new PromiseSpawn$(void 0, void 0, yieldHandler, stack), ret = spawn.promise();
      return spawn._generator = generator, spawn._promiseFulfilled(void 0), ret;
     };
    }, Promise.coroutine.addYieldHandler = function(fn) {
     if ("function" != typeof fn) throw new TypeError("expecting a function but got " + util.classString(fn));
     yieldHandlers.push(fn);
    }, Promise.spawn = function(generatorFunction) {
     if (debug.deprecated("Promise.spawn()", "Promise.coroutine()"), "function" != typeof generatorFunction) return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
     var spawn = new PromiseSpawn(generatorFunction, this), ret = spawn.promise();
     return spawn._run(Promise.spawn), ret;
    };
   };
  },
  17717: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async) {
    var reject, util = __webpack_require__(75942), canEvaluate = util.canEvaluate, tryCatch = util.tryCatch, errorObj = util.errorObj;
    if (canEvaluate) {
     for (var thenCallback = function(i) {
      return new Function("value", "holder", "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, i));
     }, promiseSetter = function(i) {
      return new Function("promise", "holder", "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ".replace(/Index/g, i));
     }, generateHolderClass = function(total) {
      for (var props = new Array(total), i = 0; i < props.length; ++i) props[i] = "this.p" + (i + 1);
      var assignment = props.join(" = ") + " = null;", cancellationCode = "var promise;\n" + props.map((function(prop) {
       return "                                                         \n                promise = " + prop + ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ";
      })).join("\n"), passedArguments = props.join(", "), name = "Holder$" + total, code = "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ";
      return code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode), 
      new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch, errorObj, Promise, async);
     }, holderClasses = [], thenCallbacks = [], promiseSetters = [], i = 0; i < 8; ++i) holderClasses.push(generateHolderClass(i + 1)), 
     thenCallbacks.push(thenCallback(i + 1)), promiseSetters.push(promiseSetter(i + 1));
     reject = function(reason) {
      this._reject(reason);
     };
    }
    Promise.join = function() {
     var fn, last = arguments.length - 1;
     if (last > 0 && "function" == typeof arguments[last] && (fn = arguments[last], last <= 8 && canEvaluate)) {
      (ret = new Promise(INTERNAL))._captureStackTrace();
      for (var holder = new (0, holderClasses[last - 1])(fn), callbacks = thenCallbacks, i = 0; i < last; ++i) {
       var maybePromise = tryConvertToPromise(arguments[i], ret);
       if (maybePromise instanceof Promise) {
        var bitField = (maybePromise = maybePromise._target())._bitField;
        0 == (50397184 & bitField) ? (maybePromise._then(callbacks[i], reject, void 0, ret, holder), 
        promiseSetters[i](maybePromise, holder), holder.asyncNeeded = !1) : 0 != (33554432 & bitField) ? callbacks[i].call(ret, maybePromise._value(), holder) : 0 != (16777216 & bitField) ? ret._reject(maybePromise._reason()) : ret._cancel();
       } else callbacks[i].call(ret, maybePromise, holder);
      }
      if (!ret._isFateSealed()) {
       if (holder.asyncNeeded) {
        var context = Promise._getContext();
        holder.fn = util.contextBind(context, holder.fn);
       }
       ret._setAsyncGuaranteed(), ret._setOnCancel(holder);
      }
      return ret;
     }
     for (var $_len = arguments.length, args = new Array($_len), $_i = 0; $_i < $_len; ++$_i) args[$_i] = arguments[$_i];
     fn && args.pop();
     var ret = new PromiseArray(args).promise();
     return void 0 !== fn ? ret.spread(fn) : ret;
    };
   };
  },
  6343: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var util = __webpack_require__(75942), tryCatch = util.tryCatch, errorObj = util.errorObj, async = Promise._async;
    function MappingPromiseArray(promises, fn, limit, _filter) {
     this.constructor$(promises), this._promise._captureStackTrace();
     var context = Promise._getContext();
     if (this._callback = util.contextBind(context, fn), this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null, 
     this._limit = limit, this._inFlight = 0, this._queue = [], async.invoke(this._asyncInit, this, void 0), 
     util.isArray(promises)) for (var i = 0; i < promises.length; ++i) {
      var maybePromise = promises[i];
      maybePromise instanceof Promise && maybePromise.suppressUnhandledRejections();
     }
    }
    function map(promises, fn, options, _filter) {
     if ("function" != typeof fn) return apiRejection("expecting a function but got " + util.classString(fn));
     var limit = 0;
     if (void 0 !== options) {
      if ("object" != typeof options || null === options) return Promise.reject(new TypeError("options argument must be an object but it is " + util.classString(options)));
      if ("number" != typeof options.concurrency) return Promise.reject(new TypeError("'concurrency' must be a number but it is " + util.classString(options.concurrency)));
      limit = options.concurrency;
     }
     return new MappingPromiseArray(promises, fn, limit = "number" == typeof limit && isFinite(limit) && limit >= 1 ? limit : 0, _filter).promise();
    }
    util.inherits(MappingPromiseArray, PromiseArray), MappingPromiseArray.prototype._asyncInit = function() {
     this._init$(void 0, -2);
    }, MappingPromiseArray.prototype._init = function() {}, MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
     var values = this._values, length = this.length(), preservedValues = this._preservedValues, limit = this._limit;
     if (index < 0) {
      if (values[index = -1 * index - 1] = value, limit >= 1 && (this._inFlight--, this._drainQueue(), 
      this._isResolved())) return !0;
     } else {
      if (limit >= 1 && this._inFlight >= limit) return values[index] = value, this._queue.push(index), 
      !1;
      null !== preservedValues && (preservedValues[index] = value);
      var promise = this._promise, callback = this._callback, receiver = promise._boundValue();
      promise._pushContext();
      var ret = tryCatch(callback).call(receiver, value, index, length), promiseCreated = promise._popContext();
      if (debug.checkForgottenReturns(ret, promiseCreated, null !== preservedValues ? "Promise.filter" : "Promise.map", promise), 
      ret === errorObj) return this._reject(ret.e), !0;
      var maybePromise = tryConvertToPromise(ret, this._promise);
      if (maybePromise instanceof Promise) {
       var bitField = (maybePromise = maybePromise._target())._bitField;
       if (0 == (50397184 & bitField)) return limit >= 1 && this._inFlight++, values[index] = maybePromise, 
       maybePromise._proxy(this, -1 * (index + 1)), !1;
       if (0 == (33554432 & bitField)) return 0 != (16777216 & bitField) ? (this._reject(maybePromise._reason()), 
       !0) : (this._cancel(), !0);
       ret = maybePromise._value();
      }
      values[index] = ret;
     }
     return ++this._totalResolved >= length && (null !== preservedValues ? this._filter(values, preservedValues) : this._resolve(values), 
     !0);
    }, MappingPromiseArray.prototype._drainQueue = function() {
     for (var queue = this._queue, limit = this._limit, values = this._values; queue.length > 0 && this._inFlight < limit; ) {
      if (this._isResolved()) return;
      var index = queue.pop();
      this._promiseFulfilled(values[index], index);
     }
    }, MappingPromiseArray.prototype._filter = function(booleans, values) {
     for (var len = values.length, ret = new Array(len), j = 0, i = 0; i < len; ++i) booleans[i] && (ret[j++] = values[i]);
     ret.length = j, this._resolve(ret);
    }, MappingPromiseArray.prototype.preservedValues = function() {
     return this._preservedValues;
    }, Promise.prototype.map = function(fn, options) {
     return map(this, fn, options, null);
    }, Promise.map = function(promises, fn, options, _filter) {
     return map(promises, fn, options, _filter);
    };
   };
  },
  96926: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
    var util = __webpack_require__(75942), tryCatch = util.tryCatch;
    Promise.method = function(fn) {
     if ("function" != typeof fn) throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
     return function() {
      var ret = new Promise(INTERNAL);
      ret._captureStackTrace(), ret._pushContext();
      var value = tryCatch(fn).apply(this, arguments), promiseCreated = ret._popContext();
      return debug.checkForgottenReturns(value, promiseCreated, "Promise.method", ret), 
      ret._resolveFromSyncValue(value), ret;
     };
    }, Promise.attempt = Promise.try = function(fn) {
     if ("function" != typeof fn) return apiRejection("expecting a function but got " + util.classString(fn));
     var value, ret = new Promise(INTERNAL);
     if (ret._captureStackTrace(), ret._pushContext(), arguments.length > 1) {
      debug.deprecated("calling Promise.try with more than 1 argument");
      var arg = arguments[1], ctx = arguments[2];
      value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);
     } else value = tryCatch(fn)();
     var promiseCreated = ret._popContext();
     return debug.checkForgottenReturns(value, promiseCreated, "Promise.try", ret), ret._resolveFromSyncValue(value), 
     ret;
    }, Promise.prototype._resolveFromSyncValue = function(value) {
     value === util.errorObj ? this._rejectCallback(value.e, !1) : this._resolveCallback(value, !0);
    };
   };
  },
  81776: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var util = __webpack_require__(75942), maybeWrapAsError = util.maybeWrapAsError, OperationalError = __webpack_require__(57621).OperationalError, es5 = __webpack_require__(89571);
   var rErrorKey = /^(?:name|message|stack|cause)$/;
   function wrapAsOperationalError(obj) {
    var ret;
    if (function(obj) {
     return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype;
    }(obj)) {
     (ret = new OperationalError(obj)).name = obj.name, ret.message = obj.message, ret.stack = obj.stack;
     for (var keys = es5.keys(obj), i = 0; i < keys.length; ++i) {
      var key = keys[i];
      rErrorKey.test(key) || (ret[key] = obj[key]);
     }
     return ret;
    }
    return util.markAsOriginatingFromRejection(obj), obj;
   }
   module.exports = function(promise, multiArgs) {
    return function(err, value) {
     if (null !== promise) {
      if (err) {
       var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
       promise._attachExtraTrace(wrapped), promise._reject(wrapped);
      } else if (multiArgs) {
       for (var $_len = arguments.length, args = new Array(Math.max($_len - 1, 0)), $_i = 1; $_i < $_len; ++$_i) args[$_i - 1] = arguments[$_i];
       promise._fulfill(args);
      } else promise._fulfill(value);
      promise = null;
     }
    };
   };
  },
  61941: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise) {
    var util = __webpack_require__(75942), async = Promise._async, tryCatch = util.tryCatch, errorObj = util.errorObj;
    function spreadAdapter(val, nodeback) {
     if (!util.isArray(val)) return successAdapter.call(this, val, nodeback);
     var ret = tryCatch(nodeback).apply(this._boundValue(), [ null ].concat(val));
     ret === errorObj && async.throwLater(ret.e);
    }
    function successAdapter(val, nodeback) {
     var receiver = this._boundValue(), ret = void 0 === val ? tryCatch(nodeback).call(receiver, null) : tryCatch(nodeback).call(receiver, null, val);
     ret === errorObj && async.throwLater(ret.e);
    }
    function errorAdapter(reason, nodeback) {
     if (!reason) {
      var newReason = new Error(reason + "");
      newReason.cause = reason, reason = newReason;
     }
     var ret = tryCatch(nodeback).call(this._boundValue(), reason);
     ret === errorObj && async.throwLater(ret.e);
    }
    Promise.prototype.asCallback = Promise.prototype.nodeify = function(nodeback, options) {
     if ("function" == typeof nodeback) {
      var adapter = successAdapter;
      void 0 !== options && Object(options).spread && (adapter = spreadAdapter), this._then(adapter, errorAdapter, void 0, this, nodeback);
     }
     return this;
    };
   };
  },
  7502: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function() {
    var makeSelfResolutionError = function() {
     return new TypeError("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
    }, reflectHandler = function() {
     return new Promise.PromiseInspection(this._target());
    }, apiRejection = function(msg) {
     return Promise.reject(new TypeError(msg));
    };
    function Proxyable() {}
    var UNDEFINED_BINDING = {}, util = __webpack_require__(75942);
    util.setReflectHandler(reflectHandler);
    var getDomain = function() {
     var domain = process.domain;
     return void 0 === domain ? null : domain;
    }, getContextDomain = function() {
     return {
      domain: getDomain(),
      async: null
     };
    }, AsyncResource = util.isNode && util.nodeSupportsAsyncResource ? __webpack_require__(50852).AsyncResource : null, getContextAsyncHooks = function() {
     return {
      domain: getDomain(),
      async: new AsyncResource("Bluebird::Promise")
     };
    }, getContext = util.isNode ? getContextDomain : function() {
     return null;
    };
    util.notEnumerableProp(Promise, "_getContext", getContext);
    var es5 = __webpack_require__(89571), Async = __webpack_require__(4601), async = new Async;
    es5.defineProperty(Promise, "_async", {
     value: async
    });
    var errors = __webpack_require__(57621), TypeError = Promise.TypeError = errors.TypeError;
    Promise.RangeError = errors.RangeError;
    var CancellationError = Promise.CancellationError = errors.CancellationError;
    Promise.TimeoutError = errors.TimeoutError, Promise.OperationalError = errors.OperationalError, 
    Promise.RejectionError = errors.OperationalError, Promise.AggregateError = errors.AggregateError;
    var INTERNAL = function() {}, APPLY = {}, NEXT_FILTER = {}, tryConvertToPromise = __webpack_require__(91778)(Promise, INTERNAL), PromiseArray = __webpack_require__(21640)(Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable), Context = __webpack_require__(75910)(Promise), createContext = Context.create, debug = __webpack_require__(90461)(Promise, Context, (function() {
     getContext = getContextAsyncHooks, util.notEnumerableProp(Promise, "_getContext", getContextAsyncHooks);
    }), (function() {
     getContext = getContextDomain, util.notEnumerableProp(Promise, "_getContext", getContextDomain);
    })), PassThroughHandlerContext = (debug.CapturedTrace, __webpack_require__(87707)(Promise, tryConvertToPromise, NEXT_FILTER)), catchFilter = __webpack_require__(89976)(NEXT_FILTER), nodebackForPromise = __webpack_require__(81776), errorObj = util.errorObj, tryCatch = util.tryCatch;
    function Promise(executor) {
     executor !== INTERNAL && function(self, executor) {
      if (null == self || self.constructor !== Promise) throw new TypeError("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
      if ("function" != typeof executor) throw new TypeError("expecting a function but got " + util.classString(executor));
     }(this, executor), this._bitField = 0, this._fulfillmentHandler0 = void 0, this._rejectionHandler0 = void 0, 
     this._promise0 = void 0, this._receiver0 = void 0, this._resolveFromExecutor(executor), 
     this._promiseCreated(), this._fireEvent("promiseCreated", this);
    }
    function deferResolve(v) {
     this.promise._resolveCallback(v);
    }
    function deferReject(v) {
     this.promise._rejectCallback(v, !1);
    }
    function fillTypes(value) {
     var p = new Promise(INTERNAL);
     p._fulfillmentHandler0 = value, p._rejectionHandler0 = value, p._promise0 = value, 
     p._receiver0 = value;
    }
    return Promise.prototype.toString = function() {
     return "[object Promise]";
    }, Promise.prototype.caught = Promise.prototype.catch = function(fn) {
     var len = arguments.length;
     if (len > 1) {
      var i, catchInstances = new Array(len - 1), j = 0;
      for (i = 0; i < len - 1; ++i) {
       var item = arguments[i];
       if (!util.isObject(item)) return apiRejection("Catch statement predicate: expecting an object but got " + util.classString(item));
       catchInstances[j++] = item;
      }
      if (catchInstances.length = j, "function" != typeof (fn = arguments[i])) throw new TypeError("The last argument to .catch() must be a function, got " + util.toString(fn));
      return this.then(void 0, catchFilter(catchInstances, fn, this));
     }
     return this.then(void 0, fn);
    }, Promise.prototype.reflect = function() {
     return this._then(reflectHandler, reflectHandler, void 0, this, void 0);
    }, Promise.prototype.then = function(didFulfill, didReject) {
     if (debug.warnings() && arguments.length > 0 && "function" != typeof didFulfill && "function" != typeof didReject) {
      var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
      arguments.length > 1 && (msg += ", " + util.classString(didReject)), this._warn(msg);
     }
     return this._then(didFulfill, didReject, void 0, void 0, void 0);
    }, Promise.prototype.done = function(didFulfill, didReject) {
     this._then(didFulfill, didReject, void 0, void 0, void 0)._setIsFinal();
    }, Promise.prototype.spread = function(fn) {
     return "function" != typeof fn ? apiRejection("expecting a function but got " + util.classString(fn)) : this.all()._then(fn, void 0, void 0, APPLY, void 0);
    }, Promise.prototype.toJSON = function() {
     var ret = {
      isFulfilled: !1,
      isRejected: !1,
      fulfillmentValue: void 0,
      rejectionReason: void 0
     };
     return this.isFulfilled() ? (ret.fulfillmentValue = this.value(), ret.isFulfilled = !0) : this.isRejected() && (ret.rejectionReason = this.reason(), 
     ret.isRejected = !0), ret;
    }, Promise.prototype.all = function() {
     return arguments.length > 0 && this._warn(".all() was passed arguments but it does not take any"), 
     new PromiseArray(this).promise();
    }, Promise.prototype.error = function(fn) {
     return this.caught(util.originatesFromRejection, fn);
    }, Promise.getNewLibraryCopy = module.exports, Promise.is = function(val) {
     return val instanceof Promise;
    }, Promise.fromNode = Promise.fromCallback = function(fn) {
     var ret = new Promise(INTERNAL);
     ret._captureStackTrace();
     var multiArgs = arguments.length > 1 && !!Object(arguments[1]).multiArgs, result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
     return result === errorObj && ret._rejectCallback(result.e, !0), ret._isFateSealed() || ret._setAsyncGuaranteed(), 
     ret;
    }, Promise.all = function(promises) {
     return new PromiseArray(promises).promise();
    }, Promise.cast = function(obj) {
     var ret = tryConvertToPromise(obj);
     return ret instanceof Promise || ((ret = new Promise(INTERNAL))._captureStackTrace(), 
     ret._setFulfilled(), ret._rejectionHandler0 = obj), ret;
    }, Promise.resolve = Promise.fulfilled = Promise.cast, Promise.reject = Promise.rejected = function(reason) {
     var ret = new Promise(INTERNAL);
     return ret._captureStackTrace(), ret._rejectCallback(reason, !0), ret;
    }, Promise.setScheduler = function(fn) {
     if ("function" != typeof fn) throw new TypeError("expecting a function but got " + util.classString(fn));
     return async.setScheduler(fn);
    }, Promise.prototype._then = function(didFulfill, didReject, _, receiver, internalData) {
     var haveInternalData = void 0 !== internalData, promise = haveInternalData ? internalData : new Promise(INTERNAL), target = this._target(), bitField = target._bitField;
     haveInternalData || (promise._propagateFrom(this, 3), promise._captureStackTrace(), 
     void 0 === receiver && 0 != (2097152 & this._bitField) && (receiver = 0 != (50397184 & bitField) ? this._boundValue() : target === this ? void 0 : this._boundTo), 
     this._fireEvent("promiseChained", this, promise));
     var context = getContext();
     if (0 != (50397184 & bitField)) {
      var handler, value, settler = target._settlePromiseCtx;
      0 != (33554432 & bitField) ? (value = target._rejectionHandler0, handler = didFulfill) : 0 != (16777216 & bitField) ? (value = target._fulfillmentHandler0, 
      handler = didReject, target._unsetRejectionIsUnhandled()) : (settler = target._settlePromiseLateCancellationObserver, 
      value = new CancellationError("late cancellation observer"), target._attachExtraTrace(value), 
      handler = didReject), async.invoke(settler, target, {
       handler: util.contextBind(context, handler),
       promise,
       receiver,
       value
      });
     } else target._addCallbacks(didFulfill, didReject, promise, receiver, context);
     return promise;
    }, Promise.prototype._length = function() {
     return 65535 & this._bitField;
    }, Promise.prototype._isFateSealed = function() {
     return 0 != (117506048 & this._bitField);
    }, Promise.prototype._isFollowing = function() {
     return 67108864 == (67108864 & this._bitField);
    }, Promise.prototype._setLength = function(len) {
     this._bitField = -65536 & this._bitField | 65535 & len;
    }, Promise.prototype._setFulfilled = function() {
     this._bitField = 33554432 | this._bitField, this._fireEvent("promiseFulfilled", this);
    }, Promise.prototype._setRejected = function() {
     this._bitField = 16777216 | this._bitField, this._fireEvent("promiseRejected", this);
    }, Promise.prototype._setFollowing = function() {
     this._bitField = 67108864 | this._bitField, this._fireEvent("promiseResolved", this);
    }, Promise.prototype._setIsFinal = function() {
     this._bitField = 4194304 | this._bitField;
    }, Promise.prototype._isFinal = function() {
     return (4194304 & this._bitField) > 0;
    }, Promise.prototype._unsetCancelled = function() {
     this._bitField = -65537 & this._bitField;
    }, Promise.prototype._setCancelled = function() {
     this._bitField = 65536 | this._bitField, this._fireEvent("promiseCancelled", this);
    }, Promise.prototype._setWillBeCancelled = function() {
     this._bitField = 8388608 | this._bitField;
    }, Promise.prototype._setAsyncGuaranteed = function() {
     if (!async.hasCustomScheduler()) {
      var bitField = this._bitField;
      this._bitField = bitField | (536870912 & bitField) >> 2 ^ 134217728;
     }
    }, Promise.prototype._setNoAsyncGuarantee = function() {
     this._bitField = -134217729 & (536870912 | this._bitField);
    }, Promise.prototype._receiverAt = function(index) {
     var ret = 0 === index ? this._receiver0 : this[4 * index - 4 + 3];
     if (ret !== UNDEFINED_BINDING) return void 0 === ret && this._isBound() ? this._boundValue() : ret;
    }, Promise.prototype._promiseAt = function(index) {
     return this[4 * index - 4 + 2];
    }, Promise.prototype._fulfillmentHandlerAt = function(index) {
     return this[4 * index - 4 + 0];
    }, Promise.prototype._rejectionHandlerAt = function(index) {
     return this[4 * index - 4 + 1];
    }, Promise.prototype._boundValue = function() {}, Promise.prototype._migrateCallback0 = function(follower) {
     follower._bitField;
     var fulfill = follower._fulfillmentHandler0, reject = follower._rejectionHandler0, promise = follower._promise0, receiver = follower._receiverAt(0);
     void 0 === receiver && (receiver = UNDEFINED_BINDING), this._addCallbacks(fulfill, reject, promise, receiver, null);
    }, Promise.prototype._migrateCallbackAt = function(follower, index) {
     var fulfill = follower._fulfillmentHandlerAt(index), reject = follower._rejectionHandlerAt(index), promise = follower._promiseAt(index), receiver = follower._receiverAt(index);
     void 0 === receiver && (receiver = UNDEFINED_BINDING), this._addCallbacks(fulfill, reject, promise, receiver, null);
    }, Promise.prototype._addCallbacks = function(fulfill, reject, promise, receiver, context) {
     var index = this._length();
     if (index >= 65531 && (index = 0, this._setLength(0)), 0 === index) this._promise0 = promise, 
     this._receiver0 = receiver, "function" == typeof fulfill && (this._fulfillmentHandler0 = util.contextBind(context, fulfill)), 
     "function" == typeof reject && (this._rejectionHandler0 = util.contextBind(context, reject)); else {
      var base = 4 * index - 4;
      this[base + 2] = promise, this[base + 3] = receiver, "function" == typeof fulfill && (this[base + 0] = util.contextBind(context, fulfill)), 
      "function" == typeof reject && (this[base + 1] = util.contextBind(context, reject));
     }
     return this._setLength(index + 1), index;
    }, Promise.prototype._proxy = function(proxyable, arg) {
     this._addCallbacks(void 0, void 0, arg, proxyable, null);
    }, Promise.prototype._resolveCallback = function(value, shouldBind) {
     if (0 == (117506048 & this._bitField)) {
      if (value === this) return this._rejectCallback(makeSelfResolutionError(), !1);
      var maybePromise = tryConvertToPromise(value, this);
      if (!(maybePromise instanceof Promise)) return this._fulfill(value);
      shouldBind && this._propagateFrom(maybePromise, 2);
      var promise = maybePromise._target();
      if (promise !== this) {
       var bitField = promise._bitField;
       if (0 == (50397184 & bitField)) {
        var len = this._length();
        len > 0 && promise._migrateCallback0(this);
        for (var i = 1; i < len; ++i) promise._migrateCallbackAt(this, i);
        this._setFollowing(), this._setLength(0), this._setFollowee(maybePromise);
       } else if (0 != (33554432 & bitField)) this._fulfill(promise._value()); else if (0 != (16777216 & bitField)) this._reject(promise._reason()); else {
        var reason = new CancellationError("late cancellation observer");
        promise._attachExtraTrace(reason), this._reject(reason);
       }
      } else this._reject(makeSelfResolutionError());
     }
    }, Promise.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
     var trace = util.ensureErrorObject(reason), hasStack = trace === reason;
     if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
      var message = "a promise was rejected with a non-error: " + util.classString(reason);
      this._warn(message, !0);
     }
     this._attachExtraTrace(trace, !!synchronous && hasStack), this._reject(reason);
    }, Promise.prototype._resolveFromExecutor = function(executor) {
     if (executor !== INTERNAL) {
      var promise = this;
      this._captureStackTrace(), this._pushContext();
      var synchronous = !0, r = this._execute(executor, (function(value) {
       promise._resolveCallback(value);
      }), (function(reason) {
       promise._rejectCallback(reason, synchronous);
      }));
      synchronous = !1, this._popContext(), void 0 !== r && promise._rejectCallback(r, !0);
     }
    }, Promise.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise) {
     var bitField = promise._bitField;
     if (0 == (65536 & bitField)) {
      var x;
      promise._pushContext(), receiver === APPLY ? value && "number" == typeof value.length ? x = tryCatch(handler).apply(this._boundValue(), value) : (x = errorObj).e = new TypeError("cannot .spread() a non-array: " + util.classString(value)) : x = tryCatch(handler).call(receiver, value);
      var promiseCreated = promise._popContext();
      0 == (65536 & (bitField = promise._bitField)) && (x === NEXT_FILTER ? promise._reject(value) : x === errorObj ? promise._rejectCallback(x.e, !1) : (debug.checkForgottenReturns(x, promiseCreated, "", promise, this), 
      promise._resolveCallback(x)));
     }
    }, Promise.prototype._target = function() {
     for (var ret = this; ret._isFollowing(); ) ret = ret._followee();
     return ret;
    }, Promise.prototype._followee = function() {
     return this._rejectionHandler0;
    }, Promise.prototype._setFollowee = function(promise) {
     this._rejectionHandler0 = promise;
    }, Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
     var isPromise = promise instanceof Promise, bitField = this._bitField, asyncGuaranteed = 0 != (134217728 & bitField);
     0 != (65536 & bitField) ? (isPromise && promise._invokeInternalOnCancel(), receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler() ? (receiver.cancelPromise = promise, 
     tryCatch(handler).call(receiver, value) === errorObj && promise._reject(errorObj.e)) : handler === reflectHandler ? promise._fulfill(reflectHandler.call(receiver)) : receiver instanceof Proxyable ? receiver._promiseCancelled(promise) : isPromise || promise instanceof PromiseArray ? promise._cancel() : receiver.cancel()) : "function" == typeof handler ? isPromise ? (asyncGuaranteed && promise._setAsyncGuaranteed(), 
     this._settlePromiseFromHandler(handler, receiver, value, promise)) : handler.call(receiver, value, promise) : receiver instanceof Proxyable ? receiver._isResolved() || (0 != (33554432 & bitField) ? receiver._promiseFulfilled(value, promise) : receiver._promiseRejected(value, promise)) : isPromise && (asyncGuaranteed && promise._setAsyncGuaranteed(), 
     0 != (33554432 & bitField) ? promise._fulfill(value) : promise._reject(value));
    }, Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
     var handler = ctx.handler, promise = ctx.promise, receiver = ctx.receiver, value = ctx.value;
     "function" == typeof handler ? promise instanceof Promise ? this._settlePromiseFromHandler(handler, receiver, value, promise) : handler.call(receiver, value, promise) : promise instanceof Promise && promise._reject(value);
    }, Promise.prototype._settlePromiseCtx = function(ctx) {
     this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
    }, Promise.prototype._settlePromise0 = function(handler, value, bitField) {
     var promise = this._promise0, receiver = this._receiverAt(0);
     this._promise0 = void 0, this._receiver0 = void 0, this._settlePromise(promise, handler, receiver, value);
    }, Promise.prototype._clearCallbackDataAtIndex = function(index) {
     var base = 4 * index - 4;
     this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = void 0;
    }, Promise.prototype._fulfill = function(value) {
     var bitField = this._bitField;
     if (!((117506048 & bitField) >>> 16)) {
      if (value === this) {
       var err = makeSelfResolutionError();
       return this._attachExtraTrace(err), this._reject(err);
      }
      this._setFulfilled(), this._rejectionHandler0 = value, (65535 & bitField) > 0 && (0 != (134217728 & bitField) ? this._settlePromises() : async.settlePromises(this), 
      this._dereferenceTrace());
     }
    }, Promise.prototype._reject = function(reason) {
     var bitField = this._bitField;
     if (!((117506048 & bitField) >>> 16)) {
      if (this._setRejected(), this._fulfillmentHandler0 = reason, this._isFinal()) return async.fatalError(reason, util.isNode);
      (65535 & bitField) > 0 ? async.settlePromises(this) : this._ensurePossibleRejectionHandled();
     }
    }, Promise.prototype._fulfillPromises = function(len, value) {
     for (var i = 1; i < len; i++) {
      var handler = this._fulfillmentHandlerAt(i), promise = this._promiseAt(i), receiver = this._receiverAt(i);
      this._clearCallbackDataAtIndex(i), this._settlePromise(promise, handler, receiver, value);
     }
    }, Promise.prototype._rejectPromises = function(len, reason) {
     for (var i = 1; i < len; i++) {
      var handler = this._rejectionHandlerAt(i), promise = this._promiseAt(i), receiver = this._receiverAt(i);
      this._clearCallbackDataAtIndex(i), this._settlePromise(promise, handler, receiver, reason);
     }
    }, Promise.prototype._settlePromises = function() {
     var bitField = this._bitField, len = 65535 & bitField;
     if (len > 0) {
      if (0 != (16842752 & bitField)) {
       var reason = this._fulfillmentHandler0;
       this._settlePromise0(this._rejectionHandler0, reason, bitField), this._rejectPromises(len, reason);
      } else {
       var value = this._rejectionHandler0;
       this._settlePromise0(this._fulfillmentHandler0, value, bitField), this._fulfillPromises(len, value);
      }
      this._setLength(0);
     }
     this._clearCancellationData();
    }, Promise.prototype._settledValue = function() {
     var bitField = this._bitField;
     return 0 != (33554432 & bitField) ? this._rejectionHandler0 : 0 != (16777216 & bitField) ? this._fulfillmentHandler0 : void 0;
    }, "undefined" != typeof Symbol && Symbol.toStringTag && es5.defineProperty(Promise.prototype, Symbol.toStringTag, {
     get: function() {
      return "Object";
     }
    }), Promise.defer = Promise.pending = function() {
     return debug.deprecated("Promise.defer", "new Promise"), {
      promise: new Promise(INTERNAL),
      resolve: deferResolve,
      reject: deferReject
     };
    }, util.notEnumerableProp(Promise, "_makeSelfResolutionError", makeSelfResolutionError), 
    __webpack_require__(96926)(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug), 
    __webpack_require__(23635)(Promise, INTERNAL, tryConvertToPromise, debug), __webpack_require__(11735)(Promise, PromiseArray, apiRejection, debug), 
    __webpack_require__(45632)(Promise), __webpack_require__(1958)(Promise), __webpack_require__(17717)(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async), 
    Promise.Promise = Promise, Promise.version = "3.7.2", __webpack_require__(12293)(Promise), 
    __webpack_require__(60687)(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug), 
    __webpack_require__(6343)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug), 
    __webpack_require__(61941)(Promise), __webpack_require__(79346)(Promise, INTERNAL), 
    __webpack_require__(5733)(Promise, PromiseArray, tryConvertToPromise, apiRejection), 
    __webpack_require__(94648)(Promise, INTERNAL, tryConvertToPromise, apiRejection), 
    __webpack_require__(73609)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug), 
    __webpack_require__(38615)(Promise, PromiseArray, debug), __webpack_require__(74488)(Promise, PromiseArray, apiRejection), 
    __webpack_require__(98418)(Promise, INTERNAL, debug), __webpack_require__(14525)(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug), 
    __webpack_require__(89846)(Promise), __webpack_require__(6574)(Promise, INTERNAL), 
    __webpack_require__(66777)(Promise, INTERNAL), util.toFastProperties(Promise), util.toFastProperties(Promise.prototype), 
    fillTypes({
     a: 1
    }), fillTypes({
     b: 2
    }), fillTypes({
     c: 3
    }), fillTypes(1), fillTypes((function() {})), fillTypes(void 0), fillTypes(!1), 
    fillTypes(new Promise(INTERNAL)), debug.setBounds(Async.firstLineError, util.lastLineError), 
    Promise;
   };
  },
  21640: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
    var util = __webpack_require__(75942);
    util.isArray;
    function PromiseArray(values) {
     var promise = this._promise = new Promise(INTERNAL);
     values instanceof Promise && (promise._propagateFrom(values, 3), values.suppressUnhandledRejections()), 
     promise._setOnCancel(this), this._values = values, this._length = 0, this._totalResolved = 0, 
     this._init(void 0, -2);
    }
    return util.inherits(PromiseArray, Proxyable), PromiseArray.prototype.length = function() {
     return this._length;
    }, PromiseArray.prototype.promise = function() {
     return this._promise;
    }, PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
     var values = tryConvertToPromise(this._values, this._promise);
     if (values instanceof Promise) {
      var bitField = (values = values._target())._bitField;
      if (this._values = values, 0 == (50397184 & bitField)) return this._promise._setAsyncGuaranteed(), 
      values._then(init, this._reject, void 0, this, resolveValueIfEmpty);
      if (0 == (33554432 & bitField)) return 0 != (16777216 & bitField) ? this._reject(values._reason()) : this._cancel();
      values = values._value();
     }
     if (null !== (values = util.asArray(values))) 0 !== values.length ? this._iterate(values) : -5 === resolveValueIfEmpty ? this._resolveEmptyArray() : this._resolve(function(val) {
      switch (val) {
      case -2:
       return [];

      case -3:
       return {};

      case -6:
       return new Map;
      }
     }(resolveValueIfEmpty)); else {
      var err = apiRejection("expecting an array or an iterable object but got " + util.classString(values)).reason();
      this._promise._rejectCallback(err, !1);
     }
    }, PromiseArray.prototype._iterate = function(values) {
     var len = this.getActualLength(values.length);
     this._length = len, this._values = this.shouldCopyValues() ? new Array(len) : this._values;
     for (var result = this._promise, isResolved = !1, bitField = null, i = 0; i < len; ++i) {
      var maybePromise = tryConvertToPromise(values[i], result);
      bitField = maybePromise instanceof Promise ? (maybePromise = maybePromise._target())._bitField : null, 
      isResolved ? null !== bitField && maybePromise.suppressUnhandledRejections() : null !== bitField ? 0 == (50397184 & bitField) ? (maybePromise._proxy(this, i), 
      this._values[i] = maybePromise) : isResolved = 0 != (33554432 & bitField) ? this._promiseFulfilled(maybePromise._value(), i) : 0 != (16777216 & bitField) ? this._promiseRejected(maybePromise._reason(), i) : this._promiseCancelled(i) : isResolved = this._promiseFulfilled(maybePromise, i);
     }
     isResolved || result._setAsyncGuaranteed();
    }, PromiseArray.prototype._isResolved = function() {
     return null === this._values;
    }, PromiseArray.prototype._resolve = function(value) {
     this._values = null, this._promise._fulfill(value);
    }, PromiseArray.prototype._cancel = function() {
     !this._isResolved() && this._promise._isCancellable() && (this._values = null, this._promise._cancel());
    }, PromiseArray.prototype._reject = function(reason) {
     this._values = null, this._promise._rejectCallback(reason, !1);
    }, PromiseArray.prototype._promiseFulfilled = function(value, index) {
     return this._values[index] = value, ++this._totalResolved >= this._length && (this._resolve(this._values), 
     !0);
    }, PromiseArray.prototype._promiseCancelled = function() {
     return this._cancel(), !0;
    }, PromiseArray.prototype._promiseRejected = function(reason) {
     return this._totalResolved++, this._reject(reason), !0;
    }, PromiseArray.prototype._resultCancelled = function() {
     if (!this._isResolved()) {
      var values = this._values;
      if (this._cancel(), values instanceof Promise) values.cancel(); else for (var i = 0; i < values.length; ++i) values[i] instanceof Promise && values[i].cancel();
     }
    }, PromiseArray.prototype.shouldCopyValues = function() {
     return !0;
    }, PromiseArray.prototype.getActualLength = function(len) {
     return len;
    }, PromiseArray;
   };
  },
  79346: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, INTERNAL) {
    var THIS = {}, util = __webpack_require__(75942), nodebackForPromise = __webpack_require__(81776), withAppended = util.withAppended, maybeWrapAsError = util.maybeWrapAsError, canEvaluate = util.canEvaluate, TypeError = __webpack_require__(57621).TypeError, defaultPromisified = {
     __isPromisified__: !0
    }, noCopyPropsPattern = new RegExp("^(?:" + [ "arity", "length", "name", "arguments", "caller", "callee", "prototype", "__isPromisified__" ].join("|") + ")$"), defaultFilter = function(name) {
     return util.isIdentifier(name) && "_" !== name.charAt(0) && "constructor" !== name;
    };
    function propsFilter(key) {
     return !noCopyPropsPattern.test(key);
    }
    function isPromisified(fn) {
     try {
      return !0 === fn.__isPromisified__;
     } catch (e) {
      return !1;
     }
    }
    function hasPromisified(obj, key, suffix) {
     var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
     return !!val && isPromisified(val);
    }
    function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
     for (var keys = util.inheritedDataKeys(obj), ret = [], i = 0; i < keys.length; ++i) {
      var key = keys[i], value = obj[key], passesDefaultFilter = filter === defaultFilter || defaultFilter(key, value, obj);
      "function" != typeof value || isPromisified(value) || hasPromisified(obj, key, suffix) || !filter(key, value, obj, passesDefaultFilter) || ret.push(key, value);
     }
     return function(ret, suffix, suffixRegexp) {
      for (var i = 0; i < ret.length; i += 2) {
       var key = ret[i];
       if (suffixRegexp.test(key)) for (var keyWithoutAsyncSuffix = key.replace(suffixRegexp, ""), j = 0; j < ret.length; j += 2) if (ret[j] === keyWithoutAsyncSuffix) throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
      }
     }(ret, suffix, suffixRegexp), ret;
    }
    var makeNodePromisifiedEval;
    makeNodePromisifiedEval = function(callback, receiver, originalName, fn, _, multiArgs) {
     var newParameterCount = Math.max(0, function(fn) {
      return "number" == typeof fn.length ? Math.max(Math.min(fn.length, 1024), 0) : 0;
     }(fn) - 1), argumentOrder = function(likelyArgumentCount) {
      for (var ret = [ likelyArgumentCount ], min = Math.max(0, likelyArgumentCount - 1 - 3), i = likelyArgumentCount - 1; i >= min; --i) ret.push(i);
      for (i = likelyArgumentCount + 1; i <= 3; ++i) ret.push(i);
      return ret;
     }(newParameterCount), shouldProxyThis = "string" == typeof callback || receiver === THIS;
     function generateCallForArgumentCount(count) {
      var argumentCount, args = (argumentCount = count, util.filledRange(argumentCount, "_arg", "")).join(", "), comma = count > 0 ? ", " : "";
      return (shouldProxyThis ? "ret = callback.call(this, {{args}}, nodeback); break;\n" : void 0 === receiver ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n").replace("{{args}}", args).replace(", ", comma);
     }
     var getFunctionCode = "string" == typeof callback ? "this != null ? this['" + callback + "'] : fn" : "fn", body = "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ".replace("[CodeForSwitchCase]", function() {
      for (var ret = "", i = 0; i < argumentOrder.length; ++i) ret += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
      return ret += "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
     }()).replace("[GetFunctionCode]", getFunctionCode);
     return body = body.replace("Parameters", function(parameterCount) {
      return util.filledRange(Math.max(parameterCount, 3), "_arg", "");
     }(newParameterCount)), new Function("Promise", "fn", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "tryCatch", "errorObj", "notEnumerableProp", "INTERNAL", body)(Promise, fn, receiver, withAppended, maybeWrapAsError, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL);
    };
    var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : function(callback, receiver, _, fn, __, multiArgs) {
     var defaultThis = function() {
      return this;
     }(), method = callback;
     function promisified() {
      var _receiver = receiver;
      receiver === THIS && (_receiver = this);
      var promise = new Promise(INTERNAL);
      promise._captureStackTrace();
      var cb = "string" == typeof method && this !== defaultThis ? this[method] : callback, fn = nodebackForPromise(promise, multiArgs);
      try {
       cb.apply(_receiver, withAppended(arguments, fn));
      } catch (e) {
       promise._rejectCallback(maybeWrapAsError(e), !0, !0);
      }
      return promise._isFateSealed() || promise._setAsyncGuaranteed(), promise;
     }
     return "string" == typeof method && (callback = fn), util.notEnumerableProp(promisified, "__isPromisified__", !0), 
     promisified;
    };
    function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
     for (var suffixRegexp = new RegExp(suffix.replace(/([$])/, "\\$") + "$"), methods = promisifiableMethods(obj, suffix, suffixRegexp, filter), i = 0, len = methods.length; i < len; i += 2) {
      var key = methods[i], fn = methods[i + 1], promisifiedKey = key + suffix;
      if (promisifier === makeNodePromisified) obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs); else {
       var promisified = promisifier(fn, (function() {
        return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
       }));
       util.notEnumerableProp(promisified, "__isPromisified__", !0), obj[promisifiedKey] = promisified;
      }
     }
     return util.toFastProperties(obj), obj;
    }
    Promise.promisify = function(fn, options) {
     if ("function" != typeof fn) throw new TypeError("expecting a function but got " + util.classString(fn));
     if (isPromisified(fn)) return fn;
     var ret = function(callback, receiver, multiArgs) {
      return makeNodePromisified(callback, receiver, void 0, callback, null, multiArgs);
     }(fn, void 0 === (options = Object(options)).context ? THIS : options.context, !!options.multiArgs);
     return util.copyDescriptors(fn, ret, propsFilter), ret;
    }, Promise.promisifyAll = function(target, options) {
     if ("function" != typeof target && "object" != typeof target) throw new TypeError("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
     var multiArgs = !!(options = Object(options)).multiArgs, suffix = options.suffix;
     "string" != typeof suffix && (suffix = "Async");
     var filter = options.filter;
     "function" != typeof filter && (filter = defaultFilter);
     var promisifier = options.promisifier;
     if ("function" != typeof promisifier && (promisifier = makeNodePromisified), !util.isIdentifier(suffix)) throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
     for (var keys = util.inheritedDataKeys(target), i = 0; i < keys.length; ++i) {
      var value = target[keys[i]];
      "constructor" !== keys[i] && util.isClass(value) && (promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs), 
      promisifyAll(value, suffix, filter, promisifier, multiArgs));
     }
     return promisifyAll(target, suffix, filter, promisifier, multiArgs);
    };
   };
  },
  5733: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, PromiseArray, tryConvertToPromise, apiRejection) {
    var Es6Map, util = __webpack_require__(75942), isObject = util.isObject, es5 = __webpack_require__(89571);
    "function" == typeof Map && (Es6Map = Map);
    var mapToEntries = function() {
     var index = 0, size = 0;
     function extractEntry(value, key) {
      this[index] = value, this[index + size] = key, index++;
     }
     return function(map) {
      size = map.size, index = 0;
      var ret = new Array(2 * map.size);
      return map.forEach(extractEntry, ret), ret;
     };
    }();
    function PropertiesPromiseArray(obj) {
     var entries, isMap = !1;
     if (void 0 !== Es6Map && obj instanceof Es6Map) entries = mapToEntries(obj), isMap = !0; else {
      var keys = es5.keys(obj), len = keys.length;
      entries = new Array(2 * len);
      for (var i = 0; i < len; ++i) {
       var key = keys[i];
       entries[i] = obj[key], entries[i + len] = key;
      }
     }
     this.constructor$(entries), this._isMap = isMap, this._init$(void 0, isMap ? -6 : -3);
    }
    function props(promises) {
     var ret, castValue = tryConvertToPromise(promises);
     return isObject(castValue) ? (ret = castValue instanceof Promise ? castValue._then(Promise.props, void 0, void 0, void 0, void 0) : new PropertiesPromiseArray(castValue).promise(), 
     castValue instanceof Promise && ret._propagateFrom(castValue, 2), ret) : apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
    }
    util.inherits(PropertiesPromiseArray, PromiseArray), PropertiesPromiseArray.prototype._init = function() {}, 
    PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
     if (this._values[index] = value, ++this._totalResolved >= this._length) {
      var val;
      if (this._isMap) val = function(entries) {
       for (var ret = new Es6Map, length = entries.length / 2 | 0, i = 0; i < length; ++i) {
        var key = entries[length + i], value = entries[i];
        ret.set(key, value);
       }
       return ret;
      }(this._values); else {
       val = {};
       for (var keyOffset = this.length(), i = 0, len = this.length(); i < len; ++i) val[this._values[i + keyOffset]] = this._values[i];
      }
      return this._resolve(val), !0;
     }
     return !1;
    }, PropertiesPromiseArray.prototype.shouldCopyValues = function() {
     return !1;
    }, PropertiesPromiseArray.prototype.getActualLength = function(len) {
     return len >> 1;
    }, Promise.prototype.props = function() {
     return props(this);
    }, Promise.props = function(promises) {
     return props(promises);
    };
   };
  },
  7824: module => {
   "use strict";
   function Queue(capacity) {
    this._capacity = capacity, this._length = 0, this._front = 0;
   }
   Queue.prototype._willBeOverCapacity = function(size) {
    return this._capacity < size;
   }, Queue.prototype._pushOne = function(arg) {
    var length = this.length();
    this._checkCapacity(length + 1), this[this._front + length & this._capacity - 1] = arg, 
    this._length = length + 1;
   }, Queue.prototype.push = function(fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) return this._pushOne(fn), this._pushOne(receiver), 
    void this._pushOne(arg);
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[j + 0 & wrapMask] = fn, this[j + 1 & wrapMask] = receiver, this[j + 2 & wrapMask] = arg, 
    this._length = length;
   }, Queue.prototype.shift = function() {
    var front = this._front, ret = this[front];
    return this[front] = void 0, this._front = front + 1 & this._capacity - 1, this._length--, 
    ret;
   }, Queue.prototype.length = function() {
    return this._length;
   }, Queue.prototype._checkCapacity = function(size) {
    this._capacity < size && this._resizeTo(this._capacity << 1);
   }, Queue.prototype._resizeTo = function(capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity, function(src, srcIndex, dst, dstIndex, len) {
     for (var j = 0; j < len; ++j) dst[j + dstIndex] = src[j + srcIndex], src[j + srcIndex] = void 0;
    }(this, 0, this, oldCapacity, this._front + this._length & oldCapacity - 1);
   }, module.exports = Queue;
  },
  94648: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
    var util = __webpack_require__(75942);
    function race(promises, parent) {
     var promise, maybePromise = tryConvertToPromise(promises);
     if (maybePromise instanceof Promise) return (promise = maybePromise).then((function(array) {
      return race(array, promise);
     }));
     if (null === (promises = util.asArray(promises))) return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
     var ret = new Promise(INTERNAL);
     void 0 !== parent && ret._propagateFrom(parent, 3);
     for (var fulfill = ret._fulfill, reject = ret._reject, i = 0, len = promises.length; i < len; ++i) {
      var val = promises[i];
      (void 0 !== val || i in promises) && Promise.cast(val)._then(fulfill, reject, void 0, ret, null);
     }
     return ret;
    }
    Promise.race = function(promises) {
     return race(promises, void 0);
    }, Promise.prototype.race = function() {
     return race(this, void 0);
    };
   };
  },
  73609: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var util = __webpack_require__(75942), tryCatch = util.tryCatch;
    function ReductionPromiseArray(promises, fn, initialValue, _each) {
     this.constructor$(promises);
     var context = Promise._getContext();
     this._fn = util.contextBind(context, fn), void 0 !== initialValue && (initialValue = Promise.resolve(initialValue))._attachCancellationCallback(this), 
     this._initialValue = initialValue, this._currentCancellable = null, this._eachValues = _each === INTERNAL ? Array(this._length) : 0 === _each ? null : void 0, 
     this._promise._captureStackTrace(), this._init$(void 0, -5);
    }
    function completed(valueOrReason, array) {
     this.isFulfilled() ? array._resolve(valueOrReason) : array._reject(valueOrReason);
    }
    function reduce(promises, fn, initialValue, _each) {
     return "function" != typeof fn ? apiRejection("expecting a function but got " + util.classString(fn)) : new ReductionPromiseArray(promises, fn, initialValue, _each).promise();
    }
    function gotAccum(accum) {
     this.accum = accum, this.array._gotAccum(accum);
     var value = tryConvertToPromise(this.value, this.array._promise);
     return value instanceof Promise ? (this.array._currentCancellable = value, value._then(gotValue, void 0, void 0, this, void 0)) : gotValue.call(this, value);
    }
    function gotValue(value) {
     var ret, array = this.array, promise = array._promise, fn = tryCatch(array._fn);
     promise._pushContext(), (ret = void 0 !== array._eachValues ? fn.call(promise._boundValue(), value, this.index, this.length) : fn.call(promise._boundValue(), this.accum, value, this.index, this.length)) instanceof Promise && (array._currentCancellable = ret);
     var promiseCreated = promise._popContext();
     return debug.checkForgottenReturns(ret, promiseCreated, void 0 !== array._eachValues ? "Promise.each" : "Promise.reduce", promise), 
     ret;
    }
    util.inherits(ReductionPromiseArray, PromiseArray), ReductionPromiseArray.prototype._gotAccum = function(accum) {
     void 0 !== this._eachValues && null !== this._eachValues && accum !== INTERNAL && this._eachValues.push(accum);
    }, ReductionPromiseArray.prototype._eachComplete = function(value) {
     return null !== this._eachValues && this._eachValues.push(value), this._eachValues;
    }, ReductionPromiseArray.prototype._init = function() {}, ReductionPromiseArray.prototype._resolveEmptyArray = function() {
     this._resolve(void 0 !== this._eachValues ? this._eachValues : this._initialValue);
    }, ReductionPromiseArray.prototype.shouldCopyValues = function() {
     return !1;
    }, ReductionPromiseArray.prototype._resolve = function(value) {
     this._promise._resolveCallback(value), this._values = null;
    }, ReductionPromiseArray.prototype._resultCancelled = function(sender) {
     if (sender === this._initialValue) return this._cancel();
     this._isResolved() || (this._resultCancelled$(), this._currentCancellable instanceof Promise && this._currentCancellable.cancel(), 
     this._initialValue instanceof Promise && this._initialValue.cancel());
    }, ReductionPromiseArray.prototype._iterate = function(values) {
     var value, i;
     this._values = values;
     var length = values.length;
     void 0 !== this._initialValue ? (value = this._initialValue, i = 0) : (value = Promise.resolve(values[0]), 
     i = 1), this._currentCancellable = value;
     for (var j = i; j < length; ++j) {
      var maybePromise = values[j];
      maybePromise instanceof Promise && maybePromise.suppressUnhandledRejections();
     }
     if (!value.isRejected()) for (;i < length; ++i) {
      var ctx = {
       accum: null,
       value: values[i],
       index: i,
       length,
       array: this
      };
      value = value._then(gotAccum, void 0, void 0, ctx, void 0), 0 == (127 & i) && value._setNoAsyncGuarantee();
     }
     void 0 !== this._eachValues && (value = value._then(this._eachComplete, void 0, void 0, this, void 0)), 
     value._then(completed, completed, void 0, value, this);
    }, Promise.prototype.reduce = function(fn, initialValue) {
     return reduce(this, fn, initialValue, null);
    }, Promise.reduce = function(promises, fn, initialValue, _each) {
     return reduce(promises, fn, initialValue, _each);
    };
   };
  },
  10679: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var schedule, util = __webpack_require__(75942), NativePromise = util.getNativePromise();
   if (util.isNode && "undefined" == typeof MutationObserver) {
    var GlobalSetImmediate = global.setImmediate, ProcessNextTick = process.nextTick;
    schedule = util.isRecentNode ? function(fn) {
     GlobalSetImmediate.call(global, fn);
    } : function(fn) {
     ProcessNextTick.call(process, fn);
    };
   } else if ("function" == typeof NativePromise && "function" == typeof NativePromise.resolve) {
    var nativePromise = NativePromise.resolve();
    schedule = function(fn) {
     nativePromise.then(fn);
    };
   } else schedule = "undefined" == typeof MutationObserver || "undefined" != typeof window && window.navigator && (window.navigator.standalone || window.cordova) || !("classList" in document.documentElement) ? "undefined" != typeof setImmediate ? function(fn) {
    setImmediate(fn);
   } : "undefined" != typeof setTimeout ? function(fn) {
    setTimeout(fn, 0);
   } : function() {
    throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
   } : function() {
    var div = document.createElement("div"), opts = {
     attributes: !0
    }, toggleScheduled = !1, div2 = document.createElement("div");
    new MutationObserver((function() {
     div.classList.toggle("foo"), toggleScheduled = !1;
    })).observe(div2, opts);
    return function(fn) {
     var o = new MutationObserver((function() {
      o.disconnect(), fn();
     }));
     o.observe(div, opts), toggleScheduled || (toggleScheduled = !0, div2.classList.toggle("foo"));
    };
   }();
   module.exports = schedule;
  },
  38615: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, PromiseArray, debug) {
    var PromiseInspection = Promise.PromiseInspection;
    function SettledPromiseArray(values) {
     this.constructor$(values);
    }
    __webpack_require__(75942).inherits(SettledPromiseArray, PromiseArray), SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
     return this._values[index] = inspection, ++this._totalResolved >= this._length && (this._resolve(this._values), 
     !0);
    }, SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
     var ret = new PromiseInspection;
     return ret._bitField = 33554432, ret._settledValueField = value, this._promiseResolved(index, ret);
    }, SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
     var ret = new PromiseInspection;
     return ret._bitField = 16777216, ret._settledValueField = reason, this._promiseResolved(index, ret);
    }, Promise.settle = function(promises) {
     return debug.deprecated(".settle()", ".reflect()"), new SettledPromiseArray(promises).promise();
    }, Promise.allSettled = function(promises) {
     return new SettledPromiseArray(promises).promise();
    }, Promise.prototype.settle = function() {
     return Promise.settle(this);
    };
   };
  },
  74488: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, PromiseArray, apiRejection) {
    var util = __webpack_require__(75942), RangeError = __webpack_require__(57621).RangeError, AggregateError = __webpack_require__(57621).AggregateError, isArray = util.isArray, CANCELLATION = {};
    function SomePromiseArray(values) {
     this.constructor$(values), this._howMany = 0, this._unwrap = !1, this._initialized = !1;
    }
    function some(promises, howMany) {
     if ((0 | howMany) !== howMany || howMany < 0) return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
     var ret = new SomePromiseArray(promises), promise = ret.promise();
     return ret.setHowMany(howMany), ret.init(), promise;
    }
    util.inherits(SomePromiseArray, PromiseArray), SomePromiseArray.prototype._init = function() {
     if (this._initialized) if (0 !== this._howMany) {
      this._init$(void 0, -5);
      var isArrayResolved = isArray(this._values);
      !this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill() && this._reject(this._getRangeError(this.length()));
     } else this._resolve([]);
    }, SomePromiseArray.prototype.init = function() {
     this._initialized = !0, this._init();
    }, SomePromiseArray.prototype.setUnwrap = function() {
     this._unwrap = !0;
    }, SomePromiseArray.prototype.howMany = function() {
     return this._howMany;
    }, SomePromiseArray.prototype.setHowMany = function(count) {
     this._howMany = count;
    }, SomePromiseArray.prototype._promiseFulfilled = function(value) {
     return this._addFulfilled(value), this._fulfilled() === this.howMany() && (this._values.length = this.howMany(), 
     1 === this.howMany() && this._unwrap ? this._resolve(this._values[0]) : this._resolve(this._values), 
     !0);
    }, SomePromiseArray.prototype._promiseRejected = function(reason) {
     return this._addRejected(reason), this._checkOutcome();
    }, SomePromiseArray.prototype._promiseCancelled = function() {
     return this._values instanceof Promise || null == this._values ? this._cancel() : (this._addRejected(CANCELLATION), 
     this._checkOutcome());
    }, SomePromiseArray.prototype._checkOutcome = function() {
     if (this.howMany() > this._canPossiblyFulfill()) {
      for (var e = new AggregateError, i = this.length(); i < this._values.length; ++i) this._values[i] !== CANCELLATION && e.push(this._values[i]);
      return e.length > 0 ? this._reject(e) : this._cancel(), !0;
     }
     return !1;
    }, SomePromiseArray.prototype._fulfilled = function() {
     return this._totalResolved;
    }, SomePromiseArray.prototype._rejected = function() {
     return this._values.length - this.length();
    }, SomePromiseArray.prototype._addRejected = function(reason) {
     this._values.push(reason);
    }, SomePromiseArray.prototype._addFulfilled = function(value) {
     this._values[this._totalResolved++] = value;
    }, SomePromiseArray.prototype._canPossiblyFulfill = function() {
     return this.length() - this._rejected();
    }, SomePromiseArray.prototype._getRangeError = function(count) {
     var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
     return new RangeError(message);
    }, SomePromiseArray.prototype._resolveEmptyArray = function() {
     this._reject(this._getRangeError(0));
    }, Promise.some = function(promises, howMany) {
     return some(promises, howMany);
    }, Promise.prototype.some = function(howMany) {
     return some(this, howMany);
    }, Promise._SomePromiseArray = SomePromiseArray;
   };
  },
  1958: module => {
   "use strict";
   module.exports = function(Promise) {
    function PromiseInspection(promise) {
     void 0 !== promise ? (promise = promise._target(), this._bitField = promise._bitField, 
     this._settledValueField = promise._isFateSealed() ? promise._settledValue() : void 0) : (this._bitField = 0, 
     this._settledValueField = void 0);
    }
    PromiseInspection.prototype._settledValue = function() {
     return this._settledValueField;
    };
    var value = PromiseInspection.prototype.value = function() {
     if (!this.isFulfilled()) throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
     return this._settledValue();
    }, reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
     if (!this.isRejected()) throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
     return this._settledValue();
    }, isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
     return 0 != (33554432 & this._bitField);
    }, isRejected = PromiseInspection.prototype.isRejected = function() {
     return 0 != (16777216 & this._bitField);
    }, isPending = PromiseInspection.prototype.isPending = function() {
     return 0 == (50397184 & this._bitField);
    }, isResolved = PromiseInspection.prototype.isResolved = function() {
     return 0 != (50331648 & this._bitField);
    };
    PromiseInspection.prototype.isCancelled = function() {
     return 0 != (8454144 & this._bitField);
    }, Promise.prototype.__isCancelled = function() {
     return 65536 == (65536 & this._bitField);
    }, Promise.prototype._isCancelled = function() {
     return this._target().__isCancelled();
    }, Promise.prototype.isCancelled = function() {
     return 0 != (8454144 & this._target()._bitField);
    }, Promise.prototype.isPending = function() {
     return isPending.call(this._target());
    }, Promise.prototype.isRejected = function() {
     return isRejected.call(this._target());
    }, Promise.prototype.isFulfilled = function() {
     return isFulfilled.call(this._target());
    }, Promise.prototype.isResolved = function() {
     return isResolved.call(this._target());
    }, Promise.prototype.value = function() {
     return value.call(this._target());
    }, Promise.prototype.reason = function() {
     var target = this._target();
     return target._unsetRejectionIsUnhandled(), reason.call(target);
    }, Promise.prototype._value = function() {
     return this._settledValue();
    }, Promise.prototype._reason = function() {
     return this._unsetRejectionIsUnhandled(), this._settledValue();
    }, Promise.PromiseInspection = PromiseInspection;
   };
  },
  91778: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, INTERNAL) {
    var util = __webpack_require__(75942), errorObj = util.errorObj, isObject = util.isObject;
    var hasProp = {}.hasOwnProperty;
    return function(obj, context) {
     if (isObject(obj)) {
      if (obj instanceof Promise) return obj;
      var then = function(obj) {
       try {
        return function(obj) {
         return obj.then;
        }(obj);
       } catch (e) {
        return errorObj.e = e, errorObj;
       }
      }(obj);
      if (then === errorObj) {
       context && context._pushContext();
       var ret = Promise.reject(then.e);
       return context && context._popContext(), ret;
      }
      if ("function" == typeof then) {
       if (function(obj) {
        try {
         return hasProp.call(obj, "_promise0");
        } catch (e) {
         return !1;
        }
       }(obj)) {
        ret = new Promise(INTERNAL);
        return obj._then(ret._fulfill, ret._reject, void 0, ret, null), ret;
       }
       return function(x, then, context) {
        var promise = new Promise(INTERNAL), ret = promise;
        context && context._pushContext();
        promise._captureStackTrace(), context && context._popContext();
        var synchronous = !0, result = util.tryCatch(then).call(x, resolve, reject);
        synchronous = !1, promise && result === errorObj && (promise._rejectCallback(result.e, !0, !0), 
        promise = null);
        function resolve(value) {
         promise && (promise._resolveCallback(value), promise = null);
        }
        function reject(reason) {
         promise && (promise._rejectCallback(reason, synchronous, !0), promise = null);
        }
        return ret;
       }(obj, then, context);
      }
     }
     return obj;
    };
   };
  },
  98418: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, INTERNAL, debug) {
    var util = __webpack_require__(75942), TimeoutError = Promise.TimeoutError;
    function HandleWrapper(handle) {
     this.handle = handle;
    }
    HandleWrapper.prototype._resultCancelled = function() {
     clearTimeout(this.handle);
    };
    var afterValue = function(value) {
     return delay(+this).thenReturn(value);
    }, delay = Promise.delay = function(ms, value) {
     var ret, handle;
     return void 0 !== value ? (ret = Promise.resolve(value)._then(afterValue, null, null, ms, void 0), 
     debug.cancellation() && value instanceof Promise && ret._setOnCancel(value)) : (ret = new Promise(INTERNAL), 
     handle = setTimeout((function() {
      ret._fulfill();
     }), +ms), debug.cancellation() && ret._setOnCancel(new HandleWrapper(handle)), ret._captureStackTrace()), 
     ret._setAsyncGuaranteed(), ret;
    };
    Promise.prototype.delay = function(ms) {
     return delay(ms, this);
    };
    function successClear(value) {
     return clearTimeout(this.handle), value;
    }
    function failureClear(reason) {
     throw clearTimeout(this.handle), reason;
    }
    Promise.prototype.timeout = function(ms, message) {
     var ret, parent;
     ms = +ms;
     var handleWrapper = new HandleWrapper(setTimeout((function() {
      ret.isPending() && function(promise, message, parent) {
       var err;
       err = "string" != typeof message ? message instanceof Error ? message : new TimeoutError("operation timed out") : new TimeoutError(message), 
       util.markAsOriginatingFromRejection(err), promise._attachExtraTrace(err), promise._reject(err), 
       null != parent && parent.cancel();
      }(ret, message, parent);
     }), ms));
     return debug.cancellation() ? (parent = this.then(), (ret = parent._then(successClear, failureClear, void 0, handleWrapper, void 0))._setOnCancel(handleWrapper)) : ret = this._then(successClear, failureClear, void 0, handleWrapper, void 0), 
     ret;
    };
   };
  },
  14525: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
    var util = __webpack_require__(75942), TypeError = __webpack_require__(57621).TypeError, inherits = __webpack_require__(75942).inherits, errorObj = util.errorObj, tryCatch = util.tryCatch, NULL = {};
    function thrower(e) {
     setTimeout((function() {
      throw e;
     }), 0);
    }
    function dispose(resources, inspection) {
     var i = 0, len = resources.length, ret = new Promise(INTERNAL);
     return function iterator() {
      if (i >= len) return ret._fulfill();
      var maybePromise = function(thenable) {
       var maybePromise = tryConvertToPromise(thenable);
       return maybePromise !== thenable && "function" == typeof thenable._isDisposable && "function" == typeof thenable._getDisposer && thenable._isDisposable() && maybePromise._setDisposable(thenable._getDisposer()), 
       maybePromise;
      }(resources[i++]);
      if (maybePromise instanceof Promise && maybePromise._isDisposable()) {
       try {
        maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
       } catch (e) {
        return thrower(e);
       }
       if (maybePromise instanceof Promise) return maybePromise._then(iterator, thrower, null, null, null);
      }
      iterator();
     }(), ret;
    }
    function Disposer(data, promise, context) {
     this._data = data, this._promise = promise, this._context = context;
    }
    function FunctionDisposer(fn, promise, context) {
     this.constructor$(fn, promise, context);
    }
    function maybeUnwrapDisposer(value) {
     return Disposer.isDisposer(value) ? (this.resources[this.index]._setDisposable(value), 
     value.promise()) : value;
    }
    function ResourceList(length) {
     this.length = length, this.promise = null, this[length - 1] = null;
    }
    Disposer.prototype.data = function() {
     return this._data;
    }, Disposer.prototype.promise = function() {
     return this._promise;
    }, Disposer.prototype.resource = function() {
     return this.promise().isFulfilled() ? this.promise().value() : NULL;
    }, Disposer.prototype.tryDispose = function(inspection) {
     var resource = this.resource(), context = this._context;
     void 0 !== context && context._pushContext();
     var ret = resource !== NULL ? this.doDispose(resource, inspection) : null;
     return void 0 !== context && context._popContext(), this._promise._unsetDisposable(), 
     this._data = null, ret;
    }, Disposer.isDisposer = function(d) {
     return null != d && "function" == typeof d.resource && "function" == typeof d.tryDispose;
    }, inherits(FunctionDisposer, Disposer), FunctionDisposer.prototype.doDispose = function(resource, inspection) {
     return this.data().call(resource, resource, inspection);
    }, ResourceList.prototype._resultCancelled = function() {
     for (var len = this.length, i = 0; i < len; ++i) {
      var item = this[i];
      item instanceof Promise && item.cancel();
     }
    }, Promise.using = function() {
     var len = arguments.length;
     if (len < 2) return apiRejection("you must pass at least 2 arguments to Promise.using");
     var input, fn = arguments[len - 1];
     if ("function" != typeof fn) return apiRejection("expecting a function but got " + util.classString(fn));
     var spreadArgs = !0;
     2 === len && Array.isArray(arguments[0]) ? (len = (input = arguments[0]).length, 
     spreadArgs = !1) : (input = arguments, len--);
     for (var resources = new ResourceList(len), i = 0; i < len; ++i) {
      var resource = input[i];
      if (Disposer.isDisposer(resource)) {
       var disposer = resource;
       (resource = resource.promise())._setDisposable(disposer);
      } else {
       var maybePromise = tryConvertToPromise(resource);
       maybePromise instanceof Promise && (resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
        resources,
        index: i
       }, void 0));
      }
      resources[i] = resource;
     }
     var reflectedResources = new Array(resources.length);
     for (i = 0; i < reflectedResources.length; ++i) reflectedResources[i] = Promise.resolve(resources[i]).reflect();
     var resultPromise = Promise.all(reflectedResources).then((function(inspections) {
      for (var i = 0; i < inspections.length; ++i) {
       var inspection = inspections[i];
       if (inspection.isRejected()) return errorObj.e = inspection.error(), errorObj;
       if (!inspection.isFulfilled()) return void resultPromise.cancel();
       inspections[i] = inspection.value();
      }
      promise._pushContext(), fn = tryCatch(fn);
      var ret = spreadArgs ? fn.apply(void 0, inspections) : fn(inspections), promiseCreated = promise._popContext();
      return debug.checkForgottenReturns(ret, promiseCreated, "Promise.using", promise), 
      ret;
     })), promise = resultPromise.lastly((function() {
      var inspection = new Promise.PromiseInspection(resultPromise);
      return dispose(resources, inspection);
     }));
     return resources.promise = promise, promise._setOnCancel(resources), promise;
    }, Promise.prototype._setDisposable = function(disposer) {
     this._bitField = 131072 | this._bitField, this._disposer = disposer;
    }, Promise.prototype._isDisposable = function() {
     return (131072 & this._bitField) > 0;
    }, Promise.prototype._getDisposer = function() {
     return this._disposer;
    }, Promise.prototype._unsetDisposable = function() {
     this._bitField = -131073 & this._bitField, this._disposer = void 0;
    }, Promise.prototype.disposer = function(fn) {
     if ("function" == typeof fn) return new FunctionDisposer(fn, this, createContext());
     throw new TypeError;
    };
   };
  },
  75942: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var es5 = __webpack_require__(89571), canEvaluate = "undefined" == typeof navigator, errorObj = {
    e: {}
   }, tryCatchTarget, globalObject = "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : void 0 !== this ? this : null;
   function tryCatcher() {
    try {
     var target = tryCatchTarget;
     return tryCatchTarget = null, target.apply(this, arguments);
    } catch (e) {
     return errorObj.e = e, errorObj;
    }
   }
   function tryCatch(fn) {
    return tryCatchTarget = fn, tryCatcher;
   }
   var inherits = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;
    function T() {
     for (var propertyName in this.constructor = Child, this.constructor$ = Parent, Parent.prototype) hasProp.call(Parent.prototype, propertyName) && "$" !== propertyName.charAt(propertyName.length - 1) && (this[propertyName + "$"] = Parent.prototype[propertyName]);
    }
    return T.prototype = Parent.prototype, Child.prototype = new T, Child.prototype;
   };
   function isPrimitive(val) {
    return null == val || !0 === val || !1 === val || "string" == typeof val || "number" == typeof val;
   }
   function isObject(value) {
    return "function" == typeof value || "object" == typeof value && null !== value;
   }
   function maybeWrapAsError(maybeError) {
    return isPrimitive(maybeError) ? new Error(safeToString(maybeError)) : maybeError;
   }
   function withAppended(target, appendee) {
    var i, len = target.length, ret = new Array(len + 1);
    for (i = 0; i < len; ++i) ret[i] = target[i];
    return ret[i] = appendee, ret;
   }
   function getDataPropertyOrDefault(obj, key, defaultValue) {
    if (!es5.isES5) return {}.hasOwnProperty.call(obj, key) ? obj[key] : void 0;
    var desc = Object.getOwnPropertyDescriptor(obj, key);
    return null != desc ? null == desc.get && null == desc.set ? desc.value : defaultValue : void 0;
   }
   function notEnumerableProp(obj, name, value) {
    if (isPrimitive(obj)) return obj;
    var descriptor = {
     value,
     configurable: !0,
     enumerable: !1,
     writable: !0
    };
    return es5.defineProperty(obj, name, descriptor), obj;
   }
   function thrower(r) {
    throw r;
   }
   var inheritedDataKeys = function() {
    var excludedPrototypes = [ Array.prototype, Object.prototype, Function.prototype ], isExcludedProto = function(val) {
     for (var i = 0; i < excludedPrototypes.length; ++i) if (excludedPrototypes[i] === val) return !0;
     return !1;
    };
    if (es5.isES5) {
     var getKeys = Object.getOwnPropertyNames;
     return function(obj) {
      for (var ret = [], visitedKeys = Object.create(null); null != obj && !isExcludedProto(obj); ) {
       var keys;
       try {
        keys = getKeys(obj);
       } catch (e) {
        return ret;
       }
       for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (!visitedKeys[key]) {
         visitedKeys[key] = !0;
         var desc = Object.getOwnPropertyDescriptor(obj, key);
         null != desc && null == desc.get && null == desc.set && ret.push(key);
        }
       }
       obj = es5.getPrototypeOf(obj);
      }
      return ret;
     };
    }
    var hasProp = {}.hasOwnProperty;
    return function(obj) {
     if (isExcludedProto(obj)) return [];
     var ret = [];
     enumeration: for (var key in obj) if (hasProp.call(obj, key)) ret.push(key); else {
      for (var i = 0; i < excludedPrototypes.length; ++i) if (hasProp.call(excludedPrototypes[i], key)) continue enumeration;
      ret.push(key);
     }
     return ret;
    };
   }(), thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
   function isClass(fn) {
    try {
     if ("function" == typeof fn) {
      var keys = es5.names(fn.prototype), hasMethods = es5.isES5 && keys.length > 1, hasMethodsOtherThanConstructor = keys.length > 0 && !(1 === keys.length && "constructor" === keys[0]), hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
      if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) return !0;
     }
     return !1;
    } catch (e) {
     return !1;
    }
   }
   function toFastProperties(obj) {
    function FakeConstructor() {}
    FakeConstructor.prototype = obj;
    var receiver = new FakeConstructor;
    function ic() {
     return typeof receiver.foo;
    }
    return ic(), ic(), obj;
   }
   var rident = /^[a-z$_][a-z$_0-9]*$/i;
   function isIdentifier(str) {
    return rident.test(str);
   }
   function filledRange(count, prefix, suffix) {
    for (var ret = new Array(count), i = 0; i < count; ++i) ret[i] = prefix + i + suffix;
    return ret;
   }
   function safeToString(obj) {
    try {
     return obj + "";
    } catch (e) {
     return "[no string representation]";
    }
   }
   function isError(obj) {
    return obj instanceof Error || null !== obj && "object" == typeof obj && "string" == typeof obj.message && "string" == typeof obj.name;
   }
   function markAsOriginatingFromRejection(e) {
    try {
     notEnumerableProp(e, "isOperational", !0);
    } catch (ignore) {}
   }
   function originatesFromRejection(e) {
    return null != e && (e instanceof Error.__BluebirdErrorTypes__.OperationalError || !0 === e.isOperational);
   }
   function canAttachTrace(obj) {
    return isError(obj) && es5.propertyIsWritable(obj, "stack");
   }
   var ensureErrorObject = "stack" in new Error ? function(value) {
    return canAttachTrace(value) ? value : new Error(safeToString(value));
   } : function(value) {
    if (canAttachTrace(value)) return value;
    try {
     throw new Error(safeToString(value));
    } catch (err) {
     return err;
    }
   };
   function classString(obj) {
    return {}.toString.call(obj);
   }
   function copyDescriptors(from, to, filter) {
    for (var keys = es5.names(from), i = 0; i < keys.length; ++i) {
     var key = keys[i];
     if (filter(key)) try {
      es5.defineProperty(to, key, es5.getDescriptor(from, key));
     } catch (ignore) {}
    }
   }
   var asArray = function(v) {
    return es5.isArray(v) ? v : null;
   };
   if ("undefined" != typeof Symbol && Symbol.iterator) {
    var ArrayFrom = "function" == typeof Array.from ? function(v) {
     return Array.from(v);
    } : function(v) {
     for (var itResult, ret = [], it = v[Symbol.iterator](); !(itResult = it.next()).done; ) ret.push(itResult.value);
     return ret;
    };
    asArray = function(v) {
     return es5.isArray(v) ? v : null != v && "function" == typeof v[Symbol.iterator] ? ArrayFrom(v) : null;
    };
   }
   var isNode = "undefined" != typeof process && "[object process]" === classString(process).toLowerCase(), hasEnvVariables = "undefined" != typeof process && void 0 !== process.env, reflectHandler;
   function env(key) {
    return hasEnvVariables ? process.env[key] : void 0;
   }
   function getNativePromise() {
    if ("function" == typeof Promise) try {
     if ("[object Promise]" === classString(new Promise((function() {})))) return Promise;
    } catch (e) {}
   }
   function contextBind(ctx, cb) {
    if (null === ctx || "function" != typeof cb || cb === reflectHandler) return cb;
    null !== ctx.domain && (cb = ctx.domain.bind(cb));
    var async = ctx.async;
    if (null !== async) {
     var old = cb;
     cb = function() {
      for (var $_len = arguments.length + 2, args = new Array($_len), $_i = 2; $_i < $_len; ++$_i) args[$_i] = arguments[$_i - 2];
      return args[0] = old, args[1] = this, async.runInAsyncScope.apply(async, args);
     };
    }
    return cb;
   }
   var ret = {
    setReflectHandler: function(fn) {
     reflectHandler = fn;
    },
    isClass,
    isIdentifier,
    inheritedDataKeys,
    getDataPropertyOrDefault,
    thrower,
    isArray: es5.isArray,
    asArray,
    notEnumerableProp,
    isPrimitive,
    isObject,
    isError,
    canEvaluate,
    errorObj,
    tryCatch,
    inherits,
    withAppended,
    maybeWrapAsError,
    toFastProperties,
    filledRange,
    toString: safeToString,
    canAttachTrace,
    ensureErrorObject,
    originatesFromRejection,
    markAsOriginatingFromRejection,
    classString,
    copyDescriptors,
    isNode,
    hasEnvVariables,
    env,
    global: globalObject,
    getNativePromise,
    contextBind
   }, version;
   ret.isRecentNode = ret.isNode && (process.versions && process.versions.node ? version = process.versions.node.split(".").map(Number) : process.version && (version = process.version.split(".").map(Number)), 
   0 === version[0] && version[1] > 10 || version[0] > 0), ret.nodeSupportsAsyncResource = ret.isNode && function() {
    var supportsAsync = !1;
    try {
     supportsAsync = "function" == typeof __webpack_require__(50852).AsyncResource.prototype.runInAsyncScope;
    } catch (e) {
     supportsAsync = !1;
    }
    return supportsAsync;
   }(), ret.isNode && ret.toFastProperties(process);
   try {
    throw new Error;
   } catch (e) {
    ret.lastLineError = e;
   }
   module.exports = ret;
  },
  44046: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   const util = __webpack_require__(73837), assert = __webpack_require__(39491), wrapEmitter = __webpack_require__(69867), asyncHook = __webpack_require__(73223), invertedProviders = [];
   for (let key in asyncHook.providers) invertedProviders[asyncHook.providers[key]] = key;
   const DEBUG_CLS_HOOKED = process.env.DEBUG_CLS_HOOKED;
   let currentUid = -1;
   function Namespace(name) {
    this.name = name, this.active = null, this._set = [], this.id = null, this._contexts = new Map;
   }
   function getNamespace(name) {
    return process.namespaces[name];
   }
   function destroyNamespace(name) {
    let namespace = getNamespace(name);
    assert.ok(namespace, "can't delete nonexistent namespace! \"" + name + '"'), assert.ok(namespace.id, "don't assign to process.namespaces directly! " + util.inspect(namespace)), 
    process.namespaces[name] = null;
   }
   function debug2(msg) {
    process.env.DEBUG && process._rawDebug(msg);
   }
   function getFunctionName(fn) {
    return fn ? "function" == typeof fn ? fn.name ? fn.name : (fn.toString().trim().match(/^function\s*([^\s(]+)/) || [])[1] : fn.constructor && fn.constructor.name ? fn.constructor.name : void 0 : fn;
   }
   if (module.exports = {
    getNamespace,
    createNamespace: function(name) {
     assert.ok(name, "namespace must be given a name."), DEBUG_CLS_HOOKED && debug2("CREATING NAMESPACE " + name);
     let namespace = new Namespace(name);
     return namespace.id = currentUid, asyncHook.addHooks({
      init(uid, handle, provider, parentUid, parentHandle) {
       currentUid = uid, parentUid ? (namespace._contexts.set(uid, namespace._contexts.get(parentUid)), 
       DEBUG_CLS_HOOKED && debug2("PARENTID: " + name + " uid:" + uid + " parent:" + parentUid + " provider:" + provider)) : namespace._contexts.set(currentUid, namespace.active), 
       DEBUG_CLS_HOOKED && debug2("INIT " + name + " uid:" + uid + " parent:" + parentUid + " provider:" + invertedProviders[provider] + " active:" + util.inspect(namespace.active, !0));
      },
      pre(uid, handle) {
       currentUid = uid;
       let context = namespace._contexts.get(uid);
       context ? (DEBUG_CLS_HOOKED && debug2(" PRE " + name + " uid:" + uid + " handle:" + getFunctionName(handle) + " context:" + util.inspect(context)), 
       namespace.enter(context)) : DEBUG_CLS_HOOKED && debug2(" PRE MISSING CONTEXT " + name + " uid:" + uid + " handle:" + getFunctionName(handle));
      },
      post(uid, handle) {
       currentUid = uid;
       let context = namespace._contexts.get(uid);
       context ? (DEBUG_CLS_HOOKED && debug2(" POST " + name + " uid:" + uid + " handle:" + getFunctionName(handle) + " context:" + util.inspect(context)), 
       namespace.exit(context)) : DEBUG_CLS_HOOKED && debug2(" POST MISSING CONTEXT " + name + " uid:" + uid + " handle:" + getFunctionName(handle));
      },
      destroy(uid) {
       currentUid = uid, DEBUG_CLS_HOOKED && debug2("DESTROY " + name + " uid:" + uid + " context:" + util.inspect(namespace._contexts.get(currentUid)) + " active:" + util.inspect(namespace.active, !0)), 
       namespace._contexts.delete(uid);
      }
     }), process.namespaces[name] = namespace, namespace;
    },
    destroyNamespace,
    reset: function() {
     process.namespaces && Object.keys(process.namespaces).forEach((function(name) {
      destroyNamespace(name);
     }));
     process.namespaces = Object.create(null);
    },
    ERROR_SYMBOL: "error@context"
   }, Namespace.prototype.set = function(key, value) {
    if (!this.active) throw new Error("No context available. ns.run() or ns.bind() must be called first.");
    return DEBUG_CLS_HOOKED && debug2("    SETTING KEY:" + key + "=" + value + " in ns:" + this.name + " uid:" + currentUid + " active:" + util.inspect(this.active, !0)), 
    this.active[key] = value, value;
   }, Namespace.prototype.get = function(key) {
    if (this.active) return DEBUG_CLS_HOOKED && debug2("    GETTING KEY:" + key + "=" + this.active[key] + " " + this.name + " uid:" + currentUid + " active:" + util.inspect(this.active, !0)), 
    this.active[key];
    DEBUG_CLS_HOOKED && debug2("    GETTING KEY:" + key + "=undefined " + this.name + " uid:" + currentUid + " active:" + util.inspect(this.active, !0));
   }, Namespace.prototype.createContext = function() {
    DEBUG_CLS_HOOKED && debug2("   CREATING Context: " + this.name + " uid:" + currentUid + " len:" + this._set.length + "  active:" + util.inspect(this.active, !0, 2, !0));
    let context = Object.create(this.active ? this.active : Object.prototype);
    return context._ns_name = this.name, context.id = currentUid, DEBUG_CLS_HOOKED && debug2("   CREATED Context: " + this.name + " uid:" + currentUid + " len:" + this._set.length + "  context:" + util.inspect(context, !0, 2, !0)), 
    context;
   }, Namespace.prototype.run = function(fn) {
    let context = this.createContext();
    this.enter(context);
    try {
     return DEBUG_CLS_HOOKED && debug2(" BEFORE RUN: " + this.name + " uid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context)), 
     fn(context), context;
    } catch (exception) {
     throw exception && (exception["error@context"] = context), exception;
    } finally {
     DEBUG_CLS_HOOKED && debug2(" AFTER RUN: " + this.name + " uid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context)), 
     this.exit(context);
    }
   }, Namespace.prototype.runAndReturn = function(fn) {
    var value;
    return this.run((function(context) {
     value = fn(context);
    })), value;
   }, Namespace.prototype.runPromise = function(fn) {
    let context = this.createContext();
    this.enter(context);
    let promise = fn(context);
    if (!promise || !promise.then || !promise.catch) throw new Error("fn must return a promise.");
    return DEBUG_CLS_HOOKED && debug2(" BEFORE runPromise: " + this.name + " uid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context)), 
    promise.then((result => (DEBUG_CLS_HOOKED && debug2(" AFTER runPromise: " + this.name + " uid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context)), 
    this.exit(context), result))).catch((err => {
     throw err["error@context"] = context, DEBUG_CLS_HOOKED && debug2(" AFTER runPromise: " + this.name + " uid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context)), 
     this.exit(context), err;
    }));
   }, Namespace.prototype.bind = function(fn, context) {
    context || (context = this.active ? this.active : this.createContext());
    let self = this;
    return function() {
     self.enter(context);
     try {
      return fn.apply(this, arguments);
     } catch (exception) {
      throw exception && (exception["error@context"] = context), exception;
     } finally {
      self.exit(context);
     }
    };
   }, Namespace.prototype.enter = function(context) {
    assert.ok(context, "context must be provided for entering"), DEBUG_CLS_HOOKED && debug2("  ENTER " + this.name + " uid:" + currentUid + " len:" + this._set.length + " context: " + util.inspect(context)), 
    this._set.push(this.active), this.active = context;
   }, Namespace.prototype.exit = function(context) {
    if (assert.ok(context, "context must be provided for exiting"), DEBUG_CLS_HOOKED && debug2("  EXIT " + this.name + " uid:" + currentUid + " len:" + this._set.length + " context: " + util.inspect(context)), 
    this.active === context) return assert.ok(this._set.length, "can't remove top context"), 
    void (this.active = this._set.pop());
    let index = this._set.lastIndexOf(context);
    index < 0 ? (DEBUG_CLS_HOOKED && debug2("??ERROR?? context exiting but not entered - ignoring: " + util.inspect(context)), 
    assert.ok(index >= 0, "context not currently entered; can't exit. \n" + util.inspect(this) + "\n" + util.inspect(context))) : (assert.ok(index, "can't remove top context"), 
    this._set.splice(index, 1));
   }, Namespace.prototype.bindEmitter = function(emitter) {
    assert.ok(emitter.on && emitter.addListener && emitter.emit, "can only bind real EEs");
    let namespace = this, thisSymbol = "context@" + this.name;
    wrapEmitter(emitter, (function(listener) {
     listener && (listener["cls@contexts"] || (listener["cls@contexts"] = Object.create(null)), 
     listener["cls@contexts"][thisSymbol] = {
      namespace,
      context: namespace.active
     });
    }), (function(unwrapped) {
     if (!unwrapped || !unwrapped["cls@contexts"]) return unwrapped;
     let wrapped = unwrapped, unwrappedContexts = unwrapped["cls@contexts"];
     return Object.keys(unwrappedContexts).forEach((function(name) {
      let thunk = unwrappedContexts[name];
      wrapped = thunk.namespace.bind(wrapped, thunk.context);
     })), wrapped;
    }));
   }, Namespace.prototype.fromException = function(exception) {
    return exception["error@context"];
   }, process.namespaces = {}, asyncHook._state && !asyncHook._state.enabled && asyncHook.enable(), 
   DEBUG_CLS_HOOKED) {
    var stackChain = __webpack_require__(92512);
    for (var modifier in stackChain.filter._modifiers) stackChain.filter.deattach(modifier);
   }
  },
  93964: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   const util = __webpack_require__(73837), assert = __webpack_require__(39491), wrapEmitter = __webpack_require__(69867), async_hooks = __webpack_require__(50852), DEBUG_CLS_HOOKED = process.env.DEBUG_CLS_HOOKED;
   let currentUid = -1;
   function Namespace(name) {
    this.name = name, this.active = null, this._set = [], this.id = null, this._contexts = new Map, 
    this._indent = 0;
   }
   function getNamespace(name) {
    return process.namespaces[name];
   }
   function destroyNamespace(name) {
    let namespace = getNamespace(name);
    assert.ok(namespace, "can't delete nonexistent namespace! \"" + name + '"'), assert.ok(namespace.id, "don't assign to process.namespaces directly! " + util.inspect(namespace)), 
    process.namespaces[name] = null;
   }
   function debug2(...args) {
    DEBUG_CLS_HOOKED && process._rawDebug(`${util.format(...args)}`);
   }
   module.exports = {
    getNamespace,
    createNamespace: function(name) {
     assert.ok(name, "namespace must be given a name."), DEBUG_CLS_HOOKED && debug2(`NS-CREATING NAMESPACE (${name})`);
     let namespace = new Namespace(name);
     namespace.id = currentUid;
     return async_hooks.createHook({
      init(asyncId, type, triggerId, resource) {
       currentUid = async_hooks.executionAsyncId();
       if (namespace.active) {
        namespace._contexts.set(asyncId, namespace.active);
        if (DEBUG_CLS_HOOKED) {
         const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
         debug2(`${indentStr}INIT [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {
          showHidden: true,
          depth: 2,
          colors: true
         })} resource:${resource}`);
        }
       } else if (currentUid === 0) {
        const triggerId = async_hooks.triggerAsyncId();
        const triggerIdContext = namespace._contexts.get(triggerId);
        if (triggerIdContext) {
         namespace._contexts.set(asyncId, triggerIdContext);
         if (DEBUG_CLS_HOOKED) {
          const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
          debug2(`${indentStr}INIT USING CONTEXT FROM TRIGGERID [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {
           showHidden: true,
           depth: 2,
           colors: true
          })} resource:${resource}`);
         }
        } else if (DEBUG_CLS_HOOKED) {
         const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
         debug2(`${indentStr}INIT MISSING CONTEXT [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {
          showHidden: true,
          depth: 2,
          colors: true
         })} resource:${resource}`);
        }
       }
       if (DEBUG_CLS_HOOKED && type === "PROMISE") {
        debug2(util.inspect(resource, {
         showHidden: true
        }));
        const parentId = resource.parentId;
        const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
        debug2(`${indentStr}INIT RESOURCE-PROMISE [${type}] (${name}) parentId:${parentId} asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {
         showHidden: true,
         depth: 2,
         colors: true
        })} resource:${resource}`);
       }
      },
      before(asyncId) {
       currentUid = async_hooks.executionAsyncId();
       let context;
       context = namespace._contexts.get(asyncId) || namespace._contexts.get(currentUid);
       if (context) {
        if (DEBUG_CLS_HOOKED) {
         const triggerId = async_hooks.triggerAsyncId();
         const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
         debug2(`${indentStr}BEFORE (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {
          showHidden: true,
          depth: 2,
          colors: true
         })} context:${util.inspect(context)}`);
         namespace._indent += 2;
        }
        namespace.enter(context);
       } else if (DEBUG_CLS_HOOKED) {
        const triggerId = async_hooks.triggerAsyncId();
        const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
        debug2(`${indentStr}BEFORE MISSING CONTEXT (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {
         showHidden: true,
         depth: 2,
         colors: true
        })} namespace._contexts:${util.inspect(namespace._contexts, {
         showHidden: true,
         depth: 2,
         colors: true
        })}`);
        namespace._indent += 2;
       }
      },
      after(asyncId) {
       currentUid = async_hooks.executionAsyncId();
       let context;
       context = namespace._contexts.get(asyncId) || namespace._contexts.get(currentUid);
       if (context) {
        if (DEBUG_CLS_HOOKED) {
         const triggerId = async_hooks.triggerAsyncId();
         namespace._indent -= 2;
         const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
         debug2(`${indentStr}AFTER (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {
          showHidden: true,
          depth: 2,
          colors: true
         })} context:${util.inspect(context)}`);
        }
        namespace.exit(context);
       } else if (DEBUG_CLS_HOOKED) {
        const triggerId = async_hooks.triggerAsyncId();
        namespace._indent -= 2;
        const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
        debug2(`${indentStr}AFTER MISSING CONTEXT (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {
         showHidden: true,
         depth: 2,
         colors: true
        })} context:${util.inspect(context)}`);
       }
      },
      destroy(asyncId) {
       currentUid = async_hooks.executionAsyncId();
       if (DEBUG_CLS_HOOKED) {
        const triggerId = async_hooks.triggerAsyncId();
        const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
        debug2(`${indentStr}DESTROY (${name}) currentUid:${currentUid} asyncId:${asyncId} triggerId:${triggerId} active:${util.inspect(namespace.active, {
         showHidden: true,
         depth: 2,
         colors: true
        })} context:${util.inspect(namespace._contexts.get(currentUid))}`);
       }
       namespace._contexts.delete(asyncId);
      }
     }).enable(), process.namespaces[name] = namespace, namespace;
    },
    destroyNamespace,
    reset: function() {
     process.namespaces && Object.keys(process.namespaces).forEach((function(name) {
      destroyNamespace(name);
     }));
     process.namespaces = Object.create(null);
    },
    ERROR_SYMBOL: "error@context"
   }, Namespace.prototype.set = function(key, value) {
    if (!this.active) throw new Error("No context available. ns.run() or ns.bind() must be called first.");
    if (this.active[key] = value, DEBUG_CLS_HOOKED) {
     debug2(" ".repeat(this._indent < 0 ? 0 : this._indent) + "CONTEXT-SET KEY:" + key + "=" + value + " in ns:" + this.name + " currentUid:" + currentUid + " active:" + util.inspect(this.active, {
      showHidden: !0,
      depth: 2,
      colors: !0
     }));
    }
    return value;
   }, Namespace.prototype.get = function(key) {
    if (this.active) {
     if (DEBUG_CLS_HOOKED) {
      const asyncHooksCurrentId = async_hooks.executionAsyncId(), triggerId = async_hooks.triggerAsyncId(), indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
      debug2(indentStr + "CONTEXT-GETTING KEY:" + key + "=" + this.active[key] + " (" + this.name + ") currentUid:" + currentUid + " active:" + util.inspect(this.active, {
       showHidden: !0,
       depth: 2,
       colors: !0
      })), debug2(`${indentStr}CONTEXT-GETTING KEY: (${this.name}) ${key}=${this.active[key]} currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length} active:${util.inspect(this.active)}`);
     }
     return this.active[key];
    }
    if (DEBUG_CLS_HOOKED) {
     const asyncHooksCurrentId = async_hooks.currentId(), triggerId = async_hooks.triggerAsyncId();
     debug2(`${" ".repeat(this._indent < 0 ? 0 : this._indent)}CONTEXT-GETTING KEY NO ACTIVE NS: (${this.name}) ${key}=undefined currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length}`);
    }
   }, Namespace.prototype.createContext = function() {
    let context = Object.create(this.active ? this.active : Object.prototype);
    if (context._ns_name = this.name, context.id = currentUid, DEBUG_CLS_HOOKED) {
     const asyncHooksCurrentId = async_hooks.executionAsyncId(), triggerId = async_hooks.triggerAsyncId();
     debug2(`${" ".repeat(this._indent < 0 ? 0 : this._indent)}CONTEXT-CREATED Context: (${this.name}) currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length} context:${util.inspect(context, {
      showHidden: !0,
      depth: 2,
      colors: !0
     })}`);
    }
    return context;
   }, Namespace.prototype.run = function(fn) {
    let context = this.createContext();
    this.enter(context);
    try {
     if (DEBUG_CLS_HOOKED) {
      const triggerId = async_hooks.triggerAsyncId(), asyncHooksCurrentId = async_hooks.executionAsyncId();
      debug2(`${" ".repeat(this._indent < 0 ? 0 : this._indent)}CONTEXT-RUN BEGIN: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} context:${util.inspect(context)}`);
     }
     return fn(context), context;
    } catch (exception) {
     throw exception && (exception["error@context"] = context), exception;
    } finally {
     if (DEBUG_CLS_HOOKED) {
      const triggerId = async_hooks.triggerAsyncId(), asyncHooksCurrentId = async_hooks.executionAsyncId();
      debug2(`${" ".repeat(this._indent < 0 ? 0 : this._indent)}CONTEXT-RUN END: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);
     }
     this.exit(context);
    }
   }, Namespace.prototype.runAndReturn = function(fn) {
    let value;
    return this.run((function(context) {
     value = fn(context);
    })), value;
   }, Namespace.prototype.runPromise = function(fn) {
    let context = this.createContext();
    this.enter(context);
    let promise = fn(context);
    if (!promise || !promise.then || !promise.catch) throw new Error("fn must return a promise.");
    return DEBUG_CLS_HOOKED && debug2("CONTEXT-runPromise BEFORE: (" + this.name + ") currentUid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context)), 
    promise.then((result => (DEBUG_CLS_HOOKED && debug2("CONTEXT-runPromise AFTER then: (" + this.name + ") currentUid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context)), 
    this.exit(context), result))).catch((err => {
     throw err["error@context"] = context, DEBUG_CLS_HOOKED && debug2("CONTEXT-runPromise AFTER catch: (" + this.name + ") currentUid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context)), 
     this.exit(context), err;
    }));
   }, Namespace.prototype.bind = function(fn, context) {
    context || (context = this.active ? this.active : this.createContext());
    let self = this;
    return function() {
     self.enter(context);
     try {
      return fn.apply(this, arguments);
     } catch (exception) {
      throw exception && (exception["error@context"] = context), exception;
     } finally {
      self.exit(context);
     }
    };
   }, Namespace.prototype.enter = function(context) {
    if (assert.ok(context, "context must be provided for entering"), DEBUG_CLS_HOOKED) {
     const asyncHooksCurrentId = async_hooks.executionAsyncId(), triggerId = async_hooks.triggerAsyncId();
     debug2(`${" ".repeat(this._indent < 0 ? 0 : this._indent)}CONTEXT-ENTER: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);
    }
    this._set.push(this.active), this.active = context;
   }, Namespace.prototype.exit = function(context) {
    if (assert.ok(context, "context must be provided for exiting"), DEBUG_CLS_HOOKED) {
     const asyncHooksCurrentId = async_hooks.executionAsyncId(), triggerId = async_hooks.triggerAsyncId();
     debug2(`${" ".repeat(this._indent < 0 ? 0 : this._indent)}CONTEXT-EXIT: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);
    }
    if (this.active === context) return assert.ok(this._set.length, "can't remove top context"), 
    void (this.active = this._set.pop());
    let index = this._set.lastIndexOf(context);
    index < 0 ? (DEBUG_CLS_HOOKED && debug2("??ERROR?? context exiting but not entered - ignoring: " + util.inspect(context)), 
    assert.ok(index >= 0, "context not currently entered; can't exit. \n" + util.inspect(this) + "\n" + util.inspect(context))) : (assert.ok(index, "can't remove top context"), 
    this._set.splice(index, 1));
   }, Namespace.prototype.bindEmitter = function(emitter) {
    assert.ok(emitter.on && emitter.addListener && emitter.emit, "can only bind real EEs");
    let namespace = this, thisSymbol = "context@" + this.name;
    wrapEmitter(emitter, (function(listener) {
     listener && (listener["cls@contexts"] || (listener["cls@contexts"] = Object.create(null)), 
     listener["cls@contexts"][thisSymbol] = {
      namespace,
      context: namespace.active
     });
    }), (function(unwrapped) {
     if (!unwrapped || !unwrapped["cls@contexts"]) return unwrapped;
     let wrapped = unwrapped, unwrappedContexts = unwrapped["cls@contexts"];
     return Object.keys(unwrappedContexts).forEach((function(name) {
      let thunk = unwrappedContexts[name];
      wrapped = thunk.namespace.bind(wrapped, thunk.context);
     })), wrapped;
    }));
   }, Namespace.prototype.fromException = function(exception) {
    return exception["error@context"];
   }, process.namespaces = {};
  },
  39562: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   const semver = __webpack_require__(49012);
   process && semver.gte(process.versions.node, "8.0.0") ? module.exports = __webpack_require__(93964) : module.exports = __webpack_require__(44046);
  },
  49012: (module, exports) => {
   var debug;
   exports = module.exports = SemVer, debug = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function() {
    var args = Array.prototype.slice.call(arguments, 0);
    args.unshift("SEMVER"), console.log.apply(console, args);
   } : function() {}, exports.SEMVER_SPEC_VERSION = "2.0.0";
   var MAX_LENGTH = 256, MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6, re = exports.re = [], safeRe = exports.safeRe = [], src = exports.src = [], R = 0, safeRegexReplacements = [ [ "\\s", 1 ], [ "\\d", MAX_LENGTH ], [ "[a-zA-Z0-9-]", MAX_SAFE_BUILD_LENGTH ] ];
   function makeSafeRe(value) {
    for (var i = 0; i < safeRegexReplacements.length; i++) {
     var token = safeRegexReplacements[i][0], max = safeRegexReplacements[i][1];
     value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
    }
    return value;
   }
   var NUMERICIDENTIFIER = R++;
   src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
   var NUMERICIDENTIFIERLOOSE = R++;
   src[NUMERICIDENTIFIERLOOSE] = "\\d+";
   var NONNUMERICIDENTIFIER = R++;
   src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
   var MAINVERSION = R++;
   src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
   var MAINVERSIONLOOSE = R++;
   src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
   var PRERELEASEIDENTIFIER = R++;
   src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
   var PRERELEASEIDENTIFIERLOOSE = R++;
   src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
   var PRERELEASE = R++;
   src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
   var PRERELEASELOOSE = R++;
   src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
   var BUILDIDENTIFIER = R++;
   src[BUILDIDENTIFIER] = "[a-zA-Z0-9-]+";
   var BUILD = R++;
   src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
   var FULL = R++, FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
   src[FULL] = "^" + FULLPLAIN + "$";
   var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?", LOOSE = R++;
   src[LOOSE] = "^" + LOOSEPLAIN + "$";
   var GTLT = R++;
   src[GTLT] = "((?:<|>)?=?)";
   var XRANGEIDENTIFIERLOOSE = R++;
   src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
   var XRANGEIDENTIFIER = R++;
   src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
   var XRANGEPLAIN = R++;
   src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
   var XRANGEPLAINLOOSE = R++;
   src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
   var XRANGE = R++;
   src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
   var XRANGELOOSE = R++;
   src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
   var COERCE = R++;
   src[COERCE] = "(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])";
   var LONETILDE = R++;
   src[LONETILDE] = "(?:~>?)";
   var TILDETRIM = R++;
   src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+", re[TILDETRIM] = new RegExp(src[TILDETRIM], "g"), 
   safeRe[TILDETRIM] = new RegExp(makeSafeRe(src[TILDETRIM]), "g");
   var TILDE = R++;
   src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
   var TILDELOOSE = R++;
   src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
   var LONECARET = R++;
   src[LONECARET] = "(?:\\^)";
   var CARETTRIM = R++;
   src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+", re[CARETTRIM] = new RegExp(src[CARETTRIM], "g"), 
   safeRe[CARETTRIM] = new RegExp(makeSafeRe(src[CARETTRIM]), "g");
   var CARET = R++;
   src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
   var CARETLOOSE = R++;
   src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
   var COMPARATORLOOSE = R++;
   src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
   var COMPARATOR = R++;
   src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
   var COMPARATORTRIM = R++;
   src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")", 
   re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g"), safeRe[COMPARATORTRIM] = new RegExp(makeSafeRe(src[COMPARATORTRIM]), "g");
   var HYPHENRANGE = R++;
   src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
   var HYPHENRANGELOOSE = R++;
   src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
   var STAR = R++;
   src[STAR] = "(<|>)?=?\\s*\\*";
   for (var i = 0; i < 35; i++) debug(i, src[i]), re[i] || (re[i] = new RegExp(src[i]), 
   safeRe[i] = new RegExp(makeSafeRe(src[i])));
   function parse(version, options) {
    if (options && "object" == typeof options || (options = {
     loose: !!options,
     includePrerelease: !1
    }), version instanceof SemVer) return version;
    if ("string" != typeof version) return null;
    if (version.length > MAX_LENGTH) return null;
    if (!(options.loose ? safeRe[LOOSE] : safeRe[FULL]).test(version)) return null;
    try {
     return new SemVer(version, options);
    } catch (er) {
     return null;
    }
   }
   function SemVer(version, options) {
    if (options && "object" == typeof options || (options = {
     loose: !!options,
     includePrerelease: !1
    }), version instanceof SemVer) {
     if (version.loose === options.loose) return version;
     version = version.version;
    } else if ("string" != typeof version) throw new TypeError("Invalid Version: " + version);
    if (version.length > MAX_LENGTH) throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    if (!(this instanceof SemVer)) return new SemVer(version, options);
    debug("SemVer", version, options), this.options = options, this.loose = !!options.loose;
    var m = version.trim().match(options.loose ? safeRe[LOOSE] : safeRe[FULL]);
    if (!m) throw new TypeError("Invalid Version: " + version);
    if (this.raw = version, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], 
    this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
    m[4] ? this.prerelease = m[4].split(".").map((function(id) {
     if (/^[0-9]+$/.test(id)) {
      var num = +id;
      if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
     }
     return id;
    })) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
   }
   exports.parse = parse, exports.valid = function(version, options) {
    var v = parse(version, options);
    return v ? v.version : null;
   }, exports.clean = function(version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
   }, exports.SemVer = SemVer, SemVer.prototype.format = function() {
    return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), 
    this.version;
   }, SemVer.prototype.toString = function() {
    return this.version;
   }, SemVer.prototype.compare = function(other) {
    return debug("SemVer.compare", this.version, this.options, other), other instanceof SemVer || (other = new SemVer(other, this.options)), 
    this.compareMain(other) || this.comparePre(other);
   }, SemVer.prototype.compareMain = function(other) {
    return other instanceof SemVer || (other = new SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
   }, SemVer.prototype.comparePre = function(other) {
    if (other instanceof SemVer || (other = new SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length) return -1;
    if (!this.prerelease.length && other.prerelease.length) return 1;
    if (!this.prerelease.length && !other.prerelease.length) return 0;
    var i = 0;
    do {
     var a = this.prerelease[i], b = other.prerelease[i];
     if (debug("prerelease compare", i, a, b), void 0 === a && void 0 === b) return 0;
     if (void 0 === b) return 1;
     if (void 0 === a) return -1;
     if (a !== b) return compareIdentifiers(a, b);
    } while (++i);
   }, SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
    case "premajor":
     this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier);
     break;

    case "preminor":
     this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier);
     break;

    case "prepatch":
     this.prerelease.length = 0, this.inc("patch", identifier), this.inc("pre", identifier);
     break;

    case "prerelease":
     0 === this.prerelease.length && this.inc("patch", identifier), this.inc("pre", identifier);
     break;

    case "major":
     0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, 
     this.minor = 0, this.patch = 0, this.prerelease = [];
     break;

    case "minor":
     0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, 
     this.prerelease = [];
     break;

    case "patch":
     0 === this.prerelease.length && this.patch++, this.prerelease = [];
     break;

    case "pre":
     if (0 === this.prerelease.length) this.prerelease = [ 0 ]; else {
      for (var i = this.prerelease.length; --i >= 0; ) "number" == typeof this.prerelease[i] && (this.prerelease[i]++, 
      i = -2);
      -1 === i && this.prerelease.push(0);
     }
     identifier && (this.prerelease[0] === identifier ? isNaN(this.prerelease[1]) && (this.prerelease = [ identifier, 0 ]) : this.prerelease = [ identifier, 0 ]);
     break;

    default:
     throw new Error("invalid increment argument: " + release);
    }
    return this.format(), this.raw = this.version, this;
   }, exports.inc = function(version, release, loose, identifier) {
    "string" == typeof loose && (identifier = loose, loose = void 0);
    try {
     return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
     return null;
    }
   }, exports.diff = function(version1, version2) {
    if (eq(version1, version2)) return null;
    var v1 = parse(version1), v2 = parse(version2), prefix = "";
    if (v1.prerelease.length || v2.prerelease.length) {
     prefix = "pre";
     var defaultResult = "prerelease";
    }
    for (var key in v1) if (("major" === key || "minor" === key || "patch" === key) && v1[key] !== v2[key]) return prefix + key;
    return defaultResult;
   }, exports.compareIdentifiers = compareIdentifiers;
   var numeric = /^[0-9]+$/;
   function compareIdentifiers(a, b) {
    var anum = numeric.test(a), bnum = numeric.test(b);
    return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
   }
   function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
   }
   function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
   }
   function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
   }
   function eq(a, b, loose) {
    return 0 === compare(a, b, loose);
   }
   function neq(a, b, loose) {
    return 0 !== compare(a, b, loose);
   }
   function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
   }
   function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
   }
   function cmp(a, op, b, loose) {
    switch (op) {
    case "===":
     return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), 
     a === b;

    case "!==":
     return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), 
     a !== b;

    case "":
    case "=":
    case "==":
     return eq(a, b, loose);

    case "!=":
     return neq(a, b, loose);

    case ">":
     return gt(a, b, loose);

    case ">=":
     return gte(a, b, loose);

    case "<":
     return lt(a, b, loose);

    case "<=":
     return lte(a, b, loose);

    default:
     throw new TypeError("Invalid operator: " + op);
    }
   }
   function Comparator(comp, options) {
    if (options && "object" == typeof options || (options = {
     loose: !!options,
     includePrerelease: !1
    }), comp instanceof Comparator) {
     if (comp.loose === !!options.loose) return comp;
     comp = comp.value;
    }
    if (!(this instanceof Comparator)) return new Comparator(comp, options);
    comp = comp.trim().split(/\s+/).join(" "), debug("comparator", comp, options), this.options = options, 
    this.loose = !!options.loose, this.parse(comp), this.semver === ANY ? this.value = "" : this.value = this.operator + this.semver.version, 
    debug("comp", this);
   }
   exports.rcompareIdentifiers = function(a, b) {
    return compareIdentifiers(b, a);
   }, exports.major = function(a, loose) {
    return new SemVer(a, loose).major;
   }, exports.minor = function(a, loose) {
    return new SemVer(a, loose).minor;
   }, exports.patch = function(a, loose) {
    return new SemVer(a, loose).patch;
   }, exports.compare = compare, exports.compareLoose = function(a, b) {
    return compare(a, b, !0);
   }, exports.rcompare = function(a, b, loose) {
    return compare(b, a, loose);
   }, exports.sort = function(list, loose) {
    return list.sort((function(a, b) {
     return exports.compare(a, b, loose);
    }));
   }, exports.rsort = function(list, loose) {
    return list.sort((function(a, b) {
     return exports.rcompare(a, b, loose);
    }));
   }, exports.gt = gt, exports.lt = lt, exports.eq = eq, exports.neq = neq, exports.gte = gte, 
   exports.lte = lte, exports.cmp = cmp, exports.Comparator = Comparator;
   var ANY = {};
   function Range(range, options) {
    if (options && "object" == typeof options || (options = {
     loose: !!options,
     includePrerelease: !1
    }), range instanceof Range) return range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease ? range : new Range(range.raw, options);
    if (range instanceof Comparator) return new Range(range.value, options);
    if (!(this instanceof Range)) return new Range(range, options);
    if (this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease, 
    this.raw = range.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((function(range) {
     return this.parseRange(range.trim());
    }), this).filter((function(c) {
     return c.length;
    })), !this.set.length) throw new TypeError("Invalid SemVer Range: " + this.raw);
    this.format();
   }
   function isX(id) {
    return !id || "x" === id.toLowerCase() || "*" === id;
   }
   function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    return ((from = isX(fM) ? "" : isX(fm) ? ">=" + fM + ".0.0" : isX(fp) ? ">=" + fM + "." + fm + ".0" : ">=" + from) + " " + (to = isX(tM) ? "" : isX(tm) ? "<" + (+tM + 1) + ".0.0" : isX(tp) ? "<" + tM + "." + (+tm + 1) + ".0" : tpr ? "<=" + tM + "." + tm + "." + tp + "-" + tpr : "<=" + to)).trim();
   }
   function testSet(set, version, options) {
    for (var i = 0; i < set.length; i++) if (!set[i].test(version)) return !1;
    if (version.prerelease.length && !options.includePrerelease) {
     for (i = 0; i < set.length; i++) if (debug(set[i].semver), set[i].semver !== ANY && set[i].semver.prerelease.length > 0) {
      var allowed = set[i].semver;
      if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return !0;
     }
     return !1;
    }
    return !0;
   }
   function satisfies(version, range, options) {
    try {
     range = new Range(range, options);
    } catch (er) {
     return !1;
    }
    return range.test(version);
   }
   function outside(version, range, hilo, options) {
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (version = new SemVer(version, options), range = new Range(range, options), 
    hilo) {
    case ">":
     gtfn = gt, ltefn = lte, ltfn = lt, comp = ">", ecomp = ">=";
     break;

    case "<":
     gtfn = lt, ltefn = gte, ltfn = gt, comp = "<", ecomp = "<=";
     break;

    default:
     throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) return !1;
    for (var i = 0; i < range.set.length; ++i) {
     var comparators = range.set[i], high = null, low = null;
     if (comparators.forEach((function(comparator) {
      comparator.semver === ANY && (comparator = new Comparator(">=0.0.0")), high = high || comparator, 
      low = low || comparator, gtfn(comparator.semver, high.semver, options) ? high = comparator : ltfn(comparator.semver, low.semver, options) && (low = comparator);
     })), high.operator === comp || high.operator === ecomp) return !1;
     if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) return !1;
     if (low.operator === ecomp && ltfn(version, low.semver)) return !1;
    }
    return !0;
   }
   Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR], m = comp.match(r);
    if (!m) throw new TypeError("Invalid comparator: " + comp);
    this.operator = m[1], "=" === this.operator && (this.operator = ""), m[2] ? this.semver = new SemVer(m[2], this.options.loose) : this.semver = ANY;
   }, Comparator.prototype.toString = function() {
    return this.value;
   }, Comparator.prototype.test = function(version) {
    return debug("Comparator.test", version, this.options.loose), this.semver === ANY || ("string" == typeof version && (version = new SemVer(version, this.options)), 
    cmp(version, this.operator, this.semver, this.options));
   }, Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) throw new TypeError("a Comparator is required");
    var rangeTmp;
    if (options && "object" == typeof options || (options = {
     loose: !!options,
     includePrerelease: !1
    }), "" === this.operator) return rangeTmp = new Range(comp.value, options), satisfies(this.value, rangeTmp, options);
    if ("" === comp.operator) return rangeTmp = new Range(this.value, options), satisfies(comp.semver, rangeTmp, options);
    var sameDirectionIncreasing = !(">=" !== this.operator && ">" !== this.operator || ">=" !== comp.operator && ">" !== comp.operator), sameDirectionDecreasing = !("<=" !== this.operator && "<" !== this.operator || "<=" !== comp.operator && "<" !== comp.operator), sameSemVer = this.semver.version === comp.semver.version, differentDirectionsInclusive = !(">=" !== this.operator && "<=" !== this.operator || ">=" !== comp.operator && "<=" !== comp.operator), oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (">=" === this.operator || ">" === this.operator) && ("<=" === comp.operator || "<" === comp.operator), oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ("<=" === this.operator || "<" === this.operator) && (">=" === comp.operator || ">" === comp.operator);
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
   }, exports.Range = Range, Range.prototype.format = function() {
    return this.range = this.set.map((function(comps) {
     return comps.join(" ").trim();
    })).join("||").trim(), this.range;
   }, Range.prototype.toString = function() {
    return this.range;
   }, Range.prototype.parseRange = function(range) {
    var loose = this.options.loose, hr = loose ? safeRe[HYPHENRANGELOOSE] : safeRe[HYPHENRANGE];
    range = range.replace(hr, hyphenReplace), debug("hyphen replace", range), range = range.replace(safeRe[COMPARATORTRIM], "$1$2$3"), 
    debug("comparator trim", range, safeRe[COMPARATORTRIM]), range = (range = range.replace(safeRe[TILDETRIM], "$1~")).replace(safeRe[CARETTRIM], "$1^");
    var compRe = loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR], set = range.split(" ").map((function(comp) {
     return function(comp, options) {
      return debug("comp", comp, options), comp = function(comp, options) {
       return comp.trim().split(/\s+/).map((function(comp) {
        return function(comp, options) {
         debug("caret", comp, options);
         var r = options.loose ? safeRe[CARETLOOSE] : safeRe[CARET];
         return comp.replace(r, (function(_, M, m, p, pr) {
          var ret;
          return debug("caret", comp, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? ret = "0" === M ? ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0" : pr ? (debug("replaceCaret pr", pr), 
          ret = "0" === M ? "0" === m ? ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1) : ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0" : ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0") : (debug("no pr"), 
          ret = "0" === M ? "0" === m ? ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1) : ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0" : ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0"), 
          debug("caret return", ret), ret;
         }));
        }(comp, options);
       })).join(" ");
      }(comp, options), debug("caret", comp), comp = function(comp, options) {
       return comp.trim().split(/\s+/).map((function(comp) {
        return function(comp, options) {
         var r = options.loose ? safeRe[TILDELOOSE] : safeRe[TILDE];
         return comp.replace(r, (function(_, M, m, p, pr) {
          var ret;
          return debug("tilde", comp, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : pr ? (debug("replaceTilde pr", pr), 
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0") : ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0", 
          debug("tilde return", ret), ret;
         }));
        }(comp, options);
       })).join(" ");
      }(comp, options), debug("tildes", comp), comp = function(comp, options) {
       return debug("replaceXRanges", comp, options), comp.split(/\s+/).map((function(comp) {
        return function(comp, options) {
         comp = comp.trim();
         var r = options.loose ? safeRe[XRANGELOOSE] : safeRe[XRANGE];
         return comp.replace(r, (function(ret, gtlt, M, m, p, pr) {
          debug("xRange", comp, ret, gtlt, M, m, p, pr);
          var xM = isX(M), xm = xM || isX(m), xp = xm || isX(p);
          return "=" === gtlt && xp && (gtlt = ""), xM ? ret = ">" === gtlt || "<" === gtlt ? "<0.0.0" : "*" : gtlt && xp ? (xm && (m = 0), 
          p = 0, ">" === gtlt ? (gtlt = ">=", xm ? (M = +M + 1, m = 0, p = 0) : (m = +m + 1, 
          p = 0)) : "<=" === gtlt && (gtlt = "<", xm ? M = +M + 1 : m = +m + 1), ret = gtlt + M + "." + m + "." + p) : xm ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : xp && (ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0"), 
          debug("xRange return", ret), ret;
         }));
        }(comp, options);
       })).join(" ");
      }(comp, options), debug("xrange", comp), comp = function(comp, options) {
       return debug("replaceStars", comp, options), comp.trim().replace(safeRe[STAR], "");
      }(comp, options), debug("stars", comp), comp;
     }(comp, this.options);
    }), this).join(" ").split(/\s+/);
    return this.options.loose && (set = set.filter((function(comp) {
     return !!comp.match(compRe);
    }))), set = set.map((function(comp) {
     return new Comparator(comp, this.options);
    }), this);
   }, Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) throw new TypeError("a Range is required");
    return this.set.some((function(thisComparators) {
     return thisComparators.every((function(thisComparator) {
      return range.set.some((function(rangeComparators) {
       return rangeComparators.every((function(rangeComparator) {
        return thisComparator.intersects(rangeComparator, options);
       }));
      }));
     }));
    }));
   }, exports.toComparators = function(range, options) {
    return new Range(range, options).set.map((function(comp) {
     return comp.map((function(c) {
      return c.value;
     })).join(" ").trim().split(" ");
    }));
   }, Range.prototype.test = function(version) {
    if (!version) return !1;
    "string" == typeof version && (version = new SemVer(version, this.options));
    for (var i = 0; i < this.set.length; i++) if (testSet(this.set[i], version, this.options)) return !0;
    return !1;
   }, exports.satisfies = satisfies, exports.maxSatisfying = function(versions, range, options) {
    var max = null, maxSV = null;
    try {
     var rangeObj = new Range(range, options);
    } catch (er) {
     return null;
    }
    return versions.forEach((function(v) {
     rangeObj.test(v) && (max && -1 !== maxSV.compare(v) || (maxSV = new SemVer(max = v, options)));
    })), max;
   }, exports.minSatisfying = function(versions, range, options) {
    var min = null, minSV = null;
    try {
     var rangeObj = new Range(range, options);
    } catch (er) {
     return null;
    }
    return versions.forEach((function(v) {
     rangeObj.test(v) && (min && 1 !== minSV.compare(v) || (minSV = new SemVer(min = v, options)));
    })), min;
   }, exports.minVersion = function(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) return minver;
    if (minver = new SemVer("0.0.0-0"), range.test(minver)) return minver;
    minver = null;
    for (var i = 0; i < range.set.length; ++i) {
     range.set[i].forEach((function(comparator) {
      var compver = new SemVer(comparator.semver.version);
      switch (comparator.operator) {
      case ">":
       0 === compver.prerelease.length ? compver.patch++ : compver.prerelease.push(0), 
       compver.raw = compver.format();

      case "":
      case ">=":
       minver && !gt(minver, compver) || (minver = compver);
       break;

      case "<":
      case "<=":
       break;

      default:
       throw new Error("Unexpected operation: " + comparator.operator);
      }
     }));
    }
    if (minver && range.test(minver)) return minver;
    return null;
   }, exports.validRange = function(range, options) {
    try {
     return new Range(range, options).range || "*";
    } catch (er) {
     return null;
    }
   }, exports.ltr = function(version, range, options) {
    return outside(version, range, "<", options);
   }, exports.gtr = function(version, range, options) {
    return outside(version, range, ">", options);
   }, exports.outside = outside, exports.prerelease = function(version, options) {
    var parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
   }, exports.intersects = function(r1, r2, options) {
    return r1 = new Range(r1, options), r2 = new Range(r2, options), r1.intersects(r2);
   }, exports.coerce = function(version) {
    if (version instanceof SemVer) return version;
    if ("string" != typeof version) return null;
    var match = version.match(safeRe[COERCE]);
    if (null == match) return null;
    return parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
   };
  },
  9779: (module, __unused_webpack_exports, __webpack_require__) => {
   var util = __webpack_require__(73837), Stream = __webpack_require__(12781).Stream, DelayedStream = __webpack_require__(63463);
   function CombinedStream() {
    this.writable = !1, this.readable = !0, this.dataSize = 0, this.maxDataSize = 2097152, 
    this.pauseStreams = !0, this._released = !1, this._streams = [], this._currentStream = null, 
    this._insideLoop = !1, this._pendingNext = !1;
   }
   module.exports = CombinedStream, util.inherits(CombinedStream, Stream), CombinedStream.create = function(options) {
    var combinedStream = new this;
    for (var option in options = options || {}) combinedStream[option] = options[option];
    return combinedStream;
   }, CombinedStream.isStreamLike = function(stream) {
    return "function" != typeof stream && "string" != typeof stream && "boolean" != typeof stream && "number" != typeof stream && !Buffer.isBuffer(stream);
   }, CombinedStream.prototype.append = function(stream) {
    if (CombinedStream.isStreamLike(stream)) {
     if (!(stream instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream, {
       maxDataSize: 1 / 0,
       pauseStream: this.pauseStreams
      });
      stream.on("data", this._checkDataSize.bind(this)), stream = newStream;
     }
     this._handleErrors(stream), this.pauseStreams && stream.pause();
    }
    return this._streams.push(stream), this;
   }, CombinedStream.prototype.pipe = function(dest, options) {
    return Stream.prototype.pipe.call(this, dest, options), this.resume(), dest;
   }, CombinedStream.prototype._getNext = function() {
    if (this._currentStream = null, this._insideLoop) this._pendingNext = !0; else {
     this._insideLoop = !0;
     try {
      do {
       this._pendingNext = !1, this._realGetNext();
      } while (this._pendingNext);
     } finally {
      this._insideLoop = !1;
     }
    }
   }, CombinedStream.prototype._realGetNext = function() {
    var stream = this._streams.shift();
    void 0 !== stream ? "function" == typeof stream ? stream(function(stream) {
     CombinedStream.isStreamLike(stream) && (stream.on("data", this._checkDataSize.bind(this)), 
     this._handleErrors(stream)), this._pipeNext(stream);
    }.bind(this)) : this._pipeNext(stream) : this.end();
   }, CombinedStream.prototype._pipeNext = function(stream) {
    if (this._currentStream = stream, CombinedStream.isStreamLike(stream)) return stream.on("end", this._getNext.bind(this)), 
    void stream.pipe(this, {
     end: !1
    });
    var value = stream;
    this.write(value), this._getNext();
   }, CombinedStream.prototype._handleErrors = function(stream) {
    var self = this;
    stream.on("error", (function(err) {
     self._emitError(err);
    }));
   }, CombinedStream.prototype.write = function(data) {
    this.emit("data", data);
   }, CombinedStream.prototype.pause = function() {
    this.pauseStreams && (this.pauseStreams && this._currentStream && "function" == typeof this._currentStream.pause && this._currentStream.pause(), 
    this.emit("pause"));
   }, CombinedStream.prototype.resume = function() {
    this._released || (this._released = !0, this.writable = !0, this._getNext()), this.pauseStreams && this._currentStream && "function" == typeof this._currentStream.resume && this._currentStream.resume(), 
    this.emit("resume");
   }, CombinedStream.prototype.end = function() {
    this._reset(), this.emit("end");
   }, CombinedStream.prototype.destroy = function() {
    this._reset(), this.emit("close");
   }, CombinedStream.prototype._reset = function() {
    this.writable = !1, this._streams = [], this._currentStream = null;
   }, CombinedStream.prototype._checkDataSize = function() {
    if (this._updateDataSize(), !(this.dataSize <= this.maxDataSize)) {
     var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
     this._emitError(new Error(message));
    }
   }, CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self = this;
    this._streams.forEach((function(stream) {
     stream.dataSize && (self.dataSize += stream.dataSize);
    })), this._currentStream && this._currentStream.dataSize && (this.dataSize += this._currentStream.dataSize);
   }, CombinedStream.prototype._emitError = function(err) {
    this._reset(), this.emit("error", err);
   };
  },
  13057: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var assert = __webpack_require__(39491), wrapEmitter = __webpack_require__(69867);
   function Namespace(name) {
    this.name = name, this.active = null, this._set = [], this.id = null;
   }
   function get(name) {
    return process.namespaces[name];
   }
   function destroy(name) {
    var namespace = get(name);
    assert.ok(namespace, "can't delete nonexistent namespace!"), assert.ok(namespace.id, "don't assign to process.namespaces directly!"), 
    process.removeAsyncListener(namespace.id), process.namespaces[name] = null;
   }
   function reset() {
    process.namespaces && Object.keys(process.namespaces).forEach((function(name) {
     destroy(name);
    })), process.namespaces = Object.create(null);
   }
   process.addAsyncListener || __webpack_require__(67645), Namespace.prototype.set = function(key, value) {
    if (!this.active) throw new Error("No context available. ns.run() or ns.bind() must be called first.");
    return this.active[key] = value, value;
   }, Namespace.prototype.get = function(key) {
    if (this.active) return this.active[key];
   }, Namespace.prototype.createContext = function() {
    return Object.create(this.active);
   }, Namespace.prototype.run = function(fn) {
    var context = this.createContext();
    this.enter(context);
    try {
     return fn(context), context;
    } catch (exception) {
     throw exception && (exception["error@context"] = context), exception;
    } finally {
     this.exit(context);
    }
   }, Namespace.prototype.runAndReturn = function(fn) {
    var value;
    return this.run((function(context) {
     value = fn(context);
    })), value;
   }, Namespace.prototype.bind = function(fn, context) {
    context || (context = this.active ? this.active : this.createContext());
    var self = this;
    return function() {
     self.enter(context);
     try {
      return fn.apply(this, arguments);
     } catch (exception) {
      throw exception && (exception["error@context"] = context), exception;
     } finally {
      self.exit(context);
     }
    };
   }, Namespace.prototype.enter = function(context) {
    assert.ok(context, "context must be provided for entering"), this._set.push(this.active), 
    this.active = context;
   }, Namespace.prototype.exit = function(context) {
    if (assert.ok(context, "context must be provided for exiting"), this.active === context) return assert.ok(this._set.length, "can't remove top context"), 
    void (this.active = this._set.pop());
    var index = this._set.lastIndexOf(context);
    assert.ok(index >= 0, "context not currently entered; can't exit"), assert.ok(index, "can't remove top context"), 
    this._set.splice(index, 1);
   }, Namespace.prototype.bindEmitter = function(emitter) {
    assert.ok(emitter.on && emitter.addListener && emitter.emit, "can only bind real EEs");
    var namespace = this, thisSymbol = "context@" + this.name;
    wrapEmitter(emitter, (function(listener) {
     listener && (listener["cls@contexts"] || (listener["cls@contexts"] = Object.create(null)), 
     listener["cls@contexts"][thisSymbol] = {
      namespace,
      context: namespace.active
     });
    }), (function(unwrapped) {
     if (!unwrapped || !unwrapped["cls@contexts"]) return unwrapped;
     var wrapped = unwrapped, contexts = unwrapped["cls@contexts"];
     return Object.keys(contexts).forEach((function(name) {
      var thunk = contexts[name];
      wrapped = thunk.namespace.bind(wrapped, thunk.context);
     })), wrapped;
    }));
   }, Namespace.prototype.fromException = function(exception) {
    return exception["error@context"];
   }, process.namespaces || reset(), module.exports = {
    getNamespace: get,
    createNamespace: function(name) {
     assert.ok(name, "namespace must be given a name!");
     var namespace = new Namespace(name);
     return namespace.id = process.addAsyncListener({
      create: function() {
       return namespace.active;
      },
      before: function(context, storage) {
       storage && namespace.enter(storage);
      },
      after: function(context, storage) {
       storage && namespace.exit(storage);
      },
      error: function(storage) {
       storage && namespace.exit(storage);
      }
     }), process.namespaces[name] = namespace, namespace;
    },
    destroyNamespace: destroy,
    reset
   };
  },
  11227: (module, exports, __webpack_require__) => {
   exports.formatArgs = function(args) {
    if (args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff), 
    !this.useColors) return;
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0, lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match => {
     "%%" !== match && (index++, "%c" === match && (lastC = index));
    })), args.splice(lastC, 0, c);
   }, exports.save = function(namespaces) {
    try {
     namespaces ? exports.storage.setItem("debug", namespaces) : exports.storage.removeItem("debug");
    } catch (error) {}
   }, exports.load = function() {
    let r;
    try {
     r = exports.storage.getItem("debug");
    } catch (error) {}
    !r && "undefined" != typeof process && "env" in process && (r = process.env.DEBUG);
    return r;
   }, exports.useColors = function() {
    if ("undefined" != typeof window && window.process && ("renderer" === window.process.type || window.process.__nwjs)) return !0;
    if ("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return !1;
    return "undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
   }, exports.storage = function() {
    try {
     return localStorage;
    } catch (error) {}
   }(), exports.destroy = (() => {
    let warned = !1;
    return () => {
     warned || (warned = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
   })(), exports.colors = [ "#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33" ], 
   exports.log = console.debug || console.log || (() => {}), module.exports = __webpack_require__(82447)(exports);
   const {formatters} = module.exports;
   formatters.j = function(v) {
    try {
     return JSON.stringify(v);
    } catch (error) {
     return "[UnexpectedJSONParseError]: " + error.message;
    }
   };
  },
  82447: (module, __unused_webpack_exports, __webpack_require__) => {
   module.exports = function(env) {
    function createDebug(namespace) {
     let prevTime, namespacesCache, enabledCache, enableOverride = null;
     function debug(...args) {
      if (!debug.enabled) return;
      const self = debug, curr = Number(new Date), ms = curr - (prevTime || curr);
      self.diff = ms, self.prev = prevTime, self.curr = curr, prevTime = curr, args[0] = createDebug.coerce(args[0]), 
      "string" != typeof args[0] && args.unshift("%O");
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, ((match, format) => {
       if ("%%" === match) return "%";
       index++;
       const formatter = createDebug.formatters[format];
       if ("function" == typeof formatter) {
        const val = args[index];
        match = formatter.call(self, val), args.splice(index, 1), index--;
       }
       return match;
      })), createDebug.formatArgs.call(self, args);
      (self.log || createDebug.log).apply(self, args);
     }
     return debug.namespace = namespace, debug.useColors = createDebug.useColors(), debug.color = createDebug.selectColor(namespace), 
     debug.extend = extend, debug.destroy = createDebug.destroy, Object.defineProperty(debug, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => null !== enableOverride ? enableOverride : (namespacesCache !== createDebug.namespaces && (namespacesCache = createDebug.namespaces, 
      enabledCache = createDebug.enabled(namespace)), enabledCache),
      set: v => {
       enableOverride = v;
      }
     }), "function" == typeof createDebug.init && createDebug.init(debug), debug;
    }
    function extend(namespace, delimiter) {
     const newDebug = createDebug(this.namespace + (void 0 === delimiter ? ":" : delimiter) + namespace);
     return newDebug.log = this.log, newDebug;
    }
    function toNamespace(regexp) {
     return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    return createDebug.debug = createDebug, createDebug.default = createDebug, createDebug.coerce = function(val) {
     if (val instanceof Error) return val.stack || val.message;
     return val;
    }, createDebug.disable = function() {
     const namespaces = [ ...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map((namespace => "-" + namespace)) ].join(",");
     return createDebug.enable(""), namespaces;
    }, createDebug.enable = function(namespaces) {
     let i;
     createDebug.save(namespaces), createDebug.namespaces = namespaces, createDebug.names = [], 
     createDebug.skips = [];
     const split = ("string" == typeof namespaces ? namespaces : "").split(/[\s,]+/), len = split.length;
     for (i = 0; i < len; i++) split[i] && ("-" === (namespaces = split[i].replace(/\*/g, ".*?"))[0] ? createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$")) : createDebug.names.push(new RegExp("^" + namespaces + "$")));
    }, createDebug.enabled = function(name) {
     if ("*" === name[name.length - 1]) return !0;
     let i, len;
     for (i = 0, len = createDebug.skips.length; i < len; i++) if (createDebug.skips[i].test(name)) return !1;
     for (i = 0, len = createDebug.names.length; i < len; i++) if (createDebug.names[i].test(name)) return !0;
     return !1;
    }, createDebug.humanize = __webpack_require__(57824), createDebug.destroy = function() {
     console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }, Object.keys(env).forEach((key => {
     createDebug[key] = env[key];
    })), createDebug.names = [], createDebug.skips = [], createDebug.formatters = {}, 
    createDebug.selectColor = function(namespace) {
     let hash = 0;
     for (let i = 0; i < namespace.length; i++) hash = (hash << 5) - hash + namespace.charCodeAt(i), 
     hash |= 0;
     return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }, createDebug.enable(createDebug.load()), createDebug;
   };
  },
  15158: (module, __unused_webpack_exports, __webpack_require__) => {
   "undefined" == typeof process || "renderer" === process.type || !0 === process.browser || process.__nwjs ? module.exports = __webpack_require__(11227) : module.exports = __webpack_require__(39);
  },
  39: (module, exports, __webpack_require__) => {
   const tty = __webpack_require__(76224), util = __webpack_require__(73837);
   exports.init = function(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0; i < keys.length; i++) debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
   }, exports.log = function(...args) {
    return process.stderr.write(util.format(...args) + "\n");
   }, exports.formatArgs = function(args) {
    const {namespace: name, useColors} = this;
    if (useColors) {
     const c = this.color, colorCode = "[3" + (c < 8 ? c : "8;5;" + c), prefix = `  ${colorCode};1m${name} [0m`;
     args[0] = prefix + args[0].split("\n").join("\n" + prefix), args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "[0m");
    } else args[0] = function() {
     if (exports.inspectOpts.hideDate) return "";
     return (new Date).toISOString() + " ";
    }() + name + " " + args[0];
   }, exports.save = function(namespaces) {
    namespaces ? process.env.DEBUG = namespaces : delete process.env.DEBUG;
   }, exports.load = function() {
    return process.env.DEBUG;
   }, exports.useColors = function() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
   }, exports.destroy = util.deprecate((() => {}), "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."), 
   exports.colors = [ 6, 2, 3, 4, 5, 1 ];
   try {
    const supportsColor = __webpack_require__(92130);
    supportsColor && (supportsColor.stderr || supportsColor).level >= 2 && (exports.colors = [ 20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221 ]);
   } catch (error) {}
   exports.inspectOpts = Object.keys(process.env).filter((key => /^debug_/i.test(key))).reduce(((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, ((_, k) => k.toUpperCase()));
    let val = process.env[key];
    return val = !!/^(yes|on|true|enabled)$/i.test(val) || !/^(no|off|false|disabled)$/i.test(val) && ("null" === val ? null : Number(val)), 
    obj[prop] = val, obj;
   }), {}), module.exports = __webpack_require__(82447)(exports);
   const {formatters} = module.exports;
   formatters.o = function(v) {
    return this.inspectOpts.colors = this.useColors, util.inspect(v, this.inspectOpts).split("\n").map((str => str.trim())).join(" ");
   }, formatters.O = function(v) {
    return this.inspectOpts.colors = this.useColors, util.inspect(v, this.inspectOpts);
   };
  },
  63463: (module, __unused_webpack_exports, __webpack_require__) => {
   var Stream = __webpack_require__(12781).Stream, util = __webpack_require__(73837);
   function DelayedStream() {
    this.source = null, this.dataSize = 0, this.maxDataSize = 1048576, this.pauseStream = !0, 
    this._maxDataSizeExceeded = !1, this._released = !1, this._bufferedEvents = [];
   }
   module.exports = DelayedStream, util.inherits(DelayedStream, Stream), DelayedStream.create = function(source, options) {
    var delayedStream = new this;
    for (var option in options = options || {}) delayedStream[option] = options[option];
    delayedStream.source = source;
    var realEmit = source.emit;
    return source.emit = function() {
     return delayedStream._handleEmit(arguments), realEmit.apply(source, arguments);
    }, source.on("error", (function() {})), delayedStream.pauseStream && source.pause(), 
    delayedStream;
   }, Object.defineProperty(DelayedStream.prototype, "readable", {
    configurable: !0,
    enumerable: !0,
    get: function() {
     return this.source.readable;
    }
   }), DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
   }, DelayedStream.prototype.resume = function() {
    this._released || this.release(), this.source.resume();
   }, DelayedStream.prototype.pause = function() {
    this.source.pause();
   }, DelayedStream.prototype.release = function() {
    this._released = !0, this._bufferedEvents.forEach(function(args) {
     this.emit.apply(this, args);
    }.bind(this)), this._bufferedEvents = [];
   }, DelayedStream.prototype.pipe = function() {
    var r = Stream.prototype.pipe.apply(this, arguments);
    return this.resume(), r;
   }, DelayedStream.prototype._handleEmit = function(args) {
    this._released ? this.emit.apply(this, args) : ("data" === args[0] && (this.dataSize += args[1].length, 
    this._checkIfMaxDataSizeExceeded()), this._bufferedEvents.push(args));
   }, DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (!(this._maxDataSizeExceeded || this.dataSize <= this.maxDataSize)) {
     this._maxDataSizeExceeded = !0;
     var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
     this.emit("error", new Error(message));
    }
   };
  },
  38604: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.enable = exports.azureCoreTracing = exports.AzureMonitorSymbol = void 0;
   var diagnostic_channel_1 = __webpack_require__(84953);
   exports.AzureMonitorSymbol = "Azure_Monitor_Tracer";
   var isPatched = !1;
   exports.azureCoreTracing = {
    versionSpecifier: ">= 1.0.0 < 2.0.0",
    patch: function(coreTracing) {
     if (isPatched) return coreTracing;
     try {
      var tracing = __webpack_require__(82506), api = __webpack_require__(94284), defaultProvider = new tracing.BasicTracerProvider, defaultTracer = defaultProvider.getTracer("applicationinsights tracer");
      if (coreTracing.setTracer) {
       var setTracerOriginal_1 = coreTracing.setTracer;
       coreTracing.setTracer = function(tracer) {
        var startSpanOriginal = tracer.startSpan;
        tracer.startSpan = function(name, options, context) {
         var span = startSpanOriginal.call(this, name, options, context), originalEnd = span.end;
         return span.end = function() {
          var result = originalEnd.apply(this, arguments);
          return diagnostic_channel_1.channel.publish("azure-coretracing", span), result;
         }, span;
        }, tracer[exports.AzureMonitorSymbol] = !0, setTracerOriginal_1.call(this, tracer);
       }, api.trace.getSpan(api.context.active()), coreTracing.setTracer(defaultTracer);
      } else {
       var setGlobalTracerProviderOriginal_1 = api.trace.setGlobalTracerProvider;
       api.trace.setGlobalTracerProvider = function(tracerProvider) {
        var getTracerOriginal = tracerProvider.getTracer;
        return tracerProvider.getTracer = function(tracerName, version) {
         var tracer = getTracerOriginal.call(this, tracerName, version);
         if (!tracer[exports.AzureMonitorSymbol]) {
          var startSpanOriginal_1 = tracer.startSpan;
          tracer.startSpan = function(spanName, options, context) {
           var span = startSpanOriginal_1.call(this, spanName, options, context), originalEnd = span.end;
           return span.end = function() {
            var result = originalEnd.apply(this, arguments);
            return diagnostic_channel_1.channel.publish("azure-coretracing", span), result;
           }, span;
          }, tracer[exports.AzureMonitorSymbol] = !0;
         }
         return tracer;
        }, setGlobalTracerProviderOriginal_1.call(this, tracerProvider);
       }, defaultProvider.register(), api.trace.getSpan(api.context.active());
       var openTelemetryInstr = __webpack_require__(30874), azureSdkInstr = __webpack_require__(87913);
       openTelemetryInstr.registerInstrumentations({
        instrumentations: [ azureSdkInstr.createAzureSdkInstrumentation() ]
       });
      }
      isPatched = !0;
     } catch (e) {}
     return coreTracing;
    },
    publisherName: "azure-coretracing"
   }, exports.enable = function() {
    diagnostic_channel_1.channel.registerMonkeyPatch("@azure/core-tracing", exports.azureCoreTracing);
   };
  },
  58859: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.enable = exports.bunyan = void 0;
   var diagnostic_channel_1 = __webpack_require__(84953);
   exports.bunyan = {
    versionSpecifier: ">= 1.0.0 < 2.0.0",
    patch: function(originalBunyan) {
     var originalEmit = originalBunyan.prototype._emit;
     return originalBunyan.prototype._emit = function(rec, noemit) {
      var ret = originalEmit.apply(this, arguments);
      if (!noemit) {
       var str = ret;
       str || (str = originalEmit.call(this, rec, !0)), diagnostic_channel_1.channel.publish("bunyan", {
        level: rec.level,
        result: str
       });
      }
      return ret;
     }, originalBunyan;
    }
   }, exports.enable = function() {
    diagnostic_channel_1.channel.registerMonkeyPatch("bunyan", exports.bunyan);
   };
  },
  92495: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.enable = exports.console = void 0;
   var diagnostic_channel_1 = __webpack_require__(84953), stream_1 = __webpack_require__(12781);
   exports.console = {
    versionSpecifier: ">= 4.0.0",
    patch: function(originalConsole) {
     var aiLoggingOutStream = new stream_1.Writable, aiLoggingErrStream = new stream_1.Writable;
     aiLoggingOutStream.write = function(chunk) {
      if (!chunk) return !0;
      var message = chunk.toString();
      return diagnostic_channel_1.channel.publish("console", {
       message
      }), !0;
     }, aiLoggingErrStream.write = function(chunk) {
      if (!chunk) return !0;
      var message = chunk.toString();
      return diagnostic_channel_1.channel.publish("console", {
       message,
       stderr: !0
      }), !0;
     };
     for (var aiLoggingConsole = new originalConsole.Console(aiLoggingOutStream, aiLoggingErrStream), _loop_1 = function(method) {
      var originalMethod = originalConsole[method];
      originalMethod && (originalConsole[method] = function() {
       if (aiLoggingConsole[method]) try {
        aiLoggingConsole[method].apply(aiLoggingConsole, arguments);
       } catch (e) {}
       return originalMethod.apply(originalConsole, arguments);
      });
     }, _i = 0, consoleMethods_1 = [ "log", "info", "warn", "error", "dir", "time", "timeEnd", "trace", "assert" ]; _i < consoleMethods_1.length; _i++) {
      _loop_1(consoleMethods_1[_i]);
     }
     return originalConsole;
    }
   }, exports.enable = function() {
    diagnostic_channel_1.channel.registerMonkeyPatch("console", exports.console), __webpack_require__(96206);
   };
  },
  4106: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.enable = exports.tedious = exports.pgPool = exports.pg = exports.winston = exports.redis = exports.mysql = exports.mongodb = exports.mongodbCore = exports.console = exports.bunyan = exports.azuresdk = void 0;
   var azuresdk = __webpack_require__(38604);
   exports.azuresdk = azuresdk;
   var bunyan = __webpack_require__(58859);
   exports.bunyan = bunyan;
   var consolePub = __webpack_require__(92495);
   exports.console = consolePub;
   var mongodbCore = __webpack_require__(72028);
   exports.mongodbCore = mongodbCore;
   var mongodb = __webpack_require__(88436);
   exports.mongodb = mongodb;
   var mysql = __webpack_require__(98002);
   exports.mysql = mysql;
   var pgPool = __webpack_require__(89024);
   exports.pgPool = pgPool;
   var pg = __webpack_require__(48060);
   exports.pg = pg;
   var redis = __webpack_require__(14487);
   exports.redis = redis;
   var tedious = __webpack_require__(66661);
   exports.tedious = tedious;
   var winston = __webpack_require__(14650);
   exports.winston = winston, exports.enable = function() {
    bunyan.enable(), consolePub.enable(), mongodbCore.enable(), mongodb.enable(), mysql.enable(), 
    pg.enable(), pgPool.enable(), redis.enable(), winston.enable(), azuresdk.enable(), 
    tedious.enable();
   };
  },
  72028: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.enable = exports.mongoCore = void 0;
   var diagnostic_channel_1 = __webpack_require__(84953);
   exports.mongoCore = {
    versionSpecifier: ">= 2.0.0 < 4.0.0",
    patch: function(originalMongoCore) {
     var originalConnect = originalMongoCore.Server.prototype.connect;
     return originalMongoCore.Server.prototype.connect = function() {
      var ret = originalConnect.apply(this, arguments), originalWrite = this.s.pool.write;
      this.s.pool.write = function() {
       var cbidx = "function" == typeof arguments[1] ? 1 : 2;
       return "function" == typeof arguments[cbidx] && (arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(arguments[cbidx])), 
       originalWrite.apply(this, arguments);
      };
      var originalLogout = this.s.pool.logout;
      return this.s.pool.logout = function() {
       return "function" == typeof arguments[1] && (arguments[1] = diagnostic_channel_1.channel.bindToContext(arguments[1])), 
       originalLogout.apply(this, arguments);
      }, ret;
     }, originalMongoCore;
    }
   }, exports.enable = function() {
    diagnostic_channel_1.channel.registerMonkeyPatch("mongodb-core", exports.mongoCore);
   };
  },
  88436: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __assign = this && this.__assign || function() {
    return __assign = Object.assign || function(t) {
     for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
     return t;
    }, __assign.apply(this, arguments);
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.enable = exports.mongo330 = exports.mongo3 = exports.mongo2 = void 0;
   var diagnostic_channel_1 = __webpack_require__(84953);
   exports.mongo2 = {
    versionSpecifier: ">= 2.0.0 <= 3.0.5",
    patch: function(originalMongo) {
     var listener = originalMongo.instrument({
      operationIdGenerator: {
       next: function() {
        return diagnostic_channel_1.channel.bindToContext((function(cb) {
         return cb();
        }));
       }
      }
     }), eventMap = {};
     return listener.on("started", (function(event) {
      eventMap[event.requestId] || (eventMap[event.requestId] = __assign(__assign({}, event), {
       time: new Date
      }));
     })), listener.on("succeeded", (function(event) {
      var startedData = eventMap[event.requestId];
      startedData && delete eventMap[event.requestId], "function" == typeof event.operationId ? event.operationId((function() {
       return diagnostic_channel_1.channel.publish("mongodb", {
        startedData,
        event,
        succeeded: !0
       });
      })) : diagnostic_channel_1.channel.publish("mongodb", {
       startedData,
       event,
       succeeded: !0
      });
     })), listener.on("failed", (function(event) {
      var startedData = eventMap[event.requestId];
      startedData && delete eventMap[event.requestId], "function" == typeof event.operationId ? event.operationId((function() {
       return diagnostic_channel_1.channel.publish("mongodb", {
        startedData,
        event,
        succeeded: !1
       });
      })) : diagnostic_channel_1.channel.publish("mongodb", {
       startedData,
       event,
       succeeded: !1
      });
     })), originalMongo;
    }
   }, exports.mongo3 = {
    versionSpecifier: "> 3.0.5 < 3.3.0",
    patch: function(originalMongo) {
     var listener = originalMongo.instrument(), eventMap = {}, contextMap = {};
     return listener.on("started", (function(event) {
      eventMap[event.requestId] || (contextMap[event.requestId] = diagnostic_channel_1.channel.bindToContext((function(cb) {
       return cb();
      })), eventMap[event.requestId] = __assign(__assign({}, event), {
       time: new Date
      }));
     })), listener.on("succeeded", (function(event) {
      var startedData = eventMap[event.requestId];
      startedData && delete eventMap[event.requestId], "object" == typeof event && "function" == typeof contextMap[event.requestId] && (contextMap[event.requestId]((function() {
       return diagnostic_channel_1.channel.publish("mongodb", {
        startedData,
        event,
        succeeded: !0
       });
      })), delete contextMap[event.requestId]);
     })), listener.on("failed", (function(event) {
      var startedData = eventMap[event.requestId];
      startedData && delete eventMap[event.requestId], "object" == typeof event && "function" == typeof contextMap[event.requestId] && (contextMap[event.requestId]((function() {
       return diagnostic_channel_1.channel.publish("mongodb", {
        startedData,
        event,
        succeeded: !1
       });
      })), delete contextMap[event.requestId]);
     })), originalMongo;
    }
   }, exports.mongo330 = {
    versionSpecifier: ">= 3.3.0 < 4.0.0",
    patch: function(originalMongo) {
     !function(originalMongo) {
      var originalConnect = originalMongo.Server.prototype.connect;
      originalMongo.Server.prototype.connect = function() {
       var ret = originalConnect.apply(this, arguments), originalWrite = this.s.coreTopology.s.pool.write;
       this.s.coreTopology.s.pool.write = function() {
        var cbidx = "function" == typeof arguments[1] ? 1 : 2;
        return "function" == typeof arguments[cbidx] && (arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(arguments[cbidx])), 
        originalWrite.apply(this, arguments);
       };
       var originalLogout = this.s.coreTopology.s.pool.logout;
       return this.s.coreTopology.s.pool.logout = function() {
        return "function" == typeof arguments[1] && (arguments[1] = diagnostic_channel_1.channel.bindToContext(arguments[1])), 
        originalLogout.apply(this, arguments);
       }, ret;
      };
     }(originalMongo);
     var listener = originalMongo.instrument(), eventMap = {}, contextMap = {};
     return listener.on("started", (function(event) {
      eventMap[event.requestId] || (contextMap[event.requestId] = diagnostic_channel_1.channel.bindToContext((function(cb) {
       return cb();
      })), eventMap[event.requestId] = event);
     })), listener.on("succeeded", (function(event) {
      var startedData = eventMap[event.requestId];
      startedData && delete eventMap[event.requestId], "object" == typeof event && "function" == typeof contextMap[event.requestId] && (contextMap[event.requestId]((function() {
       return diagnostic_channel_1.channel.publish("mongodb", {
        startedData,
        event,
        succeeded: !0
       });
      })), delete contextMap[event.requestId]);
     })), listener.on("failed", (function(event) {
      var startedData = eventMap[event.requestId];
      startedData && delete eventMap[event.requestId], "object" == typeof event && "function" == typeof contextMap[event.requestId] && (contextMap[event.requestId]((function() {
       return diagnostic_channel_1.channel.publish("mongodb", {
        startedData,
        event,
        succeeded: !1
       });
      })), delete contextMap[event.requestId]);
     })), originalMongo;
    }
   }, exports.enable = function() {
    diagnostic_channel_1.channel.registerMonkeyPatch("mongodb", exports.mongo2), diagnostic_channel_1.channel.registerMonkeyPatch("mongodb", exports.mongo3), 
    diagnostic_channel_1.channel.registerMonkeyPatch("mongodb", exports.mongo330);
   };
  },
  98002: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.enable = exports.mysql = void 0;
   var diagnostic_channel_1 = __webpack_require__(84953), path = __webpack_require__(71017);
   exports.mysql = {
    versionSpecifier: ">= 2.0.0 < 3.0.0",
    patch: function(originalMysql, originalMysqlPath) {
     var patchObjectFunction = function(obj, name) {
      return function(func, cbWrapper) {
       var originalFunc = obj[func];
       originalFunc && (obj[func] = function() {
        for (var cbidx = arguments.length - 1, i = arguments.length - 1; i >= 0; --i) {
         if ("function" == typeof arguments[i]) {
          cbidx = i;
          break;
         }
         if (void 0 !== arguments[i]) break;
        }
        var cb = arguments[cbidx], resultContainer = {
         result: null,
         startTime: null,
         startDate: null
        };
        "function" == typeof cb && (cbWrapper ? (resultContainer.startTime = process.hrtime(), 
        resultContainer.startDate = new Date, arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(cbWrapper(resultContainer, cb))) : arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(cb));
        var result = originalFunc.apply(this, arguments);
        return resultContainer.result = result, result;
       });
      };
     }, patchClassMemberFunction = function(classObject, name) {
      return patchObjectFunction(classObject.prototype);
     }, connectionClass = __webpack_require__(54694)(path.dirname(originalMysqlPath) + "/lib/Connection");
     [ "connect", "changeUser", "ping", "statistics", "end" ].forEach((function(value) {
      return patchClassMemberFunction(connectionClass)(value);
     })), patchObjectFunction(connectionClass)("createQuery", (function(resultContainer, cb) {
      return function(err) {
       var hrDuration = process.hrtime(resultContainer.startTime), duration = 1e3 * hrDuration[0] + hrDuration[1] / 1e6 | 0;
       diagnostic_channel_1.channel.publish("mysql", {
        query: resultContainer.result,
        callbackArgs: arguments,
        err,
        duration,
        time: resultContainer.startDate
       }), cb.apply(this, arguments);
      };
     }));
     var poolClass = __webpack_require__(80420)(path.dirname(originalMysqlPath) + "/lib/Pool");
     return [ "_enqueueCallback" ].forEach((function(value) {
      return patchClassMemberFunction(poolClass)(value);
     })), originalMysql;
    }
   }, exports.enable = function() {
    diagnostic_channel_1.channel.registerMonkeyPatch("mysql", exports.mysql);
   };
  },
  89024: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.enable = exports.postgresPool1 = void 0;
   var diagnostic_channel_1 = __webpack_require__(84953);
   exports.postgresPool1 = {
    versionSpecifier: ">= 1.0.0 < 3.0.0",
    patch: function(originalPgPool) {
     var originalConnect = originalPgPool.prototype.connect;
     return originalPgPool.prototype.connect = function(callback) {
      return callback && (arguments[0] = diagnostic_channel_1.channel.bindToContext(callback)), 
      originalConnect.apply(this, arguments);
     }, originalPgPool;
    }
   }, exports.enable = function() {
    diagnostic_channel_1.channel.registerMonkeyPatch("pg-pool", exports.postgresPool1);
   };
  },
  48060: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.enable = exports.postgres = exports.postgres6 = void 0;
   var diagnostic_channel_1 = __webpack_require__(84953), events_1 = __webpack_require__(82361);
   exports.postgres6 = {
    versionSpecifier: "6.*",
    patch: function(originalPg, originalPgPath) {
     var originalClientQuery = originalPg.Client.prototype.query;
     return originalPg.Client.prototype.query = function(config, values, callback) {
      var queryResult, data = {
       query: {},
       database: {
        host: this.connectionParameters.host,
        port: this.connectionParameters.port
       },
       result: null,
       error: null,
       duration: 0,
       time: new Date
      }, start = process.hrtime();
      function patchCallback(cb) {
       cb && cb.__diagnosticOriginalFunc && (cb = cb.__diagnosticOriginalFunc);
       var trackingCallback = diagnostic_channel_1.channel.bindToContext((function(err, res) {
        var end = process.hrtime(start);
        if (data.result = res && {
         rowCount: res.rowCount,
         command: res.command
        }, data.error = err, data.duration = Math.ceil(1e3 * end[0] + end[1] / 1e6), diagnostic_channel_1.channel.publish("postgres", data), 
        err) {
         if (cb) return cb.apply(this, arguments);
         queryResult && queryResult instanceof events_1.EventEmitter && queryResult.emit("error", err);
        } else cb && cb.apply(this, arguments);
       }));
       try {
        return Object.defineProperty(trackingCallback, "__diagnosticOriginalFunc", {
         value: cb
        }), trackingCallback;
       } catch (e) {
        return cb;
       }
      }
      try {
       "string" == typeof config ? values instanceof Array ? (data.query.preparable = {
        text: config,
        args: values
       }, callback = patchCallback(callback)) : (data.query.text = config, callback ? callback = patchCallback(callback) : values = patchCallback(values)) : ("string" == typeof config.name ? data.query.plan = config.name : config.values instanceof Array ? data.query.preparable = {
        text: config.text,
        args: config.values
       } : data.query.text = config.text, callback ? callback = patchCallback(callback) : values ? values = patchCallback(values) : config.callback = patchCallback(config.callback));
      } catch (e) {
       return originalClientQuery.apply(this, arguments);
      }
      return arguments[0] = config, arguments[1] = values, arguments[2] = callback, arguments.length = arguments.length > 3 ? arguments.length : 3, 
      queryResult = originalClientQuery.apply(this, arguments);
     }, originalPg;
    }
   }, exports.postgres = {
    versionSpecifier: ">=7.* <=8.*",
    patch: function(originalPg, originalPgPath) {
     var originalClientQuery = originalPg.Client.prototype.query;
     return originalPg.Client.prototype.query = function(config, values, callback) {
      var _a, _b, queryResult, _this = this, callbackProvided = !!callback, data = {
       query: {},
       database: {
        host: this.connectionParameters.host,
        port: this.connectionParameters.port
       },
       result: null,
       error: null,
       duration: 0,
       time: new Date
      }, start = process.hrtime();
      function patchCallback(cb) {
       cb && cb.__diagnosticOriginalFunc && (cb = cb.__diagnosticOriginalFunc);
       var trackingCallback = diagnostic_channel_1.channel.bindToContext((function(err, res) {
        var end = process.hrtime(start);
        if (data.result = res && {
         rowCount: res.rowCount,
         command: res.command
        }, data.error = err, data.duration = Math.ceil(1e3 * end[0] + end[1] / 1e6), diagnostic_channel_1.channel.publish("postgres", data), 
        err) {
         if (cb) return cb.apply(this, arguments);
         queryResult && queryResult instanceof events_1.EventEmitter && queryResult.emit("error", err);
        } else cb && cb.apply(this, arguments);
       }));
       try {
        return Object.defineProperty(trackingCallback, "__diagnosticOriginalFunc", {
         value: cb
        }), trackingCallback;
       } catch (e) {
        return cb;
       }
      }
      try {
       "string" == typeof config ? values instanceof Array ? (data.query.preparable = {
        text: config,
        args: values
       }, callback = (callbackProvided = "function" == typeof callback) ? patchCallback(callback) : callback) : (data.query.text = config, 
       callback ? callback = (callbackProvided = "function" == typeof callback) ? patchCallback(callback) : callback : values = (callbackProvided = "function" == typeof values) ? patchCallback(values) : values) : ("string" == typeof config.name ? data.query.plan = config.name : config.values instanceof Array ? data.query.preparable = {
        text: config.text,
        args: config.values
       } : config.cursor ? data.query.text = null === (_a = config.cursor) || void 0 === _a ? void 0 : _a.text : data.query.text = config.text, 
       callback ? (callbackProvided = "function" == typeof callback, callback = patchCallback(callback)) : values ? values = (callbackProvided = "function" == typeof values) ? patchCallback(values) : values : (callbackProvided = "function" == typeof config.callback, 
       config.callback = callbackProvided ? patchCallback(config.callback) : config.callback));
      } catch (e) {
       return originalClientQuery.apply(this, arguments);
      }
      arguments[0] = config, arguments[1] = values, arguments[2] = callback, arguments.length = arguments.length > 3 ? arguments.length : 3;
      try {
       queryResult = originalClientQuery.apply(this, arguments);
      } catch (err) {
       throw patchCallback()(err, void 0), err;
      }
      if (!callbackProvided) {
       if (queryResult instanceof Promise) return queryResult.then((function(result) {
        return patchCallback()(void 0, result), new _this._Promise((function(resolve, reject) {
         resolve(result);
        }));
       })).catch((function(error) {
        return patchCallback()(error, void 0), new _this._Promise((function(resolve, reject) {
         reject(error);
        }));
       }));
       var command = queryResult.text ? queryResult.text : "";
       if (queryResult.cursor && (command = null === (_b = queryResult.cursor) || void 0 === _b ? void 0 : _b.text), 
       command) {
        var res = {
         command,
         rowCount: 0
        };
        patchCallback()(void 0, res);
       }
      }
      return queryResult;
     }, originalPg;
    },
    publisherName: "postgres"
   }, exports.enable = function() {
    diagnostic_channel_1.channel.registerMonkeyPatch("pg", exports.postgres6), diagnostic_channel_1.channel.registerMonkeyPatch("pg", exports.postgres);
   };
  },
  14487: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.enable = exports.redis = void 0;
   var diagnostic_channel_1 = __webpack_require__(84953);
   exports.redis = {
    versionSpecifier: ">= 2.0.0 < 4.0.0",
    patch: function(originalRedis) {
     var originalSend = originalRedis.RedisClient.prototype.internal_send_command;
     return originalRedis.RedisClient.prototype.internal_send_command = function(commandObj) {
      if (commandObj) {
       var cb_1 = commandObj.callback;
       if (!cb_1 || !cb_1.pubsubBound) {
        var address_1 = this.address, startTime_1 = process.hrtime(), startDate_1 = new Date;
        commandObj.callback = diagnostic_channel_1.channel.bindToContext((function(err, result) {
         var hrDuration = process.hrtime(startTime_1), duration = 1e3 * hrDuration[0] + hrDuration[1] / 1e6 | 0;
         diagnostic_channel_1.channel.publish("redis", {
          duration,
          address: address_1,
          commandObj,
          err,
          result,
          time: startDate_1
         }), "function" == typeof cb_1 && cb_1.apply(this, arguments);
        })), commandObj.callback.pubsubBound = !0;
       }
      }
      return originalSend.call(this, commandObj);
     }, originalRedis;
    }
   }, exports.enable = function() {
    diagnostic_channel_1.channel.registerMonkeyPatch("redis", exports.redis);
   };
  },
  66661: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __assign = this && this.__assign || function() {
    return __assign = Object.assign || function(t) {
     for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
     return t;
    }, __assign.apply(this, arguments);
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.enable = exports.tedious = void 0;
   var diagnostic_channel_1 = __webpack_require__(84953);
   exports.tedious = {
    versionSpecifier: ">= 6.0.0 < 9.0.0",
    patch: function(originalTedious) {
     var originalMakeRequest = originalTedious.Connection.prototype.makeRequest;
     return originalTedious.Connection.prototype.makeRequest = function() {
      var origCallback, start, data, request = arguments[0];
      arguments[0].callback = (origCallback = request.callback, start = process.hrtime(), 
      data = {
       query: {},
       database: {
        host: null,
        port: null
       },
       result: null,
       error: null,
       duration: 0
      }, diagnostic_channel_1.channel.bindToContext((function(err, rowCount, rows) {
       var end = process.hrtime(start);
       data = __assign(__assign({}, data), {
        database: {
         host: this.connection.config.server,
         port: this.connection.config.options.port
        },
        result: !err && {
         rowCount,
         rows
        },
        query: {
         text: this.parametersByName.statement.value
        },
        error: err,
        duration: Math.ceil(1e3 * end[0] + end[1] / 1e6)
       }), diagnostic_channel_1.channel.publish("tedious", data), origCallback.call(this, err, rowCount, rows);
      }))), originalMakeRequest.apply(this, arguments);
     }, originalTedious;
    }
   }, exports.enable = function() {
    diagnostic_channel_1.channel.registerMonkeyPatch("tedious", exports.tedious);
   };
  },
  14650: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var extendStatics, __extends = this && this.__extends || (extendStatics = function(d, b) {
    return extendStatics = Object.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
    }, extendStatics(d, b);
   }, function(d, b) {
    function __() {
     this.constructor = d;
    }
    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
    new __);
   }), __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
     var i = 0;
     for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.enable = exports.winston2 = exports.winston3 = void 0;
   var diagnostic_channel_1 = __webpack_require__(84953);
   exports.winston3 = {
    versionSpecifier: "3.x",
    patch: function(originalWinston) {
     var AppInsightsTransport = function(_super) {
      function AppInsightsTransport(winston, opts) {
       var _this = _super.call(this, opts) || this;
       return _this.winston = winston, _this;
      }
      return __extends(AppInsightsTransport, _super), AppInsightsTransport.prototype.log = function(info, callback) {
       var message = info.message, level = info.level, meta = info.meta, splat = __rest(info, [ "message", "level", "meta" ]);
       level = "function" == typeof Symbol.for ? info[Symbol.for("level")] : level, message = info instanceof Error ? info : message;
       var levelKind = function(winston, level) {
        return null != winston.config.npm.levels[level] ? "npm" : null != winston.config.syslog.levels[level] ? "syslog" : "unknown";
       }(this.winston, level);
       for (var key in meta = meta || {}, splat) splat.hasOwnProperty(key) && (meta[key] = splat[key]);
       diagnostic_channel_1.channel.publish("winston", {
        message,
        level,
        levelKind,
        meta
       }), callback();
      }, AppInsightsTransport;
     }(originalWinston.Transport);
     function patchedConfigure() {
      var lastLevel, levels = originalWinston.config.npm.levels;
      for (var level in arguments && arguments[0] && arguments[0].levels && (levels = arguments[0].levels), 
      levels) levels.hasOwnProperty(level) && (lastLevel = void 0 === lastLevel || levels[level] > levels[lastLevel] ? level : lastLevel);
      this.add(new AppInsightsTransport(originalWinston, {
       level: lastLevel
      }));
     }
     var origCreate = originalWinston.createLogger;
     originalWinston.createLogger = function() {
      var lastLevel, levels = originalWinston.config.npm.levels;
      for (var level in arguments && arguments[0] && arguments[0].levels && (levels = arguments[0].levels), 
      levels) levels.hasOwnProperty(level) && (lastLevel = void 0 === lastLevel || levels[level] > levels[lastLevel] ? level : lastLevel);
      var result = origCreate.apply(this, arguments);
      result.add(new AppInsightsTransport(originalWinston, {
       level: lastLevel
      }));
      var origConfigure = result.configure;
      return result.configure = function() {
       origConfigure.apply(this, arguments), patchedConfigure.apply(this, arguments);
      }, result;
     };
     var origRootConfigure = originalWinston.configure;
     return originalWinston.configure = function() {
      origRootConfigure.apply(this, arguments), patchedConfigure.apply(this, arguments);
     }, originalWinston.add(new AppInsightsTransport(originalWinston)), originalWinston;
    }
   }, exports.winston2 = {
    versionSpecifier: "2.x",
    patch: function(originalWinston) {
     var curLevels, originalLog = originalWinston.Logger.prototype.log, loggingFilter = function(level, message, meta) {
      var levelKind;
      return levelKind = curLevels === originalWinston.config.npm.levels ? "npm" : curLevels === originalWinston.config.syslog.levels ? "syslog" : "unknown", 
      diagnostic_channel_1.channel.publish("winston", {
       level,
       message,
       meta,
       levelKind
      }), message;
     };
     return originalWinston.Logger.prototype.log = function() {
      return curLevels = this.levels, this.filters && 0 !== this.filters.length ? this.filters[this.filters.length - 1] !== loggingFilter && (this.filters = this.filters.filter((function(f) {
       return f !== loggingFilter;
      })), this.filters.push(loggingFilter)) : this.filters = [ loggingFilter ], originalLog.apply(this, arguments);
     }, originalWinston;
    }
   }, exports.enable = function() {
    diagnostic_channel_1.channel.registerMonkeyPatch("winston", exports.winston2), diagnostic_channel_1.channel.registerMonkeyPatch("winston", exports.winston3);
   };
  },
  54694: module => {
   function webpackEmptyContext(req) {
    var e = new Error("Cannot find module '" + req + "'");
    throw e.code = "MODULE_NOT_FOUND", e;
   }
   webpackEmptyContext.keys = () => [], webpackEmptyContext.resolve = webpackEmptyContext, 
   webpackEmptyContext.id = 54694, module.exports = webpackEmptyContext;
  },
  80420: module => {
   function webpackEmptyContext(req) {
    var e = new Error("Cannot find module '" + req + "'");
    throw e.code = "MODULE_NOT_FOUND", e;
   }
   webpackEmptyContext.keys = () => [], webpackEmptyContext.resolve = webpackEmptyContext, 
   webpackEmptyContext.id = 80420, module.exports = webpackEmptyContext;
  },
  84953: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.channel = exports.ContextPreservingEventEmitter = exports.trueFilter = exports.makePatchingRequire = void 0;
   var patchRequire_1 = __webpack_require__(37424), patchRequire_2 = __webpack_require__(37424);
   Object.defineProperty(exports, "makePatchingRequire", {
    enumerable: !0,
    get: function() {
     return patchRequire_2.makePatchingRequire;
    }
   });
   exports.trueFilter = function(publishing) {
    return !0;
   };
   var ContextPreservingEventEmitter = function() {
    function ContextPreservingEventEmitter() {
     this.version = __webpack_require__(130).i8, this.subscribers = {}, this.contextPreservationFunction = function(cb) {
      return cb;
     }, this.knownPatches = {}, this.modulesPatched = [], this.currentlyPublishing = !1;
    }
    return ContextPreservingEventEmitter.prototype.shouldPublish = function(name) {
     var listeners = this.subscribers[name];
     return !!listeners && listeners.some((function(_a) {
      var filter = _a.filter;
      return !filter || filter(!1);
     }));
    }, ContextPreservingEventEmitter.prototype.publish = function(name, event) {
     if (!this.currentlyPublishing) {
      var listeners = this.subscribers[name];
      if (listeners) {
       var standardEvent_1 = {
        timestamp: Date.now(),
        data: event
       };
       this.currentlyPublishing = !0, listeners.forEach((function(_a) {
        var listener = _a.listener, filter = _a.filter;
        try {
         filter && filter(!0) && listener(standardEvent_1);
        } catch (e) {}
       })), this.currentlyPublishing = !1;
      }
     }
    }, ContextPreservingEventEmitter.prototype.subscribe = function(name, listener, filter, patchCallback) {
     void 0 === filter && (filter = exports.trueFilter), this.subscribers[name] || (this.subscribers[name] = []), 
     this.subscribers[name].push({
      listener,
      filter,
      patchCallback
     });
     var patched = this.checkIfModuleIsAlreadyPatched(name);
     patched && patchCallback && patchCallback(patched.name, patched.version);
    }, ContextPreservingEventEmitter.prototype.unsubscribe = function(name, listener, filter) {
     void 0 === filter && (filter = exports.trueFilter);
     var listeners = this.subscribers[name];
     if (listeners) for (var index = 0; index < listeners.length; ++index) if (listeners[index].listener === listener && listeners[index].filter === filter) return listeners.splice(index, 1), 
     !0;
     return !1;
    }, ContextPreservingEventEmitter.prototype.reset = function() {
     var _this = this;
     this.subscribers = {}, this.contextPreservationFunction = function(cb) {
      return cb;
     }, Object.getOwnPropertyNames(this.knownPatches).forEach((function(prop) {
      return delete _this.knownPatches[prop];
     }));
    }, ContextPreservingEventEmitter.prototype.bindToContext = function(cb) {
     return this.contextPreservationFunction(cb);
    }, ContextPreservingEventEmitter.prototype.addContextPreservation = function(preserver) {
     var previousPreservationStack = this.contextPreservationFunction;
     this.contextPreservationFunction = function(cb) {
      return preserver(previousPreservationStack(cb));
     };
    }, ContextPreservingEventEmitter.prototype.registerMonkeyPatch = function(packageName, patcher) {
     this.knownPatches[packageName] || (this.knownPatches[packageName] = []), this.knownPatches[packageName].push(patcher);
    }, ContextPreservingEventEmitter.prototype.getPatchesObject = function() {
     return this.knownPatches;
    }, ContextPreservingEventEmitter.prototype.addPatchedModule = function(name, version) {
     for (var _i = 0, _a = this.modulesPatched; _i < _a.length; _i++) {
      if (_a[_i].name === name) return;
     }
     this.modulesPatched.push({
      name,
      version
     });
     var listeners = this.subscribers[name];
     listeners && listeners.forEach((function(listener) {
      listener.patchCallback && listener.patchCallback(name, version);
     }));
    }, ContextPreservingEventEmitter.prototype.checkIfModuleIsAlreadyPatched = function(name) {
     for (var _i = 0, _a = this.modulesPatched; _i < _a.length; _i++) {
      var module_2 = _a[_i];
      if (module_2.name === name) return module_2;
     }
     return null;
    }, ContextPreservingEventEmitter;
   }();
   (exports.ContextPreservingEventEmitter = ContextPreservingEventEmitter, global.diagnosticsSource) || (global.diagnosticsSource = new ContextPreservingEventEmitter, 
   __webpack_require__(98188).prototype.require = patchRequire_1.makePatchingRequire(global.diagnosticsSource.getPatchesObject()));
   exports.channel = global.diagnosticsSource;
  },
  37424: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.makePatchingRequire = void 0;
   var path = __webpack_require__(71017), semver = __webpack_require__(81249), channel_1 = __webpack_require__(84953), moduleModule = __webpack_require__(98188), nativeModules = Object.keys(process.binding("natives")), originalRequire = moduleModule.prototype.require;
   exports.makePatchingRequire = function(knownPatches) {
    var patchedModules = {};
    return function(moduleId) {
     var originalModule = originalRequire.apply(this, arguments);
     if (knownPatches[moduleId]) {
      var modulePath = moduleModule._resolveFilename(moduleId, this);
      if (patchedModules.hasOwnProperty(modulePath)) return patchedModules[modulePath];
      var moduleVersion = void 0;
      if (nativeModules.indexOf(moduleId) < 0) try {
       moduleVersion = originalRequire.call(this, path.join(moduleId, "package.json")).version;
      } catch (e) {
       return originalModule;
      } else moduleVersion = process.version.substring(1);
      var prereleaseTagIndex = moduleVersion.indexOf("-");
      prereleaseTagIndex >= 0 && (moduleVersion = moduleVersion.substring(0, prereleaseTagIndex));
      for (var modifiedModule = originalModule, _i = 0, _a = knownPatches[moduleId]; _i < _a.length; _i++) {
       var modulePatcher = _a[_i];
       if (semver.satisfies(moduleVersion, modulePatcher.versionSpecifier) && (modifiedModule = modulePatcher.patch(modifiedModule, modulePath), 
       channel_1.channel)) {
        var name_1 = modulePatcher.publisherName || moduleId;
        channel_1.channel.addPatchedModule(name_1, moduleVersion);
       }
      }
      return patchedModules[modulePath] = modifiedModule;
     }
     return originalModule;
    };
   };
  },
  69867: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var shimmer = __webpack_require__(76372), wrap = shimmer.wrap, unwrap = shimmer.unwrap, SYMBOL = "wrap@before";
   function defineProperty(obj, name, value) {
    var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);
    Object.defineProperty(obj, name, {
     configurable: !0,
     enumerable,
     writable: !0,
     value
    });
   }
   function _listeners(self, event) {
    var listeners;
    return listeners = self._events && self._events[event], Array.isArray(listeners) || (listeners = listeners ? [ listeners ] : []), 
    listeners;
   }
   function _findAndProcess(self, event, before) {
    var unprocessed = _listeners(self, event).filter((function(fn) {
     return -1 === before.indexOf(fn);
    }));
    unprocessed.length > 0 && function(self, listeners) {
     for (var l = listeners.length, p = 0; p < l; p++) {
      var listener = listeners[p], before = self[SYMBOL];
      if ("function" == typeof before) before(listener); else if (Array.isArray(before)) for (var length = before.length, i = 0; i < length; i++) before[i](listener);
     }
    }(self, unprocessed);
   }
   function _wrap(unwrapped, visit) {
    if (unwrapped) {
     var wrapped = unwrapped;
     if ("function" == typeof unwrapped) wrapped = visit(unwrapped); else if (Array.isArray(unwrapped)) {
      wrapped = [];
      for (var i = 0; i < unwrapped.length; i++) wrapped[i] = visit(unwrapped[i]);
     }
     return wrapped;
    }
   }
   module.exports = function(emitter, onAddListener, onEmit) {
    if (!(emitter && emitter.on && emitter.addListener && emitter.removeListener && emitter.emit)) throw new Error("can only wrap real EEs");
    if (!onAddListener) throw new Error("must have function to run on listener addition");
    if (!onEmit) throw new Error("must have function to wrap listeners when emitting");
    function adding(on) {
     return function(event, listener) {
      var existing = _listeners(this, event).slice();
      try {
       var returned = on.call(this, event, listener);
       return _findAndProcess(this, event, existing), returned;
      } finally {
       this.on.__wrapped || wrap(this, "on", adding), this.addListener.__wrapped || wrap(this, "addListener", adding);
      }
     };
    }
    emitter[SYMBOL] ? "function" == typeof emitter[SYMBOL] ? defineProperty(emitter, SYMBOL, [ emitter[SYMBOL], onAddListener ]) : Array.isArray(emitter[SYMBOL]) && emitter[SYMBOL].push(onAddListener) : defineProperty(emitter, SYMBOL, onAddListener), 
    emitter.__wrapped || (wrap(emitter, "addListener", adding), wrap(emitter, "on", adding), 
    wrap(emitter, "emit", (function(emit) {
     return function(event) {
      if (!this._events || !this._events[event]) return emit.apply(this, arguments);
      var unwrapped = this._events[event];
      wrap(this, "removeListener", (function(removeListener) {
       return function() {
        this._events[event] = unwrapped;
        try {
         return removeListener.apply(this, arguments);
        } finally {
         unwrapped = this._events[event], this._events[event] = _wrap(unwrapped, onEmit);
        }
       };
      }));
      try {
       return this._events[event] = _wrap(unwrapped, onEmit), emit.apply(this, arguments);
      } finally {
       unwrap(this, "removeListener"), this._events[event] = unwrapped;
      }
     };
    })), defineProperty(emitter, "__unwrap", (function() {
     unwrap(emitter, "addListener"), unwrap(emitter, "on"), unwrap(emitter, "emit"), 
     delete emitter[SYMBOL], delete emitter.__wrapped;
    })), defineProperty(emitter, "__wrapped", !0));
   };
  },
  46882: (module, __unused_webpack_exports, __webpack_require__) => {
   var CombinedStream = __webpack_require__(9779), util = __webpack_require__(73837), path = __webpack_require__(71017), http = __webpack_require__(13685), https = __webpack_require__(95687), parseUrl = __webpack_require__(57310).parse, fs = __webpack_require__(57147), Stream = __webpack_require__(12781).Stream, mime = __webpack_require__(80983), asynckit = __webpack_require__(59118), populate = __webpack_require__(32275);
   function FormData(options) {
    if (!(this instanceof FormData)) return new FormData(options);
    for (var option in this._overheadLength = 0, this._valueLength = 0, this._valuesToMeasure = [], 
    CombinedStream.call(this), options = options || {}) this[option] = options[option];
   }
   module.exports = FormData, util.inherits(FormData, CombinedStream), FormData.LINE_BREAK = "\r\n", 
   FormData.DEFAULT_CONTENT_TYPE = "application/octet-stream", FormData.prototype.append = function(field, value, options) {
    "string" == typeof (options = options || {}) && (options = {
     filename: options
    });
    var append = CombinedStream.prototype.append.bind(this);
    if ("number" == typeof value && (value = "" + value), util.isArray(value)) this._error(new Error("Arrays are not supported.")); else {
     var header = this._multiPartHeader(field, value, options), footer = this._multiPartFooter();
     append(header), append(value), append(footer), this._trackLength(header, value, options);
    }
   }, FormData.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    null != options.knownLength ? valueLength += +options.knownLength : Buffer.isBuffer(value) ? valueLength = value.length : "string" == typeof value && (valueLength = Buffer.byteLength(value)), 
    this._valueLength += valueLength, this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length, 
    value && (value.path || value.readable && value.hasOwnProperty("httpVersion") || value instanceof Stream) && (options.knownLength || this._valuesToMeasure.push(value));
   }, FormData.prototype._lengthRetriever = function(value, callback) {
    value.hasOwnProperty("fd") ? null != value.end && value.end != 1 / 0 && null != value.start ? callback(null, value.end + 1 - (value.start ? value.start : 0)) : fs.stat(value.path, (function(err, stat) {
     var fileSize;
     err ? callback(err) : (fileSize = stat.size - (value.start ? value.start : 0), callback(null, fileSize));
    })) : value.hasOwnProperty("httpVersion") ? callback(null, +value.headers["content-length"]) : value.hasOwnProperty("httpModule") ? (value.on("response", (function(response) {
     value.pause(), callback(null, +response.headers["content-length"]);
    })), value.resume()) : callback("Unknown stream");
   }, FormData.prototype._multiPartHeader = function(field, value, options) {
    if ("string" == typeof options.header) return options.header;
    var header, contentDisposition = this._getContentDisposition(value, options), contentType = this._getContentType(value, options), contents = "", headers = {
     "Content-Disposition": [ "form-data", 'name="' + field + '"' ].concat(contentDisposition || []),
     "Content-Type": [].concat(contentType || [])
    };
    for (var prop in "object" == typeof options.header && populate(headers, options.header), 
    headers) headers.hasOwnProperty(prop) && null != (header = headers[prop]) && (Array.isArray(header) || (header = [ header ]), 
    header.length && (contents += prop + ": " + header.join("; ") + FormData.LINE_BREAK));
    return "--" + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
   }, FormData.prototype._getContentDisposition = function(value, options) {
    var filename, contentDisposition;
    return "string" == typeof options.filepath ? filename = path.normalize(options.filepath).replace(/\\/g, "/") : options.filename || value.name || value.path ? filename = path.basename(options.filename || value.name || value.path) : value.readable && value.hasOwnProperty("httpVersion") && (filename = path.basename(value.client._httpMessage.path || "")), 
    filename && (contentDisposition = 'filename="' + filename + '"'), contentDisposition;
   }, FormData.prototype._getContentType = function(value, options) {
    var contentType = options.contentType;
    return !contentType && value.name && (contentType = mime.lookup(value.name)), !contentType && value.path && (contentType = mime.lookup(value.path)), 
    !contentType && value.readable && value.hasOwnProperty("httpVersion") && (contentType = value.headers["content-type"]), 
    contentType || !options.filepath && !options.filename || (contentType = mime.lookup(options.filepath || options.filename)), 
    contentType || "object" != typeof value || (contentType = FormData.DEFAULT_CONTENT_TYPE), 
    contentType;
   }, FormData.prototype._multiPartFooter = function() {
    return function(next) {
     var footer = FormData.LINE_BREAK;
     0 === this._streams.length && (footer += this._lastBoundary()), next(footer);
    }.bind(this);
   }, FormData.prototype._lastBoundary = function() {
    return "--" + this.getBoundary() + "--" + FormData.LINE_BREAK;
   }, FormData.prototype.getHeaders = function(userHeaders) {
    var header, formHeaders = {
     "content-type": "multipart/form-data; boundary=" + this.getBoundary()
    };
    for (header in userHeaders) userHeaders.hasOwnProperty(header) && (formHeaders[header.toLowerCase()] = userHeaders[header]);
    return formHeaders;
   }, FormData.prototype.setBoundary = function(boundary) {
    this._boundary = boundary;
   }, FormData.prototype.getBoundary = function() {
    return this._boundary || this._generateBoundary(), this._boundary;
   }, FormData.prototype.getBuffer = function() {
    for (var dataBuffer = new Buffer.alloc(0), boundary = this.getBoundary(), i = 0, len = this._streams.length; i < len; i++) "function" != typeof this._streams[i] && (dataBuffer = Buffer.isBuffer(this._streams[i]) ? Buffer.concat([ dataBuffer, this._streams[i] ]) : Buffer.concat([ dataBuffer, Buffer.from(this._streams[i]) ]), 
    "string" == typeof this._streams[i] && this._streams[i].substring(2, boundary.length + 2) === boundary || (dataBuffer = Buffer.concat([ dataBuffer, Buffer.from(FormData.LINE_BREAK) ])));
    return Buffer.concat([ dataBuffer, Buffer.from(this._lastBoundary()) ]);
   }, FormData.prototype._generateBoundary = function() {
    for (var boundary = "--------------------------", i = 0; i < 24; i++) boundary += Math.floor(10 * Math.random()).toString(16);
    this._boundary = boundary;
   }, FormData.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    return this._streams.length && (knownLength += this._lastBoundary().length), this.hasKnownLength() || this._error(new Error("Cannot calculate proper length in synchronous way.")), 
    knownLength;
   }, FormData.prototype.hasKnownLength = function() {
    var hasKnownLength = !0;
    return this._valuesToMeasure.length && (hasKnownLength = !1), hasKnownLength;
   }, FormData.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    this._streams.length && (knownLength += this._lastBoundary().length), this._valuesToMeasure.length ? asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, (function(err, values) {
     err ? cb(err) : (values.forEach((function(length) {
      knownLength += length;
     })), cb(null, knownLength));
    })) : process.nextTick(cb.bind(this, null, knownLength));
   }, FormData.prototype.submit = function(params, cb) {
    var request, options, defaults = {
     method: "post"
    };
    return "string" == typeof params ? (params = parseUrl(params), options = populate({
     port: params.port,
     path: params.pathname,
     host: params.hostname,
     protocol: params.protocol
    }, defaults)) : (options = populate(params, defaults)).port || (options.port = "https:" == options.protocol ? 443 : 80), 
    options.headers = this.getHeaders(params.headers), request = "https:" == options.protocol ? https.request(options) : http.request(options), 
    this.getLength(function(err, length) {
     if (err && "Unknown stream" !== err) this._error(err); else if (length && request.setHeader("Content-Length", length), 
     this.pipe(request), cb) {
      var onResponse, callback = function(error, responce) {
       return request.removeListener("error", callback), request.removeListener("response", onResponse), 
       cb.call(this, error, responce);
      };
      onResponse = callback.bind(this, null), request.on("error", callback), request.on("response", onResponse);
     }
    }.bind(this)), request;
   }, FormData.prototype._error = function(err) {
    this.error || (this.error = err, this.pause(), this.emit("error", err));
   }, FormData.prototype.toString = function() {
    return "[object FormData]";
   };
  },
  32275: module => {
   module.exports = function(dst, src) {
    return Object.keys(src).forEach((function(prop) {
     dst[prop] = dst[prop] || src[prop];
    })), dst;
   };
  },
  86560: module => {
   "use strict";
   module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : 1 === flag.length ? "-" : "--", position = argv.indexOf(prefix + flag), terminatorPosition = argv.indexOf("--");
    return -1 !== position && (-1 === terminatorPosition || position < terminatorPosition);
   };
  },
  39146: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }, __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
     default: mod
    };
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   const net_1 = __importDefault(__webpack_require__(41808)), tls_1 = __importDefault(__webpack_require__(24404)), url_1 = __importDefault(__webpack_require__(57310)), assert_1 = __importDefault(__webpack_require__(39491)), debug_1 = __importDefault(__webpack_require__(15158)), agent_base_1 = __webpack_require__(88054), parse_proxy_response_1 = __importDefault(__webpack_require__(59829)), debug = debug_1.default("https-proxy-agent:agent");
   class HttpsProxyAgent extends agent_base_1.Agent {
    constructor(_opts) {
     let opts;
     if (opts = "string" == typeof _opts ? url_1.default.parse(_opts) : _opts, !opts) throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
     debug("creating new HttpsProxyAgent instance: %o", opts), super(opts);
     const proxy = Object.assign({}, opts);
     var protocol;
     this.secureProxy = opts.secureProxy || "string" == typeof (protocol = proxy.protocol) && /^https:?$/i.test(protocol), 
     proxy.host = proxy.hostname || proxy.host, "string" == typeof proxy.port && (proxy.port = parseInt(proxy.port, 10)), 
     !proxy.port && proxy.host && (proxy.port = this.secureProxy ? 443 : 80), this.secureProxy && !("ALPNProtocols" in proxy) && (proxy.ALPNProtocols = [ "http 1.1" ]), 
     proxy.host && proxy.path && (delete proxy.path, delete proxy.pathname), this.proxy = proxy;
    }
    callback(req, opts) {
     return __awaiter(this, void 0, void 0, (function*() {
      const {proxy, secureProxy} = this;
      let socket;
      secureProxy ? (debug("Creating `tls.Socket`: %o", proxy), socket = tls_1.default.connect(proxy)) : (debug("Creating `net.Socket`: %o", proxy), 
      socket = net_1.default.connect(proxy));
      const headers = Object.assign({}, proxy.headers);
      let payload = `CONNECT ${`${opts.host}:${opts.port}`} HTTP/1.1\r\n`;
      proxy.auth && (headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`);
      let {host, port, secureEndpoint} = opts;
      (function(port, secure) {
       return Boolean(!secure && 80 === port || secure && 443 === port);
      })(port, secureEndpoint) || (host += `:${port}`), headers.Host = host, headers.Connection = "close";
      for (const name of Object.keys(headers)) payload += `${name}: ${headers[name]}\r\n`;
      const proxyResponsePromise = parse_proxy_response_1.default(socket);
      socket.write(`${payload}\r\n`);
      const {statusCode, buffered} = yield proxyResponsePromise;
      if (200 === statusCode) {
       if (req.once("socket", resume), opts.secureEndpoint) {
        debug("Upgrading socket connection to TLS");
        const servername = opts.servername || opts.host;
        return tls_1.default.connect(Object.assign(Object.assign({}, function(obj, ...keys) {
         const ret = {};
         let key;
         for (key in obj) keys.includes(key) || (ret[key] = obj[key]);
         return ret;
        }(opts, "host", "hostname", "path", "port")), {
         socket,
         servername
        }));
       }
       return socket;
      }
      socket.destroy();
      const fakeSocket = new net_1.default.Socket({
       writable: !1
      });
      return fakeSocket.readable = !0, req.once("socket", (s => {
       debug("replaying proxy buffer for failed request"), assert_1.default(s.listenerCount("data") > 0), 
       s.push(buffered), s.push(null);
      })), fakeSocket;
     }));
    }
   }
   function resume(socket) {
    socket.resume();
   }
   exports.default = HttpsProxyAgent;
  },
  26018: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   const agent_1 = (this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
     default: mod
    };
   })(__webpack_require__(39146));
   function createHttpsProxyAgent(opts) {
    return new agent_1.default(opts);
   }
   !function(createHttpsProxyAgent) {
    createHttpsProxyAgent.HttpsProxyAgent = agent_1.default, createHttpsProxyAgent.prototype = agent_1.default.prototype;
   }(createHttpsProxyAgent || (createHttpsProxyAgent = {})), module.exports = createHttpsProxyAgent;
  },
  59829: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
     default: mod
    };
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   const debug = __importDefault(__webpack_require__(15158)).default("https-proxy-agent:parse-proxy-response");
   exports.default = function(socket) {
    return new Promise(((resolve, reject) => {
     let buffersLength = 0;
     const buffers = [];
     function read() {
      const b = socket.read();
      b ? function(b) {
       buffers.push(b), buffersLength += b.length;
       const buffered = Buffer.concat(buffers, buffersLength);
       if (-1 === buffered.indexOf("\r\n\r\n")) return debug("have not received end of HTTP headers yet..."), 
       void read();
       const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n")), statusCode = +firstLine.split(" ")[1];
       debug("got proxy server response: %o", firstLine), resolve({
        statusCode,
        buffered
       });
      }(b) : socket.once("readable", read);
     }
     function onclose(err) {
      debug("onclose had error %o", err);
     }
     function onend() {
      debug("onend");
     }
     function onerror(err) {
      socket.removeListener("end", onend), socket.removeListener("error", onerror), socket.removeListener("close", onclose), 
      socket.removeListener("readable", read), debug("onerror %o", err), reject(err);
     }
     socket.on("error", onerror), socket.on("close", onclose), socket.on("end", onend), 
     read();
    }));
   };
  },
  55915: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   exports.METADATA_KEY = {
    provide: "inversify-binding-decorators:provide"
   };
  },
  25620: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var provide_in_when_on_syntax_1 = __webpack_require__(73063), provide_when_syntax_1 = __webpack_require__(22721), provide_on_syntax_1 = __webpack_require__(88064), provide_in_syntax_1 = __webpack_require__(43351), provide_done_syntax_1 = __webpack_require__(33813);
   exports.default = function(serviceIdentifier) {
    var bindingWhenOnSyntax = function(bind, target) {
     return bind(serviceIdentifier).to(target);
    }, provideDoneSyntax = new provide_done_syntax_1.default((function(bind, target) {
     return bindingWhenOnSyntax(bind, target)._binding;
    }));
    return new provide_in_when_on_syntax_1.default(new provide_in_syntax_1.default((function(bind, target) {
     return bindingWhenOnSyntax(bind, target);
    }), provideDoneSyntax), new provide_when_syntax_1.default(bindingWhenOnSyntax, provideDoneSyntax), new provide_on_syntax_1.default(bindingWhenOnSyntax, provideDoneSyntax));
   };
  },
  50651: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var inversify_1 = __webpack_require__(26594), constants_1 = __webpack_require__(55915);
   exports.default = function(serviceIdentifier, force) {
    return function(target) {
     var isAlreadyDecorated = Reflect.hasOwnMetadata(inversify_1.METADATA_KEY.PARAM_TYPES, target), redecorateWithInject = !0 === force;
     if (!0 === redecorateWithInject && !1 === isAlreadyDecorated) inversify_1.decorate(inversify_1.injectable(), target); else if (!0 === redecorateWithInject && !0 === isAlreadyDecorated) ; else try {
      inversify_1.decorate(inversify_1.injectable(), target);
     } catch (e) {
      throw new Error("Cannot apply @provide decorator multiple times but is has been used multiple times in " + target.name + " Please use @provide(ID, true) if you are trying to declare multiple bindings!");
     }
     var currentMetadata = {
      constraint: function(bind, bindTarget) {
       return bind(serviceIdentifier).to(bindTarget);
      },
      implementationType: target
     }, previousMetadata = Reflect.getMetadata(constants_1.METADATA_KEY.provide, Reflect) || [], newMetadata = [ currentMetadata ].concat(previousMetadata);
     return Reflect.defineMetadata(constants_1.METADATA_KEY.provide, newMetadata, Reflect), 
     target;
    };
   };
  },
  22677: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var constants_1 = __webpack_require__(55915), inversify_1 = __webpack_require__(26594);
   exports.default = function() {
    return new inversify_1.ContainerModule((function(bind, unbind) {
     (Reflect.getMetadata(constants_1.METADATA_KEY.provide, Reflect) || []).map((function(metadata) {
      return function(metadata, bind) {
       return metadata.constraint(bind, metadata.implementationType);
      }(metadata, bind);
     }));
    }));
   };
  },
  84904: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var auto_wire_1 = __webpack_require__(70788);
   exports.autoProvide = auto_wire_1.default;
   var provide_1 = __webpack_require__(50651);
   exports.provide = provide_1.default;
   var fluent_provide_1 = __webpack_require__(25620);
   exports.fluentProvide = fluent_provide_1.default;
   var module_factory_1 = __webpack_require__(22677);
   exports.buildProviderModule = module_factory_1.default;
  },
  33813: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var inversify_1 = __webpack_require__(26594), inversify_2 = __webpack_require__(26594), constants_1 = __webpack_require__(55915), ProvideDoneSyntax = function() {
    function ProvideDoneSyntax(binding) {
     this._binding = binding;
    }
    return ProvideDoneSyntax.prototype.done = function(force) {
     var that = this;
     return function(target) {
      var isAlreadyDecorated = Reflect.hasOwnMetadata(inversify_2.METADATA_KEY.PARAM_TYPES, target), redecorateWithInject = !0 === force;
      if (!0 === redecorateWithInject && !1 === isAlreadyDecorated) inversify_1.decorate(inversify_1.injectable(), target); else if (!0 === redecorateWithInject && !0 === isAlreadyDecorated) ; else try {
       inversify_1.decorate(inversify_1.injectable(), target);
      } catch (e) {
       throw new Error("Cannot apply @provideFluent decorator multiple times but is has been used multiple times in " + target.name + " Please use done(true) if you are trying to declare multiple bindings!");
      }
      var currentMetadata = {
       constraint: that._binding,
       implementationType: target
      }, previousMetadata = Reflect.getMetadata(constants_1.METADATA_KEY.provide, Reflect) || [], newMetadata = [ currentMetadata ].concat(previousMetadata);
      return Reflect.defineMetadata(constants_1.METADATA_KEY.provide, newMetadata, Reflect), 
      target;
     };
    }, ProvideDoneSyntax;
   }();
   exports.default = ProvideDoneSyntax;
  },
  43351: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var provide_when_on_syntax_1 = __webpack_require__(3993), provide_when_syntax_1 = __webpack_require__(22721), provide_on_syntax_1 = __webpack_require__(88064), provide_done_syntax_1 = __webpack_require__(33813), ProvideInSyntax = function() {
    function ProvideInSyntax(bindingInSyntax, provideDoneSyntax) {
     this._bindingInSyntax = bindingInSyntax, this._provideDoneSyntax = provideDoneSyntax;
    }
    return ProvideInSyntax.prototype.inSingletonScope = function() {
     var _this = this, bindingWhenOnSyntax = function(bind, target) {
      return _this._bindingInSyntax(bind, target).inSingletonScope();
     }, inDoneSyntax = new provide_done_syntax_1.default(bindingWhenOnSyntax), provideWhenSyntax = new provide_when_syntax_1.default(bindingWhenOnSyntax, inDoneSyntax), provideOnSyntax = new provide_on_syntax_1.default(bindingWhenOnSyntax, inDoneSyntax);
     return new provide_when_on_syntax_1.default(provideWhenSyntax, provideOnSyntax);
    }, ProvideInSyntax.prototype.inTransientScope = function() {
     var _this = this, bindingWhenOnSyntax = function(bind, target) {
      return _this._bindingInSyntax(bind, target).inTransientScope();
     }, inDoneSyntax = new provide_done_syntax_1.default(bindingWhenOnSyntax), provideWhenSyntax = new provide_when_syntax_1.default(bindingWhenOnSyntax, inDoneSyntax), provideOnSyntax = new provide_on_syntax_1.default(bindingWhenOnSyntax, inDoneSyntax);
     return new provide_when_on_syntax_1.default(provideWhenSyntax, provideOnSyntax);
    }, ProvideInSyntax.prototype.done = function(force) {
     return this._provideDoneSyntax.done(force);
    }, ProvideInSyntax;
   }();
   exports.default = ProvideInSyntax;
  },
  73063: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var ProvideInWhenOnSyntax = function() {
    function ProvideInWhenOnSyntax(provideInSyntax, provideWhenSyntax, provideOnSyntax) {
     this._provideInSyntax = provideInSyntax, this._provideWhenSyntax = provideWhenSyntax, 
     this._provideOnSyntax = provideOnSyntax;
    }
    return ProvideInWhenOnSyntax.prototype.when = function(constraint) {
     return this._provideWhenSyntax.when(constraint);
    }, ProvideInWhenOnSyntax.prototype.whenTargetNamed = function(name) {
     return this._provideWhenSyntax.whenTargetNamed(name);
    }, ProvideInWhenOnSyntax.prototype.whenTargetTagged = function(tag, value) {
     return this._provideWhenSyntax.whenTargetTagged(tag, value);
    }, ProvideInWhenOnSyntax.prototype.whenInjectedInto = function(parent) {
     return this._provideWhenSyntax.whenInjectedInto(parent);
    }, ProvideInWhenOnSyntax.prototype.whenParentNamed = function(name) {
     return this._provideWhenSyntax.whenParentNamed(name);
    }, ProvideInWhenOnSyntax.prototype.whenParentTagged = function(tag, value) {
     return this._provideWhenSyntax.whenParentTagged(tag, value);
    }, ProvideInWhenOnSyntax.prototype.whenAnyAncestorIs = function(ancestor) {
     return this._provideWhenSyntax.whenAnyAncestorIs(ancestor);
    }, ProvideInWhenOnSyntax.prototype.whenNoAncestorIs = function(ancestor) {
     return this._provideWhenSyntax.whenNoAncestorIs(ancestor);
    }, ProvideInWhenOnSyntax.prototype.whenAnyAncestorNamed = function(name) {
     return this._provideWhenSyntax.whenAnyAncestorNamed(name);
    }, ProvideInWhenOnSyntax.prototype.whenAnyAncestorTagged = function(tag, value) {
     return this._provideWhenSyntax.whenAnyAncestorTagged(tag, value);
    }, ProvideInWhenOnSyntax.prototype.whenNoAncestorNamed = function(name) {
     return this._provideWhenSyntax.whenNoAncestorNamed(name);
    }, ProvideInWhenOnSyntax.prototype.whenNoAncestorTagged = function(tag, value) {
     return this._provideWhenSyntax.whenNoAncestorTagged(tag, value);
    }, ProvideInWhenOnSyntax.prototype.whenAnyAncestorMatches = function(constraint) {
     return this._provideWhenSyntax.whenAnyAncestorMatches(constraint);
    }, ProvideInWhenOnSyntax.prototype.whenNoAncestorMatches = function(constraint) {
     return this._provideWhenSyntax.whenNoAncestorMatches(constraint);
    }, ProvideInWhenOnSyntax.prototype.onActivation = function(fn) {
     return this._provideOnSyntax.onActivation(fn);
    }, ProvideInWhenOnSyntax.prototype.inSingletonScope = function() {
     return this._provideInSyntax.inSingletonScope();
    }, ProvideInWhenOnSyntax.prototype.inTransientScope = function() {
     return this._provideInSyntax.inTransientScope();
    }, ProvideInWhenOnSyntax.prototype.done = function(force) {
     return this._provideInSyntax.done(force);
    }, ProvideInWhenOnSyntax;
   }();
   exports.default = ProvideInWhenOnSyntax;
  },
  88064: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var provide_when_syntax_1 = __webpack_require__(22721), provide_done_syntax_1 = __webpack_require__(33813), ProvideOnSyntax = function() {
    function ProvideOnSyntax(bindingOnSyntax, provideDoneSyntax) {
     this._bindingOnSyntax = bindingOnSyntax, this._provideDoneSyntax = provideDoneSyntax;
    }
    return ProvideOnSyntax.prototype.onActivation = function(fn) {
     var _this = this, bindingWhenSyntax = function(bind, target) {
      return _this._bindingOnSyntax(bind, target).onActivation(fn);
     }, onDoneSyntax = new provide_done_syntax_1.default(bindingWhenSyntax);
     return new provide_when_syntax_1.default(bindingWhenSyntax, onDoneSyntax);
    }, ProvideOnSyntax.prototype.done = function(force) {
     return this._provideDoneSyntax.done(force);
    }, ProvideOnSyntax;
   }();
   exports.default = ProvideOnSyntax;
  },
  3993: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var ProvideWhenOnSyntax = function() {
    function ProvideWhenOnSyntax(provideWhenSyntax, provideOnSyntax) {
     this._provideWhenSyntax = provideWhenSyntax, this._provideOnSyntax = provideOnSyntax;
    }
    return ProvideWhenOnSyntax.prototype.when = function(constraint) {
     return this._provideWhenSyntax.when(constraint);
    }, ProvideWhenOnSyntax.prototype.whenTargetNamed = function(name) {
     return this._provideWhenSyntax.whenTargetNamed(name);
    }, ProvideWhenOnSyntax.prototype.whenTargetTagged = function(tag, value) {
     return this._provideWhenSyntax.whenTargetTagged(tag, value);
    }, ProvideWhenOnSyntax.prototype.whenInjectedInto = function(parent) {
     return this._provideWhenSyntax.whenInjectedInto(parent);
    }, ProvideWhenOnSyntax.prototype.whenParentNamed = function(name) {
     return this._provideWhenSyntax.whenParentNamed(name);
    }, ProvideWhenOnSyntax.prototype.whenParentTagged = function(tag, value) {
     return this._provideWhenSyntax.whenParentTagged(tag, value);
    }, ProvideWhenOnSyntax.prototype.whenAnyAncestorIs = function(ancestor) {
     return this._provideWhenSyntax.whenAnyAncestorIs(ancestor);
    }, ProvideWhenOnSyntax.prototype.whenNoAncestorIs = function(ancestor) {
     return this._provideWhenSyntax.whenNoAncestorIs(ancestor);
    }, ProvideWhenOnSyntax.prototype.whenAnyAncestorNamed = function(name) {
     return this._provideWhenSyntax.whenAnyAncestorNamed(name);
    }, ProvideWhenOnSyntax.prototype.whenAnyAncestorTagged = function(tag, value) {
     return this._provideWhenSyntax.whenAnyAncestorTagged(tag, value);
    }, ProvideWhenOnSyntax.prototype.whenNoAncestorNamed = function(name) {
     return this._provideWhenSyntax.whenNoAncestorNamed(name);
    }, ProvideWhenOnSyntax.prototype.whenNoAncestorTagged = function(tag, value) {
     return this._provideWhenSyntax.whenNoAncestorTagged(tag, value);
    }, ProvideWhenOnSyntax.prototype.whenAnyAncestorMatches = function(constraint) {
     return this._provideWhenSyntax.whenAnyAncestorMatches(constraint);
    }, ProvideWhenOnSyntax.prototype.whenNoAncestorMatches = function(constraint) {
     return this._provideWhenSyntax.whenNoAncestorMatches(constraint);
    }, ProvideWhenOnSyntax.prototype.onActivation = function(fn) {
     return this._provideOnSyntax.onActivation(fn);
    }, ProvideWhenOnSyntax.prototype.done = function(force) {
     return this._provideWhenSyntax.done(force);
    }, ProvideWhenOnSyntax;
   }();
   exports.default = ProvideWhenOnSyntax;
  },
  22721: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var provide_on_syntax_1 = __webpack_require__(88064), provide_done_syntax_1 = __webpack_require__(33813), ProvideWhenSyntax = function() {
    function ProvideWhenSyntax(bindingWhenSyntax, provideDoneSyntax) {
     this._bindingWhenSyntax = bindingWhenSyntax, this._provideDoneSyntax = provideDoneSyntax;
    }
    return ProvideWhenSyntax.prototype.when = function(constraint) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).when(constraint);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenTargetNamed = function(name) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenTargetNamed(name);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenTargetTagged = function(tag, value) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenTargetTagged(tag, value);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenInjectedInto = function(parent) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenInjectedInto(parent);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenParentNamed = function(name) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenParentNamed(name);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenParentTagged = function(tag, value) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenParentTagged(tag, value);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenAnyAncestorIs = function(ancestor) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenAnyAncestorIs(ancestor);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenNoAncestorIs = function(ancestor) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenNoAncestorIs(ancestor);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenAnyAncestorNamed = function(name) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenAnyAncestorNamed(name);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenAnyAncestorTagged = function(tag, value) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenAnyAncestorTagged(tag, value);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenNoAncestorNamed = function(name) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenNoAncestorNamed(name);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenNoAncestorTagged = function(tag, value) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenNoAncestorTagged(tag, value);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenAnyAncestorMatches = function(constraint) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenAnyAncestorMatches(constraint);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenNoAncestorMatches = function(constraint) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenNoAncestorMatches(constraint);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.done = function(force) {
     return this._provideDoneSyntax.done(force);
    }, ProvideWhenSyntax;
   }();
   exports.default = ProvideWhenSyntax;
  },
  70788: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var inversify_1 = __webpack_require__(26594), provide_1 = __webpack_require__(50651);
   exports.default = function(container) {
    for (var modules = [], _i = 1; _i < arguments.length; _i++) modules[_i - 1] = arguments[_i];
    modules.forEach((function(module) {
     Object.keys(module).forEach((function(key) {
      var entity = module[key], decorator = provide_1.default(entity);
      inversify_1.decorate(decorator, entity);
     }));
    }));
   };
  },
  26594: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    AsyncContainerModule: () => AsyncContainerModule,
    BindingScopeEnum: () => BindingScopeEnum,
    BindingTypeEnum: () => BindingTypeEnum,
    Container: () => Container,
    ContainerModule: () => ContainerModule,
    LazyServiceIdentifer: () => LazyServiceIdentifer,
    METADATA_KEY: () => METADATA_KEY,
    MetadataReader: () => MetadataReader,
    TargetTypeEnum: () => TargetTypeEnum,
    createTaggedDecorator: () => createTaggedDecorator,
    decorate: () => decorate,
    getServiceIdentifierAsString: () => getServiceIdentifierAsString,
    id: () => id,
    inject: () => inject,
    injectable: () => injectable,
    interfaces: () => interfaces,
    multiBindToService: () => multiBindToService,
    multiInject: () => multiInject,
    named: () => named,
    namedConstraint: () => namedConstraint,
    optional: () => optional,
    postConstruct: () => postConstruct,
    preDestroy: () => preDestroy,
    tagged: () => tagged,
    taggedConstraint: () => taggedConstraint,
    targetName: () => targetName,
    traverseAncerstors: () => traverseAncerstors,
    typeConstraint: () => typeConstraint,
    unmanaged: () => unmanaged
   });
   var metadata_keys_namespaceObject = {};
   __webpack_require__.r(metadata_keys_namespaceObject), __webpack_require__.d(metadata_keys_namespaceObject, {
    DESIGN_PARAM_TYPES: () => DESIGN_PARAM_TYPES,
    INJECT_TAG: () => INJECT_TAG,
    MULTI_INJECT_TAG: () => MULTI_INJECT_TAG,
    NAMED_TAG: () => NAMED_TAG,
    NAME_TAG: () => NAME_TAG,
    NON_CUSTOM_TAG_KEYS: () => NON_CUSTOM_TAG_KEYS,
    OPTIONAL_TAG: () => OPTIONAL_TAG,
    PARAM_TYPES: () => PARAM_TYPES,
    POST_CONSTRUCT: () => POST_CONSTRUCT,
    PRE_DESTROY: () => PRE_DESTROY,
    TAGGED: () => TAGGED,
    TAGGED_PROP: () => TAGGED_PROP,
    UNMANAGED_TAG: () => UNMANAGED_TAG
   });
   var NAMED_TAG = "named", NAME_TAG = "name", UNMANAGED_TAG = "unmanaged", OPTIONAL_TAG = "optional", INJECT_TAG = "inject", MULTI_INJECT_TAG = "multi_inject", TAGGED = "inversify:tagged", TAGGED_PROP = "inversify:tagged_props", PARAM_TYPES = "inversify:paramtypes", DESIGN_PARAM_TYPES = "design:paramtypes", POST_CONSTRUCT = "post_construct", PRE_DESTROY = "pre_destroy";
   var NON_CUSTOM_TAG_KEYS = [ INJECT_TAG, MULTI_INJECT_TAG, NAME_TAG, UNMANAGED_TAG, NAMED_TAG, OPTIONAL_TAG ], BindingScopeEnum = {
    Request: "Request",
    Singleton: "Singleton",
    Transient: "Transient"
   }, BindingTypeEnum = {
    ConstantValue: "ConstantValue",
    Constructor: "Constructor",
    DynamicValue: "DynamicValue",
    Factory: "Factory",
    Function: "Function",
    Instance: "Instance",
    Invalid: "Invalid",
    Provider: "Provider"
   }, TargetTypeEnum = {
    ClassProperty: "ClassProperty",
    ConstructorArgument: "ConstructorArgument",
    Variable: "Variable"
   }, idCounter = 0;
   function id() {
    return idCounter++;
   }
   var Binding = function() {
    function Binding(serviceIdentifier, scope) {
     this.id = id(), this.activated = !1, this.serviceIdentifier = serviceIdentifier, 
     this.scope = scope, this.type = BindingTypeEnum.Invalid, this.constraint = function(request) {
      return !0;
     }, this.implementationType = null, this.cache = null, this.factory = null, this.provider = null, 
     this.onActivation = null, this.onDeactivation = null, this.dynamicValue = null;
    }
    return Binding.prototype.clone = function() {
     var clone = new Binding(this.serviceIdentifier, this.scope);
     return clone.activated = clone.scope === BindingScopeEnum.Singleton && this.activated, 
     clone.implementationType = this.implementationType, clone.dynamicValue = this.dynamicValue, 
     clone.scope = this.scope, clone.type = this.type, clone.factory = this.factory, 
     clone.provider = this.provider, clone.constraint = this.constraint, clone.onActivation = this.onActivation, 
     clone.onDeactivation = this.onDeactivation, clone.cache = this.cache, clone;
    }, Binding;
   }(), DUPLICATED_INJECTABLE_DECORATOR = "Cannot apply @injectable decorator multiple times.", DUPLICATED_METADATA = "Metadata key was used more than once in a parameter:", AMBIGUOUS_MATCH = "Ambiguous match found for serviceIdentifier:", NOT_REGISTERED = "No matching bindings found for serviceIdentifier:", MISSING_INJECTABLE_ANNOTATION = "Missing required @injectable annotation in:", MISSING_INJECT_ANNOTATION = "Missing required @inject or @multiInject annotation in:", CIRCULAR_DEPENDENCY = "Circular dependency found:", INVALID_DECORATOR_OPERATION = "The @inject @multiInject @tagged and @named decorators must be applied to the parameters of a class constructor or a class property.", ARGUMENTS_LENGTH_MISMATCH = function() {
    for (var values = [], _i = 0; _i < arguments.length; _i++) values[_i] = arguments[_i];
    return "The number of constructor arguments in the derived class " + values[0] + " must be >= than the number of constructor arguments of its base class.";
   }, POST_CONSTRUCT_ERROR = function(clazz, errorMessage) {
    return "@postConstruct error in class " + clazz + ": " + errorMessage;
   }, PRE_DESTROY_ERROR = function(clazz, errorMessage) {
    return "@preDestroy error in class " + clazz + ": " + errorMessage;
   }, ON_DEACTIVATION_ERROR = function(clazz, errorMessage) {
    return "onDeactivation() error in class " + clazz + ": " + errorMessage;
   }, STACK_OVERFLOW = "Maximum call stack size exceeded", MetadataReader = function() {
    function MetadataReader() {}
    return MetadataReader.prototype.getConstructorMetadata = function(constructorFunc) {
     return {
      compilerGeneratedMetadata: Reflect.getMetadata(PARAM_TYPES, constructorFunc),
      userGeneratedMetadata: Reflect.getMetadata(TAGGED, constructorFunc) || {}
     };
    }, MetadataReader.prototype.getPropertiesMetadata = function(constructorFunc) {
     return Reflect.getMetadata(TAGGED_PROP, constructorFunc) || [];
    }, MetadataReader;
   }(), BindingCount = {
    MultipleBindingsAvailable: 2,
    NoBindingsAvailable: 0,
    OnlyOneBindingAvailable: 1
   };
   function isStackOverflowExeption(error) {
    return error instanceof RangeError || error.message === STACK_OVERFLOW;
   }
   function getServiceIdentifierAsString(serviceIdentifier) {
    return "function" == typeof serviceIdentifier ? serviceIdentifier.name : "symbol" == typeof serviceIdentifier ? serviceIdentifier.toString() : serviceIdentifier;
   }
   function listRegisteredBindingsForServiceIdentifier(container, serviceIdentifier, getBindings) {
    var registeredBindingsList = "", registeredBindings = getBindings(container, serviceIdentifier);
    return 0 !== registeredBindings.length && (registeredBindingsList = "\nRegistered bindings:", 
    registeredBindings.forEach((function(binding) {
     var name = "Object";
     null !== binding.implementationType && (name = getFunctionName(binding.implementationType)), 
     registeredBindingsList = registeredBindingsList + "\n " + name, binding.constraint.metaData && (registeredBindingsList = registeredBindingsList + " - " + binding.constraint.metaData);
    }))), registeredBindingsList;
   }
   function alreadyDependencyChain(request, serviceIdentifier) {
    return null !== request.parentRequest && (request.parentRequest.serviceIdentifier === serviceIdentifier || alreadyDependencyChain(request.parentRequest, serviceIdentifier));
   }
   function circularDependencyToException(request) {
    request.childRequests.forEach((function(childRequest) {
     if (alreadyDependencyChain(childRequest, childRequest.serviceIdentifier)) {
      var services = function(request) {
       var stringArr = function _createStringArr(req, result) {
        void 0 === result && (result = []);
        var serviceIdentifier = getServiceIdentifierAsString(req.serviceIdentifier);
        return result.push(serviceIdentifier), null !== req.parentRequest ? _createStringArr(req.parentRequest, result) : result;
       }(request);
       return stringArr.reverse().join(" --\x3e ");
      }(childRequest);
      throw new Error(CIRCULAR_DEPENDENCY + " " + services);
     }
     circularDependencyToException(childRequest);
    }));
   }
   function getFunctionName(func) {
    if (func.name) return func.name;
    var name_1 = func.toString(), match = name_1.match(/^function\s*([^\s(]+)/);
    return match ? match[1] : "Anonymous function: " + name_1;
   }
   var Context = function() {
    function Context(container) {
     this.id = id(), this.container = container;
    }
    return Context.prototype.addPlan = function(plan) {
     this.plan = plan;
    }, Context.prototype.setCurrentRequest = function(currentRequest) {
     this.currentRequest = currentRequest;
    }, Context;
   }(), Metadata = function() {
    function Metadata(key, value) {
     this.key = key, this.value = value;
    }
    return Metadata.prototype.toString = function() {
     return this.key === NAMED_TAG ? "named: " + String(this.value).toString() + " " : "tagged: { key:" + this.key.toString() + ", value: " + String(this.value) + " }";
    }, Metadata;
   }(), Plan = function(parentContext, rootRequest) {
    this.parentContext = parentContext, this.rootRequest = rootRequest;
   }, LazyServiceIdentifer = function() {
    function LazyServiceIdentifer(cb) {
     this._cb = cb;
    }
    return LazyServiceIdentifer.prototype.unwrap = function() {
     return this._cb();
    }, LazyServiceIdentifer;
   }(), QueryableString = function() {
    function QueryableString(str) {
     this.str = str;
    }
    return QueryableString.prototype.startsWith = function(searchString) {
     return 0 === this.str.indexOf(searchString);
    }, QueryableString.prototype.endsWith = function(searchString) {
     var reverseString, reverseSearchString = searchString.split("").reverse().join("");
     return reverseString = this.str.split("").reverse().join(""), this.startsWith.call({
      str: reverseString
     }, reverseSearchString);
    }, QueryableString.prototype.contains = function(searchString) {
     return -1 !== this.str.indexOf(searchString);
    }, QueryableString.prototype.equals = function(compareString) {
     return this.str === compareString;
    }, QueryableString.prototype.value = function() {
     return this.str;
    }, QueryableString;
   }(), Target = function() {
    function Target(type, identifier, serviceIdentifier, namedOrTagged) {
     this.id = id(), this.type = type, this.serviceIdentifier = serviceIdentifier;
     var queryableName = "symbol" == typeof identifier ? identifier.toString().slice(7, -1) : identifier;
     this.name = new QueryableString(queryableName || ""), this.identifier = identifier, 
     this.metadata = new Array;
     var metadataItem = null;
     "string" == typeof namedOrTagged ? metadataItem = new Metadata(NAMED_TAG, namedOrTagged) : namedOrTagged instanceof Metadata && (metadataItem = namedOrTagged), 
     null !== metadataItem && this.metadata.push(metadataItem);
    }
    return Target.prototype.hasTag = function(key) {
     for (var _i = 0, _a = this.metadata; _i < _a.length; _i++) {
      if (_a[_i].key === key) return !0;
     }
     return !1;
    }, Target.prototype.isArray = function() {
     return this.hasTag(MULTI_INJECT_TAG);
    }, Target.prototype.matchesArray = function(name) {
     return this.matchesTag(MULTI_INJECT_TAG)(name);
    }, Target.prototype.isNamed = function() {
     return this.hasTag(NAMED_TAG);
    }, Target.prototype.isTagged = function() {
     return this.metadata.some((function(metadata) {
      return NON_CUSTOM_TAG_KEYS.every((function(key) {
       return metadata.key !== key;
      }));
     }));
    }, Target.prototype.isOptional = function() {
     return this.matchesTag(OPTIONAL_TAG)(!0);
    }, Target.prototype.getNamedTag = function() {
     return this.isNamed() ? this.metadata.filter((function(m) {
      return m.key === NAMED_TAG;
     }))[0] : null;
    }, Target.prototype.getCustomTags = function() {
     return this.isTagged() ? this.metadata.filter((function(metadata) {
      return NON_CUSTOM_TAG_KEYS.every((function(key) {
       return metadata.key !== key;
      }));
     })) : null;
    }, Target.prototype.matchesNamedTag = function(name) {
     return this.matchesTag(NAMED_TAG)(name);
    }, Target.prototype.matchesTag = function(key) {
     var _this = this;
     return function(value) {
      for (var _i = 0, _a = _this.metadata; _i < _a.length; _i++) {
       var m = _a[_i];
       if (m.key === key && m.value === value) return !0;
      }
      return !1;
     };
    }, Target;
   }(), __spreadArray = function(to, from, pack) {
    if (pack || 2 === arguments.length) for (var ar, i = 0, l = from.length; i < l; i++) !ar && i in from || (ar || (ar = Array.prototype.slice.call(from, 0, i)), 
    ar[i] = from[i]);
    return to.concat(ar || Array.prototype.slice.call(from));
   };
   function getTargets(metadataReader, constructorName, func, isBaseClass) {
    var metadata = metadataReader.getConstructorMetadata(func), serviceIdentifiers = metadata.compilerGeneratedMetadata;
    if (void 0 === serviceIdentifiers) throw new Error(MISSING_INJECTABLE_ANNOTATION + " " + constructorName + ".");
    var constructorArgsMetadata = metadata.userGeneratedMetadata, keys = Object.keys(constructorArgsMetadata), hasUserDeclaredUnknownInjections = 0 === func.length && keys.length > 0, hasOptionalParameters = keys.length > func.length, constructorTargets = function(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations) {
     for (var targets = [], i = 0; i < iterations; i++) {
      var target = getConstructorArgsAsTarget(i, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata);
      null !== target && targets.push(target);
     }
     return targets;
    }(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, hasUserDeclaredUnknownInjections || hasOptionalParameters ? keys.length : func.length), propertyTargets = getClassPropsAsTargets(metadataReader, func, constructorName);
    return __spreadArray(__spreadArray([], constructorTargets, !0), propertyTargets, !0);
   }
   function getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata) {
    var targetMetadata = constructorArgsMetadata[index.toString()] || [], metadata = formatTargetMetadata(targetMetadata), isManaged = !0 !== metadata.unmanaged, serviceIdentifier = serviceIdentifiers[index], injectIdentifier = metadata.inject || metadata.multiInject;
    if ((serviceIdentifier = injectIdentifier || serviceIdentifier) instanceof LazyServiceIdentifer && (serviceIdentifier = serviceIdentifier.unwrap()), 
    isManaged) {
     if (!isBaseClass && (serviceIdentifier === Object || serviceIdentifier === Function || void 0 === serviceIdentifier)) throw new Error(MISSING_INJECT_ANNOTATION + " argument " + index + " in class " + constructorName + ".");
     var target = new Target(TargetTypeEnum.ConstructorArgument, metadata.targetName, serviceIdentifier);
     return target.metadata = targetMetadata, target;
    }
    return null;
   }
   function _getServiceIdentifierForProperty(inject, multiInject, propertyName, className) {
    var serviceIdentifier = inject || multiInject;
    if (void 0 === serviceIdentifier) {
     var msg = MISSING_INJECTABLE_ANNOTATION + " for property " + String(propertyName) + " in class " + className + ".";
     throw new Error(msg);
    }
    return serviceIdentifier;
   }
   function getClassPropsAsTargets(metadataReader, constructorFunc, constructorName) {
    for (var classPropsMetadata = metadataReader.getPropertiesMetadata(constructorFunc), targets = [], symbolKeys = Object.getOwnPropertySymbols(classPropsMetadata), _i = 0, keys_1 = Object.keys(classPropsMetadata).concat(symbolKeys); _i < keys_1.length; _i++) {
     var key = keys_1[_i], targetMetadata = classPropsMetadata[key], metadata = formatTargetMetadata(targetMetadata), identifier = metadata.targetName || key, serviceIdentifier = _getServiceIdentifierForProperty(metadata.inject, metadata.multiInject, key, constructorName), target = new Target(TargetTypeEnum.ClassProperty, identifier, serviceIdentifier);
     target.metadata = targetMetadata, targets.push(target);
    }
    var baseConstructor = Object.getPrototypeOf(constructorFunc.prototype).constructor;
    if (baseConstructor !== Object) {
     var baseTargets = getClassPropsAsTargets(metadataReader, baseConstructor, constructorName);
     targets = __spreadArray(__spreadArray([], targets, !0), baseTargets, !0);
    }
    return targets;
   }
   function getBaseClassDependencyCount(metadataReader, func) {
    var baseConstructor = Object.getPrototypeOf(func.prototype).constructor;
    if (baseConstructor !== Object) {
     var targets = getTargets(metadataReader, getFunctionName(baseConstructor), baseConstructor, !0), metadata = targets.map((function(t) {
      return t.metadata.filter((function(m) {
       return m.key === UNMANAGED_TAG;
      }));
     })), unmanagedCount = [].concat.apply([], metadata).length, dependencyCount = targets.length - unmanagedCount;
     return dependencyCount > 0 ? dependencyCount : getBaseClassDependencyCount(metadataReader, baseConstructor);
    }
    return 0;
   }
   function formatTargetMetadata(targetMetadata) {
    var targetMetadataMap = {};
    return targetMetadata.forEach((function(m) {
     targetMetadataMap[m.key.toString()] = m.value;
    })), {
     inject: targetMetadataMap[INJECT_TAG],
     multiInject: targetMetadataMap[MULTI_INJECT_TAG],
     targetName: targetMetadataMap[NAME_TAG],
     unmanaged: targetMetadataMap[UNMANAGED_TAG]
    };
   }
   var Request = function() {
    function Request(serviceIdentifier, parentContext, parentRequest, bindings, target) {
     this.id = id(), this.serviceIdentifier = serviceIdentifier, this.parentContext = parentContext, 
     this.parentRequest = parentRequest, this.target = target, this.childRequests = [], 
     this.bindings = Array.isArray(bindings) ? bindings : [ bindings ], this.requestScope = null === parentRequest ? new Map : null;
    }
    return Request.prototype.addChildRequest = function(serviceIdentifier, bindings, target) {
     var child = new Request(serviceIdentifier, this.parentContext, this, bindings, target);
     return this.childRequests.push(child), child;
    }, Request;
   }();
   function getBindingDictionary(cntnr) {
    return cntnr._bindingDictionary;
   }
   function _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target) {
    var bindings = getBindings(context.container, target.serviceIdentifier), activeBindings = [];
    return bindings.length === BindingCount.NoBindingsAvailable && context.container.options.autoBindInjectable && "function" == typeof target.serviceIdentifier && metadataReader.getConstructorMetadata(target.serviceIdentifier).compilerGeneratedMetadata && (context.container.bind(target.serviceIdentifier).toSelf(), 
    bindings = getBindings(context.container, target.serviceIdentifier)), activeBindings = avoidConstraints ? bindings : bindings.filter((function(binding) {
     var request = new Request(binding.serviceIdentifier, context, parentRequest, binding, target);
     return binding.constraint(request);
    })), function(serviceIdentifier, bindings, target, container) {
     switch (bindings.length) {
     case BindingCount.NoBindingsAvailable:
      if (target.isOptional()) return bindings;
      var serviceIdentifierString = getServiceIdentifierAsString(serviceIdentifier), msg = NOT_REGISTERED;
      throw msg += function(serviceIdentifierString, target) {
       if (target.isTagged() || target.isNamed()) {
        var m_1 = "", namedTag = target.getNamedTag(), otherTags = target.getCustomTags();
        return null !== namedTag && (m_1 += namedTag.toString() + "\n"), null !== otherTags && otherTags.forEach((function(tag) {
         m_1 += tag.toString() + "\n";
        })), " " + serviceIdentifierString + "\n " + serviceIdentifierString + " - " + m_1;
       }
       return " " + serviceIdentifierString;
      }(serviceIdentifierString, target), msg += listRegisteredBindingsForServiceIdentifier(container, serviceIdentifierString, getBindings), 
      new Error(msg);

     case BindingCount.OnlyOneBindingAvailable:
      return bindings;

     case BindingCount.MultipleBindingsAvailable:
     default:
      if (target.isArray()) return bindings;
      serviceIdentifierString = getServiceIdentifierAsString(serviceIdentifier), msg = AMBIGUOUS_MATCH + " " + serviceIdentifierString;
      throw msg += listRegisteredBindingsForServiceIdentifier(container, serviceIdentifierString, getBindings), 
      new Error(msg);
     }
    }(target.serviceIdentifier, activeBindings, target, context.container), activeBindings;
   }
   function _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, parentRequest, target) {
    var activeBindings, childRequest;
    if (null === parentRequest) {
     activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, null, target), 
     childRequest = new Request(serviceIdentifier, context, null, activeBindings, target);
     var thePlan = new Plan(context, childRequest);
     context.addPlan(thePlan);
    } else activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target), 
    childRequest = parentRequest.addChildRequest(target.serviceIdentifier, activeBindings, target);
    activeBindings.forEach((function(binding) {
     var subChildRequest = null;
     if (target.isArray()) subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target); else {
      if (binding.cache) return;
      subChildRequest = childRequest;
     }
     if (binding.type === BindingTypeEnum.Instance && null !== binding.implementationType) {
      var dependencies = function(metadataReader, func) {
       return getTargets(metadataReader, getFunctionName(func), func, !1);
      }(metadataReader, binding.implementationType);
      if (!context.container.options.skipBaseClassChecks) {
       var baseClassDependencyCount = getBaseClassDependencyCount(metadataReader, binding.implementationType);
       if (dependencies.length < baseClassDependencyCount) {
        var error = ARGUMENTS_LENGTH_MISMATCH(getFunctionName(binding.implementationType));
        throw new Error(error);
       }
      }
      dependencies.forEach((function(dependency) {
       _createSubRequests(metadataReader, !1, dependency.serviceIdentifier, context, subChildRequest, dependency);
      }));
     }
    }));
   }
   function getBindings(container, serviceIdentifier) {
    var bindings = [], bindingDictionary = getBindingDictionary(container);
    return bindingDictionary.hasKey(serviceIdentifier) ? bindings = bindingDictionary.get(serviceIdentifier) : null !== container.parent && (bindings = getBindings(container.parent, serviceIdentifier)), 
    bindings;
   }
   function plan(metadataReader, container, isMultiInject, targetType, serviceIdentifier, key, value, avoidConstraints) {
    void 0 === avoidConstraints && (avoidConstraints = !1);
    var context = new Context(container), target = function(isMultiInject, targetType, serviceIdentifier, name, key, value) {
     var injectMetadata = new Metadata(isMultiInject ? MULTI_INJECT_TAG : INJECT_TAG, serviceIdentifier), target = new Target(targetType, name, serviceIdentifier, injectMetadata);
     if (void 0 !== key) {
      var tagMetadata = new Metadata(key, value);
      target.metadata.push(tagMetadata);
     }
     return target;
    }(isMultiInject, targetType, serviceIdentifier, "", key, value);
    try {
     return _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, null, target), 
     context;
    } catch (error) {
     throw isStackOverflowExeption(error) && circularDependencyToException(context.plan.rootRequest), 
     error;
    }
   }
   function isPromise(object) {
    return ("object" == typeof object && null !== object || "function" == typeof object) && "function" == typeof object.then;
   }
   function isPromiseOrContainsPromise(object) {
    return !!isPromise(object) || Array.isArray(object) && object.some(isPromise);
   }
   var FactoryType, __awaiter = function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }, __generator = function(thisArg, body) {
    var f, y, t, g, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    };
    return g = {
     next: verb(0),
     throw: verb(1),
     return: verb(2)
    }, "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;_; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   }, _saveToRequestScope = function(requestScope, binding, result) {
    requestScope.has(binding.id) || requestScope.set(binding.id, result);
   }, _saveToSingletonScope = function(binding, result) {
    binding.cache = result, binding.activated = !0, isPromise(result) && _saveAsyncResultToSingletonScope(binding, result);
   }, _saveAsyncResultToSingletonScope = function(binding, asyncResult) {
    return __awaiter(void 0, void 0, void 0, (function() {
     var result, ex_1;
     return __generator(this, (function(_a) {
      switch (_a.label) {
      case 0:
       return _a.trys.push([ 0, 2, , 3 ]), [ 4, asyncResult ];

      case 1:
       return result = _a.sent(), binding.cache = result, [ 3, 3 ];

      case 2:
       throw ex_1 = _a.sent(), binding.cache = null, binding.activated = !1, ex_1;

      case 3:
       return [ 2 ];
      }
     }));
    }));
   };
   !function(FactoryType) {
    FactoryType.DynamicValue = "toDynamicValue", FactoryType.Factory = "toFactory", 
    FactoryType.Provider = "toProvider";
   }(FactoryType || (FactoryType = {}));
   var multiBindToService = function(container) {
    return function(service) {
     return function() {
      for (var types = [], _i = 0; _i < arguments.length; _i++) types[_i] = arguments[_i];
      return types.forEach((function(t) {
       return container.bind(t).toService(service);
      }));
     };
    };
   }, __assign = function() {
    return __assign = Object.assign || function(t) {
     for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
     return t;
    }, __assign.apply(this, arguments);
   }, instantiation_awaiter = function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }, instantiation_generator = function(thisArg, body) {
    var f, y, t, g, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    };
    return g = {
     next: verb(0),
     throw: verb(1),
     return: verb(2)
    }, "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;_; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   }, instantiation_spreadArray = function(to, from, pack) {
    if (pack || 2 === arguments.length) for (var ar, i = 0, l = from.length; i < l; i++) !ar && i in from || (ar || (ar = Array.prototype.slice.call(from, 0, i)), 
    ar[i] = from[i]);
    return to.concat(ar || Array.prototype.slice.call(from));
   };
   function _createInstance(constr, childRequests, resolveRequest) {
    var result;
    if (childRequests.length > 0) {
     var resolved = function(childRequests, resolveRequest) {
      return childRequests.reduce((function(resolvedRequests, childRequest) {
       var injection = resolveRequest(childRequest);
       return childRequest.target.type === TargetTypeEnum.ConstructorArgument ? resolvedRequests.constructorInjections.push(injection) : (resolvedRequests.propertyRequests.push(childRequest), 
       resolvedRequests.propertyInjections.push(injection)), resolvedRequests.isAsync || (resolvedRequests.isAsync = isPromiseOrContainsPromise(injection)), 
       resolvedRequests;
      }), {
       constructorInjections: [],
       propertyInjections: [],
       propertyRequests: [],
       isAsync: !1
      });
     }(childRequests, resolveRequest), createInstanceWithInjectionsArg = __assign(__assign({}, resolved), {
      constr
     });
     result = resolved.isAsync ? function(args) {
      return instantiation_awaiter(this, void 0, void 0, (function() {
       var constructorInjections, propertyInjections;
       return instantiation_generator(this, (function(_a) {
        switch (_a.label) {
        case 0:
         return [ 4, possiblyWaitInjections(args.constructorInjections) ];

        case 1:
         return constructorInjections = _a.sent(), [ 4, possiblyWaitInjections(args.propertyInjections) ];

        case 2:
         return propertyInjections = _a.sent(), [ 2, createInstanceWithInjections(__assign(__assign({}, args), {
          constructorInjections,
          propertyInjections
         })) ];
        }
       }));
      }));
     }(createInstanceWithInjectionsArg) : createInstanceWithInjections(createInstanceWithInjectionsArg);
    } else result = new constr;
    return result;
   }
   function createInstanceWithInjections(args) {
    var _a, instance = new ((_a = args.constr).bind.apply(_a, instantiation_spreadArray([ void 0 ], args.constructorInjections, !1)));
    return args.propertyRequests.forEach((function(r, index) {
     var property = r.target.identifier, injection = args.propertyInjections[index];
     instance[property] = injection;
    })), instance;
   }
   function possiblyWaitInjections(possiblePromiseinjections) {
    return instantiation_awaiter(this, void 0, void 0, (function() {
     var injections, _i, possiblePromiseinjections_1, injection;
     return instantiation_generator(this, (function(_a) {
      for (injections = [], _i = 0, possiblePromiseinjections_1 = possiblePromiseinjections; _i < possiblePromiseinjections_1.length; _i++) injection = possiblePromiseinjections_1[_i], 
      Array.isArray(injection) ? injections.push(Promise.all(injection)) : injections.push(injection);
      return [ 2, Promise.all(injections) ];
     }));
    }));
   }
   function _getInstanceAfterPostConstruct(constr, result) {
    var postConstructResult = function(constr, instance) {
     var _a, _b;
     if (Reflect.hasMetadata(POST_CONSTRUCT, constr)) {
      var data = Reflect.getMetadata(POST_CONSTRUCT, constr);
      try {
       return null === (_b = (_a = instance)[data.value]) || void 0 === _b ? void 0 : _b.call(_a);
      } catch (e) {
       throw new Error(POST_CONSTRUCT_ERROR(constr.name, e.message));
      }
     }
    }(constr, result);
    return isPromise(postConstructResult) ? postConstructResult.then((function() {
     return result;
    })) : result;
   }
   function _validateInstanceResolution(binding, constr) {
    binding.scope !== BindingScopeEnum.Singleton && function(binding, constr) {
     var scopeErrorMessage = "Class cannot be instantiated in " + (binding.scope === BindingScopeEnum.Request ? "request" : "transient") + " scope.";
     if ("function" == typeof binding.onDeactivation) throw new Error(ON_DEACTIVATION_ERROR(constr.name, scopeErrorMessage));
     if (Reflect.hasMetadata(PRE_DESTROY, constr)) throw new Error(PRE_DESTROY_ERROR(constr.name, scopeErrorMessage));
    }(binding, constr);
   }
   var resolver_awaiter = function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }, resolver_generator = function(thisArg, body) {
    var f, y, t, g, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    };
    return g = {
     next: verb(0),
     throw: verb(1),
     return: verb(2)
    }, "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;_; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   }, _resolveRequest = function(requestScope) {
    return function(request) {
     request.parentContext.setCurrentRequest(request);
     var bindings = request.bindings, childRequests = request.childRequests, targetIsAnArray = request.target && request.target.isArray(), targetParentIsNotAnArray = !(request.parentRequest && request.parentRequest.target && request.target && request.parentRequest.target.matchesArray(request.target.serviceIdentifier));
     if (targetIsAnArray && targetParentIsNotAnArray) return childRequests.map((function(childRequest) {
      return _resolveRequest(requestScope)(childRequest);
     }));
     if (!request.target.isOptional() || 0 !== bindings.length) {
      var binding = bindings[0];
      return _resolveBinding(requestScope, request, binding);
     }
    };
   }, _resolveFactoryFromBinding = function(binding, context) {
    var factoryDetails = function(binding) {
     switch (binding.type) {
     case BindingTypeEnum.Factory:
      return {
       factory: binding.factory,
       factoryType: FactoryType.Factory
      };

     case BindingTypeEnum.Provider:
      return {
       factory: binding.provider,
       factoryType: FactoryType.Provider
      };

     case BindingTypeEnum.DynamicValue:
      return {
       factory: binding.dynamicValue,
       factoryType: FactoryType.DynamicValue
      };

     default:
      throw new Error("Unexpected factory type " + binding.type);
     }
    }(binding);
    return function(fn, errorCallback) {
     try {
      return fn();
     } catch (error) {
      throw isStackOverflowExeption(error) && (error = errorCallback()), error;
     }
    }((function() {
     return factoryDetails.factory.bind(binding)(context);
    }), (function() {
     return new Error((factoryType = factoryDetails.factoryType, serviceIdentifier = context.currentRequest.serviceIdentifier.toString(), 
     "It looks like there is a circular dependency in one of the '" + factoryType + "' bindings. Please investigate bindings withservice identifier '" + serviceIdentifier + "'."));
     var factoryType, serviceIdentifier;
    }));
   }, _getResolvedFromBinding = function(requestScope, request, binding) {
    var result, childRequests = request.childRequests;
    switch (function(binding) {
     var boundValue = null;
     switch (binding.type) {
     case BindingTypeEnum.ConstantValue:
     case BindingTypeEnum.Function:
      boundValue = binding.cache;
      break;

     case BindingTypeEnum.Constructor:
     case BindingTypeEnum.Instance:
      boundValue = binding.implementationType;
      break;

     case BindingTypeEnum.DynamicValue:
      boundValue = binding.dynamicValue;
      break;

     case BindingTypeEnum.Provider:
      boundValue = binding.provider;
      break;

     case BindingTypeEnum.Factory:
      boundValue = binding.factory;
     }
     if (null === boundValue) {
      var serviceIdentifierAsString = getServiceIdentifierAsString(binding.serviceIdentifier);
      throw new Error("Invalid binding type: " + serviceIdentifierAsString);
     }
    }(binding), binding.type) {
    case BindingTypeEnum.ConstantValue:
    case BindingTypeEnum.Function:
     result = binding.cache;
     break;

    case BindingTypeEnum.Constructor:
     result = binding.implementationType;
     break;

    case BindingTypeEnum.Instance:
     result = function(binding, constr, childRequests, resolveRequest) {
      _validateInstanceResolution(binding, constr);
      var result = _createInstance(constr, childRequests, resolveRequest);
      return isPromise(result) ? result.then((function(resolvedResult) {
       return _getInstanceAfterPostConstruct(constr, resolvedResult);
      })) : _getInstanceAfterPostConstruct(constr, result);
     }(binding, binding.implementationType, childRequests, _resolveRequest(requestScope));
     break;

    default:
     result = _resolveFactoryFromBinding(binding, request.parentContext);
    }
    return result;
   }, _resolveInScope = function(requestScope, binding, resolveFromBinding) {
    var result = function(requestScope, binding) {
     return binding.scope === BindingScopeEnum.Singleton && binding.activated ? binding.cache : binding.scope === BindingScopeEnum.Request && requestScope.has(binding.id) ? requestScope.get(binding.id) : null;
    }(requestScope, binding);
    return null !== result || function(requestScope, binding, result) {
     binding.scope === BindingScopeEnum.Singleton && _saveToSingletonScope(binding, result), 
     binding.scope === BindingScopeEnum.Request && _saveToRequestScope(requestScope, binding, result);
    }(requestScope, binding, result = resolveFromBinding()), result;
   }, _resolveBinding = function(requestScope, request, binding) {
    return _resolveInScope(requestScope, binding, (function() {
     var result = _getResolvedFromBinding(requestScope, request, binding);
     return result = isPromise(result) ? result.then((function(resolved) {
      return _onActivation(request, binding, resolved);
     })) : _onActivation(request, binding, result);
    }));
   };
   function _onActivation(request, binding, resolved) {
    var container, result = _bindingActivation(request.parentContext, binding, resolved), containersIterator = _getContainersIterator(request.parentContext.container), containersIteratorResult = containersIterator.next();
    do {
     container = containersIteratorResult.value;
     var context_1 = request.parentContext, serviceIdentifier = request.serviceIdentifier, activationsIterator = _getContainerActivationsForService(container, serviceIdentifier);
     result = isPromise(result) ? _activateContainerAsync(activationsIterator, context_1, result) : _activateContainer(activationsIterator, context_1, result), 
     containersIteratorResult = containersIterator.next();
    } while (!0 !== containersIteratorResult.done && !getBindingDictionary(container).hasKey(request.serviceIdentifier));
    return result;
   }
   var _bindingActivation = function(context, binding, previousResult) {
    return "function" == typeof binding.onActivation ? binding.onActivation(context, previousResult) : previousResult;
   }, _activateContainer = function(activationsIterator, context, result) {
    for (var activation = activationsIterator.next(); !activation.done; ) {
     if (isPromise(result = activation.value(context, result))) return _activateContainerAsync(activationsIterator, context, result);
     activation = activationsIterator.next();
    }
    return result;
   }, _activateContainerAsync = function(activationsIterator, context, resultPromise) {
    return resolver_awaiter(void 0, void 0, void 0, (function() {
     var result, activation;
     return resolver_generator(this, (function(_a) {
      switch (_a.label) {
      case 0:
       return [ 4, resultPromise ];

      case 1:
       result = _a.sent(), activation = activationsIterator.next(), _a.label = 2;

      case 2:
       return activation.done ? [ 3, 4 ] : [ 4, activation.value(context, result) ];

      case 3:
       return result = _a.sent(), activation = activationsIterator.next(), [ 3, 2 ];

      case 4:
       return [ 2, result ];
      }
     }));
    }));
   }, _getContainerActivationsForService = function(container, serviceIdentifier) {
    var activations = container._activations;
    return activations.hasKey(serviceIdentifier) ? activations.get(serviceIdentifier).values() : [].values();
   }, _getContainersIterator = function(container) {
    for (var containersStack = [ container ], parent = container.parent; null !== parent; ) containersStack.push(parent), 
    parent = parent.parent;
    return {
     next: function() {
      var nextContainer = containersStack.pop();
      return void 0 !== nextContainer ? {
       done: !1,
       value: nextContainer
      } : {
       done: !0,
       value: void 0
      };
     }
    };
   };
   var traverseAncerstors = function(request, constraint) {
    var parent = request.parentRequest;
    return null !== parent && (!!constraint(parent) || traverseAncerstors(parent, constraint));
   }, taggedConstraint = function(key) {
    return function(value) {
     var constraint = function(request) {
      return null !== request && null !== request.target && request.target.matchesTag(key)(value);
     };
     return constraint.metaData = new Metadata(key, value), constraint;
    };
   }, namedConstraint = taggedConstraint(NAMED_TAG), typeConstraint = function(type) {
    return function(request) {
     var binding = null;
     if (null !== request) {
      if (binding = request.bindings[0], "string" == typeof type) return binding.serviceIdentifier === type;
      var constructor = request.bindings[0].implementationType;
      return type === constructor;
     }
     return !1;
    };
   }, BindingWhenSyntax = function() {
    function BindingWhenSyntax(binding) {
     this._binding = binding;
    }
    return BindingWhenSyntax.prototype.when = function(constraint) {
     return this._binding.constraint = constraint, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenTargetNamed = function(name) {
     return this._binding.constraint = namedConstraint(name), new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenTargetIsDefault = function() {
     return this._binding.constraint = function(request) {
      return null !== request && (null !== request.target && !request.target.isNamed() && !request.target.isTagged());
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenTargetTagged = function(tag, value) {
     return this._binding.constraint = taggedConstraint(tag)(value), new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenInjectedInto = function(parent) {
     return this._binding.constraint = function(request) {
      return null !== request && typeConstraint(parent)(request.parentRequest);
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenParentNamed = function(name) {
     return this._binding.constraint = function(request) {
      return null !== request && namedConstraint(name)(request.parentRequest);
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenParentTagged = function(tag, value) {
     return this._binding.constraint = function(request) {
      return null !== request && taggedConstraint(tag)(value)(request.parentRequest);
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenAnyAncestorIs = function(ancestor) {
     return this._binding.constraint = function(request) {
      return null !== request && traverseAncerstors(request, typeConstraint(ancestor));
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenNoAncestorIs = function(ancestor) {
     return this._binding.constraint = function(request) {
      return null !== request && !traverseAncerstors(request, typeConstraint(ancestor));
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenAnyAncestorNamed = function(name) {
     return this._binding.constraint = function(request) {
      return null !== request && traverseAncerstors(request, namedConstraint(name));
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenNoAncestorNamed = function(name) {
     return this._binding.constraint = function(request) {
      return null !== request && !traverseAncerstors(request, namedConstraint(name));
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenAnyAncestorTagged = function(tag, value) {
     return this._binding.constraint = function(request) {
      return null !== request && traverseAncerstors(request, taggedConstraint(tag)(value));
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenNoAncestorTagged = function(tag, value) {
     return this._binding.constraint = function(request) {
      return null !== request && !traverseAncerstors(request, taggedConstraint(tag)(value));
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenAnyAncestorMatches = function(constraint) {
     return this._binding.constraint = function(request) {
      return null !== request && traverseAncerstors(request, constraint);
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenNoAncestorMatches = function(constraint) {
     return this._binding.constraint = function(request) {
      return null !== request && !traverseAncerstors(request, constraint);
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax;
   }(), BindingOnSyntax = function() {
    function BindingOnSyntax(binding) {
     this._binding = binding;
    }
    return BindingOnSyntax.prototype.onActivation = function(handler) {
     return this._binding.onActivation = handler, new BindingWhenSyntax(this._binding);
    }, BindingOnSyntax.prototype.onDeactivation = function(handler) {
     return this._binding.onDeactivation = handler, new BindingWhenSyntax(this._binding);
    }, BindingOnSyntax;
   }(), BindingWhenOnSyntax = function() {
    function BindingWhenOnSyntax(binding) {
     this._binding = binding, this._bindingWhenSyntax = new BindingWhenSyntax(this._binding), 
     this._bindingOnSyntax = new BindingOnSyntax(this._binding);
    }
    return BindingWhenOnSyntax.prototype.when = function(constraint) {
     return this._bindingWhenSyntax.when(constraint);
    }, BindingWhenOnSyntax.prototype.whenTargetNamed = function(name) {
     return this._bindingWhenSyntax.whenTargetNamed(name);
    }, BindingWhenOnSyntax.prototype.whenTargetIsDefault = function() {
     return this._bindingWhenSyntax.whenTargetIsDefault();
    }, BindingWhenOnSyntax.prototype.whenTargetTagged = function(tag, value) {
     return this._bindingWhenSyntax.whenTargetTagged(tag, value);
    }, BindingWhenOnSyntax.prototype.whenInjectedInto = function(parent) {
     return this._bindingWhenSyntax.whenInjectedInto(parent);
    }, BindingWhenOnSyntax.prototype.whenParentNamed = function(name) {
     return this._bindingWhenSyntax.whenParentNamed(name);
    }, BindingWhenOnSyntax.prototype.whenParentTagged = function(tag, value) {
     return this._bindingWhenSyntax.whenParentTagged(tag, value);
    }, BindingWhenOnSyntax.prototype.whenAnyAncestorIs = function(ancestor) {
     return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
    }, BindingWhenOnSyntax.prototype.whenNoAncestorIs = function(ancestor) {
     return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
    }, BindingWhenOnSyntax.prototype.whenAnyAncestorNamed = function(name) {
     return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
    }, BindingWhenOnSyntax.prototype.whenAnyAncestorTagged = function(tag, value) {
     return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
    }, BindingWhenOnSyntax.prototype.whenNoAncestorNamed = function(name) {
     return this._bindingWhenSyntax.whenNoAncestorNamed(name);
    }, BindingWhenOnSyntax.prototype.whenNoAncestorTagged = function(tag, value) {
     return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
    }, BindingWhenOnSyntax.prototype.whenAnyAncestorMatches = function(constraint) {
     return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
    }, BindingWhenOnSyntax.prototype.whenNoAncestorMatches = function(constraint) {
     return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
    }, BindingWhenOnSyntax.prototype.onActivation = function(handler) {
     return this._bindingOnSyntax.onActivation(handler);
    }, BindingWhenOnSyntax.prototype.onDeactivation = function(handler) {
     return this._bindingOnSyntax.onDeactivation(handler);
    }, BindingWhenOnSyntax;
   }(), BindingInSyntax = function() {
    function BindingInSyntax(binding) {
     this._binding = binding;
    }
    return BindingInSyntax.prototype.inRequestScope = function() {
     return this._binding.scope = BindingScopeEnum.Request, new BindingWhenOnSyntax(this._binding);
    }, BindingInSyntax.prototype.inSingletonScope = function() {
     return this._binding.scope = BindingScopeEnum.Singleton, new BindingWhenOnSyntax(this._binding);
    }, BindingInSyntax.prototype.inTransientScope = function() {
     return this._binding.scope = BindingScopeEnum.Transient, new BindingWhenOnSyntax(this._binding);
    }, BindingInSyntax;
   }(), BindingInWhenOnSyntax = function() {
    function BindingInWhenOnSyntax(binding) {
     this._binding = binding, this._bindingWhenSyntax = new BindingWhenSyntax(this._binding), 
     this._bindingOnSyntax = new BindingOnSyntax(this._binding), this._bindingInSyntax = new BindingInSyntax(binding);
    }
    return BindingInWhenOnSyntax.prototype.inRequestScope = function() {
     return this._bindingInSyntax.inRequestScope();
    }, BindingInWhenOnSyntax.prototype.inSingletonScope = function() {
     return this._bindingInSyntax.inSingletonScope();
    }, BindingInWhenOnSyntax.prototype.inTransientScope = function() {
     return this._bindingInSyntax.inTransientScope();
    }, BindingInWhenOnSyntax.prototype.when = function(constraint) {
     return this._bindingWhenSyntax.when(constraint);
    }, BindingInWhenOnSyntax.prototype.whenTargetNamed = function(name) {
     return this._bindingWhenSyntax.whenTargetNamed(name);
    }, BindingInWhenOnSyntax.prototype.whenTargetIsDefault = function() {
     return this._bindingWhenSyntax.whenTargetIsDefault();
    }, BindingInWhenOnSyntax.prototype.whenTargetTagged = function(tag, value) {
     return this._bindingWhenSyntax.whenTargetTagged(tag, value);
    }, BindingInWhenOnSyntax.prototype.whenInjectedInto = function(parent) {
     return this._bindingWhenSyntax.whenInjectedInto(parent);
    }, BindingInWhenOnSyntax.prototype.whenParentNamed = function(name) {
     return this._bindingWhenSyntax.whenParentNamed(name);
    }, BindingInWhenOnSyntax.prototype.whenParentTagged = function(tag, value) {
     return this._bindingWhenSyntax.whenParentTagged(tag, value);
    }, BindingInWhenOnSyntax.prototype.whenAnyAncestorIs = function(ancestor) {
     return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
    }, BindingInWhenOnSyntax.prototype.whenNoAncestorIs = function(ancestor) {
     return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
    }, BindingInWhenOnSyntax.prototype.whenAnyAncestorNamed = function(name) {
     return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
    }, BindingInWhenOnSyntax.prototype.whenAnyAncestorTagged = function(tag, value) {
     return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
    }, BindingInWhenOnSyntax.prototype.whenNoAncestorNamed = function(name) {
     return this._bindingWhenSyntax.whenNoAncestorNamed(name);
    }, BindingInWhenOnSyntax.prototype.whenNoAncestorTagged = function(tag, value) {
     return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
    }, BindingInWhenOnSyntax.prototype.whenAnyAncestorMatches = function(constraint) {
     return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
    }, BindingInWhenOnSyntax.prototype.whenNoAncestorMatches = function(constraint) {
     return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
    }, BindingInWhenOnSyntax.prototype.onActivation = function(handler) {
     return this._bindingOnSyntax.onActivation(handler);
    }, BindingInWhenOnSyntax.prototype.onDeactivation = function(handler) {
     return this._bindingOnSyntax.onDeactivation(handler);
    }, BindingInWhenOnSyntax;
   }(), BindingToSyntax = function() {
    function BindingToSyntax(binding) {
     this._binding = binding;
    }
    return BindingToSyntax.prototype.to = function(constructor) {
     return this._binding.type = BindingTypeEnum.Instance, this._binding.implementationType = constructor, 
     new BindingInWhenOnSyntax(this._binding);
    }, BindingToSyntax.prototype.toSelf = function() {
     if ("function" != typeof this._binding.serviceIdentifier) throw new Error("The toSelf function can only be applied when a constructor is used as service identifier");
     var self = this._binding.serviceIdentifier;
     return this.to(self);
    }, BindingToSyntax.prototype.toConstantValue = function(value) {
     return this._binding.type = BindingTypeEnum.ConstantValue, this._binding.cache = value, 
     this._binding.dynamicValue = null, this._binding.implementationType = null, this._binding.scope = BindingScopeEnum.Singleton, 
     new BindingWhenOnSyntax(this._binding);
    }, BindingToSyntax.prototype.toDynamicValue = function(func) {
     return this._binding.type = BindingTypeEnum.DynamicValue, this._binding.cache = null, 
     this._binding.dynamicValue = func, this._binding.implementationType = null, new BindingInWhenOnSyntax(this._binding);
    }, BindingToSyntax.prototype.toConstructor = function(constructor) {
     return this._binding.type = BindingTypeEnum.Constructor, this._binding.implementationType = constructor, 
     this._binding.scope = BindingScopeEnum.Singleton, new BindingWhenOnSyntax(this._binding);
    }, BindingToSyntax.prototype.toFactory = function(factory) {
     return this._binding.type = BindingTypeEnum.Factory, this._binding.factory = factory, 
     this._binding.scope = BindingScopeEnum.Singleton, new BindingWhenOnSyntax(this._binding);
    }, BindingToSyntax.prototype.toFunction = function(func) {
     if ("function" != typeof func) throw new Error("Value provided to function binding must be a function!");
     var bindingWhenOnSyntax = this.toConstantValue(func);
     return this._binding.type = BindingTypeEnum.Function, this._binding.scope = BindingScopeEnum.Singleton, 
     bindingWhenOnSyntax;
    }, BindingToSyntax.prototype.toAutoFactory = function(serviceIdentifier) {
     return this._binding.type = BindingTypeEnum.Factory, this._binding.factory = function(context) {
      return function() {
       return context.container.get(serviceIdentifier);
      };
     }, this._binding.scope = BindingScopeEnum.Singleton, new BindingWhenOnSyntax(this._binding);
    }, BindingToSyntax.prototype.toAutoNamedFactory = function(serviceIdentifier) {
     return this._binding.type = BindingTypeEnum.Factory, this._binding.factory = function(context) {
      return function(named) {
       return context.container.getNamed(serviceIdentifier, named);
      };
     }, new BindingWhenOnSyntax(this._binding);
    }, BindingToSyntax.prototype.toProvider = function(provider) {
     return this._binding.type = BindingTypeEnum.Provider, this._binding.provider = provider, 
     this._binding.scope = BindingScopeEnum.Singleton, new BindingWhenOnSyntax(this._binding);
    }, BindingToSyntax.prototype.toService = function(service) {
     this.toDynamicValue((function(context) {
      return context.container.get(service);
     }));
    }, BindingToSyntax;
   }(), ContainerSnapshot = function() {
    function ContainerSnapshot() {}
    return ContainerSnapshot.of = function(bindings, middleware, activations, deactivations, moduleActivationStore) {
     var snapshot = new ContainerSnapshot;
     return snapshot.bindings = bindings, snapshot.middleware = middleware, snapshot.deactivations = deactivations, 
     snapshot.activations = activations, snapshot.moduleActivationStore = moduleActivationStore, 
     snapshot;
    }, ContainerSnapshot;
   }();
   var Lookup = function() {
    function Lookup() {
     this._map = new Map;
    }
    return Lookup.prototype.getMap = function() {
     return this._map;
    }, Lookup.prototype.add = function(serviceIdentifier, value) {
     if (null == serviceIdentifier) throw new Error("NULL argument");
     if (null == value) throw new Error("NULL argument");
     var entry = this._map.get(serviceIdentifier);
     void 0 !== entry ? entry.push(value) : this._map.set(serviceIdentifier, [ value ]);
    }, Lookup.prototype.get = function(serviceIdentifier) {
     if (null == serviceIdentifier) throw new Error("NULL argument");
     var entry = this._map.get(serviceIdentifier);
     if (void 0 !== entry) return entry;
     throw new Error("Key Not Found");
    }, Lookup.prototype.remove = function(serviceIdentifier) {
     if (null == serviceIdentifier) throw new Error("NULL argument");
     if (!this._map.delete(serviceIdentifier)) throw new Error("Key Not Found");
    }, Lookup.prototype.removeIntersection = function(lookup) {
     var _this = this;
     this.traverse((function(serviceIdentifier, value) {
      var lookupActivations = lookup.hasKey(serviceIdentifier) ? lookup.get(serviceIdentifier) : void 0;
      if (void 0 !== lookupActivations) {
       var filteredValues = value.filter((function(lookupValue) {
        return !lookupActivations.some((function(moduleActivation) {
         return lookupValue === moduleActivation;
        }));
       }));
       _this._setValue(serviceIdentifier, filteredValues);
      }
     }));
    }, Lookup.prototype.removeByCondition = function(condition) {
     var _this = this, removals = [];
     return this._map.forEach((function(entries, key) {
      for (var updatedEntries = [], _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
       var entry = entries_1[_i];
       condition(entry) ? removals.push(entry) : updatedEntries.push(entry);
      }
      _this._setValue(key, updatedEntries);
     })), removals;
    }, Lookup.prototype.hasKey = function(serviceIdentifier) {
     if (null == serviceIdentifier) throw new Error("NULL argument");
     return this._map.has(serviceIdentifier);
    }, Lookup.prototype.clone = function() {
     var copy = new Lookup;
     return this._map.forEach((function(value, key) {
      value.forEach((function(b) {
       return copy.add(key, "object" == typeof (obj = b) && null !== obj && "clone" in obj && "function" == typeof obj.clone ? b.clone() : b);
       var obj;
      }));
     })), copy;
    }, Lookup.prototype.traverse = function(func) {
     this._map.forEach((function(value, key) {
      func(key, value);
     }));
    }, Lookup.prototype._setValue = function(serviceIdentifier, value) {
     value.length > 0 ? this._map.set(serviceIdentifier, value) : this._map.delete(serviceIdentifier);
    }, Lookup;
   }(), ModuleActivationStore = function() {
    function ModuleActivationStore() {
     this._map = new Map;
    }
    return ModuleActivationStore.prototype.remove = function(moduleId) {
     if (this._map.has(moduleId)) {
      var handlers = this._map.get(moduleId);
      return this._map.delete(moduleId), handlers;
     }
     return this._getEmptyHandlersStore();
    }, ModuleActivationStore.prototype.addDeactivation = function(moduleId, serviceIdentifier, onDeactivation) {
     this._getModuleActivationHandlers(moduleId).onDeactivations.add(serviceIdentifier, onDeactivation);
    }, ModuleActivationStore.prototype.addActivation = function(moduleId, serviceIdentifier, onActivation) {
     this._getModuleActivationHandlers(moduleId).onActivations.add(serviceIdentifier, onActivation);
    }, ModuleActivationStore.prototype.clone = function() {
     var clone = new ModuleActivationStore;
     return this._map.forEach((function(handlersStore, moduleId) {
      clone._map.set(moduleId, {
       onActivations: handlersStore.onActivations.clone(),
       onDeactivations: handlersStore.onDeactivations.clone()
      });
     })), clone;
    }, ModuleActivationStore.prototype._getModuleActivationHandlers = function(moduleId) {
     var moduleActivationHandlers = this._map.get(moduleId);
     return void 0 === moduleActivationHandlers && (moduleActivationHandlers = this._getEmptyHandlersStore(), 
     this._map.set(moduleId, moduleActivationHandlers)), moduleActivationHandlers;
    }, ModuleActivationStore.prototype._getEmptyHandlersStore = function() {
     return {
      onActivations: new Lookup,
      onDeactivations: new Lookup
     };
    }, ModuleActivationStore;
   }(), container_assign = function() {
    return container_assign = Object.assign || function(t) {
     for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
     return t;
    }, container_assign.apply(this, arguments);
   }, container_awaiter = function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }, container_generator = function(thisArg, body) {
    var f, y, t, g, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    };
    return g = {
     next: verb(0),
     throw: verb(1),
     return: verb(2)
    }, "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;_; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   }, container_spreadArray = function(to, from, pack) {
    if (pack || 2 === arguments.length) for (var ar, i = 0, l = from.length; i < l; i++) !ar && i in from || (ar || (ar = Array.prototype.slice.call(from, 0, i)), 
    ar[i] = from[i]);
    return to.concat(ar || Array.prototype.slice.call(from));
   }, Container = function() {
    function Container(containerOptions) {
     var options = containerOptions || {};
     if ("object" != typeof options) throw new Error("Invalid Container constructor argument. Container options must be an object.");
     if (void 0 === options.defaultScope) options.defaultScope = BindingScopeEnum.Transient; else if (options.defaultScope !== BindingScopeEnum.Singleton && options.defaultScope !== BindingScopeEnum.Transient && options.defaultScope !== BindingScopeEnum.Request) throw new Error("Invalid Container option. Default scope must be a string ('singleton' or 'transient').");
     if (void 0 === options.autoBindInjectable) options.autoBindInjectable = !1; else if ("boolean" != typeof options.autoBindInjectable) throw new Error("Invalid Container option. Auto bind injectable must be a boolean");
     if (void 0 === options.skipBaseClassChecks) options.skipBaseClassChecks = !1; else if ("boolean" != typeof options.skipBaseClassChecks) throw new Error("Invalid Container option. Skip base check must be a boolean");
     this.options = {
      autoBindInjectable: options.autoBindInjectable,
      defaultScope: options.defaultScope,
      skipBaseClassChecks: options.skipBaseClassChecks
     }, this.id = id(), this._bindingDictionary = new Lookup, this._snapshots = [], this._middleware = null, 
     this._activations = new Lookup, this._deactivations = new Lookup, this.parent = null, 
     this._metadataReader = new MetadataReader, this._moduleActivationStore = new ModuleActivationStore;
    }
    return Container.merge = function(container1, container2) {
     for (var containers = [], _i = 2; _i < arguments.length; _i++) containers[_i - 2] = arguments[_i];
     var container = new Container, targetContainers = container_spreadArray([ container1, container2 ], containers, !0).map((function(targetContainer) {
      return getBindingDictionary(targetContainer);
     })), bindingDictionary = getBindingDictionary(container);
     return targetContainers.forEach((function(targetBindingDictionary) {
      var destination;
      destination = bindingDictionary, targetBindingDictionary.traverse((function(_key, value) {
       value.forEach((function(binding) {
        destination.add(binding.serviceIdentifier, binding.clone());
       }));
      }));
     })), container;
    }, Container.prototype.load = function() {
     for (var modules = [], _i = 0; _i < arguments.length; _i++) modules[_i] = arguments[_i];
     for (var getHelpers = this._getContainerModuleHelpersFactory(), _a = 0, modules_1 = modules; _a < modules_1.length; _a++) {
      var currentModule = modules_1[_a], containerModuleHelpers = getHelpers(currentModule.id);
      currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction);
     }
    }, Container.prototype.loadAsync = function() {
     for (var modules = [], _i = 0; _i < arguments.length; _i++) modules[_i] = arguments[_i];
     return container_awaiter(this, void 0, void 0, (function() {
      var getHelpers, _a, modules_2, currentModule, containerModuleHelpers;
      return container_generator(this, (function(_b) {
       switch (_b.label) {
       case 0:
        getHelpers = this._getContainerModuleHelpersFactory(), _a = 0, modules_2 = modules, 
        _b.label = 1;

       case 1:
        return _a < modules_2.length ? (currentModule = modules_2[_a], containerModuleHelpers = getHelpers(currentModule.id), 
        [ 4, currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction) ]) : [ 3, 4 ];

       case 2:
        _b.sent(), _b.label = 3;

       case 3:
        return _a++, [ 3, 1 ];

       case 4:
        return [ 2 ];
       }
      }));
     }));
    }, Container.prototype.unload = function() {
     for (var _this = this, modules = [], _i = 0; _i < arguments.length; _i++) modules[_i] = arguments[_i];
     modules.forEach((function(module) {
      var deactivations = _this._removeModuleBindings(module.id);
      _this._deactivateSingletons(deactivations), _this._removeModuleHandlers(module.id);
     }));
    }, Container.prototype.unloadAsync = function() {
     for (var modules = [], _i = 0; _i < arguments.length; _i++) modules[_i] = arguments[_i];
     return container_awaiter(this, void 0, void 0, (function() {
      var _a, modules_3, module_1, deactivations;
      return container_generator(this, (function(_b) {
       switch (_b.label) {
       case 0:
        _a = 0, modules_3 = modules, _b.label = 1;

       case 1:
        return _a < modules_3.length ? (module_1 = modules_3[_a], deactivations = this._removeModuleBindings(module_1.id), 
        [ 4, this._deactivateSingletonsAsync(deactivations) ]) : [ 3, 4 ];

       case 2:
        _b.sent(), this._removeModuleHandlers(module_1.id), _b.label = 3;

       case 3:
        return _a++, [ 3, 1 ];

       case 4:
        return [ 2 ];
       }
      }));
     }));
    }, Container.prototype.bind = function(serviceIdentifier) {
     var scope = this.options.defaultScope || BindingScopeEnum.Transient, binding = new Binding(serviceIdentifier, scope);
     return this._bindingDictionary.add(serviceIdentifier, binding), new BindingToSyntax(binding);
    }, Container.prototype.rebind = function(serviceIdentifier) {
     return this.unbind(serviceIdentifier), this.bind(serviceIdentifier);
    }, Container.prototype.rebindAsync = function(serviceIdentifier) {
     return container_awaiter(this, void 0, void 0, (function() {
      return container_generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return [ 4, this.unbindAsync(serviceIdentifier) ];

       case 1:
        return _a.sent(), [ 2, this.bind(serviceIdentifier) ];
       }
      }));
     }));
    }, Container.prototype.unbind = function(serviceIdentifier) {
     if (this._bindingDictionary.hasKey(serviceIdentifier)) {
      var bindings = this._bindingDictionary.get(serviceIdentifier);
      this._deactivateSingletons(bindings);
     }
     this._removeServiceFromDictionary(serviceIdentifier);
    }, Container.prototype.unbindAsync = function(serviceIdentifier) {
     return container_awaiter(this, void 0, void 0, (function() {
      var bindings;
      return container_generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return this._bindingDictionary.hasKey(serviceIdentifier) ? (bindings = this._bindingDictionary.get(serviceIdentifier), 
        [ 4, this._deactivateSingletonsAsync(bindings) ]) : [ 3, 2 ];

       case 1:
        _a.sent(), _a.label = 2;

       case 2:
        return this._removeServiceFromDictionary(serviceIdentifier), [ 2 ];
       }
      }));
     }));
    }, Container.prototype.unbindAll = function() {
     var _this = this;
     this._bindingDictionary.traverse((function(_key, value) {
      _this._deactivateSingletons(value);
     })), this._bindingDictionary = new Lookup;
    }, Container.prototype.unbindAllAsync = function() {
     return container_awaiter(this, void 0, void 0, (function() {
      var promises, _this = this;
      return container_generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return promises = [], this._bindingDictionary.traverse((function(_key, value) {
         promises.push(_this._deactivateSingletonsAsync(value));
        })), [ 4, Promise.all(promises) ];

       case 1:
        return _a.sent(), this._bindingDictionary = new Lookup, [ 2 ];
       }
      }));
     }));
    }, Container.prototype.onActivation = function(serviceIdentifier, onActivation) {
     this._activations.add(serviceIdentifier, onActivation);
    }, Container.prototype.onDeactivation = function(serviceIdentifier, onDeactivation) {
     this._deactivations.add(serviceIdentifier, onDeactivation);
    }, Container.prototype.isBound = function(serviceIdentifier) {
     var bound = this._bindingDictionary.hasKey(serviceIdentifier);
     return !bound && this.parent && (bound = this.parent.isBound(serviceIdentifier)), 
     bound;
    }, Container.prototype.isCurrentBound = function(serviceIdentifier) {
     return this._bindingDictionary.hasKey(serviceIdentifier);
    }, Container.prototype.isBoundNamed = function(serviceIdentifier, named) {
     return this.isBoundTagged(serviceIdentifier, NAMED_TAG, named);
    }, Container.prototype.isBoundTagged = function(serviceIdentifier, key, value) {
     var bound = !1;
     if (this._bindingDictionary.hasKey(serviceIdentifier)) {
      var bindings = this._bindingDictionary.get(serviceIdentifier), request_1 = function(container, serviceIdentifier, key, value) {
       var target = new Target(TargetTypeEnum.Variable, "", serviceIdentifier, new Metadata(key, value)), context = new Context(container);
       return new Request(serviceIdentifier, context, null, [], target);
      }(this, serviceIdentifier, key, value);
      bound = bindings.some((function(b) {
       return b.constraint(request_1);
      }));
     }
     return !bound && this.parent && (bound = this.parent.isBoundTagged(serviceIdentifier, key, value)), 
     bound;
    }, Container.prototype.snapshot = function() {
     this._snapshots.push(ContainerSnapshot.of(this._bindingDictionary.clone(), this._middleware, this._activations.clone(), this._deactivations.clone(), this._moduleActivationStore.clone()));
    }, Container.prototype.restore = function() {
     var snapshot = this._snapshots.pop();
     if (void 0 === snapshot) throw new Error("No snapshot available to restore.");
     this._bindingDictionary = snapshot.bindings, this._activations = snapshot.activations, 
     this._deactivations = snapshot.deactivations, this._middleware = snapshot.middleware, 
     this._moduleActivationStore = snapshot.moduleActivationStore;
    }, Container.prototype.createChild = function(containerOptions) {
     var child = new Container(containerOptions || this.options);
     return child.parent = this, child;
    }, Container.prototype.applyMiddleware = function() {
     for (var middlewares = [], _i = 0; _i < arguments.length; _i++) middlewares[_i] = arguments[_i];
     var initial = this._middleware ? this._middleware : this._planAndResolve();
     this._middleware = middlewares.reduce((function(prev, curr) {
      return curr(prev);
     }), initial);
    }, Container.prototype.applyCustomMetadataReader = function(metadataReader) {
     this._metadataReader = metadataReader;
    }, Container.prototype.get = function(serviceIdentifier) {
     var getArgs = this._getNotAllArgs(serviceIdentifier, !1);
     return this._getButThrowIfAsync(getArgs);
    }, Container.prototype.getAsync = function(serviceIdentifier) {
     return container_awaiter(this, void 0, void 0, (function() {
      var getArgs;
      return container_generator(this, (function(_a) {
       return getArgs = this._getNotAllArgs(serviceIdentifier, !1), [ 2, this._get(getArgs) ];
      }));
     }));
    }, Container.prototype.getTagged = function(serviceIdentifier, key, value) {
     var getArgs = this._getNotAllArgs(serviceIdentifier, !1, key, value);
     return this._getButThrowIfAsync(getArgs);
    }, Container.prototype.getTaggedAsync = function(serviceIdentifier, key, value) {
     return container_awaiter(this, void 0, void 0, (function() {
      var getArgs;
      return container_generator(this, (function(_a) {
       return getArgs = this._getNotAllArgs(serviceIdentifier, !1, key, value), [ 2, this._get(getArgs) ];
      }));
     }));
    }, Container.prototype.getNamed = function(serviceIdentifier, named) {
     return this.getTagged(serviceIdentifier, NAMED_TAG, named);
    }, Container.prototype.getNamedAsync = function(serviceIdentifier, named) {
     return this.getTaggedAsync(serviceIdentifier, NAMED_TAG, named);
    }, Container.prototype.getAll = function(serviceIdentifier) {
     var getArgs = this._getAllArgs(serviceIdentifier);
     return this._getButThrowIfAsync(getArgs);
    }, Container.prototype.getAllAsync = function(serviceIdentifier) {
     var getArgs = this._getAllArgs(serviceIdentifier);
     return this._getAll(getArgs);
    }, Container.prototype.getAllTagged = function(serviceIdentifier, key, value) {
     var getArgs = this._getNotAllArgs(serviceIdentifier, !0, key, value);
     return this._getButThrowIfAsync(getArgs);
    }, Container.prototype.getAllTaggedAsync = function(serviceIdentifier, key, value) {
     var getArgs = this._getNotAllArgs(serviceIdentifier, !0, key, value);
     return this._getAll(getArgs);
    }, Container.prototype.getAllNamed = function(serviceIdentifier, named) {
     return this.getAllTagged(serviceIdentifier, NAMED_TAG, named);
    }, Container.prototype.getAllNamedAsync = function(serviceIdentifier, named) {
     return this.getAllTaggedAsync(serviceIdentifier, NAMED_TAG, named);
    }, Container.prototype.resolve = function(constructorFunction) {
     var isBound = this.isBound(constructorFunction);
     isBound || this.bind(constructorFunction).toSelf();
     var resolved = this.get(constructorFunction);
     return isBound || this.unbind(constructorFunction), resolved;
    }, Container.prototype._preDestroy = function(constructor, instance) {
     if (Reflect.hasMetadata(PRE_DESTROY, constructor)) return instance[Reflect.getMetadata(PRE_DESTROY, constructor).value]();
    }, Container.prototype._removeModuleHandlers = function(moduleId) {
     var moduleActivationsHandlers = this._moduleActivationStore.remove(moduleId);
     this._activations.removeIntersection(moduleActivationsHandlers.onActivations), this._deactivations.removeIntersection(moduleActivationsHandlers.onDeactivations);
    }, Container.prototype._removeModuleBindings = function(moduleId) {
     return this._bindingDictionary.removeByCondition((function(binding) {
      return binding.moduleId === moduleId;
     }));
    }, Container.prototype._deactivate = function(binding, instance) {
     var _this = this, constructor = Object.getPrototypeOf(instance).constructor;
     try {
      if (this._deactivations.hasKey(binding.serviceIdentifier)) {
       var result = this._deactivateContainer(instance, this._deactivations.get(binding.serviceIdentifier).values());
       if (isPromise(result)) return this._handleDeactivationError(result.then((function() {
        return _this._propagateContainerDeactivationThenBindingAndPreDestroyAsync(binding, instance, constructor);
       })), constructor);
      }
      var propagateDeactivationResult = this._propagateContainerDeactivationThenBindingAndPreDestroy(binding, instance, constructor);
      if (isPromise(propagateDeactivationResult)) return this._handleDeactivationError(propagateDeactivationResult, constructor);
     } catch (ex) {
      throw new Error(ON_DEACTIVATION_ERROR(constructor.name, ex.message));
     }
    }, Container.prototype._handleDeactivationError = function(asyncResult, constructor) {
     return container_awaiter(this, void 0, void 0, (function() {
      var ex_1;
      return container_generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return _a.trys.push([ 0, 2, , 3 ]), [ 4, asyncResult ];

       case 1:
        return _a.sent(), [ 3, 3 ];

       case 2:
        throw ex_1 = _a.sent(), new Error(ON_DEACTIVATION_ERROR(constructor.name, ex_1.message));

       case 3:
        return [ 2 ];
       }
      }));
     }));
    }, Container.prototype._deactivateContainer = function(instance, deactivationsIterator) {
     for (var _this = this, deactivation = deactivationsIterator.next(); deactivation.value; ) {
      var result = deactivation.value(instance);
      if (isPromise(result)) return result.then((function() {
       return _this._deactivateContainerAsync(instance, deactivationsIterator);
      }));
      deactivation = deactivationsIterator.next();
     }
    }, Container.prototype._deactivateContainerAsync = function(instance, deactivationsIterator) {
     return container_awaiter(this, void 0, void 0, (function() {
      var deactivation;
      return container_generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        deactivation = deactivationsIterator.next(), _a.label = 1;

       case 1:
        return deactivation.value ? [ 4, deactivation.value(instance) ] : [ 3, 3 ];

       case 2:
        return _a.sent(), deactivation = deactivationsIterator.next(), [ 3, 1 ];

       case 3:
        return [ 2 ];
       }
      }));
     }));
    }, Container.prototype._getContainerModuleHelpersFactory = function() {
     var _this = this, setModuleId = function(bindingToSyntax, moduleId) {
      bindingToSyntax._binding.moduleId = moduleId;
     }, getRebindFunction = function(moduleId) {
      return function(serviceIdentifier) {
       var bindingToSyntax = _this.rebind(serviceIdentifier);
       return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
      };
     }, getOnActivationFunction = function(moduleId) {
      return function(serviceIdentifier, onActivation) {
       _this._moduleActivationStore.addActivation(moduleId, serviceIdentifier, onActivation), 
       _this.onActivation(serviceIdentifier, onActivation);
      };
     }, getOnDeactivationFunction = function(moduleId) {
      return function(serviceIdentifier, onDeactivation) {
       _this._moduleActivationStore.addDeactivation(moduleId, serviceIdentifier, onDeactivation), 
       _this.onDeactivation(serviceIdentifier, onDeactivation);
      };
     };
     return function(mId) {
      return {
       bindFunction: (moduleId = mId, function(serviceIdentifier) {
        var bindingToSyntax = _this.bind(serviceIdentifier);
        return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
       }),
       isboundFunction: function(serviceIdentifier) {
        return _this.isBound(serviceIdentifier);
       },
       onActivationFunction: getOnActivationFunction(mId),
       onDeactivationFunction: getOnDeactivationFunction(mId),
       rebindFunction: getRebindFunction(mId),
       unbindFunction: function(serviceIdentifier) {
        return _this.unbind(serviceIdentifier);
       },
       unbindAsyncFunction: function(serviceIdentifier) {
        return _this.unbindAsync(serviceIdentifier);
       }
      };
      var moduleId;
     };
    }, Container.prototype._getAll = function(getArgs) {
     return Promise.all(this._get(getArgs));
    }, Container.prototype._get = function(getArgs) {
     var planAndResolveArgs = container_assign(container_assign({}, getArgs), {
      contextInterceptor: function(context) {
       return context;
      },
      targetType: TargetTypeEnum.Variable
     });
     if (this._middleware) {
      var middlewareResult = this._middleware(planAndResolveArgs);
      if (null == middlewareResult) throw new Error("Invalid return type in middleware. Middleware must return!");
      return middlewareResult;
     }
     return this._planAndResolve()(planAndResolveArgs);
    }, Container.prototype._getButThrowIfAsync = function(getArgs) {
     var result = this._get(getArgs);
     if (isPromiseOrContainsPromise(result)) throw new Error("You are attempting to construct '" + getArgs.serviceIdentifier + "' in a synchronous way\n but it has asynchronous dependencies.");
     return result;
    }, Container.prototype._getAllArgs = function(serviceIdentifier) {
     return {
      avoidConstraints: !0,
      isMultiInject: !0,
      serviceIdentifier
     };
    }, Container.prototype._getNotAllArgs = function(serviceIdentifier, isMultiInject, key, value) {
     return {
      avoidConstraints: !1,
      isMultiInject,
      serviceIdentifier,
      key,
      value
     };
    }, Container.prototype._planAndResolve = function() {
     var _this = this;
     return function(args) {
      var context = plan(_this._metadataReader, _this, args.isMultiInject, args.targetType, args.serviceIdentifier, args.key, args.value, args.avoidConstraints);
      return function(context) {
       return _resolveRequest(context.plan.rootRequest.requestScope)(context.plan.rootRequest);
      }(context = args.contextInterceptor(context));
     };
    }, Container.prototype._deactivateIfSingleton = function(binding) {
     var _this = this;
     if (binding.activated) return isPromise(binding.cache) ? binding.cache.then((function(resolved) {
      return _this._deactivate(binding, resolved);
     })) : this._deactivate(binding, binding.cache);
    }, Container.prototype._deactivateSingletons = function(bindings) {
     for (var _i = 0, bindings_1 = bindings; _i < bindings_1.length; _i++) {
      var binding = bindings_1[_i];
      if (isPromise(this._deactivateIfSingleton(binding))) throw new Error("Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)");
     }
    }, Container.prototype._deactivateSingletonsAsync = function(bindings) {
     return container_awaiter(this, void 0, void 0, (function() {
      var _this = this;
      return container_generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return [ 4, Promise.all(bindings.map((function(b) {
         return _this._deactivateIfSingleton(b);
        }))) ];

       case 1:
        return _a.sent(), [ 2 ];
       }
      }));
     }));
    }, Container.prototype._propagateContainerDeactivationThenBindingAndPreDestroy = function(binding, instance, constructor) {
     return this.parent ? this._deactivate.bind(this.parent)(binding, instance) : this._bindingDeactivationAndPreDestroy(binding, instance, constructor);
    }, Container.prototype._propagateContainerDeactivationThenBindingAndPreDestroyAsync = function(binding, instance, constructor) {
     return container_awaiter(this, void 0, void 0, (function() {
      return container_generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return this.parent ? [ 4, this._deactivate.bind(this.parent)(binding, instance) ] : [ 3, 2 ];

       case 1:
        return _a.sent(), [ 3, 4 ];

       case 2:
        return [ 4, this._bindingDeactivationAndPreDestroyAsync(binding, instance, constructor) ];

       case 3:
        _a.sent(), _a.label = 4;

       case 4:
        return [ 2 ];
       }
      }));
     }));
    }, Container.prototype._removeServiceFromDictionary = function(serviceIdentifier) {
     try {
      this._bindingDictionary.remove(serviceIdentifier);
     } catch (e) {
      throw new Error("Could not unbind serviceIdentifier: " + getServiceIdentifierAsString(serviceIdentifier));
     }
    }, Container.prototype._bindingDeactivationAndPreDestroy = function(binding, instance, constructor) {
     var _this = this;
     if ("function" == typeof binding.onDeactivation) {
      var result = binding.onDeactivation(instance);
      if (isPromise(result)) return result.then((function() {
       return _this._preDestroy(constructor, instance);
      }));
     }
     return this._preDestroy(constructor, instance);
    }, Container.prototype._bindingDeactivationAndPreDestroyAsync = function(binding, instance, constructor) {
     return container_awaiter(this, void 0, void 0, (function() {
      return container_generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return "function" != typeof binding.onDeactivation ? [ 3, 2 ] : [ 4, binding.onDeactivation(instance) ];

       case 1:
        _a.sent(), _a.label = 2;

       case 2:
        return [ 4, this._preDestroy(constructor, instance) ];

       case 3:
        return _a.sent(), [ 2 ];
       }
      }));
     }));
    }, Container;
   }(), ContainerModule = function(registry) {
    this.id = id(), this.registry = registry;
   }, AsyncContainerModule = function(registry) {
    this.id = id(), this.registry = registry;
   };
   function tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {
    !function(parameterName) {
     if (void 0 !== parameterName) throw new Error(INVALID_DECORATOR_OPERATION);
    }(parameterName), _tagParameterOrProperty(TAGGED, annotationTarget, parameterIndex.toString(), metadata);
   }
   function _ensureNoMetadataKeyDuplicates(metadata) {
    var metadatas = [];
    if (Array.isArray(metadata)) {
     var duplicate = function(array) {
      for (var seenValues = new Set, _i = 0, array_1 = array; _i < array_1.length; _i++) {
       var entry = array_1[_i];
       if (seenValues.has(entry)) return entry;
       seenValues.add(entry);
      }
     }((metadatas = metadata).map((function(md) {
      return md.key;
     })));
     if (void 0 !== duplicate) throw new Error(DUPLICATED_METADATA + " " + duplicate.toString());
    } else metadatas = [ metadata ];
    return metadatas;
   }
   function _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {
    var metadatas = _ensureNoMetadataKeyDuplicates(metadata), paramsOrPropertiesMetadata = {};
    Reflect.hasOwnMetadata(metadataKey, annotationTarget) && (paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget));
    var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
    if (void 0 === paramOrPropertyMetadata) paramOrPropertyMetadata = []; else for (var _loop_1 = function(m) {
     if (metadatas.some((function(md) {
      return md.key === m.key;
     }))) throw new Error(DUPLICATED_METADATA + " " + m.key.toString());
    }, _i = 0, paramOrPropertyMetadata_1 = paramOrPropertyMetadata; _i < paramOrPropertyMetadata_1.length; _i++) {
     _loop_1(paramOrPropertyMetadata_1[_i]);
    }
    paramOrPropertyMetadata.push.apply(paramOrPropertyMetadata, metadatas), paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata, 
    Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
   }
   function createTaggedDecorator(metadata) {
    return function(target, targetKey, indexOrPropertyDescriptor) {
     "number" == typeof indexOrPropertyDescriptor ? tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata) : function(annotationTarget, propertyName, metadata) {
      if (void 0 !== annotationTarget.prototype) throw new Error(INVALID_DECORATOR_OPERATION);
      _tagParameterOrProperty(TAGGED_PROP, annotationTarget.constructor, propertyName, metadata);
     }(target, targetKey, metadata);
    };
   }
   function _decorate(decorators, target) {
    Reflect.decorate(decorators, target);
   }
   function _param(paramIndex, decorator) {
    return function(target, key) {
     decorator(target, key, paramIndex);
    };
   }
   function decorate(decorator, target, parameterIndexOrProperty) {
    "number" == typeof parameterIndexOrProperty ? _decorate([ _param(parameterIndexOrProperty, decorator) ], target) : "string" == typeof parameterIndexOrProperty ? Reflect.decorate([ decorator ], target, parameterIndexOrProperty) : _decorate([ decorator ], target);
   }
   function injectable() {
    return function(target) {
     if (Reflect.hasOwnMetadata(PARAM_TYPES, target)) throw new Error(DUPLICATED_INJECTABLE_DECORATOR);
     var types = Reflect.getMetadata(DESIGN_PARAM_TYPES, target) || [];
     return Reflect.defineMetadata(PARAM_TYPES, types, target), target;
    };
   }
   function tagged(metadataKey, metadataValue) {
    return createTaggedDecorator(new Metadata(metadataKey, metadataValue));
   }
   function named(name) {
    return createTaggedDecorator(new Metadata(NAMED_TAG, name));
   }
   function injectBase(metadataKey) {
    return function(serviceIdentifier) {
     return function(target, targetKey, indexOrPropertyDescriptor) {
      if (void 0 === serviceIdentifier) {
       var className = "function" == typeof target ? target.name : target.constructor.name;
       throw new Error("@inject called with undefined this could mean that the class " + className + " has a circular dependency problem. You can use a LazyServiceIdentifer to  overcome this limitation.");
      }
      return createTaggedDecorator(new Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);
     };
    };
   }
   var inject = injectBase(INJECT_TAG);
   function optional() {
    return createTaggedDecorator(new Metadata(OPTIONAL_TAG, !0));
   }
   function unmanaged() {
    return function(target, targetKey, index) {
     tagParameter(target, targetKey, index, new Metadata(UNMANAGED_TAG, !0));
    };
   }
   var multiInject = injectBase(MULTI_INJECT_TAG);
   function targetName(name) {
    return function(target, targetKey, index) {
     tagParameter(target, targetKey, index, new Metadata(NAME_TAG, name));
    };
   }
   function propertyEventDecorator(eventKey, errorMessage) {
    return function() {
     return function(target, propertyKey) {
      var metadata = new Metadata(eventKey, propertyKey);
      if (Reflect.hasOwnMetadata(eventKey, target.constructor)) throw new Error(errorMessage);
      Reflect.defineMetadata(eventKey, metadata, target.constructor);
     };
    };
   }
   var interfaces, postConstruct = propertyEventDecorator(POST_CONSTRUCT, "Cannot apply @postConstruct decorator multiple times in the same class"), preDestroy = propertyEventDecorator(PRE_DESTROY, "Cannot apply @preDestroy decorator multiple times in the same class");
   interfaces || (interfaces = {});
   var METADATA_KEY = metadata_keys_namespaceObject;
  },
  39593: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   const Yallist = __webpack_require__(34411), MAX = Symbol("max"), LENGTH = Symbol("length"), LENGTH_CALCULATOR = Symbol("lengthCalculator"), ALLOW_STALE = Symbol("allowStale"), MAX_AGE = Symbol("maxAge"), DISPOSE = Symbol("dispose"), NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet"), LRU_LIST = Symbol("lruList"), CACHE = Symbol("cache"), UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet"), naiveLength = () => 1;
   const get = (self, key, doUse) => {
    const node = self[CACHE].get(key);
    if (node) {
     const hit = node.value;
     if (isStale(self, hit)) {
      if (del(self, node), !self[ALLOW_STALE]) return;
     } else doUse && (self[UPDATE_AGE_ON_GET] && (node.value.now = Date.now()), self[LRU_LIST].unshiftNode(node));
     return hit.value;
    }
   }, isStale = (self, hit) => {
    if (!hit || !hit.maxAge && !self[MAX_AGE]) return !1;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
   }, trim = self => {
    if (self[LENGTH] > self[MAX]) for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && null !== walker; ) {
     const prev = walker.prev;
     del(self, walker), walker = prev;
    }
   }, del = (self, node) => {
    if (node) {
     const hit = node.value;
     self[DISPOSE] && self[DISPOSE](hit.key, hit.value), self[LENGTH] -= hit.length, 
     self[CACHE].delete(hit.key), self[LRU_LIST].removeNode(node);
    }
   };
   class Entry {
    constructor(key, value, length, now, maxAge) {
     this.key = key, this.value = value, this.length = length, this.now = now, this.maxAge = maxAge || 0;
    }
   }
   const forEachStep = (self, fn, node, thisp) => {
    let hit = node.value;
    isStale(self, hit) && (del(self, node), self[ALLOW_STALE] || (hit = void 0)), hit && fn.call(thisp, hit.value, hit.key, self);
   };
   module.exports = class {
    constructor(options) {
     if ("number" == typeof options && (options = {
      max: options
     }), options || (options = {}), options.max && ("number" != typeof options.max || options.max < 0)) throw new TypeError("max must be a non-negative number");
     this[MAX] = options.max || 1 / 0;
     const lc = options.length || naiveLength;
     if (this[LENGTH_CALCULATOR] = "function" != typeof lc ? naiveLength : lc, this[ALLOW_STALE] = options.stale || !1, 
     options.maxAge && "number" != typeof options.maxAge) throw new TypeError("maxAge must be a number");
     this[MAX_AGE] = options.maxAge || 0, this[DISPOSE] = options.dispose, this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || !1, 
     this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || !1, this.reset();
    }
    set max(mL) {
     if ("number" != typeof mL || mL < 0) throw new TypeError("max must be a non-negative number");
     this[MAX] = mL || 1 / 0, trim(this);
    }
    get max() {
     return this[MAX];
    }
    set allowStale(allowStale) {
     this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
     return this[ALLOW_STALE];
    }
    set maxAge(mA) {
     if ("number" != typeof mA) throw new TypeError("maxAge must be a non-negative number");
     this[MAX_AGE] = mA, trim(this);
    }
    get maxAge() {
     return this[MAX_AGE];
    }
    set lengthCalculator(lC) {
     "function" != typeof lC && (lC = naiveLength), lC !== this[LENGTH_CALCULATOR] && (this[LENGTH_CALCULATOR] = lC, 
     this[LENGTH] = 0, this[LRU_LIST].forEach((hit => {
      hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key), this[LENGTH] += hit.length;
     }))), trim(this);
    }
    get lengthCalculator() {
     return this[LENGTH_CALCULATOR];
    }
    get length() {
     return this[LENGTH];
    }
    get itemCount() {
     return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
     thisp = thisp || this;
     for (let walker = this[LRU_LIST].tail; null !== walker; ) {
      const prev = walker.prev;
      forEachStep(this, fn, walker, thisp), walker = prev;
     }
    }
    forEach(fn, thisp) {
     thisp = thisp || this;
     for (let walker = this[LRU_LIST].head; null !== walker; ) {
      const next = walker.next;
      forEachStep(this, fn, walker, thisp), walker = next;
     }
    }
    keys() {
     return this[LRU_LIST].toArray().map((k => k.key));
    }
    values() {
     return this[LRU_LIST].toArray().map((k => k.value));
    }
    reset() {
     this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length && this[LRU_LIST].forEach((hit => this[DISPOSE](hit.key, hit.value))), 
     this[CACHE] = new Map, this[LRU_LIST] = new Yallist, this[LENGTH] = 0;
    }
    dump() {
     return this[LRU_LIST].map((hit => !isStale(this, hit) && {
      k: hit.key,
      v: hit.value,
      e: hit.now + (hit.maxAge || 0)
     })).toArray().filter((h => h));
    }
    dumpLru() {
     return this[LRU_LIST];
    }
    set(key, value, maxAge) {
     if ((maxAge = maxAge || this[MAX_AGE]) && "number" != typeof maxAge) throw new TypeError("maxAge must be a number");
     const now = maxAge ? Date.now() : 0, len = this[LENGTH_CALCULATOR](value, key);
     if (this[CACHE].has(key)) {
      if (len > this[MAX]) return del(this, this[CACHE].get(key)), !1;
      const item = this[CACHE].get(key).value;
      return this[DISPOSE] && (this[NO_DISPOSE_ON_SET] || this[DISPOSE](key, item.value)), 
      item.now = now, item.maxAge = maxAge, item.value = value, this[LENGTH] += len - item.length, 
      item.length = len, this.get(key), trim(this), !0;
     }
     const hit = new Entry(key, value, len, now, maxAge);
     return hit.length > this[MAX] ? (this[DISPOSE] && this[DISPOSE](key, value), !1) : (this[LENGTH] += hit.length, 
     this[LRU_LIST].unshift(hit), this[CACHE].set(key, this[LRU_LIST].head), trim(this), 
     !0);
    }
    has(key) {
     if (!this[CACHE].has(key)) return !1;
     const hit = this[CACHE].get(key).value;
     return !isStale(this, hit);
    }
    get(key) {
     return get(this, key, !0);
    }
    peek(key) {
     return get(this, key, !1);
    }
    pop() {
     const node = this[LRU_LIST].tail;
     return node ? (del(this, node), node.value) : null;
    }
    del(key) {
     del(this, this[CACHE].get(key));
    }
    load(arr) {
     this.reset();
     const now = Date.now();
     for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l], expiresAt = hit.e || 0;
      if (0 === expiresAt) this.set(hit.k, hit.v); else {
       const maxAge = expiresAt - now;
       maxAge > 0 && this.set(hit.k, hit.v, maxAge);
      }
     }
    }
    prune() {
     this[CACHE].forEach(((value, key) => get(this, key, !1)));
    }
   };
  },
  55234: (module, __unused_webpack_exports, __webpack_require__) => {
   module.exports = __webpack_require__(53765);
  },
  80983: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var extensions, types, preference, db = __webpack_require__(55234), extname = __webpack_require__(71017).extname, EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/, TEXT_TYPE_REGEXP = /^text\//i;
   function charset(type) {
    if (!type || "string" != typeof type) return !1;
    var match = EXTRACT_TYPE_REGEXP.exec(type), mime = match && db[match[1].toLowerCase()];
    return mime && mime.charset ? mime.charset : !(!match || !TEXT_TYPE_REGEXP.test(match[1])) && "UTF-8";
   }
   exports.charset = charset, exports.charsets = {
    lookup: charset
   }, exports.contentType = function(str) {
    if (!str || "string" != typeof str) return !1;
    var mime = -1 === str.indexOf("/") ? exports.lookup(str) : str;
    if (!mime) return !1;
    if (-1 === mime.indexOf("charset")) {
     var charset = exports.charset(mime);
     charset && (mime += "; charset=" + charset.toLowerCase());
    }
    return mime;
   }, exports.extension = function(type) {
    if (!type || "string" != typeof type) return !1;
    var match = EXTRACT_TYPE_REGEXP.exec(type), exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) return !1;
    return exts[0];
   }, exports.extensions = Object.create(null), exports.lookup = function(path) {
    if (!path || "string" != typeof path) return !1;
    var extension = extname("x." + path).toLowerCase().substr(1);
    if (!extension) return !1;
    return exports.types[extension] || !1;
   }, exports.types = Object.create(null), extensions = exports.extensions, types = exports.types, 
   preference = [ "nginx", "apache", void 0, "iana" ], Object.keys(db).forEach((function(type) {
    var mime = db[type], exts = mime.extensions;
    if (exts && exts.length) {
     extensions[type] = exts;
     for (var i = 0; i < exts.length; i++) {
      var extension = exts[i];
      if (types[extension]) {
       var from = preference.indexOf(db[types[extension]].source), to = preference.indexOf(mime.source);
       if ("application/octet-stream" !== types[extension] && (from > to || from === to && "application/" === types[extension].substr(0, 12))) continue;
      }
      types[extension] = type;
     }
    }
   }));
  },
  57824: module => {
   var s = 1e3, m = 60 * s, h = 60 * m, d = 24 * h, w = 7 * d, y = 365.25 * d;
   function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= 1.5 * n;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
   }
   module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if ("string" === type && val.length > 0) return function(str) {
     if ((str = String(str)).length > 100) return;
     var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
     if (!match) return;
     var n = parseFloat(match[1]);
     switch ((match[2] || "ms").toLowerCase()) {
     case "years":
     case "year":
     case "yrs":
     case "yr":
     case "y":
      return n * y;

     case "weeks":
     case "week":
     case "w":
      return n * w;

     case "days":
     case "day":
     case "d":
      return n * d;

     case "hours":
     case "hour":
     case "hrs":
     case "hr":
     case "h":
      return n * h;

     case "minutes":
     case "minute":
     case "mins":
     case "min":
     case "m":
      return n * m;

     case "seconds":
     case "second":
     case "secs":
     case "sec":
     case "s":
      return n * s;

     case "milliseconds":
     case "millisecond":
     case "msecs":
     case "msec":
     case "ms":
      return n;

     default:
      return;
     }
    }(val);
    if ("number" === type && isFinite(val)) return options.long ? function(ms) {
     var msAbs = Math.abs(ms);
     if (msAbs >= d) return plural(ms, msAbs, d, "day");
     if (msAbs >= h) return plural(ms, msAbs, h, "hour");
     if (msAbs >= m) return plural(ms, msAbs, m, "minute");
     if (msAbs >= s) return plural(ms, msAbs, s, "second");
     return ms + " ms";
    }(val) : function(ms) {
     var msAbs = Math.abs(ms);
     if (msAbs >= d) return Math.round(ms / d) + "d";
     if (msAbs >= h) return Math.round(ms / h) + "h";
     if (msAbs >= m) return Math.round(ms / m) + "m";
     if (msAbs >= s) return Math.round(ms / s) + "s";
     return ms + "ms";
    }(val);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
   };
  },
  73414: (module, __unused_webpack_exports, __webpack_require__) => {
   if (!globalThis.DOMException) try {
    const {MessageChannel} = __webpack_require__(71267), port = (new MessageChannel).port1, ab = new ArrayBuffer;
    port.postMessage(ab, [ ab, ab ]);
   } catch (err) {
    "DOMException" === err.constructor.name && (globalThis.DOMException = err.constructor);
   }
   module.exports = globalThis.DOMException;
  },
  23145: module => {
   "use strict";
   function _typeof(obj) {
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
     return typeof obj;
    } : function(obj) {
     return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
   }
   function _defineProperty(obj, key, value) {
    return (key = function(arg) {
     var key = function(input, hint) {
      if ("object" !== _typeof(input) || null === input) return input;
      var prim = input[Symbol.toPrimitive];
      if (void 0 !== prim) {
       var res = prim.call(input, hint || "default");
       if ("object" !== _typeof(res)) return res;
       throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === hint ? String : Number)(input);
     }(arg, "string");
     return "symbol" === _typeof(key) ? key : String(key);
    }(key)) in obj ? Object.defineProperty(obj, key, {
     value,
     enumerable: !0,
     configurable: !0,
     writable: !0
    }) : obj[key] = value, obj;
   }
   function _slicedToArray(arr, i) {
    return function(arr) {
     if (Array.isArray(arr)) return arr;
    }(arr) || function(arr, i) {
     var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
     if (null != _i) {
      var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;
      try {
       if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i) return;
        _n = !1;
       } else for (;!(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) ;
      } catch (err) {
       _d = !0, _e = err;
      } finally {
       try {
        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
       } finally {
        if (_d) throw _e;
       }
      }
      return _arr;
     }
    }(arr, i) || _unsupportedIterableToArray(arr, i) || function() {
     throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
   }
   function _unsupportedIterableToArray(o, minLen) {
    if (o) {
     if ("string" == typeof o) return _arrayLikeToArray(o, minLen);
     var n = Object.prototype.toString.call(o).slice(8, -1);
     return "Object" === n && o.constructor && (n = o.constructor.name), "Map" === n || "Set" === n ? Array.from(o) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _arrayLikeToArray(o, minLen) : void 0;
    }
   }
   function _arrayLikeToArray(arr, len) {
    (null == len || len > arr.length) && (len = arr.length);
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
   }
   module.exports = function(input) {
    if (!input) return [];
    if ("string" != typeof input || input.match(/^\s+$/)) return [];
    var lines = input.split("\n");
    if (0 === lines.length) return [];
    var _step, files = [], currentFile = null, currentChunk = null, deletedLineCounter = 0, addedLineCounter = 0, currentFileChanges = null, start = function(line) {
     var _parseFiles, _ref2 = _slicedToArray(null !== (_parseFiles = parseFiles(line)) && void 0 !== _parseFiles ? _parseFiles : [], 2), fromFileName = _ref2[0], toFileName = _ref2[1];
     currentFile = {
      chunks: [],
      deletions: 0,
      additions: 0,
      from: fromFileName,
      to: toFileName
     }, files.push(currentFile);
    }, restart = function() {
     currentFile && !currentFile.chunks.length || start();
    }, toNumOfLines = function(number) {
     return +(number || 1);
    }, eof = function(line) {
     var _currentChunk$changes3;
     if (currentChunk) {
      var mostRecentChange = _slicedToArray(currentChunk.changes.slice(-1), 1)[0];
      currentChunk.changes.push((_defineProperty(_currentChunk$changes3 = {
       type: mostRecentChange.type
      }, mostRecentChange.type, !0), _defineProperty(_currentChunk$changes3, "ln1", mostRecentChange.ln1), 
      _defineProperty(_currentChunk$changes3, "ln2", mostRecentChange.ln2), _defineProperty(_currentChunk$changes3, "ln", mostRecentChange.ln), 
      _defineProperty(_currentChunk$changes3, "content", line), _currentChunk$changes3));
     }
    }, schemaHeaders = [ [ /^diff\s/, start ], [ /^new file mode (\d+)$/, function(_, match) {
     restart(), currentFile.new = !0, currentFile.newMode = match[1], currentFile.from = "/dev/null";
    } ], [ /^deleted file mode (\d+)$/, function(_, match) {
     restart(), currentFile.deleted = !0, currentFile.oldMode = match[1], currentFile.to = "/dev/null";
    } ], [ /^old mode (\d+)$/, function(_, match) {
     restart(), currentFile.oldMode = match[1];
    } ], [ /^new mode (\d+)$/, function(_, match) {
     restart(), currentFile.newMode = match[1];
    } ], [ /^index\s[\da-zA-Z]+\.\.[\da-zA-Z]+(\s(\d+))?$/, function(line, match) {
     restart(), currentFile.index = line.split(" ").slice(1), match[1] && (currentFile.oldMode = currentFile.newMode = match[1].trim());
    } ], [ /^---\s/, function(line) {
     restart(), currentFile.from = parseOldOrNewFile(line);
    } ], [ /^\+\+\+\s/, function(line) {
     restart(), currentFile.to = parseOldOrNewFile(line);
    } ], [ /^@@\s+-(\d+),?(\d+)?\s+\+(\d+),?(\d+)?\s@@/, function(line, match) {
     currentFile || start(line);
     var _match$slice2 = _slicedToArray(match.slice(1), 4), oldStart = _match$slice2[0], oldNumLines = _match$slice2[1], newStart = _match$slice2[2], newNumLines = _match$slice2[3];
     deletedLineCounter = +oldStart, addedLineCounter = +newStart, currentChunk = {
      content: line,
      changes: [],
      oldStart: +oldStart,
      oldLines: toNumOfLines(oldNumLines),
      newStart: +newStart,
      newLines: toNumOfLines(newNumLines)
     }, currentFileChanges = {
      oldLines: toNumOfLines(oldNumLines),
      newLines: toNumOfLines(newNumLines)
     }, currentFile.chunks.push(currentChunk);
    } ], [ /^\\ No newline at end of file$/, eof ] ], schemaContent = [ [ /^\\ No newline at end of file$/, eof ], [ /^-/, function(line) {
     currentChunk && (currentChunk.changes.push({
      type: "del",
      del: !0,
      ln: deletedLineCounter++,
      content: line
     }), currentFile.deletions++, currentFileChanges.oldLines--);
    } ], [ /^\+/, function(line) {
     currentChunk && (currentChunk.changes.push({
      type: "add",
      add: !0,
      ln: addedLineCounter++,
      content: line
     }), currentFile.additions++, currentFileChanges.newLines--);
    } ], [ /^\s+/, function(line) {
     var _currentChunk;
     null === (_currentChunk = currentChunk) || void 0 === _currentChunk || _currentChunk.changes.push({
      type: "normal",
      normal: !0,
      ln1: deletedLineCounter++,
      ln2: addedLineCounter++,
      content: line
     }), currentFileChanges.oldLines--, currentFileChanges.newLines--;
    } ] ], parseLine = function(line) {
     currentFileChanges ? function(line) {
      for (var _i2 = 0, _schemaContent = schemaContent; _i2 < _schemaContent.length; _i2++) {
       var _schemaContent$_i = _slicedToArray(_schemaContent[_i2], 2), pattern = _schemaContent$_i[0], handler = _schemaContent$_i[1], match = line.match(pattern);
       if (match) {
        handler(line, match);
        break;
       }
      }
      0 === currentFileChanges.oldLines && 0 === currentFileChanges.newLines && (currentFileChanges = null);
     }(line) : function(line) {
      for (var _i3 = 0, _schemaHeaders = schemaHeaders; _i3 < _schemaHeaders.length; _i3++) {
       var _schemaHeaders$_i = _slicedToArray(_schemaHeaders[_i3], 2), pattern = _schemaHeaders$_i[0], handler = _schemaHeaders$_i[1], match = line.match(pattern);
       if (match) {
        handler(line, match);
        break;
       }
      }
     }(line);
    }, _iterator = function(o, allowArrayLike) {
     var it = "undefined" != typeof Symbol && o[Symbol.iterator] || o["@@iterator"];
     if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && "number" == typeof o.length) {
       it && (o = it);
       var i = 0, F = function() {};
       return {
        s: F,
        n: function() {
         return i >= o.length ? {
          done: !0
         } : {
          done: !1,
          value: o[i++]
         };
        },
        e: function(_e2) {
         throw _e2;
        },
        f: F
       };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
     }
     var err, normalCompletion = !0, didErr = !1;
     return {
      s: function() {
       it = it.call(o);
      },
      n: function() {
       var step = it.next();
       return normalCompletion = step.done, step;
      },
      e: function(_e3) {
       didErr = !0, err = _e3;
      },
      f: function() {
       try {
        normalCompletion || null == it.return || it.return();
       } finally {
        if (didErr) throw err;
       }
      }
     };
    }(lines);
    try {
     for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      parseLine(_step.value);
     }
    } catch (err) {
     _iterator.e(err);
    } finally {
     _iterator.f();
    }
    return files;
   };
   var fileNameDiffRegex = /(a|i|w|c|o|1|2)\/.*(?=["']? ["']?(b|i|w|c|o|1|2)\/)|(b|i|w|c|o|1|2)\/.*$/g, gitFileHeaderRegex = /^(a|b|i|w|c|o|1|2)\//, parseFiles = function(line) {
    var fileNames = null == line ? void 0 : line.match(fileNameDiffRegex);
    return null == fileNames ? void 0 : fileNames.map((function(fileName) {
     return fileName.replace(gitFileHeaderRegex, "").replace(/("|')$/, "");
    }));
   }, qoutedFileNameRegex = /^\\?['"]|\\?['"]$/g, parseOldOrNewFile = function(line) {
    var fileName = leftTrimChars(line, "-+").trim();
    return (fileName = removeTimeStamp(fileName)).replace(qoutedFileNameRegex, "").replace(gitFileHeaderRegex, "");
   }, leftTrimChars = function(string, trimmingChars) {
    if (string = makeString(string), !trimmingChars && String.prototype.trimLeft) return string.trimLeft();
    var trimmingString = formTrimmingString(trimmingChars);
    return string.replace(new RegExp("^".concat(trimmingString, "+")), "");
   }, timeStampRegex = /\t.*|\d{4}-\d\d-\d\d\s\d\d:\d\d:\d\d(.\d+)?\s(\+|-)\d\d\d\d/, removeTimeStamp = function(string) {
    var timeStamp = timeStampRegex.exec(string);
    return timeStamp && (string = string.substring(0, timeStamp.index).trim()), string;
   }, formTrimmingString = function(trimmingChars) {
    return null == trimmingChars ? "\\s" : trimmingChars instanceof RegExp ? trimmingChars.source : "[".concat(makeString(trimmingChars).replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1"), "]");
   }, makeString = function(itemToConvert) {
    return (null != itemToConvert ? itemToConvert : "") + "";
   };
  },
  1438: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   let Promise = __webpack_require__(93786), path = __webpack_require__(71017), child_process = Promise.promisifyAll(__webpack_require__(32081));
   const PYTHON_BRIDGE_SCRIPT = path.join(__dirname, "node_python_bridge.py");
   function pythonBridge(opts) {
    let intepreter = opts && opts.python || "python", stdio = opts && opts.stdio || [ "pipe", process.stdout, process.stderr ], options = {
     cwd: opts && opts.cwd,
     env: opts && opts.env,
     uid: opts && opts.uid,
     gid: opts && opts.gid,
     stdio: stdio.concat([ "ipc" ]),
     detached: opts && opts.detached
    }, ps = child_process.spawn(intepreter, [ PYTHON_BRIDGE_SCRIPT ], options), queue = singleQueue();
    function sendPythonCommand(type, enqueue, self) {
     function wrapper() {
      self = self || wrapper;
      let code = json.apply(this, arguments);
      return this && this.connected || self.connected ? enqueue((() => new Promise(((resolve, reject) => {
       function onMessage(data) {
        ps.removeListener("close", onClose), data && data.type && "success" === data.type ? resolve(eval(`(${data.value})`)) : data && data.type && "exception" === data.type ? reject(new PythonException(data.value)) : reject(data);
       }
       function onClose(exit_code, message) {
        ps.removeListener("message", onMessage), reject(message ? new Error(`Python process closed with exit code ${exit_code} and message: ${message}`) : new Error(`Python process closed with exit code ${exit_code}`));
       }
       ps.send({
        type,
        code
       }), ps.once("message", onMessage), ps.once("close", onClose);
      })))) : Promise.reject(new PythonBridgeNotConnected);
     }
     return wrapper;
    }
    function setupLock(enqueue) {
     return f => enqueue((() => {
      let lock_queue = singleQueue(), lock_python = sendPythonCommand("evaluate", lock_queue);
      return lock_python.ex = sendPythonCommand("execute", lock_queue, lock_python), lock_python.lock = setupLock(lock_queue), 
      lock_python.connected = !0, lock_python.__proto__ = python, f(lock_python);
     }));
    }
    let python = sendPythonCommand("evaluate", queue);
    return python.ex = sendPythonCommand("execute", queue, python), python.lock = setupLock(queue), 
    python.pid = ps.pid, python.connected = !0, python.Exception = PythonException, 
    python.isException = isPythonException, python.disconnect = () => (python.connected = !1, 
    queue((() => {
     ps.disconnect();
    }))), python.end = python.disconnect, python.kill = signal => {
     python.connected = !1, ps.kill(signal);
    }, python.stdin = ps.stdin, python.stdout = ps.stdout, python.stderr = ps.stderr, 
    python;
   }
   class PythonException extends Error {
    constructor(exc) {
     exc && exc.format ? super(exc.format.join("")) : exc && exc.error ? super(`Python exception: ${exc.error}`) : super("Unknown Python exception"), 
     this.error = exc.error, this.exception = exc.exception, this.traceback = exc.traceback, 
     this.format = exc.format;
    }
   }
   class PythonBridgeNotConnected extends Error {
    constructor() {
     super("Python bridge is no longer connected.");
    }
   }
   function isPythonException(name, exc) {
    const thunk = exc => exc instanceof PythonException && exc.exception && exc.exception.type.name === name;
    return void 0 === exc ? thunk : thunk(exc);
   }
   function singleQueue() {
    let last = Promise.resolve();
    return function(f) {
     let done, wait = last;
     return last = new Promise((resolve => {
      done = resolve;
     })), new Promise(((resolve, reject) => {
      wait.finally((() => {
       Promise.try(f).then(resolve, reject);
      }));
     })).finally((() => done()));
    };
   }
   function dedent(code) {
    let lines = code.split("\n"), offset = null;
    lines[0].trim() || lines.shift();
    for (let line of lines) {
     let trimmed = line.trimLeft();
     if (trimmed) {
      offset = line.length - trimmed.length + 1;
      break;
     }
    }
    if (!offset) return code;
    let match = new RegExp("^" + new Array(offset).join("\\s?"));
    return lines.map((line => line.replace(match, ""))).join("\n");
   }
   function json(text_nodes) {
    let values = Array.prototype.slice.call(arguments, 1);
    return dedent(text_nodes.reduce(((cur, acc, i) => cur + serializePython(values[i - 1]) + acc)));
   }
   function serializePython(value) {
    if (null == value) return "None";
    if (!0 === value) return "True";
    if (!1 === value) return "False";
    if (value === 1 / 0) return "float('inf')";
    if (value === -1 / 0) return "float('-inf')";
    if (value instanceof Array) return `[${value.map(serializePython).join(", ")}]`;
    if ("number" == typeof value) return isNaN(value) ? "float('nan')" : JSON.stringify(value);
    if ("string" == typeof value) return JSON.stringify(value);
    if (value instanceof Map) {
     return `{${Array.from(value.entries()).map((kv => `${serializePython(kv[0])}: ${serializePython(kv[1])}`)).join(", ")}}`;
    }
    return `{${Object.keys(value).map((k => `${serializePython(k)}: ${serializePython(value[k])}`)).join(", ")}}`;
   }
   pythonBridge.pythonBridge = pythonBridge, pythonBridge.PythonException = PythonException, 
   pythonBridge.PythonBridgeNotConnected = PythonBridgeNotConnected, pythonBridge.isPythonException = isPythonException, 
   pythonBridge.json = json, pythonBridge.serializePython = serializePython, module.exports = pythonBridge.pythonBridge = pythonBridge;
  },
  28660: () => {
   var Reflect;
   !function(Reflect) {
    !function(factory) {
     var root = "object" == typeof global ? global : "object" == typeof self ? self : "object" == typeof this ? this : Function("return this;")(), exporter = makeExporter(Reflect);
     function makeExporter(target, previous) {
      return function(key, value) {
       "function" != typeof target[key] && Object.defineProperty(target, key, {
        configurable: !0,
        writable: !0,
        value
       }), previous && previous(key, value);
      };
     }
     void 0 === root.Reflect ? root.Reflect = Reflect : exporter = makeExporter(root.Reflect, exporter), 
     function(exporter) {
      var hasOwn = Object.prototype.hasOwnProperty, supportsSymbol = "function" == typeof Symbol, toPrimitiveSymbol = supportsSymbol && void 0 !== Symbol.toPrimitive ? Symbol.toPrimitive : "@@toPrimitive", iteratorSymbol = supportsSymbol && void 0 !== Symbol.iterator ? Symbol.iterator : "@@iterator", supportsCreate = "function" == typeof Object.create, supportsProto = {
       __proto__: []
      } instanceof Array, downLevel = !supportsCreate && !supportsProto, HashMap = {
       create: supportsCreate ? function() {
        return MakeDictionary(Object.create(null));
       } : supportsProto ? function() {
        return MakeDictionary({
         __proto__: null
        });
       } : function() {
        return MakeDictionary({});
       },
       has: downLevel ? function(map, key) {
        return hasOwn.call(map, key);
       } : function(map, key) {
        return key in map;
       },
       get: downLevel ? function(map, key) {
        return hasOwn.call(map, key) ? map[key] : void 0;
       } : function(map, key) {
        return map[key];
       }
      }, functionPrototype = Object.getPrototypeOf(Function), usePolyfill = "object" == typeof process && process.env && "true" === process.env.REFLECT_METADATA_USE_MAP_POLYFILL, _Map = usePolyfill || "function" != typeof Map || "function" != typeof Map.prototype.entries ? CreateMapPolyfill() : Map, _Set = usePolyfill || "function" != typeof Set || "function" != typeof Set.prototype.entries ? CreateSetPolyfill() : Set, Metadata = new (usePolyfill || "function" != typeof WeakMap ? CreateWeakMapPolyfill() : WeakMap);
      function decorate(decorators, target, propertyKey, attributes) {
       if (IsUndefined(propertyKey)) {
        if (!IsArray(decorators)) throw new TypeError;
        if (!IsConstructor(target)) throw new TypeError;
        return DecorateConstructor(decorators, target);
       }
       if (!IsArray(decorators)) throw new TypeError;
       if (!IsObject(target)) throw new TypeError;
       if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes)) throw new TypeError;
       return IsNull(attributes) && (attributes = void 0), DecorateProperty(decorators, target, propertyKey = ToPropertyKey(propertyKey), attributes);
      }
      function metadata(metadataKey, metadataValue) {
       function decorator(target, propertyKey) {
        if (!IsObject(target)) throw new TypeError;
        if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey)) throw new TypeError;
        OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
       }
       return decorator;
      }
      function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
       if (!IsObject(target)) throw new TypeError;
       return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      function hasMetadata(metadataKey, target, propertyKey) {
       if (!IsObject(target)) throw new TypeError;
       return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasMetadata(metadataKey, target, propertyKey);
      }
      function hasOwnMetadata(metadataKey, target, propertyKey) {
       if (!IsObject(target)) throw new TypeError;
       return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
      }
      function getMetadata(metadataKey, target, propertyKey) {
       if (!IsObject(target)) throw new TypeError;
       return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryGetMetadata(metadataKey, target, propertyKey);
      }
      function getOwnMetadata(metadataKey, target, propertyKey) {
       if (!IsObject(target)) throw new TypeError;
       return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
      }
      function getMetadataKeys(target, propertyKey) {
       if (!IsObject(target)) throw new TypeError;
       return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryMetadataKeys(target, propertyKey);
      }
      function getOwnMetadataKeys(target, propertyKey) {
       if (!IsObject(target)) throw new TypeError;
       return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryOwnMetadataKeys(target, propertyKey);
      }
      function deleteMetadata(metadataKey, target, propertyKey) {
       if (!IsObject(target)) throw new TypeError;
       IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey));
       var metadataMap = GetOrCreateMetadataMap(target, propertyKey, !1);
       if (IsUndefined(metadataMap)) return !1;
       if (!metadataMap.delete(metadataKey)) return !1;
       if (metadataMap.size > 0) return !0;
       var targetMetadata = Metadata.get(target);
       return targetMetadata.delete(propertyKey), targetMetadata.size > 0 || Metadata.delete(target), 
       !0;
      }
      function DecorateConstructor(decorators, target) {
       for (var i = decorators.length - 1; i >= 0; --i) {
        var decorated = (0, decorators[i])(target);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
         if (!IsConstructor(decorated)) throw new TypeError;
         target = decorated;
        }
       }
       return target;
      }
      function DecorateProperty(decorators, target, propertyKey, descriptor) {
       for (var i = decorators.length - 1; i >= 0; --i) {
        var decorated = (0, decorators[i])(target, propertyKey, descriptor);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
         if (!IsObject(decorated)) throw new TypeError;
         descriptor = decorated;
        }
       }
       return descriptor;
      }
      function GetOrCreateMetadataMap(O, P, Create) {
       var targetMetadata = Metadata.get(O);
       if (IsUndefined(targetMetadata)) {
        if (!Create) return;
        targetMetadata = new _Map, Metadata.set(O, targetMetadata);
       }
       var metadataMap = targetMetadata.get(P);
       if (IsUndefined(metadataMap)) {
        if (!Create) return;
        metadataMap = new _Map, targetMetadata.set(P, metadataMap);
       }
       return metadataMap;
      }
      function OrdinaryHasMetadata(MetadataKey, O, P) {
       if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) return !0;
       var parent = OrdinaryGetPrototypeOf(O);
       return !IsNull(parent) && OrdinaryHasMetadata(MetadataKey, parent, P);
      }
      function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
       var metadataMap = GetOrCreateMetadataMap(O, P, !1);
       return !IsUndefined(metadataMap) && ToBoolean(metadataMap.has(MetadataKey));
      }
      function OrdinaryGetMetadata(MetadataKey, O, P) {
       if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) return OrdinaryGetOwnMetadata(MetadataKey, O, P);
       var parent = OrdinaryGetPrototypeOf(O);
       return IsNull(parent) ? void 0 : OrdinaryGetMetadata(MetadataKey, parent, P);
      }
      function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
       var metadataMap = GetOrCreateMetadataMap(O, P, !1);
       if (!IsUndefined(metadataMap)) return metadataMap.get(MetadataKey);
      }
      function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
       GetOrCreateMetadataMap(O, P, !0).set(MetadataKey, MetadataValue);
      }
      function OrdinaryMetadataKeys(O, P) {
       var ownKeys = OrdinaryOwnMetadataKeys(O, P), parent = OrdinaryGetPrototypeOf(O);
       if (null === parent) return ownKeys;
       var parentKeys = OrdinaryMetadataKeys(parent, P);
       if (parentKeys.length <= 0) return ownKeys;
       if (ownKeys.length <= 0) return parentKeys;
       for (var set = new _Set, keys = [], _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
        var key = ownKeys_1[_i];
        set.has(key) || (set.add(key), keys.push(key));
       }
       for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
        key = parentKeys_1[_a];
        set.has(key) || (set.add(key), keys.push(key));
       }
       return keys;
      }
      function OrdinaryOwnMetadataKeys(O, P) {
       var keys = [], metadataMap = GetOrCreateMetadataMap(O, P, !1);
       if (IsUndefined(metadataMap)) return keys;
       for (var iterator = GetIterator(metadataMap.keys()), k = 0; ;) {
        var next = IteratorStep(iterator);
        if (!next) return keys.length = k, keys;
        var nextValue = IteratorValue(next);
        try {
         keys[k] = nextValue;
        } catch (e) {
         try {
          IteratorClose(iterator);
         } finally {
          throw e;
         }
        }
        k++;
       }
      }
      function Type(x) {
       if (null === x) return 1;
       switch (typeof x) {
       case "undefined":
        return 0;

       case "boolean":
        return 2;

       case "string":
        return 3;

       case "symbol":
        return 4;

       case "number":
        return 5;

       case "object":
        return null === x ? 1 : 6;

       default:
        return 6;
       }
      }
      function IsUndefined(x) {
       return void 0 === x;
      }
      function IsNull(x) {
       return null === x;
      }
      function IsSymbol(x) {
       return "symbol" == typeof x;
      }
      function IsObject(x) {
       return "object" == typeof x ? null !== x : "function" == typeof x;
      }
      function ToPrimitive(input, PreferredType) {
       switch (Type(input)) {
       case 0:
       case 1:
       case 2:
       case 3:
       case 4:
       case 5:
        return input;
       }
       var hint = 3 === PreferredType ? "string" : 5 === PreferredType ? "number" : "default", exoticToPrim = GetMethod(input, toPrimitiveSymbol);
       if (void 0 !== exoticToPrim) {
        var result = exoticToPrim.call(input, hint);
        if (IsObject(result)) throw new TypeError;
        return result;
       }
       return OrdinaryToPrimitive(input, "default" === hint ? "number" : hint);
      }
      function OrdinaryToPrimitive(O, hint) {
       if ("string" === hint) {
        var toString_1 = O.toString;
        if (IsCallable(toString_1)) if (!IsObject(result = toString_1.call(O))) return result;
        if (IsCallable(valueOf = O.valueOf)) if (!IsObject(result = valueOf.call(O))) return result;
       } else {
        var valueOf;
        if (IsCallable(valueOf = O.valueOf)) if (!IsObject(result = valueOf.call(O))) return result;
        var result, toString_2 = O.toString;
        if (IsCallable(toString_2)) if (!IsObject(result = toString_2.call(O))) return result;
       }
       throw new TypeError;
      }
      function ToBoolean(argument) {
       return !!argument;
      }
      function ToString(argument) {
       return "" + argument;
      }
      function ToPropertyKey(argument) {
       var key = ToPrimitive(argument, 3);
       return IsSymbol(key) ? key : ToString(key);
      }
      function IsArray(argument) {
       return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : "[object Array]" === Object.prototype.toString.call(argument);
      }
      function IsCallable(argument) {
       return "function" == typeof argument;
      }
      function IsConstructor(argument) {
       return "function" == typeof argument;
      }
      function IsPropertyKey(argument) {
       switch (Type(argument)) {
       case 3:
       case 4:
        return !0;

       default:
        return !1;
       }
      }
      function GetMethod(V, P) {
       var func = V[P];
       if (null != func) {
        if (!IsCallable(func)) throw new TypeError;
        return func;
       }
      }
      function GetIterator(obj) {
       var method = GetMethod(obj, iteratorSymbol);
       if (!IsCallable(method)) throw new TypeError;
       var iterator = method.call(obj);
       if (!IsObject(iterator)) throw new TypeError;
       return iterator;
      }
      function IteratorValue(iterResult) {
       return iterResult.value;
      }
      function IteratorStep(iterator) {
       var result = iterator.next();
       return !result.done && result;
      }
      function IteratorClose(iterator) {
       var f = iterator.return;
       f && f.call(iterator);
      }
      function OrdinaryGetPrototypeOf(O) {
       var proto = Object.getPrototypeOf(O);
       if ("function" != typeof O || O === functionPrototype) return proto;
       if (proto !== functionPrototype) return proto;
       var prototype = O.prototype, prototypeProto = prototype && Object.getPrototypeOf(prototype);
       if (null == prototypeProto || prototypeProto === Object.prototype) return proto;
       var constructor = prototypeProto.constructor;
       return "function" != typeof constructor || constructor === O ? proto : constructor;
      }
      function CreateMapPolyfill() {
       var cacheSentinel = {}, arraySentinel = [], MapIterator = function() {
        function MapIterator(keys, values, selector) {
         this._index = 0, this._keys = keys, this._values = values, this._selector = selector;
        }
        return MapIterator.prototype["@@iterator"] = function() {
         return this;
        }, MapIterator.prototype[iteratorSymbol] = function() {
         return this;
        }, MapIterator.prototype.next = function() {
         var index = this._index;
         if (index >= 0 && index < this._keys.length) {
          var result = this._selector(this._keys[index], this._values[index]);
          return index + 1 >= this._keys.length ? (this._index = -1, this._keys = arraySentinel, 
          this._values = arraySentinel) : this._index++, {
           value: result,
           done: !1
          };
         }
         return {
          value: void 0,
          done: !0
         };
        }, MapIterator.prototype.throw = function(error) {
         throw this._index >= 0 && (this._index = -1, this._keys = arraySentinel, this._values = arraySentinel), 
         error;
        }, MapIterator.prototype.return = function(value) {
         return this._index >= 0 && (this._index = -1, this._keys = arraySentinel, this._values = arraySentinel), 
         {
          value,
          done: !0
         };
        }, MapIterator;
       }();
       return function() {
        function Map() {
         this._keys = [], this._values = [], this._cacheKey = cacheSentinel, this._cacheIndex = -2;
        }
        return Object.defineProperty(Map.prototype, "size", {
         get: function() {
          return this._keys.length;
         },
         enumerable: !0,
         configurable: !0
        }), Map.prototype.has = function(key) {
         return this._find(key, !1) >= 0;
        }, Map.prototype.get = function(key) {
         var index = this._find(key, !1);
         return index >= 0 ? this._values[index] : void 0;
        }, Map.prototype.set = function(key, value) {
         var index = this._find(key, !0);
         return this._values[index] = value, this;
        }, Map.prototype.delete = function(key) {
         var index = this._find(key, !1);
         if (index >= 0) {
          for (var size = this._keys.length, i = index + 1; i < size; i++) this._keys[i - 1] = this._keys[i], 
          this._values[i - 1] = this._values[i];
          return this._keys.length--, this._values.length--, key === this._cacheKey && (this._cacheKey = cacheSentinel, 
          this._cacheIndex = -2), !0;
         }
         return !1;
        }, Map.prototype.clear = function() {
         this._keys.length = 0, this._values.length = 0, this._cacheKey = cacheSentinel, 
         this._cacheIndex = -2;
        }, Map.prototype.keys = function() {
         return new MapIterator(this._keys, this._values, getKey);
        }, Map.prototype.values = function() {
         return new MapIterator(this._keys, this._values, getValue);
        }, Map.prototype.entries = function() {
         return new MapIterator(this._keys, this._values, getEntry);
        }, Map.prototype["@@iterator"] = function() {
         return this.entries();
        }, Map.prototype[iteratorSymbol] = function() {
         return this.entries();
        }, Map.prototype._find = function(key, insert) {
         return this._cacheKey !== key && (this._cacheIndex = this._keys.indexOf(this._cacheKey = key)), 
         this._cacheIndex < 0 && insert && (this._cacheIndex = this._keys.length, this._keys.push(key), 
         this._values.push(void 0)), this._cacheIndex;
        }, Map;
       }();
       function getKey(key, _) {
        return key;
       }
       function getValue(_, value) {
        return value;
       }
       function getEntry(key, value) {
        return [ key, value ];
       }
      }
      function CreateSetPolyfill() {
       return function() {
        function Set() {
         this._map = new _Map;
        }
        return Object.defineProperty(Set.prototype, "size", {
         get: function() {
          return this._map.size;
         },
         enumerable: !0,
         configurable: !0
        }), Set.prototype.has = function(value) {
         return this._map.has(value);
        }, Set.prototype.add = function(value) {
         return this._map.set(value, value), this;
        }, Set.prototype.delete = function(value) {
         return this._map.delete(value);
        }, Set.prototype.clear = function() {
         this._map.clear();
        }, Set.prototype.keys = function() {
         return this._map.keys();
        }, Set.prototype.values = function() {
         return this._map.values();
        }, Set.prototype.entries = function() {
         return this._map.entries();
        }, Set.prototype["@@iterator"] = function() {
         return this.keys();
        }, Set.prototype[iteratorSymbol] = function() {
         return this.keys();
        }, Set;
       }();
      }
      function CreateWeakMapPolyfill() {
       var UUID_SIZE = 16, keys = HashMap.create(), rootKey = CreateUniqueKey();
       return function() {
        function WeakMap() {
         this._key = CreateUniqueKey();
        }
        return WeakMap.prototype.has = function(target) {
         var table = GetOrCreateWeakMapTable(target, !1);
         return void 0 !== table && HashMap.has(table, this._key);
        }, WeakMap.prototype.get = function(target) {
         var table = GetOrCreateWeakMapTable(target, !1);
         return void 0 !== table ? HashMap.get(table, this._key) : void 0;
        }, WeakMap.prototype.set = function(target, value) {
         return GetOrCreateWeakMapTable(target, !0)[this._key] = value, this;
        }, WeakMap.prototype.delete = function(target) {
         var table = GetOrCreateWeakMapTable(target, !1);
         return void 0 !== table && delete table[this._key];
        }, WeakMap.prototype.clear = function() {
         this._key = CreateUniqueKey();
        }, WeakMap;
       }();
       function CreateUniqueKey() {
        var key;
        do {
         key = "@@WeakMap@@" + CreateUUID();
        } while (HashMap.has(keys, key));
        return keys[key] = !0, key;
       }
       function GetOrCreateWeakMapTable(target, create) {
        if (!hasOwn.call(target, rootKey)) {
         if (!create) return;
         Object.defineProperty(target, rootKey, {
          value: HashMap.create()
         });
        }
        return target[rootKey];
       }
       function FillRandomBytes(buffer, size) {
        for (var i = 0; i < size; ++i) buffer[i] = 255 * Math.random() | 0;
        return buffer;
       }
       function GenRandomBytes(size) {
        return "function" == typeof Uint8Array ? "undefined" != typeof crypto ? crypto.getRandomValues(new Uint8Array(size)) : "undefined" != typeof msCrypto ? msCrypto.getRandomValues(new Uint8Array(size)) : FillRandomBytes(new Uint8Array(size), size) : FillRandomBytes(new Array(size), size);
       }
       function CreateUUID() {
        var data = GenRandomBytes(UUID_SIZE);
        data[6] = 79 & data[6] | 64, data[8] = 191 & data[8] | 128;
        for (var result = "", offset = 0; offset < UUID_SIZE; ++offset) {
         var byte = data[offset];
         4 !== offset && 6 !== offset && 8 !== offset || (result += "-"), byte < 16 && (result += "0"), 
         result += byte.toString(16).toLowerCase();
        }
        return result;
       }
      }
      function MakeDictionary(obj) {
       return obj.__ = void 0, delete obj.__, obj;
      }
      exporter("decorate", decorate), exporter("metadata", metadata), exporter("defineMetadata", defineMetadata), 
      exporter("hasMetadata", hasMetadata), exporter("hasOwnMetadata", hasOwnMetadata), 
      exporter("getMetadata", getMetadata), exporter("getOwnMetadata", getOwnMetadata), 
      exporter("getMetadataKeys", getMetadataKeys), exporter("getOwnMetadataKeys", getOwnMetadataKeys), 
      exporter("deleteMetadata", deleteMetadata);
     }(exporter);
    }();
   }(Reflect || (Reflect = {}));
  },
  22257: (module, __unused_webpack_exports, __webpack_require__) => {
   const ANY = Symbol("SemVer ANY");
   class Comparator {
    static get ANY() {
     return ANY;
    }
    constructor(comp, options) {
     if (options = parseOptions(options), comp instanceof Comparator) {
      if (comp.loose === !!options.loose) return comp;
      comp = comp.value;
     }
     comp = comp.trim().split(/\s+/).join(" "), debug("comparator", comp, options), this.options = options, 
     this.loose = !!options.loose, this.parse(comp), this.semver === ANY ? this.value = "" : this.value = this.operator + this.semver.version, 
     debug("comp", this);
    }
    parse(comp) {
     const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR], m = comp.match(r);
     if (!m) throw new TypeError(`Invalid comparator: ${comp}`);
     this.operator = void 0 !== m[1] ? m[1] : "", "=" === this.operator && (this.operator = ""), 
     m[2] ? this.semver = new SemVer(m[2], this.options.loose) : this.semver = ANY;
    }
    toString() {
     return this.value;
    }
    test(version) {
     if (debug("Comparator.test", version, this.options.loose), this.semver === ANY || version === ANY) return !0;
     if ("string" == typeof version) try {
      version = new SemVer(version, this.options);
     } catch (er) {
      return !1;
     }
     return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
     if (!(comp instanceof Comparator)) throw new TypeError("a Comparator is required");
     return "" === this.operator ? "" === this.value || new Range(comp.value, options).test(this.value) : "" === comp.operator ? "" === comp.value || new Range(this.value, options).test(comp.semver) : (!(options = parseOptions(options)).includePrerelease || "<0.0.0-0" !== this.value && "<0.0.0-0" !== comp.value) && (!(!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) && (!(!this.operator.startsWith(">") || !comp.operator.startsWith(">")) || (!(!this.operator.startsWith("<") || !comp.operator.startsWith("<")) || (!(this.semver.version !== comp.semver.version || !this.operator.includes("=") || !comp.operator.includes("=")) || (!!(cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) || !!(cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")))))));
    }
   }
   module.exports = Comparator;
   const parseOptions = __webpack_require__(12893), {safeRe: re, t} = __webpack_require__(55765), cmp = __webpack_require__(7539), debug = __webpack_require__(74225), SemVer = __webpack_require__(26376), Range = __webpack_require__(66902);
  },
  66902: (module, __unused_webpack_exports, __webpack_require__) => {
   class Range {
    constructor(range, options) {
     if (options = parseOptions(options), range instanceof Range) return range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease ? range : new Range(range.raw, options);
     if (range instanceof Comparator) return this.raw = range.value, this.set = [ [ range ] ], 
     this.format(), this;
     if (this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease, 
     this.raw = range.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((r => this.parseRange(r.trim()))).filter((c => c.length)), 
     !this.set.length) throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
     if (this.set.length > 1) {
      const first = this.set[0];
      if (this.set = this.set.filter((c => !isNullSet(c[0]))), 0 === this.set.length) this.set = [ first ]; else if (this.set.length > 1) for (const c of this.set) if (1 === c.length && isAny(c[0])) {
       this.set = [ c ];
       break;
      }
     }
     this.format();
    }
    format() {
     return this.range = this.set.map((comps => comps.join(" ").trim())).join("||").trim(), 
     this.range;
    }
    toString() {
     return this.range;
    }
    parseRange(range) {
     const memoKey = ((this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE)) + ":" + range, cached = cache.get(memoKey);
     if (cached) return cached;
     const loose = this.options.loose, hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
     range = range.replace(hr, hyphenReplace(this.options.includePrerelease)), debug("hyphen replace", range), 
     range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace), debug("comparator trim", range), 
     range = range.replace(re[t.TILDETRIM], tildeTrimReplace), debug("tilde trim", range), 
     range = range.replace(re[t.CARETTRIM], caretTrimReplace), debug("caret trim", range);
     let rangeList = range.split(" ").map((comp => parseComparator(comp, this.options))).join(" ").split(/\s+/).map((comp => replaceGTE0(comp, this.options)));
     loose && (rangeList = rangeList.filter((comp => (debug("loose invalid filter", comp, this.options), 
     !!comp.match(re[t.COMPARATORLOOSE]))))), debug("range list", rangeList);
     const rangeMap = new Map, comparators = rangeList.map((comp => new Comparator(comp, this.options)));
     for (const comp of comparators) {
      if (isNullSet(comp)) return [ comp ];
      rangeMap.set(comp.value, comp);
     }
     rangeMap.size > 1 && rangeMap.has("") && rangeMap.delete("");
     const result = [ ...rangeMap.values() ];
     return cache.set(memoKey, result), result;
    }
    intersects(range, options) {
     if (!(range instanceof Range)) throw new TypeError("a Range is required");
     return this.set.some((thisComparators => isSatisfiable(thisComparators, options) && range.set.some((rangeComparators => isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator => rangeComparators.every((rangeComparator => thisComparator.intersects(rangeComparator, options)))))))));
    }
    test(version) {
     if (!version) return !1;
     if ("string" == typeof version) try {
      version = new SemVer(version, this.options);
     } catch (er) {
      return !1;
     }
     for (let i = 0; i < this.set.length; i++) if (testSet(this.set[i], version, this.options)) return !0;
     return !1;
    }
   }
   module.exports = Range;
   const cache = new (__webpack_require__(39593))({
    max: 1e3
   }), parseOptions = __webpack_require__(12893), Comparator = __webpack_require__(22257), debug = __webpack_require__(74225), SemVer = __webpack_require__(26376), {safeRe: re, t, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace} = __webpack_require__(55765), {FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE} = __webpack_require__(83295), isNullSet = c => "<0.0.0-0" === c.value, isAny = c => "" === c.value, isSatisfiable = (comparators, options) => {
    let result = !0;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    for (;result && remainingComparators.length; ) result = remainingComparators.every((otherComparator => testComparator.intersects(otherComparator, options))), 
    testComparator = remainingComparators.pop();
    return result;
   }, parseComparator = (comp, options) => (debug("comp", comp, options), comp = replaceCarets(comp, options), 
   debug("caret", comp), comp = replaceTildes(comp, options), debug("tildes", comp), 
   comp = replaceXRanges(comp, options), debug("xrange", comp), comp = replaceStars(comp, options), 
   debug("stars", comp), comp), isX = id => !id || "x" === id.toLowerCase() || "*" === id, replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((c => replaceTilde(c, options))).join(" "), replaceTilde = (comp, options) => {
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, ((_, M, m, p, pr) => {
     let ret;
     return debug("tilde", comp, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = `>=${M}.0.0 <${+M + 1}.0.0-0` : isX(p) ? ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0` : pr ? (debug("replaceTilde pr", pr), 
     ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`) : ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`, 
     debug("tilde return", ret), ret;
    }));
   }, replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((c => replaceCaret(c, options))).join(" "), replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET], z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, ((_, M, m, p, pr) => {
     let ret;
     return debug("caret", comp, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0` : isX(p) ? ret = "0" === M ? `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.0${z} <${+M + 1}.0.0-0` : pr ? (debug("replaceCaret pr", pr), 
     ret = "0" === M ? "0" === m ? `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0` : `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`) : (debug("no pr"), 
     ret = "0" === M ? "0" === m ? `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0` : `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.${p} <${+M + 1}.0.0-0`), 
     debug("caret return", ret), ret;
    }));
   }, replaceXRanges = (comp, options) => (debug("replaceXRanges", comp, options), 
   comp.split(/\s+/).map((c => replaceXRange(c, options))).join(" ")), replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, ((ret, gtlt, M, m, p, pr) => {
     debug("xRange", comp, ret, gtlt, M, m, p, pr);
     const xM = isX(M), xm = xM || isX(m), xp = xm || isX(p), anyX = xp;
     return "=" === gtlt && anyX && (gtlt = ""), pr = options.includePrerelease ? "-0" : "", 
     xM ? ret = ">" === gtlt || "<" === gtlt ? "<0.0.0-0" : "*" : gtlt && anyX ? (xm && (m = 0), 
     p = 0, ">" === gtlt ? (gtlt = ">=", xm ? (M = +M + 1, m = 0, p = 0) : (m = +m + 1, 
     p = 0)) : "<=" === gtlt && (gtlt = "<", xm ? M = +M + 1 : m = +m + 1), "<" === gtlt && (pr = "-0"), 
     ret = `${gtlt + M}.${m}.${p}${pr}`) : xm ? ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0` : xp && (ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`), 
     debug("xRange return", ret), ret;
    }));
   }, replaceStars = (comp, options) => (debug("replaceStars", comp, options), comp.trim().replace(re[t.STAR], "")), replaceGTE0 = (comp, options) => (debug("replaceGTE0", comp, options), 
   comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "")), hyphenReplace = incPr => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => `${from = isX(fM) ? "" : isX(fm) ? `>=${fM}.0.0${incPr ? "-0" : ""}` : isX(fp) ? `>=${fM}.${fm}.0${incPr ? "-0" : ""}` : fpr ? `>=${from}` : `>=${from}${incPr ? "-0" : ""}`} ${to = isX(tM) ? "" : isX(tm) ? `<${+tM + 1}.0.0-0` : isX(tp) ? `<${tM}.${+tm + 1}.0-0` : tpr ? `<=${tM}.${tm}.${tp}-${tpr}` : incPr ? `<${tM}.${tm}.${+tp + 1}-0` : `<=${to}`}`.trim(), testSet = (set, version, options) => {
    for (let i = 0; i < set.length; i++) if (!set[i].test(version)) return !1;
    if (version.prerelease.length && !options.includePrerelease) {
     for (let i = 0; i < set.length; i++) if (debug(set[i].semver), set[i].semver !== Comparator.ANY && set[i].semver.prerelease.length > 0) {
      const allowed = set[i].semver;
      if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return !0;
     }
     return !1;
    }
    return !0;
   };
  },
  26376: (module, __unused_webpack_exports, __webpack_require__) => {
   const debug = __webpack_require__(74225), {MAX_LENGTH, MAX_SAFE_INTEGER} = __webpack_require__(83295), {safeRe: re, t} = __webpack_require__(55765), parseOptions = __webpack_require__(12893), {compareIdentifiers} = __webpack_require__(86742);
   class SemVer {
    constructor(version, options) {
     if (options = parseOptions(options), version instanceof SemVer) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) return version;
      version = version.version;
     } else if ("string" != typeof version) throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
     if (version.length > MAX_LENGTH) throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
     debug("SemVer", version, options), this.options = options, this.loose = !!options.loose, 
     this.includePrerelease = !!options.includePrerelease;
     const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
     if (!m) throw new TypeError(`Invalid Version: ${version}`);
     if (this.raw = version, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], 
     this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
     if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
     if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
     m[4] ? this.prerelease = m[4].split(".").map((id => {
      if (/^[0-9]+$/.test(id)) {
       const num = +id;
       if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
      }
      return id;
     })) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
    }
    format() {
     return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), 
     this.version;
    }
    toString() {
     return this.version;
    }
    compare(other) {
     if (debug("SemVer.compare", this.version, this.options, other), !(other instanceof SemVer)) {
      if ("string" == typeof other && other === this.version) return 0;
      other = new SemVer(other, this.options);
     }
     return other.version === this.version ? 0 : this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
     return other instanceof SemVer || (other = new SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
     if (other instanceof SemVer || (other = new SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length) return -1;
     if (!this.prerelease.length && other.prerelease.length) return 1;
     if (!this.prerelease.length && !other.prerelease.length) return 0;
     let i = 0;
     do {
      const a = this.prerelease[i], b = other.prerelease[i];
      if (debug("prerelease compare", i, a, b), void 0 === a && void 0 === b) return 0;
      if (void 0 === b) return 1;
      if (void 0 === a) return -1;
      if (a !== b) return compareIdentifiers(a, b);
     } while (++i);
    }
    compareBuild(other) {
     other instanceof SemVer || (other = new SemVer(other, this.options));
     let i = 0;
     do {
      const a = this.build[i], b = other.build[i];
      if (debug("prerelease compare", i, a, b), void 0 === a && void 0 === b) return 0;
      if (void 0 === b) return 1;
      if (void 0 === a) return -1;
      if (a !== b) return compareIdentifiers(a, b);
     } while (++i);
    }
    inc(release, identifier, identifierBase) {
     switch (release) {
     case "premajor":
      this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier, identifierBase);
      break;

     case "preminor":
      this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier, identifierBase);
      break;

     case "prepatch":
      this.prerelease.length = 0, this.inc("patch", identifier, identifierBase), this.inc("pre", identifier, identifierBase);
      break;

     case "prerelease":
      0 === this.prerelease.length && this.inc("patch", identifier, identifierBase), this.inc("pre", identifier, identifierBase);
      break;

     case "major":
      0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, 
      this.minor = 0, this.patch = 0, this.prerelease = [];
      break;

     case "minor":
      0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, 
      this.prerelease = [];
      break;

     case "patch":
      0 === this.prerelease.length && this.patch++, this.prerelease = [];
      break;

     case "pre":
      {
       const base = Number(identifierBase) ? 1 : 0;
       if (!identifier && !1 === identifierBase) throw new Error("invalid increment argument: identifier is empty");
       if (0 === this.prerelease.length) this.prerelease = [ base ]; else {
        let i = this.prerelease.length;
        for (;--i >= 0; ) "number" == typeof this.prerelease[i] && (this.prerelease[i]++, 
        i = -2);
        if (-1 === i) {
         if (identifier === this.prerelease.join(".") && !1 === identifierBase) throw new Error("invalid increment argument: identifier already exists");
         this.prerelease.push(base);
        }
       }
       if (identifier) {
        let prerelease = [ identifier, base ];
        !1 === identifierBase && (prerelease = [ identifier ]), 0 === compareIdentifiers(this.prerelease[0], identifier) ? isNaN(this.prerelease[1]) && (this.prerelease = prerelease) : this.prerelease = prerelease;
       }
       break;
      }

     default:
      throw new Error(`invalid increment argument: ${release}`);
     }
     return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), 
     this;
    }
   }
   module.exports = SemVer;
  },
  13507: (module, __unused_webpack_exports, __webpack_require__) => {
   const parse = __webpack_require__(33959);
   module.exports = (version, options) => {
    const s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
   };
  },
  7539: (module, __unused_webpack_exports, __webpack_require__) => {
   const eq = __webpack_require__(58718), neq = __webpack_require__(81194), gt = __webpack_require__(71312), gte = __webpack_require__(25903), lt = __webpack_require__(21544), lte = __webpack_require__(12056);
   module.exports = (a, op, b, loose) => {
    switch (op) {
    case "===":
     return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), 
     a === b;

    case "!==":
     return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), 
     a !== b;

    case "":
    case "=":
    case "==":
     return eq(a, b, loose);

    case "!=":
     return neq(a, b, loose);

    case ">":
     return gt(a, b, loose);

    case ">=":
     return gte(a, b, loose);

    case "<":
     return lt(a, b, loose);

    case "<=":
     return lte(a, b, loose);

    default:
     throw new TypeError(`Invalid operator: ${op}`);
    }
   };
  },
  99038: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(26376), parse = __webpack_require__(33959), {safeRe: re, t} = __webpack_require__(55765);
   module.exports = (version, options) => {
    if (version instanceof SemVer) return version;
    if ("number" == typeof version && (version = String(version)), "string" != typeof version) return null;
    let match = null;
    if ((options = options || {}).rtl) {
     let next;
     for (;(next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length); ) match && next.index + next[0].length === match.index + match[0].length || (match = next), 
     re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
     re[t.COERCERTL].lastIndex = -1;
    } else match = version.match(re[t.COERCE]);
    return null === match ? null : parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
   };
  },
  88880: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(26376);
   module.exports = (a, b, loose) => {
    const versionA = new SemVer(a, loose), versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
   };
  },
  27880: (module, __unused_webpack_exports, __webpack_require__) => {
   const compare = __webpack_require__(46269);
   module.exports = (a, b) => compare(a, b, !0);
  },
  46269: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(26376);
   module.exports = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  },
  62378: (module, __unused_webpack_exports, __webpack_require__) => {
   const parse = __webpack_require__(33959);
   module.exports = (version1, version2) => {
    const v1 = parse(version1, null, !0), v2 = parse(version2, null, !0), comparison = v1.compare(v2);
    if (0 === comparison) return null;
    const v1Higher = comparison > 0, highVersion = v1Higher ? v1 : v2, lowVersion = v1Higher ? v2 : v1, highHasPre = !!highVersion.prerelease.length;
    if (!!lowVersion.prerelease.length && !highHasPre) return lowVersion.patch || lowVersion.minor ? highVersion.patch ? "patch" : highVersion.minor ? "minor" : "major" : "major";
    const prefix = highHasPre ? "pre" : "";
    return v1.major !== v2.major ? prefix + "major" : v1.minor !== v2.minor ? prefix + "minor" : v1.patch !== v2.patch ? prefix + "patch" : "prerelease";
   };
  },
  58718: (module, __unused_webpack_exports, __webpack_require__) => {
   const compare = __webpack_require__(46269);
   module.exports = (a, b, loose) => 0 === compare(a, b, loose);
  },
  71312: (module, __unused_webpack_exports, __webpack_require__) => {
   const compare = __webpack_require__(46269);
   module.exports = (a, b, loose) => compare(a, b, loose) > 0;
  },
  25903: (module, __unused_webpack_exports, __webpack_require__) => {
   const compare = __webpack_require__(46269);
   module.exports = (a, b, loose) => compare(a, b, loose) >= 0;
  },
  20253: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(26376);
   module.exports = (version, release, options, identifier, identifierBase) => {
    "string" == typeof options && (identifierBase = identifier, identifier = options, 
    options = void 0);
    try {
     return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
     return null;
    }
   };
  },
  21544: (module, __unused_webpack_exports, __webpack_require__) => {
   const compare = __webpack_require__(46269);
   module.exports = (a, b, loose) => compare(a, b, loose) < 0;
  },
  12056: (module, __unused_webpack_exports, __webpack_require__) => {
   const compare = __webpack_require__(46269);
   module.exports = (a, b, loose) => compare(a, b, loose) <= 0;
  },
  38679: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(26376);
   module.exports = (a, loose) => new SemVer(a, loose).major;
  },
  87789: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(26376);
   module.exports = (a, loose) => new SemVer(a, loose).minor;
  },
  81194: (module, __unused_webpack_exports, __webpack_require__) => {
   const compare = __webpack_require__(46269);
   module.exports = (a, b, loose) => 0 !== compare(a, b, loose);
  },
  33959: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(26376);
   module.exports = (version, options, throwErrors = !1) => {
    if (version instanceof SemVer) return version;
    try {
     return new SemVer(version, options);
    } catch (er) {
     if (!throwErrors) return null;
     throw er;
    }
   };
  },
  52358: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(26376);
   module.exports = (a, loose) => new SemVer(a, loose).patch;
  },
  57559: (module, __unused_webpack_exports, __webpack_require__) => {
   const parse = __webpack_require__(33959);
   module.exports = (version, options) => {
    const parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
   };
  },
  79795: (module, __unused_webpack_exports, __webpack_require__) => {
   const compare = __webpack_require__(46269);
   module.exports = (a, b, loose) => compare(b, a, loose);
  },
  63657: (module, __unused_webpack_exports, __webpack_require__) => {
   const compareBuild = __webpack_require__(88880);
   module.exports = (list, loose) => list.sort(((a, b) => compareBuild(b, a, loose)));
  },
  45712: (module, __unused_webpack_exports, __webpack_require__) => {
   const Range = __webpack_require__(66902);
   module.exports = (version, range, options) => {
    try {
     range = new Range(range, options);
    } catch (er) {
     return !1;
    }
    return range.test(version);
   };
  },
  21100: (module, __unused_webpack_exports, __webpack_require__) => {
   const compareBuild = __webpack_require__(88880);
   module.exports = (list, loose) => list.sort(((a, b) => compareBuild(a, b, loose)));
  },
  76397: (module, __unused_webpack_exports, __webpack_require__) => {
   const parse = __webpack_require__(33959);
   module.exports = (version, options) => {
    const v = parse(version, options);
    return v ? v.version : null;
   };
  },
  81249: (module, __unused_webpack_exports, __webpack_require__) => {
   const internalRe = __webpack_require__(55765), constants = __webpack_require__(83295), SemVer = __webpack_require__(26376), identifiers = __webpack_require__(86742), parse = __webpack_require__(33959), valid = __webpack_require__(76397), clean = __webpack_require__(13507), inc = __webpack_require__(20253), diff = __webpack_require__(62378), major = __webpack_require__(38679), minor = __webpack_require__(87789), patch = __webpack_require__(52358), prerelease = __webpack_require__(57559), compare = __webpack_require__(46269), rcompare = __webpack_require__(79795), compareLoose = __webpack_require__(27880), compareBuild = __webpack_require__(88880), sort = __webpack_require__(21100), rsort = __webpack_require__(63657), gt = __webpack_require__(71312), lt = __webpack_require__(21544), eq = __webpack_require__(58718), neq = __webpack_require__(81194), gte = __webpack_require__(25903), lte = __webpack_require__(12056), cmp = __webpack_require__(7539), coerce = __webpack_require__(99038), Comparator = __webpack_require__(22257), Range = __webpack_require__(66902), satisfies = __webpack_require__(45712), toComparators = __webpack_require__(51042), maxSatisfying = __webpack_require__(85775), minSatisfying = __webpack_require__(71657), minVersion = __webpack_require__(95316), validRange = __webpack_require__(89042), outside = __webpack_require__(6826), gtr = __webpack_require__(97606), ltr = __webpack_require__(50032), intersects = __webpack_require__(82937), simplifyRange = __webpack_require__(17908), subset = __webpack_require__(50799);
   module.exports = {
    parse,
    valid,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
   };
  },
  83295: module => {
   const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
   module.exports = {
    MAX_LENGTH: 256,
    MAX_SAFE_COMPONENT_LENGTH: 16,
    MAX_SAFE_BUILD_LENGTH: 250,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES: [ "major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease" ],
    SEMVER_SPEC_VERSION: "2.0.0",
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
   };
  },
  74225: module => {
   const debug = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {};
   module.exports = debug;
  },
  86742: module => {
   const numeric = /^[0-9]+$/, compareIdentifiers = (a, b) => {
    const anum = numeric.test(a), bnum = numeric.test(b);
    return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
   };
   module.exports = {
    compareIdentifiers,
    rcompareIdentifiers: (a, b) => compareIdentifiers(b, a)
   };
  },
  12893: module => {
   const looseOption = Object.freeze({
    loose: !0
   }), emptyOpts = Object.freeze({});
   module.exports = options => options ? "object" != typeof options ? looseOption : options : emptyOpts;
  },
  55765: (module, exports, __webpack_require__) => {
   const {MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH} = __webpack_require__(83295), debug = __webpack_require__(74225), re = (exports = module.exports = {}).re = [], safeRe = exports.safeRe = [], src = exports.src = [], t = exports.t = {};
   let R = 0;
   const safeRegexReplacements = [ [ "\\s", 1 ], [ "\\d", MAX_LENGTH ], [ "[a-zA-Z0-9-]", MAX_SAFE_BUILD_LENGTH ] ], createToken = (name, value, isGlobal) => {
    const safe = (value => {
     for (const [token, max] of safeRegexReplacements) value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
     return value;
    })(value), index = R++;
    debug(name, index, value), t[name] = index, src[index] = value, re[index] = new RegExp(value, isGlobal ? "g" : void 0), 
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
   };
   createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*"), createToken("NUMERICIDENTIFIERLOOSE", "\\d+"), 
   createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`), 
   createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`), 
   createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`), 
   createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`), 
   createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`), 
   createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`), 
   createToken("BUILDIDENTIFIER", "[a-zA-Z0-9-]+"), createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`), 
   createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`), 
   createToken("FULL", `^${src[t.FULLPLAIN]}$`), createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`), 
   createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`), createToken("GTLT", "((?:<|>)?=?)"), 
   createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), 
   createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`), createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`), 
   createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`), 
   createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`), createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`), 
   createToken("COERCE", `(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`), 
   createToken("COERCERTL", src[t.COERCE], !0), createToken("LONETILDE", "(?:~>?)"), 
   createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, !0), exports.tildeTrimReplace = "$1~", 
   createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`), createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`), 
   createToken("LONECARET", "(?:\\^)"), createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, !0), 
   exports.caretTrimReplace = "$1^", createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`), 
   createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`), createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`), 
   createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`), createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, !0), 
   exports.comparatorTrimReplace = "$1$2$3", createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`), 
   createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`), 
   createToken("STAR", "(<|>)?=?\\s*\\*"), createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), 
   createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  },
  97606: (module, __unused_webpack_exports, __webpack_require__) => {
   const outside = __webpack_require__(6826);
   module.exports = (version, range, options) => outside(version, range, ">", options);
  },
  82937: (module, __unused_webpack_exports, __webpack_require__) => {
   const Range = __webpack_require__(66902);
   module.exports = (r1, r2, options) => (r1 = new Range(r1, options), r2 = new Range(r2, options), 
   r1.intersects(r2, options));
  },
  50032: (module, __unused_webpack_exports, __webpack_require__) => {
   const outside = __webpack_require__(6826);
   module.exports = (version, range, options) => outside(version, range, "<", options);
  },
  85775: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(26376), Range = __webpack_require__(66902);
   module.exports = (versions, range, options) => {
    let max = null, maxSV = null, rangeObj = null;
    try {
     rangeObj = new Range(range, options);
    } catch (er) {
     return null;
    }
    return versions.forEach((v => {
     rangeObj.test(v) && (max && -1 !== maxSV.compare(v) || (max = v, maxSV = new SemVer(max, options)));
    })), max;
   };
  },
  71657: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(26376), Range = __webpack_require__(66902);
   module.exports = (versions, range, options) => {
    let min = null, minSV = null, rangeObj = null;
    try {
     rangeObj = new Range(range, options);
    } catch (er) {
     return null;
    }
    return versions.forEach((v => {
     rangeObj.test(v) && (min && 1 !== minSV.compare(v) || (min = v, minSV = new SemVer(min, options)));
    })), min;
   };
  },
  95316: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(26376), Range = __webpack_require__(66902), gt = __webpack_require__(71312);
   module.exports = (range, loose) => {
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) return minver;
    if (minver = new SemVer("0.0.0-0"), range.test(minver)) return minver;
    minver = null;
    for (let i = 0; i < range.set.length; ++i) {
     const comparators = range.set[i];
     let setMin = null;
     comparators.forEach((comparator => {
      const compver = new SemVer(comparator.semver.version);
      switch (comparator.operator) {
      case ">":
       0 === compver.prerelease.length ? compver.patch++ : compver.prerelease.push(0), 
       compver.raw = compver.format();

      case "":
      case ">=":
       setMin && !gt(compver, setMin) || (setMin = compver);
       break;

      case "<":
      case "<=":
       break;

      default:
       throw new Error(`Unexpected operation: ${comparator.operator}`);
      }
     })), !setMin || minver && !gt(minver, setMin) || (minver = setMin);
    }
    return minver && range.test(minver) ? minver : null;
   };
  },
  6826: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(26376), Comparator = __webpack_require__(22257), {ANY} = Comparator, Range = __webpack_require__(66902), satisfies = __webpack_require__(45712), gt = __webpack_require__(71312), lt = __webpack_require__(21544), lte = __webpack_require__(12056), gte = __webpack_require__(25903);
   module.exports = (version, range, hilo, options) => {
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (version = new SemVer(version, options), range = new Range(range, options), 
    hilo) {
    case ">":
     gtfn = gt, ltefn = lte, ltfn = lt, comp = ">", ecomp = ">=";
     break;

    case "<":
     gtfn = lt, ltefn = gte, ltfn = gt, comp = "<", ecomp = "<=";
     break;

    default:
     throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) return !1;
    for (let i = 0; i < range.set.length; ++i) {
     const comparators = range.set[i];
     let high = null, low = null;
     if (comparators.forEach((comparator => {
      comparator.semver === ANY && (comparator = new Comparator(">=0.0.0")), high = high || comparator, 
      low = low || comparator, gtfn(comparator.semver, high.semver, options) ? high = comparator : ltfn(comparator.semver, low.semver, options) && (low = comparator);
     })), high.operator === comp || high.operator === ecomp) return !1;
     if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) return !1;
     if (low.operator === ecomp && ltfn(version, low.semver)) return !1;
    }
    return !0;
   };
  },
  17908: (module, __unused_webpack_exports, __webpack_require__) => {
   const satisfies = __webpack_require__(45712), compare = __webpack_require__(46269);
   module.exports = (versions, range, options) => {
    const set = [];
    let first = null, prev = null;
    const v = versions.sort(((a, b) => compare(a, b, options)));
    for (const version of v) {
     satisfies(version, range, options) ? (prev = version, first || (first = version)) : (prev && set.push([ first, prev ]), 
     prev = null, first = null);
    }
    first && set.push([ first, null ]);
    const ranges = [];
    for (const [min, max] of set) min === max ? ranges.push(min) : max || min !== v[0] ? max ? min === v[0] ? ranges.push(`<=${max}`) : ranges.push(`${min} - ${max}`) : ranges.push(`>=${min}`) : ranges.push("*");
    const simplified = ranges.join(" || "), original = "string" == typeof range.raw ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
   };
  },
  50799: (module, __unused_webpack_exports, __webpack_require__) => {
   const Range = __webpack_require__(66902), Comparator = __webpack_require__(22257), {ANY} = Comparator, satisfies = __webpack_require__(45712), compare = __webpack_require__(46269), minimumVersionWithPreRelease = [ new Comparator(">=0.0.0-0") ], minimumVersion = [ new Comparator(">=0.0.0") ], simpleSubset = (sub, dom, options) => {
    if (sub === dom) return !0;
    if (1 === sub.length && sub[0].semver === ANY) {
     if (1 === dom.length && dom[0].semver === ANY) return !0;
     sub = options.includePrerelease ? minimumVersionWithPreRelease : minimumVersion;
    }
    if (1 === dom.length && dom[0].semver === ANY) {
     if (options.includePrerelease) return !0;
     dom = minimumVersion;
    }
    const eqSet = new Set;
    let gt, lt, gtltComp, higher, lower, hasDomLT, hasDomGT;
    for (const c of sub) ">" === c.operator || ">=" === c.operator ? gt = higherGT(gt, c, options) : "<" === c.operator || "<=" === c.operator ? lt = lowerLT(lt, c, options) : eqSet.add(c.semver);
    if (eqSet.size > 1) return null;
    if (gt && lt) {
     if (gtltComp = compare(gt.semver, lt.semver, options), gtltComp > 0) return null;
     if (0 === gtltComp && (">=" !== gt.operator || "<=" !== lt.operator)) return null;
    }
    for (const eq of eqSet) {
     if (gt && !satisfies(eq, String(gt), options)) return null;
     if (lt && !satisfies(eq, String(lt), options)) return null;
     for (const c of dom) if (!satisfies(eq, String(c), options)) return !1;
     return !0;
    }
    let needDomLTPre = !(!lt || options.includePrerelease || !lt.semver.prerelease.length) && lt.semver, needDomGTPre = !(!gt || options.includePrerelease || !gt.semver.prerelease.length) && gt.semver;
    needDomLTPre && 1 === needDomLTPre.prerelease.length && "<" === lt.operator && 0 === needDomLTPre.prerelease[0] && (needDomLTPre = !1);
    for (const c of dom) {
     if (hasDomGT = hasDomGT || ">" === c.operator || ">=" === c.operator, hasDomLT = hasDomLT || "<" === c.operator || "<=" === c.operator, 
     gt) if (needDomGTPre && c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch && (needDomGTPre = !1), 
     ">" === c.operator || ">=" === c.operator) {
      if (higher = higherGT(gt, c, options), higher === c && higher !== gt) return !1;
     } else if (">=" === gt.operator && !satisfies(gt.semver, String(c), options)) return !1;
     if (lt) if (needDomLTPre && c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch && (needDomLTPre = !1), 
     "<" === c.operator || "<=" === c.operator) {
      if (lower = lowerLT(lt, c, options), lower === c && lower !== lt) return !1;
     } else if ("<=" === lt.operator && !satisfies(lt.semver, String(c), options)) return !1;
     if (!c.operator && (lt || gt) && 0 !== gtltComp) return !1;
    }
    return !(gt && hasDomLT && !lt && 0 !== gtltComp) && (!(lt && hasDomGT && !gt && 0 !== gtltComp) && (!needDomGTPre && !needDomLTPre));
   }, higherGT = (a, b, options) => {
    if (!a) return b;
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 || ">" === b.operator && ">=" === a.operator ? b : a;
   }, lowerLT = (a, b, options) => {
    if (!a) return b;
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 || "<" === b.operator && "<=" === a.operator ? b : a;
   };
   module.exports = (sub, dom, options = {}) => {
    if (sub === dom) return !0;
    sub = new Range(sub, options), dom = new Range(dom, options);
    let sawNonNull = !1;
    OUTER: for (const simpleSub of sub.set) {
     for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options);
      if (sawNonNull = sawNonNull || null !== isSub, isSub) continue OUTER;
     }
     if (sawNonNull) return !1;
    }
    return !0;
   };
  },
  51042: (module, __unused_webpack_exports, __webpack_require__) => {
   const Range = __webpack_require__(66902);
   module.exports = (range, options) => new Range(range, options).set.map((comp => comp.map((c => c.value)).join(" ").trim().split(" ")));
  },
  89042: (module, __unused_webpack_exports, __webpack_require__) => {
   const Range = __webpack_require__(66902);
   module.exports = (range, options) => {
    try {
     return new Range(range, options).range || "*";
    } catch (er) {
     return null;
    }
   };
  },
  76372: module => {
   "use strict";
   function isFunction(funktion) {
    return "function" == typeof funktion;
   }
   var logger = console.error.bind(console);
   function defineProperty(obj, name, value) {
    var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);
    Object.defineProperty(obj, name, {
     configurable: !0,
     enumerable,
     writable: !0,
     value
    });
   }
   function shimmer(options) {
    options && options.logger && (isFunction(options.logger) ? logger = options.logger : logger("new logger isn't a function, not replacing"));
   }
   function wrap(nodule, name, wrapper) {
    if (nodule && nodule[name]) {
     if (!wrapper) return logger("no wrapper function"), void logger((new Error).stack);
     if (isFunction(nodule[name]) && isFunction(wrapper)) {
      var original = nodule[name], wrapped = wrapper(original, name);
      return defineProperty(wrapped, "__original", original), defineProperty(wrapped, "__unwrap", (function() {
       nodule[name] === wrapped && defineProperty(nodule, name, original);
      })), defineProperty(wrapped, "__wrapped", !0), defineProperty(nodule, name, wrapped), 
      wrapped;
     }
     logger("original object and wrapper must be functions");
    } else logger("no original function " + name + " to wrap");
   }
   function unwrap(nodule, name) {
    return nodule && nodule[name] ? nodule[name].__unwrap ? nodule[name].__unwrap() : void logger("no original to unwrap to -- has " + name + " already been unwrapped?") : (logger("no function to unwrap."), 
    void logger((new Error).stack));
   }
   shimmer.wrap = wrap, shimmer.massWrap = function(nodules, names, wrapper) {
    if (!nodules) return logger("must provide one or more modules to patch"), void logger((new Error).stack);
    Array.isArray(nodules) || (nodules = [ nodules ]), names && Array.isArray(names) ? nodules.forEach((function(nodule) {
     names.forEach((function(name) {
      wrap(nodule, name, wrapper);
     }));
    })) : logger("must provide one or more functions to wrap on modules");
   }, shimmer.unwrap = unwrap, shimmer.massUnwrap = function(nodules, names) {
    if (!nodules) return logger("must provide one or more modules to patch"), void logger((new Error).stack);
    Array.isArray(nodules) || (nodules = [ nodules ]), names && Array.isArray(names) ? nodules.forEach((function(nodule) {
     names.forEach((function(name) {
      unwrap(nodule, name);
     }));
    })) : logger("must provide one or more functions to unwrap on modules");
   }, module.exports = shimmer;
  },
  60465: module => {
   module.exports = function(error, frames) {
    var lines = [];
    lines.push(function(error) {
     try {
      return Error.prototype.toString.call(error);
     } catch (e) {
      try {
       return "<error: " + e + ">";
      } catch (ee) {
       return "<error>";
      }
     }
    }(error));
    for (var i = 0; i < frames.length; i++) {
     var line, frame = frames[i];
     try {
      line = frame.toString();
     } catch (e) {
      try {
       line = "<error: " + e + ">";
      } catch (ee) {
       line = "<error>";
      }
     }
     lines.push("    at " + line);
    }
    return lines.join("\n");
   };
  },
  92512: (module, __unused_webpack_exports, __webpack_require__) => {
   if (global._stackChain) {
    if (global._stackChain.version !== __webpack_require__(32301).i8) throw new Error("Conflicting version of stack-chain found");
    module.exports = global._stackChain;
   } else module.exports = global._stackChain = __webpack_require__(87898);
  },
  87898: (module, __unused_webpack_exports, __webpack_require__) => {
   var defaultFormater = __webpack_require__(60465);
   function stackChain() {
    this.extend = new TraceModifier, this.filter = new TraceModifier, this.format = new StackFormater, 
    this.version = __webpack_require__(32301).i8;
   }
   var SHORTCIRCUIT_CALLSITE = !1;
   stackChain.prototype.callSite = function collectCallSites(options) {
    options || (options = {}), SHORTCIRCUIT_CALLSITE = !0;
    var obj = {};
    Error.captureStackTrace(obj, collectCallSites);
    var callSites = obj.stack;
    return SHORTCIRCUIT_CALLSITE = !1, callSites = callSites.slice(options.slice || 0), 
    options.extend && (callSites = this.extend._modify(obj, callSites)), options.filter && (callSites = this.filter._modify(obj, callSites)), 
    callSites;
   };
   var chain = new stackChain;
   function TraceModifier() {
    this._modifiers = [];
   }
   function StackFormater() {
    this._formater = defaultFormater, this._previous = void 0;
   }
   TraceModifier.prototype._modify = function(error, frames) {
    for (var i = 0, l = this._modifiers.length; i < l; i++) frames = this._modifiers[i](error, frames);
    return frames;
   }, TraceModifier.prototype.attach = function(modifier) {
    this._modifiers.push(modifier);
   }, TraceModifier.prototype.deattach = function(modifier) {
    var index = this._modifiers.indexOf(modifier);
    return -1 !== index && (this._modifiers.splice(index, 1), !0);
   }, StackFormater.prototype.replace = function(formater) {
    formater ? this._formater = formater : this.restore();
   }, StackFormater.prototype.restore = function() {
    this._formater = defaultFormater, this._previous = void 0;
   }, StackFormater.prototype._backup = function() {
    this._previous = this._formater;
   }, StackFormater.prototype._roolback = function() {
    this._previous === defaultFormater ? this.replace(void 0) : this.replace(this._previous), 
    this._previous = void 0;
   }, Error.prepareStackTrace && chain.format.replace(Error.prepareStackTrace);
   var SHORTCIRCUIT_FORMATER = !1;
   function prepareStackTrace(error, originalFrames) {
    if (SHORTCIRCUIT_CALLSITE) return originalFrames;
    if (SHORTCIRCUIT_FORMATER) return defaultFormater(error, originalFrames);
    var frames = originalFrames.concat();
    frames = chain.extend._modify(error, frames), frames = (frames = chain.filter._modify(error, frames)).slice(0, Error.stackTraceLimit), 
    Object.isExtensible(error) && void 0 === Object.getOwnPropertyDescriptor(error, "callSite") && (error.callSite = {
     original: originalFrames,
     mutated: frames
    }), SHORTCIRCUIT_FORMATER = !0;
    var format = chain.format._formater(error, frames);
    return SHORTCIRCUIT_FORMATER = !1, format;
   }
   Object.defineProperty(Error, "prepareStackTrace", {
    get: function() {
     return prepareStackTrace;
    },
    set: function(formater) {
     formater === prepareStackTrace ? chain.format._roolback() : (chain.format._backup(), 
     chain.format.replace(formater));
    }
   }), Object.defineProperty(Error.prototype, "callSite", {
    get: function() {
     return this.stack, this.callSite;
    },
    set: function(frames) {
     Object.defineProperty(this, "callSite", {
      value: frames,
      writable: !0,
      configurable: !0
     });
    },
    configurable: !0
   }), module.exports = chain;
  },
  92130: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   const os = __webpack_require__(22037), tty = __webpack_require__(76224), hasFlag = __webpack_require__(86560), {env} = process;
   let forceColor;
   function translateLevel(level) {
    return 0 !== level && {
     level,
     hasBasic: !0,
     has256: level >= 2,
     has16m: level >= 3
    };
   }
   function supportsColor(haveStream, streamIsTTY) {
    if (0 === forceColor) return 0;
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) return 3;
    if (hasFlag("color=256")) return 2;
    if (haveStream && !streamIsTTY && void 0 === forceColor) return 0;
    const min = forceColor || 0;
    if ("dumb" === env.TERM) return min;
    if ("win32" === process.platform) {
     const osRelease = os.release().split(".");
     return Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in env) return [ "TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE" ].some((sign => sign in env)) || "codeship" === env.CI_NAME ? 1 : min;
    if ("TEAMCITY_VERSION" in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    if ("truecolor" === env.COLORTERM) return 3;
    if ("TERM_PROGRAM" in env) {
     const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
     switch (env.TERM_PROGRAM) {
     case "iTerm.app":
      return version >= 3 ? 3 : 2;

     case "Apple_Terminal":
      return 2;
     }
    }
    return /-256(color)?$/i.test(env.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM) || "COLORTERM" in env ? 1 : min;
   }
   hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never") ? forceColor = 0 : (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) && (forceColor = 1), 
   "FORCE_COLOR" in env && (forceColor = "true" === env.FORCE_COLOR ? 1 : "false" === env.FORCE_COLOR ? 0 : 0 === env.FORCE_COLOR.length ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3)), 
   module.exports = {
    supportsColor: function(stream) {
     return translateLevel(supportsColor(stream, stream && stream.isTTY));
    },
    stdout: translateLevel(supportsColor(!0, tty.isatty(1))),
    stderr: translateLevel(supportsColor(!0, tty.isatty(2)))
   };
  },
  99160: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var AltimateRequest_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.AltimateRequest = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593), node_fetch_1 = __webpack_require__(74126), telemetry_1 = __webpack_require__(27407), dbtProjectContainer_1 = __webpack_require__(37343), exceptions_1 = __webpack_require__(62633);
   var PromptAnswer;
   !function(PromptAnswer) {
    PromptAnswer.YES = "Get your free API Key";
   }(PromptAnswer || (PromptAnswer = {}));
   let AltimateRequest = AltimateRequest_1 = class {
    constructor(dbtProjectContainer, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry;
    }
    getConfig() {
     const key = vscode_1.workspace.getConfiguration("dbt").get("altimateAiKey"), instance = vscode_1.workspace.getConfiguration("dbt").get("altimateInstanceName");
     if (key && instance) return {
      key,
      instance
     };
    }
    enabled() {
     return !!this.getConfig();
    }
    showAPIKeyMessage(message) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      (yield vscode_1.window.showInformationMessage(message, PromptAnswer.YES)) === PromptAnswer.YES && vscode_1.env.openExternal(vscode_1.Uri.parse("https://app.myaltimate.com/register?source=extension"));
     }));
    }
    getCredentialsMessage() {
     const key = vscode_1.workspace.getConfiguration("dbt").get("altimateAiKey"), instance = vscode_1.workspace.getConfiguration("dbt").get("altimateInstanceName");
     return key || instance ? key ? instance ? void 0 : "To use this feature, please add an instance name in the settings." : "To use this feature, please add an API key in the settings." : "To use this feature, please add an API Key and an instance name in the settings.";
    }
    handlePreviewFeatures() {
     const message = this.getCredentialsMessage();
     return !message || (this.showAPIKeyMessage(message), !1);
    }
    fetch(endpoint, fetchArgs = {}, timeout = 12e4) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      console.log("network:request:", endpoint, ":", fetchArgs);
      const abortController = new AbortController, timeoutHandler = setTimeout((() => {
       abortController.abort();
      }), timeout), message = this.getCredentialsMessage();
      if (message) return void vscode_1.window.showErrorMessage(message);
      const config = this.getConfig();
      try {
       const url = `${AltimateRequest_1.ALTIMATE_URL}/${endpoint}`;
       console.log("network:url:", url);
       const response = yield (0, node_fetch_1.default)(url, Object.assign(Object.assign({
        method: "GET"
       }, fetchArgs), {
        signal: abortController.signal,
        headers: {
         "x-tenant": config.instance,
         Authorization: "Bearer " + config.key,
         "Content-Type": "application/json",
         "extension-version": this.dbtProjectContainer.extensionVersion
        }
       }));
       if (console.log("network:response:", endpoint, ":", response.status), response.ok && 200 === response.status) {
        const jsonResponse = yield response.json();
        return clearTimeout(timeoutHandler), jsonResponse;
       }
       401 !== response.status && 403 !== response.status && 404 !== response.status || (vscode_1.window.showErrorMessage("Invalid credentials"), 
       this.telemetry.sendTelemetryEvent("invalidCredentials"));
       const textResponse = yield response.text();
       if (console.log("network:response:error:", textResponse), 429 === response.status) throw new exceptions_1.RateLimitException(textResponse, response.headers.get("Retry-After") ? parseInt(response.headers.get("Retry-After") || "") : 6e4);
       return this.telemetry.sendTelemetryError("apiError", {
        endpoint,
        status: response.status,
        textResponse
       }), clearTimeout(timeoutHandler), {};
      } catch (e) {
       throw console.log("network:response:catchAllError:", e), this.telemetry.sendTelemetryError("apiCatchAllError", e, {
        endpoint
       }), clearTimeout(timeoutHandler), e;
      }
     }));
    }
    isAuthenticated() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       yield this.fetch("auth_health", {
        method: "POST"
       });
      } catch (error) {
       return !1;
      }
      return !0;
     }));
    }
    generateModelDocs(docsGenerate) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch("dbt/v1", {
       method: "POST",
       body: JSON.stringify(docsGenerate)
      });
     }));
    }
    generateModelDocsV2(docsGenerate) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch("dbt/v2", {
       method: "POST",
       body: JSON.stringify(docsGenerate)
      });
     }));
    }
    sendFeedback(feedback) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return yield this.fetch("feedbacks/ai/fb", {
       method: "POST",
       body: JSON.stringify(feedback)
      });
     }));
    }
    getDocPromptOptions() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.fetch("dbt/v1/doc_prompt_options", {
       method: "POST"
      });
     }));
    }
    getColumnLevelLineage(req) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch("dbt/v3/lineage", {
       method: "POST",
       body: JSON.stringify(req)
      });
     }));
    }
    runModeller(req) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch("dbt/v1/sqltomodel", {
       method: "POST",
       body: JSON.stringify(req)
      });
     }));
    }
    getQuerySummary(compiled_sql, adapter) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch("dbt/v1/query-explain", {
       method: "POST",
       body: JSON.stringify({
        compiled_sql,
        adapter
       })
      });
     }));
    }
    validateSql(req) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch("dbt/v1/modelvalidation", {
       method: "POST",
       body: JSON.stringify(req)
      });
     }));
    }
    validateCredentials(instance, key) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const url = `${AltimateRequest_1.ALTIMATE_URL}/dbt/v3/validate-credentials`, response = yield (0, 
      node_fetch_1.default)(url, {
       method: "GET",
       headers: {
        "x-tenant": instance,
        Authorization: "Bearer " + key,
        "Content-Type": "application/json"
       }
      });
      return yield response.json();
     }));
    }
   };
   AltimateRequest.ALTIMATE_URL = vscode_1.workspace.getConfiguration("dbt").get("altimateUrl", "https://api.myaltimate.com"), 
   AltimateRequest = AltimateRequest_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(AltimateRequest_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], AltimateRequest), 
   exports.AltimateRequest = AltimateRequest;
  },
  22174: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DocAutocompletionProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DocAutocompletionProvider = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), dbtProjectContainer_1 = __webpack_require__(37343), utils_1 = __webpack_require__(78593), telemetry_1 = __webpack_require__(27407);
   let DocAutocompletionProvider = DocAutocompletionProvider_1 = class {
    constructor(dbtProjectContainer, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.docAutocompleteNameItemsMap = new Map, 
     this.disposables = [], this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    provideCompletionItems(document, position, token, context) {
     const linePrefix = document.lineAt(position).text.substr(0, position.character);
     if (!(0, utils_1.isEnclosedWithinCodeBlock)(document, position)) return;
     const projectRootpath = this.dbtProjectContainer.getProjectRootpath(document.uri);
     return void 0 !== projectRootpath && linePrefix.match(DocAutocompletionProvider_1.ENDS_WITH_DOC) ? this.showDocNameAutocompletionItems(projectRootpath) : void 0;
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.docAutocompleteNameItemsMap.set(added.project.projectRoot.fsPath, Array.from(added.docMetaMap.keys()).map((docName => new vscode_1.CompletionItem(docName, vscode_1.CompletionItemKind.File))));
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.docAutocompleteNameItemsMap.delete(removed.projectRoot.fsPath);
     }));
    }
    showDocNameAutocompletionItems(projectRootpath) {
     return this.telemetry.sendTelemetryEvent("provideDocAutocompletion"), this.docAutocompleteNameItemsMap.get(projectRootpath.fsPath);
    }
   };
   DocAutocompletionProvider.ENDS_WITH_DOC = /doc\(['|"]$/, DocAutocompletionProvider = DocAutocompletionProvider_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DocAutocompletionProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], DocAutocompletionProvider), 
   exports.DocAutocompletionProvider = DocAutocompletionProvider;
  },
  8403: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var AutocompletionProviders_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.AutocompletionProviders = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), dbtPowerUserExtension_1 = __webpack_require__(92182), utils_1 = __webpack_require__(78593), docAutocompletionProvider_1 = __webpack_require__(22174), macroAutocompletionProvider_1 = __webpack_require__(91253), modelAutocompletionProvider_1 = __webpack_require__(96382), sourceAutocompletionProvider_1 = __webpack_require__(76881);
   let AutocompletionProviders = AutocompletionProviders_1 = class {
    constructor(macroAutocompletionProvider, modelAutocompletionProvider, sourceAutocompletionProvider, docAutocompletionProvider) {
     this.macroAutocompletionProvider = macroAutocompletionProvider, this.modelAutocompletionProvider = modelAutocompletionProvider, 
     this.sourceAutocompletionProvider = sourceAutocompletionProvider, this.docAutocompletionProvider = docAutocompletionProvider, 
     this.disposables = [], this.disposables.push(vscode_1.languages.registerCompletionItemProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_SQL_SELECTOR, this.macroAutocompletionProvider), vscode_1.languages.registerCompletionItemProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_SQL_SELECTOR, this.modelAutocompletionProvider, ".", "(", '"', "'"), vscode_1.languages.registerCompletionItemProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_SQL_SELECTOR, this.sourceAutocompletionProvider, ".", "(", '"', "'"), vscode_1.languages.registerCompletionItemProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_YAML_SELECTOR, this.docAutocompletionProvider, ".", "(", '"', "'"));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   AutocompletionProviders = AutocompletionProviders_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(AutocompletionProviders_1), tslib_1.__metadata("design:paramtypes", [ macroAutocompletionProvider_1.MacroAutocompletionProvider, modelAutocompletionProvider_1.ModelAutocompletionProvider, sourceAutocompletionProvider_1.SourceAutocompletionProvider, docAutocompletionProvider_1.DocAutocompletionProvider ]) ], AutocompletionProviders), 
   exports.AutocompletionProviders = AutocompletionProviders;
  },
  91253: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var MacroAutocompletionProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.MacroAutocompletionProvider = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), dbtProjectContainer_1 = __webpack_require__(37343), utils_1 = __webpack_require__(78593), telemetry_1 = __webpack_require__(27407);
   let MacroAutocompletionProvider = MacroAutocompletionProvider_1 = class {
    constructor(dbtProjectContainer, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.macrosAutocompleteMap = new Map, 
     this.disposables = [], this.getAutoCompleteItems = currentFilePath => {
      const projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
      if (void 0 !== projectRootpath) return this.telemetry.sendTelemetryEvent("provideMacroAutocompletion"), 
      this.macrosAutocompleteMap.get(projectRootpath.fsPath);
     }, this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    provideCompletionItems(document, position, token, context) {
     const range = document.getWordRangeAtPosition(position);
     if (range && (0, utils_1.isEnclosedWithinCodeBlock)(document, range)) return this.getAutoCompleteItems(document.uri);
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.macrosAutocompleteMap.set(added.project.projectRoot.fsPath, Array.from(added.macroMetaMap.keys()).map((macro => ({
       label: macro,
       insertText: macro,
       kind: vscode_1.CompletionItemKind.Value,
       detail: "Macro"
      }))));
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.macrosAutocompleteMap.delete(removed.projectRoot.fsPath);
     }));
    }
   };
   MacroAutocompletionProvider = MacroAutocompletionProvider_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(MacroAutocompletionProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], MacroAutocompletionProvider), 
   exports.MacroAutocompletionProvider = MacroAutocompletionProvider;
  },
  96382: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ModelAutocompletionProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ModelAutocompletionProvider = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), dbtProjectContainer_1 = __webpack_require__(37343), utils_1 = __webpack_require__(78593), telemetry_1 = __webpack_require__(27407), dbtProject_1 = __webpack_require__(49827);
   let ModelAutocompletionProvider = ModelAutocompletionProvider_1 = class {
    constructor(dbtProjectContainer, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.modelAutocompleteMap = new Map, 
     this.disposables = [], this.getAutoCompleteItems = currentFilePath => {
      const projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
      if (void 0 !== projectRootpath) return this.telemetry.sendTelemetryEvent("provideModelAutocompletion"), 
      this.modelAutocompleteMap.get(projectRootpath.fsPath);
     }, this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    provideCompletionItems(document, position, token, context) {
     var _a;
     const linePrefix = document.lineAt(position).text.substr(0, position.character);
     if ((linePrefix.match(ModelAutocompletionProvider_1.MODEL_PATTERN) || linePrefix.match(ModelAutocompletionProvider_1.PACKAGE_PATTERN)) && (0, 
     utils_1.isEnclosedWithinCodeBlock)(document, position)) {
      let quoteFound = !1, quote = "";
      linePrefix.endsWith("'") ? (quoteFound = !0, quote = "'") : linePrefix.endsWith('"') && (quoteFound = !0, 
      quote = '"');
      return null === (_a = this.getAutoCompleteItems(document.uri)) || void 0 === _a ? void 0 : _a.map((completionItem => Object.assign(Object.assign({}, completionItem), {
       insertText: this.encloseWithQuotes(completionItem.insertText, quoteFound, quote)
      })));
     }
    }
    encloseWithQuotes(insertText, quoteFound, quote) {
     let enclosing = "";
     return quoteFound || (enclosing = '"'), `${enclosing}${insertText.replace('"', quote)}${enclosing}`;
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      const projectName = added.project.getProjectName(), models = added.nodeMetaMap.entries();
      this.modelAutocompleteMap.set(added.project.projectRoot.fsPath, Array.from(models).filter((([key, model]) => model.resource_type !== dbtProject_1.DBTProject.RESOURCE_TYPE_ANALYSIS)).map((([key, model]) => ({
       label: `(${model.package_name}) ${key}`,
       insertText: model.package_name === projectName ? key : `${model.package_name}, ${key}`,
       kind: vscode_1.CompletionItemKind.Value,
       detail: "Model"
      }))));
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.modelAutocompleteMap.delete(removed.projectRoot.fsPath);
     }));
    }
   };
   ModelAutocompletionProvider.MODEL_PATTERN = /ref\s*\(\s*(['|"])?\s*\w*$/, ModelAutocompletionProvider.PACKAGE_PATTERN = /ref\s*\(\s*('[^)']*'|"[^)"]*")\s*,\s*('|")\s*\w*$/, 
   ModelAutocompletionProvider = ModelAutocompletionProvider_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(ModelAutocompletionProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], ModelAutocompletionProvider), 
   exports.ModelAutocompletionProvider = ModelAutocompletionProvider;
  },
  76881: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var SourceAutocompletionProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SourceAutocompletionProvider = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), dbtProjectContainer_1 = __webpack_require__(37343), utils_1 = __webpack_require__(78593), telemetry_1 = __webpack_require__(27407);
   let SourceAutocompletionProvider = SourceAutocompletionProvider_1 = class {
    constructor(dbtProjectContainer, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.sourceAutocompleteNameItemsMap = new Map, 
     this.sourceAutocompleteTableMap = new Map, this.disposables = [], this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    provideCompletionItems(document, position, token, context) {
     const linePrefix = document.lineAt(position).text.substr(0, position.character);
     if (!(0, utils_1.isEnclosedWithinCodeBlock)(document, position)) return;
     const projectRootpath = this.dbtProjectContainer.getProjectRootpath(document.uri);
     if (void 0 !== projectRootpath) {
      if (linePrefix.match(SourceAutocompletionProvider_1.ENDS_WITH_SOURCE)) return this.showSourceNameAutocompletionItems(projectRootpath);
      if (linePrefix.match(SourceAutocompletionProvider_1.GET_SOURCE_NAME) && linePrefix.includes("source")) {
       return this.showTableNameAutocompletionItems(linePrefix, projectRootpath);
      }
     }
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.sourceAutocompleteNameItemsMap.set(added.project.projectRoot.fsPath, Array.from(added.sourceMetaMap.keys()).map((source => new vscode_1.CompletionItem(source, vscode_1.CompletionItemKind.File))));
      const sourceTableMap = new Map;
      added.sourceMetaMap.forEach(((value, key) => {
       const autocompleteItems = value.tables.map((item => new vscode_1.CompletionItem(item.name, vscode_1.CompletionItemKind.File)));
       sourceTableMap.set(key, autocompleteItems);
      })), this.sourceAutocompleteTableMap.set(added.project.projectRoot.fsPath, sourceTableMap);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.sourceAutocompleteNameItemsMap.delete(removed.projectRoot.fsPath), this.sourceAutocompleteTableMap.delete(removed.projectRoot.fsPath);
     }));
    }
    showSourceNameAutocompletionItems(projectRootpath) {
     return this.sourceAutocompleteNameItemsMap.get(projectRootpath.fsPath);
    }
    showTableNameAutocompletionItems(linePrefix, projectRootpath) {
     const sourceNameMatch = linePrefix.match(SourceAutocompletionProvider_1.GET_SOURCE_NAME);
     if (null !== sourceNameMatch) {
      const sourceTableMap = this.sourceAutocompleteTableMap.get(projectRootpath.fsPath);
      if (void 0 === sourceTableMap) return;
      return this.telemetry.sendTelemetryEvent("provideSourceAutocompletion"), sourceTableMap.get(sourceNameMatch[0]);
     }
    }
   };
   SourceAutocompletionProvider.GET_SOURCE_NAME = /(?!['"])(\w+)(?=['"])/, SourceAutocompletionProvider.ENDS_WITH_SOURCE = /source\(['|"]$/, 
   SourceAutocompletionProvider = SourceAutocompletionProvider_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(SourceAutocompletionProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], SourceAutocompletionProvider), 
   exports.SourceAutocompletionProvider = SourceAutocompletionProvider;
  },
  90475: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var CodeLensProviders_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.CodeLensProviders = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), dbtPowerUserExtension_1 = __webpack_require__(92182), utils_1 = __webpack_require__(78593), sourceModelCreationCodeLensProvider_1 = __webpack_require__(21938);
   let CodeLensProviders = CodeLensProviders_1 = class {
    constructor(sourceModelCreationCodeLensProvider) {
     this.sourceModelCreationCodeLensProvider = sourceModelCreationCodeLensProvider, 
     this.disposables = [], this.disposables.push(vscode_1.languages.registerCodeLensProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_YAML_SELECTOR, this.sourceModelCreationCodeLensProvider));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   CodeLensProviders = CodeLensProviders_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(CodeLensProviders_1), tslib_1.__metadata("design:paramtypes", [ sourceModelCreationCodeLensProvider_1.SourceModelCreationCodeLensProvider ]) ], CodeLensProviders), 
   exports.CodeLensProviders = CodeLensProviders;
  },
  21938: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var SourceModelCreationCodeLensProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SourceModelCreationCodeLensProvider = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), yaml_1 = __webpack_require__(93419), utils_1 = __webpack_require__(78593);
   let SourceModelCreationCodeLensProvider = SourceModelCreationCodeLensProvider_1 = class {
    constructor() {
     this.codeLenses = [], this._onDidChangeCodeLenses = new vscode_1.EventEmitter, this.onDidChangeCodeLenses = this._onDidChangeCodeLenses.event;
    }
    provideCodeLenses(document, token) {
     this.codeLenses = [];
     const lineCounter = new yaml_1.LineCounter;
     let currentSource, currentDatabase, currentSchema, currentTables;
     for (const token of new yaml_1.Parser(lineCounter.addNewLine).parse(document.getText())) if ("document" === token.type && yaml_1.CST.isCollection(token.value)) for (const i in token.value.items) {
      const item = token.value.items[i];
      if (yaml_1.CST.isScalar(item.key) && "sources" === item.key.source && yaml_1.CST.isCollection(item.value)) for (const j in item.value.items) {
       currentTables = [];
       const source = item.value.items[j];
       if (yaml_1.CST.isCollection(source.value)) for (const k in source.value.items) {
        const sourceProperty = source.value.items[k];
        if (yaml_1.CST.isScalar(sourceProperty.key) && yaml_1.CST.isScalar(sourceProperty.value) && ("name" === sourceProperty.key.source && (currentSource = sourceProperty.value.source), 
        "database" === sourceProperty.key.source && (currentDatabase = sourceProperty.value.source), 
        "schema" === sourceProperty.key.source && (currentSchema = sourceProperty.value.source)), 
        yaml_1.CST.isScalar(sourceProperty.key) && yaml_1.CST.isCollection(sourceProperty.value) && "tables" === sourceProperty.key.source) {
         let tableName, tableIdentifier, position;
         for (const l in sourceProperty.value.items) {
          const table = sourceProperty.value.items[l];
          if (yaml_1.CST.isCollection(table.value)) for (const m in table.value.items) {
           position = lineCounter.linePos(table.value.offset);
           const tableProperty = table.value.items[m];
           yaml_1.CST.isScalar(tableProperty.value) && yaml_1.CST.isScalar(tableProperty.key) && ("name" === tableProperty.key.source && (tableName = tableProperty.value.source), 
           "identifier" === tableProperty.key.source && (tableIdentifier = tableProperty.value.source));
          }
          void 0 !== tableName && void 0 !== position && (currentTables.push({
           tableName,
           tableIdentifier,
           pos: position
          }), tableName = void 0, tableIdentifier = void 0, position = void 0);
         }
        }
       }
       for (const i in currentTables) {
        const table = currentTables[i], params = {
         currentDoc: document.uri,
         sourceName: currentSource,
         database: currentDatabase,
         schema: currentSchema,
         tableName: table.tableName,
         tableIdentifier: table.tableIdentifier
        };
        this.codeLenses.push(new vscode_1.CodeLens(new vscode_1.Range(table.pos.line - 1, table.pos.col, table.pos.line - 1, table.pos.col), {
         title: "Generate model",
         tooltip: "Generate model based on source configuration",
         command: "dbtPowerUser.createModelBasedonSourceConfig",
         arguments: [ params ]
        }));
       }
       currentDatabase = void 0, currentSchema = void 0, currentSource = void 0;
      }
     }
     return this.codeLenses;
    }
   };
   SourceModelCreationCodeLensProvider = SourceModelCreationCodeLensProvider_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(SourceModelCreationCodeLensProvider_1) ], SourceModelCreationCodeLensProvider), 
   exports.SourceModelCreationCodeLensProvider = SourceModelCreationCodeLensProvider;
  },
  11986: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var CommandProcessExecutionFactory_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.CommandProcessExecution = exports.CommandProcessExecutionFactory = void 0;
   const tslib_1 = __webpack_require__(70655), child_process_1 = __webpack_require__(32081), inversify_binding_decorators_1 = __webpack_require__(84904);
   let CommandProcessExecutionFactory = CommandProcessExecutionFactory_1 = class {
    createCommandProcessExecution({command, args, stdin, cwd, token, envVars}) {
     return new CommandProcessExecution(command, args, stdin, cwd, token, envVars);
    }
   };
   CommandProcessExecutionFactory = CommandProcessExecutionFactory_1 = tslib_1.__decorate([ (0, 
   inversify_binding_decorators_1.provide)(CommandProcessExecutionFactory_1) ], CommandProcessExecutionFactory), 
   exports.CommandProcessExecutionFactory = CommandProcessExecutionFactory;
   class CommandProcessExecution {
    constructor(command, args, stdin, cwd, token, envVars) {
     this.command = command, this.args = args, this.stdin = stdin, this.cwd = cwd, this.token = token, 
     this.envVars = envVars, this.disposables = [];
    }
    spawn() {
     const proc = (0, child_process_1.spawn)(this.command, this.args, {
      cwd: this.cwd,
      env: this.envVars
     });
     return void 0 !== this.token && this.disposables.push(this.token.onCancellationRequested((() => {
      proc.kill("SIGINT");
     }))), proc;
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    complete() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return new Promise(((resolve, reject) => {
       const commandProcess = this.spawn();
       let stdoutBuffer = "", stderrBuffer = "";
       commandProcess.stdout.on("data", (chunk => stdoutBuffer += chunk.toString())), commandProcess.stderr.on("data", (chunk => stderrBuffer += chunk.toString())), 
       commandProcess.once("close", (() => {
        stderrBuffer ? reject(stderrBuffer) : resolve(stdoutBuffer);
       })), commandProcess.once("error", (error => {
        console.warn(error), reject(`${error}`);
       })), this.stdin && (commandProcess.stdin.write(this.stdin), commandProcess.stdin.end());
      }));
     }));
    }
    completeWithTerminalOutput(terminal) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return new Promise(((resolve, reject) => {
       const commandProcess = this.spawn();
       let stdoutBuffer = "", stderrBuffer = "";
       commandProcess.stdout.on("data", (chunk => {
        const line = `${this.formatText(chunk.toString())}`;
        stdoutBuffer += line, terminal.log(line);
       })), commandProcess.stderr.on("data", (chunk => {
        const line = `${this.formatText(chunk.toString())}`;
        stderrBuffer += line, terminal.log(line);
       })), commandProcess.once("close", (() => {
        stderrBuffer ? reject(stderrBuffer) : (terminal.log(""), resolve(stdoutBuffer)), 
        this.dispose();
       })), commandProcess.once("error", (error => {
        reject(`Error occurred during process execution: ${error}`);
       })), this.stdin && (commandProcess.stdin.write(this.stdin), commandProcess.stdin.end());
      }));
     }));
    }
    formatText(text) {
     return `${text.split(/(\r?\n)+/g).join("\r")}`;
    }
   }
   exports.CommandProcessExecution = CommandProcessExecution;
  },
  30848: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var AltimateScan_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.AltimateScan = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), altimate_1 = __webpack_require__(99160), dbtProjectContainer_1 = __webpack_require__(37343), telemetry_1 = __webpack_require__(27407), utils_1 = __webpack_require__(78593), initCatalog_1 = __webpack_require__(42262), undocumentedModelColumnTest_1 = __webpack_require__(64603), staleModelColumnTest_1 = __webpack_require__(50894), missingSchemaTest_1 = __webpack_require__(78033), unmaterializedModelTest_1 = __webpack_require__(32855), scanContext_1 = __webpack_require__(83335);
   let AltimateScan = AltimateScan_1 = class {
    constructor(dbtProjectContainer, telemetry, altimate, missingSchemaTest, undocumentedModelColumnTest, unmaterializedModelTest, staleModelColumnTest) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.altimate = altimate, 
     this.missingSchemaTest = missingSchemaTest, this.undocumentedModelColumnTest = undocumentedModelColumnTest, 
     this.unmaterializedModelTest = unmaterializedModelTest, this.staleModelColumnTest = staleModelColumnTest, 
     this.eventMap = new Map, dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))), 
     this.offlineAltimateScanSteps = [ missingSchemaTest ], this.onlineAltimateScanSteps = [ unmaterializedModelTest, undocumentedModelColumnTest, staleModelColumnTest ], 
     this.altimateScanSteps = [];
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
       this.eventMap.set(added.project.projectRoot.fsPath, added);
      })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
       this.eventMap.delete(removed.projectRoot.fsPath);
      }));
     }));
    }
    clearProblems() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.telemetry.sendTelemetryEvent("altimateScan:Clear"), vscode_1.window.withProgress({
       location: vscode_1.ProgressLocation.Notification,
       title: "Clearing problems...",
       cancellable: !1
      }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       const projects = this.dbtProjectContainer.getProjects();
       for (const project of projects) project.projectHealth.clear();
      }))));
     }));
    }
    getProblems() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.telemetry.sendTelemetryEvent("altimateScan:Start");
      let totalProblems = 0;
      vscode_1.window.withProgress({
       location: vscode_1.ProgressLocation.Notification,
       title: "Scanning for problems...",
       cancellable: !0
      }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       const projects = this.dbtProjectContainer.getProjects();
       for (const project of projects) try {
        const scanContext = new scanContext_1.ScanContext(project, this.eventMap.get(project.projectRoot.fsPath));
        yield this.runSteps(scanContext), totalProblems += this.showDiagnostics(scanContext);
       } catch (err) {
        console.log(err);
       }
       yield vscode_1.commands.executeCommand("workbench.actions.view.problems"), this.telemetry.sendTelemetryEvent("altimateScan:Done", {
        problemsFound: totalProblems.toString()
       });
      }))));
     }));
    }
    runSteps(scanContext) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield Promise.all(this.offlineAltimateScanSteps.map((stepof => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       return yield stepof.run(scanContext);
      }))))), yield this.initCatalog(scanContext), void 0 !== scanContext.scanResults.missingCatalog && !0 === scanContext.scanResults.missingCatalog[scanContext.project.getProjectName() + scanContext.project.projectRoot] || (yield Promise.all(this.onlineAltimateScanSteps.map((stepon => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       return yield stepon.run(scanContext);
      }))))));
     }));
    }
    initCatalog(scanContext) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (void 0 === scanContext) throw new Error("Scan Context has not been set");
      const projectCatalog = yield (new initCatalog_1.InitCatalog).run(scanContext);
      scanContext.catalog[scanContext.project.getProjectName() + scanContext.project.projectRoot] = projectCatalog;
     }));
    }
    showDiagnostics(scanContext) {
     if (void 0 === scanContext) throw new Error("Scan Context has not been set");
     scanContext.project.projectHealth.clear();
     let totalProblems = 0;
     for (const [filePath, fileDiagnostics] of Object.entries(scanContext.diagnostics)) scanContext.project.projectHealth.set(vscode_1.Uri.file(filePath), fileDiagnostics), 
     totalProblems += fileDiagnostics.length;
     return totalProblems;
    }
   };
   AltimateScan = AltimateScan_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(AltimateScan_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService, altimate_1.AltimateRequest, missingSchemaTest_1.MissingSchemaTest, undocumentedModelColumnTest_1.UndocumentedModelColumnTest, unmaterializedModelTest_1.UnmaterializedModelTest, staleModelColumnTest_1.StaleModelColumnTest ]) ], AltimateScan), 
   exports.AltimateScan = AltimateScan;
  },
  21634: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var BigQueryCostEstimate_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.BigQueryCostEstimate = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), path = __webpack_require__(71017), utils_1 = __webpack_require__(78593), dbtTerminal_1 = __webpack_require__(26684), telemetry_1 = __webpack_require__(27407), dbtProjectContainer_1 = __webpack_require__(37343), python_bridge_1 = __webpack_require__(1438);
   let BigQueryCostEstimate = BigQueryCostEstimate_1 = class {
    constructor(dbtProjectContainer, dbtTerminal, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.dbtTerminal = dbtTerminal, 
     this.telemetry = telemetry;
    }
    estimateCost() {
     var _a, _b, _c;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const modelName = path.basename(vscode_1.window.activeTextEditor.document.fileName, ".sql");
      this.dbtTerminal.show(!0);
      try {
       const query = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.getText();
       if (!query) return void vscode_1.window.showErrorMessage("We need a valid query to get a cost estimate.");
       const compiledQuery = yield null === (_b = this.getProject()) || void 0 === _b ? void 0 : _b.unsafeCompileQuery(query);
       if (!compiledQuery) return void vscode_1.window.showErrorMessage("We need a valid query to get a cost estimate.");
       const result = yield null === (_c = this.getProject()) || void 0 === _c ? void 0 : _c.validateSQLDryRun(compiledQuery);
       if (!result) return;
       this.dbtTerminal.log(`The query for ${modelName} will process ${result.bytes_processed}.\r\n`);
      } catch (error) {
       if (error instanceof python_bridge_1.PythonException) return vscode_1.window.showErrorMessage((0, 
       utils_1.extendErrorWithSupportLinks)(`An error occured while trying to compile your node: ${modelName}` + error.exception.message + ".")), 
       void this.telemetry.sendTelemetryError("bigqueryCostEstimatePythonError", error);
       vscode_1.window.showErrorMessage("Could not perform bigquery cost estimate: " + error.message);
      }
     }));
    }
    getProject() {
     var _a;
     const currentFilePath = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
     if (currentFilePath) return this.dbtProjectContainer.findDBTProject(currentFilePath);
    }
   };
   BigQueryCostEstimate = BigQueryCostEstimate_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(BigQueryCostEstimate_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, dbtTerminal_1.DBTTerminal, telemetry_1.TelemetryService ]) ], BigQueryCostEstimate), 
   exports.BigQueryCostEstimate = BigQueryCostEstimate;
  },
  45885: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var VSCodeCommands_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.VSCodeCommands = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), sqlPreviewContentProvider_1 = __webpack_require__(17179), domain_1 = __webpack_require__(37512), utils_1 = __webpack_require__(78593), runModel_1 = __webpack_require__(18524), sqlToModel_1 = __webpack_require__(62639), altimateScan_1 = __webpack_require__(30848), walkthroughCommands_1 = __webpack_require__(28129), dbtProjectContainer_1 = __webpack_require__(37343), validateSql_1 = __webpack_require__(25695), bigQueryCostEstimate_1 = __webpack_require__(21634);
   let VSCodeCommands = VSCodeCommands_1 = class {
    constructor(dbtProjectContainer, runModel, sqlToModel, validateSql, altimateScan, walkthroughCommands, bigQueryCostEstimate) {
     this.dbtProjectContainer = dbtProjectContainer, this.runModel = runModel, this.sqlToModel = sqlToModel, 
     this.validateSql = validateSql, this.altimateScan = altimateScan, this.walkthroughCommands = walkthroughCommands, 
     this.bigQueryCostEstimate = bigQueryCostEstimate, this.disposables = [], this.disposables.push(vscode_1.commands.registerCommand("dbtPowerUser.checkIfDbtIsInstalled", (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.dbtProjectContainer.detectDBT(), this.dbtProjectContainer.initialize();
     })))), vscode_1.commands.registerCommand("dbtPowerUser.installDbt", (() => this.walkthroughCommands.installDbt())), vscode_1.commands.registerCommand("dbtPowerUser.runCurrentModel", (() => this.runModel.runModelOnActiveWindow())), vscode_1.commands.registerCommand("dbtPowerUser.testCurrentModel", (() => this.runModel.runTestsOnActiveWindow())), vscode_1.commands.registerCommand("dbtPowerUser.compileCurrentModel", (() => this.runModel.compileModelOnActiveWindow())), vscode_1.commands.registerCommand("dbtPowerUser.bigqueryCostEstimate", (() => this.bigQueryCostEstimate.estimateCost())), vscode_1.commands.registerTextEditorCommand("dbtPowerUser.sqlPreview", (editor => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const uri = editor.document.uri.with({
       scheme: sqlPreviewContentProvider_1.SqlPreviewContentProvider.SCHEME
      }), doc = yield vscode_1.workspace.openTextDocument(uri), isOpen = vscode_1.window.visibleTextEditors.some((e => e.document.uri === uri));
      yield vscode_1.window.showTextDocument(doc, vscode_1.ViewColumn.Beside, !1), yield vscode_1.languages.setTextDocumentLanguage(doc, "sql"), 
      isOpen ? yield vscode_1.commands.executeCommand("workbench.action.closeActiveEditor") : (yield vscode_1.commands.executeCommand("workbench.action.lockEditorGroup"), 
      yield vscode_1.commands.executeCommand("workbench.action.focusPreviousGroup"));
     })))), vscode_1.commands.registerCommand("dbtPowerUser.goToDocumentationEditor", (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield vscode_1.commands.executeCommand("workbench.view.extension.docs_edit_view");
     })))), vscode_1.commands.registerCommand("dbtPowerUser.runTest", (model => this.runModel.runModelOnNodeTreeItem(domain_1.RunModelType.TEST)(model))), vscode_1.commands.registerCommand("dbtPowerUser.runChildrenModels", (model => this.runModel.runModelOnNodeTreeItem(domain_1.RunModelType.RUN_CHILDREN)(model))), vscode_1.commands.registerCommand("dbtPowerUser.runParentModels", (model => this.runModel.runModelOnNodeTreeItem(domain_1.RunModelType.RUN_PARENTS)(model))), vscode_1.commands.registerCommand("dbtPowerUser.showRunSQL", (() => this.runModel.showRunSQLOnActiveWindow())), vscode_1.commands.registerCommand("dbtPowerUser.showCompiledSQL", (() => this.runModel.showCompiledSQLOnActiveWindow())), vscode_1.commands.registerCommand("dbtPowerUser.generateSchemaYML", (() => this.runModel.generateSchemaYMLOnActiveWindow())), vscode_1.commands.registerCommand("dbtPowerUser.generateDBTDocs", (() => this.runModel.generateDBTDocsOnActiveWindow())), vscode_1.commands.registerCommand("dbtPowerUser.executeSQL", (() => this.runModel.executeQueryOnActiveWindow())), vscode_1.commands.registerCommand("dbtPowerUser.summarizeQuery", (() => this.runModel.getSummaryOnActiveWindow())), vscode_1.commands.registerCommand("dbtPowerUser.createModelBasedonSourceConfig", (params => {
      this.runModel.createModelBasedonSourceConfig(params);
     })), vscode_1.commands.registerCommand("dbtPowerUser.buildCurrentModel", (() => this.runModel.buildModelOnActiveWindow())), vscode_1.commands.registerCommand("dbtPowerUser.buildChildrenModels", (() => this.runModel.buildModelOnActiveWindow(domain_1.RunModelType.BUILD_CHILDREN))), vscode_1.commands.registerCommand("dbtPowerUser.buildParentModels", (() => this.runModel.buildModelOnActiveWindow(domain_1.RunModelType.BUILD_PARENTS))), vscode_1.commands.registerCommand("dbtPowerUser.buildChildrenParentModels", (() => this.runModel.buildModelOnActiveWindow(domain_1.RunModelType.BUILD_CHILDREN_PARENTS))), vscode_1.commands.registerCommand("dbtPowerUser.sqlToModel", (() => this.sqlToModel.getModelFromSql())), vscode_1.commands.registerCommand("dbtPowerUser.validateSql", (() => this.validateSql.validateSql())), vscode_1.commands.registerCommand("dbtPowerUser.altimateScan", (() => this.altimateScan.getProblems())), vscode_1.commands.registerCommand("dbtPowerUser.clearAltimateScanResults", (() => this.altimateScan.clearProblems())), vscode_1.commands.registerCommand("dbtPowerUser.validateProject", (() => {
      const pickedProject = this.dbtProjectContainer.getFromWorkspaceState("dbtPowerUser.projectSelected");
      this.walkthroughCommands.validateProjects(pickedProject);
     })), vscode_1.commands.registerCommand("dbtPowerUser.installDeps", (() => {
      this.dbtProjectContainer.setToGlobalState("showSetupWalkthrough", !1);
      const pickedProject = this.dbtProjectContainer.getFromWorkspaceState("dbtPowerUser.projectSelected");
      this.walkthroughCommands.installDeps(pickedProject);
     })), vscode_1.commands.registerCommand("dbtPowerUser.openSetupWalkthrough", (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield vscode_1.commands.executeCommand("workbench.action.openWalkthrough"), vscode_1.commands.executeCommand("workbench.action.openWalkthrough", `${this.dbtProjectContainer.extensionId}#initialSetup`, !0);
     })))), vscode_1.commands.registerCommand("dbtPowerUser.openTutorialWalkthrough", (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield vscode_1.commands.executeCommand("workbench.action.openWalkthrough"), vscode_1.commands.executeCommand("workbench.action.openWalkthrough", `${this.dbtProjectContainer.extensionId}#tutorials`, !1);
     })))), vscode_1.commands.registerCommand("dbtPowerUser.associateFileExts", (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      vscode_1.commands.executeCommand("workbench.action.openSettings", "@id:files.associations");
     })))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   VSCodeCommands = VSCodeCommands_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(VSCodeCommands_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, runModel_1.RunModel, sqlToModel_1.SqlToModel, validateSql_1.ValidateSql, altimateScan_1.AltimateScan, walkthroughCommands_1.WalkthroughCommands, bigQueryCostEstimate_1.BigQueryCostEstimate ]) ], VSCodeCommands), 
   exports.VSCodeCommands = VSCodeCommands;
  },
  18524: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var RunModel_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.RunModel = void 0;
   const tslib_1 = __webpack_require__(70655), path = __webpack_require__(71017), vscode_1 = __webpack_require__(66828), domain_1 = __webpack_require__(37512), dbtProjectContainer_1 = __webpack_require__(37343), utils_1 = __webpack_require__(78593);
   let RunModel = RunModel_1 = class {
    constructor(dbtProjectContainer) {
     this.dbtProjectContainer = dbtProjectContainer;
    }
    runModelOnActiveWindow(type) {
     if (!vscode_1.window.activeTextEditor) return;
     const fullPath = vscode_1.window.activeTextEditor.document.uri;
     this.runDBTModel(fullPath, type);
    }
    buildModelOnActiveWindow(type) {
     if (!vscode_1.window.activeTextEditor) return;
     const fullPath = vscode_1.window.activeTextEditor.document.uri;
     this.buildDBTModel(fullPath, type);
    }
    runTestsOnActiveWindow() {
     if (!vscode_1.window.activeTextEditor) return;
     const fullPath = vscode_1.window.activeTextEditor.document.uri;
     this.runDBTModelTest(fullPath);
    }
    compileModelOnActiveWindow() {
     if (!vscode_1.window.activeTextEditor) return;
     const fullPath = vscode_1.window.activeTextEditor.document.uri;
     this.compileDBTModel(fullPath);
    }
    compileQueryOnActiveWindow() {
     if (!vscode_1.window.activeTextEditor) return;
     const fullPath = vscode_1.window.activeTextEditor.document.uri, query = vscode_1.window.activeTextEditor.document.getText();
     void 0 !== query && this.compileDBTQuery(fullPath, query);
    }
    getQuery() {
     if (!vscode_1.window.activeTextEditor) return;
     const cursor = vscode_1.window.activeTextEditor.selection;
     return vscode_1.window.activeTextEditor.document.getText(cursor.isEmpty ? void 0 : cursor);
    }
    executeQueryOnActiveWindow() {
     var _a;
     const query = this.getQuery();
     if (void 0 === query) return;
     const cursor = vscode_1.window.activeTextEditor.selection, queryName = "Results: " + path.basename(null !== (_a = vscode_1.window.activeTextEditor.document.uri.fsPath) && void 0 !== _a ? _a : "Ad Hoc") + " " + (cursor.isEmpty ? "" : "(Ad Hoc) ") + (new Date).toTimeString().split(" ")[0];
     this.executeSQL(vscode_1.window.activeTextEditor.document.uri, query, queryName);
    }
    getSummaryOnActiveWindow() {
     const query = this.getQuery();
     void 0 !== query && this.getSummary(vscode_1.window.activeTextEditor.document.uri, query);
    }
    runModelOnNodeTreeItem(type) {
     return model => {
      if (void 0 !== model) switch (type) {
      case domain_1.RunModelType.TEST:
       model.label && this.runDBTTest(vscode_1.Uri.file(model.url), model.label.toString().split(".")[0]);
       break;

      case domain_1.RunModelType.BUILD_CHILDREN:
      case domain_1.RunModelType.BUILD_CHILDREN_PARENTS:
      case domain_1.RunModelType.BUILD_PARENTS:
       this.buildDBTModel(vscode_1.Uri.file(model.url), type);
       break;

      case domain_1.RunModelType.RUN_CHILDREN:
      case domain_1.RunModelType.RUN_PARENTS:
       this.runDBTModel(vscode_1.Uri.file(model.url), type);
      } else this.runModelOnActiveWindow(type);
     };
    }
    showCompiledSQLOnActiveWindow() {
     var _a;
     const fullPath = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
     void 0 !== fullPath && this.showCompiledSQL(fullPath);
    }
    generateSchemaYMLOnActiveWindow() {
     var _a;
     const fullPath = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
     void 0 !== fullPath && this.generateSchemaYML(fullPath);
    }
    showRunSQLOnActiveWindow() {
     var _a;
     const fullPath = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
     void 0 !== fullPath && this.showRunSQL(fullPath);
    }
    generateDBTDocsOnActiveWindow() {
     var _a;
     const fullPath = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
     void 0 !== fullPath && this.generateDBTDocs(fullPath);
    }
    runDBTModel(modelPath, type) {
     this.dbtProjectContainer.runModel(modelPath, type);
    }
    buildDBTModel(modelPath, type) {
     this.dbtProjectContainer.buildModel(modelPath, type);
    }
    compileDBTModel(modelPath, type) {
     this.dbtProjectContainer.compileModel(modelPath, type);
    }
    generateDBTDocs(modelPath, type) {
     this.dbtProjectContainer.generateDocs(modelPath);
    }
    compileDBTQuery(modelPath, query) {
     this.dbtProjectContainer.compileQuery(modelPath, query);
    }
    runDBTTest(modelPath, testName) {
     this.dbtProjectContainer.runTest(modelPath, testName);
    }
    runDBTModelTest(modelPath) {
     const modelName = path.basename(modelPath.fsPath, ".sql");
     this.dbtProjectContainer.runModelTest(modelPath, modelName);
    }
    executeSQL(uri, query, title) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.dbtProjectContainer.executeSQL(uri, query);
     }));
    }
    getSummary(uri, query) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.dbtProjectContainer.getSummary(uri, query);
     }));
    }
    showCompiledSQL(modelPath) {
     this.dbtProjectContainer.showCompiledSQL(modelPath);
    }
    generateSchemaYML(modelPath) {
     const modelName = path.basename(modelPath.fsPath, ".sql");
     this.dbtProjectContainer.generateSchemaYML(modelPath, modelName);
    }
    showRunSQL(modelPath) {
     this.dbtProjectContainer.showRunSQL(modelPath);
    }
    createModelBasedonSourceConfig(params) {
     const project = this.dbtProjectContainer.findDBTProject(params.currentDoc), sourcePath = path.dirname(params.currentDoc.fsPath);
     project ? project.generateModel(params.sourceName, params.tableName, sourcePath) : vscode_1.window.showErrorMessage((0, 
     utils_1.extendErrorWithSupportLinks)("Could not generate model! No project found for " + params.currentDoc.fsPath + "."));
    }
   };
   RunModel = RunModel_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(RunModel_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer ]) ], RunModel), 
   exports.RunModel = RunModel;
  },
  62639: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var SqlToModel_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SqlToModel = void 0;
   const tslib_1 = __webpack_require__(70655), altimate_1 = __webpack_require__(99160), dbtProjectContainer_1 = __webpack_require__(37343), telemetry_1 = __webpack_require__(27407), utils_1 = __webpack_require__(78593), vscode_1 = __webpack_require__(66828);
   let SqlToModel = SqlToModel_1 = class {
    constructor(dbtProjectContainer, telemetry, altimate) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.altimate = altimate, 
     this.eventMap = new Map, dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event)));
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
       this.eventMap.set(added.project.projectRoot.fsPath, added);
      })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
       this.eventMap.delete(removed.projectRoot.fsPath);
      }));
     }));
    }
    getModelFromSql() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (!this.altimate.handlePreviewFeatures()) return;
      if (this.telemetry.sendTelemetryEvent("sqlToModel"), !vscode_1.window.activeTextEditor) return;
      const activedoc = vscode_1.window.activeTextEditor, currentFilePath = activedoc.document.uri, allmodels = [], project = this.dbtProjectContainer.findDBTProject(currentFilePath);
      if (void 0 === project) return vscode_1.window.showErrorMessage("Could not find a dbt project.       Please put the new model in a dbt project before converting to a model."), 
      void this.telemetry.sendTelemetryError("sqlToModelNoProjectError");
      const event = this.eventMap.get(project.projectRoot.fsPath);
      if (void 0 === event) return vscode_1.window.showErrorMessage("Could not convert to model due to pending initiation,       Please retry again."), 
      void this.telemetry.sendTelemetryError("sqlToModelNoManifestError");
      const rriter = event.nodeMetaMap.values();
      for (const rrvalue of rriter) allmodels.push(rrvalue);
      const allsources = [], srcriter = event.sourceMetaMap.values();
      for (const srcvalue of srcriter) allsources.push(srcvalue);
      const fileText = activedoc.document.getText();
      let compiledSql;
      try {
       compiledSql = yield project.unsafeCompileQuery(fileText);
      } catch (error) {
       return void vscode_1.window.showErrorMessage("Could not compile the SQL: " + error.message);
      }
      const retobj = yield this.altimate.runModeller({
       sql: compiledSql || fileText,
       adapter: project.getAdapterType(),
       models: allmodels,
       sources: allsources
      }).catch((err => {
       vscode_1.window.showErrorMessage("Could not convert sql to model.         Encountered unknown error when converting sql to model."), 
       this.telemetry.sendTelemetryError("sqlToModelBackendError", err), console.error(err);
      }));
      if (void 0 === retobj || void 0 === retobj.sql) return vscode_1.window.showErrorMessage("Could not convert sql to model.         Encountered unknown error when converting sql to model."), 
      void this.telemetry.sendTelemetryError("sqlToModelEmptyBackendResponseError");
      const startpos = new vscode_1.Position(0, 0), endpos = new vscode_1.Position(activedoc.document.lineCount, activedoc.document.lineAt(activedoc.document.lineCount - 1).text.length);
      activedoc.edit((editBuilder => {
       editBuilder.replace(new vscode_1.Range(startpos, endpos), retobj.sql);
      }));
     }));
    }
   };
   SqlToModel = SqlToModel_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(SqlToModel_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService, altimate_1.AltimateRequest ]) ], SqlToModel), 
   exports.SqlToModel = SqlToModel;
  },
  42262: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var InitCatalog_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.InitCatalog = void 0;
   const tslib_1 = __webpack_require__(70655), utils_1 = __webpack_require__(78593);
   let InitCatalog = InitCatalog_1 = class {
    run(scanContext) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const project = scanContext.project, scanResults = scanContext.scanResults, cata = yield project.getCatalog();
      if (0 === cata.length) {
       let catalogResults = scanResults.missingCatalog;
       void 0 === catalogResults && (catalogResults = scanResults.missingCatalog = {}), 
       scanResults.missingCatalog[project.getProjectName() + project.projectRoot] = !0;
      }
      return cata.reduce(((mdict, model) => {
       const modelKey = JSON.stringify({
        projectroot: project.projectRoot.fsPath,
        project: project.getProjectName(),
        database: model.table_database.toLowerCase(),
        schema: model.table_schema.toLowerCase(),
        name: model.table_name.toLowerCase()
       });
       return mdict[modelKey] = mdict[modelKey] || [], mdict[modelKey].push(model), mdict;
      }), Object.create(null));
     }));
    }
   };
   InitCatalog = InitCatalog_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(InitCatalog_1) ], InitCatalog), 
   exports.InitCatalog = InitCatalog;
  },
  78033: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var MissingSchemaTest_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.MissingSchemaTest = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593), dbtProject_1 = __webpack_require__(49827);
   let MissingSchemaTest = MissingSchemaTest_1 = class {
    run(scanContext) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {eventMap: projectEventMap, diagnostics: projectDiagnostics, scanResults} = scanContext;
      if (void 0 === projectEventMap) return;
      const {nodeMetaMap} = projectEventMap;
      for (const [key, value] of nodeMetaMap) if (value.uniqueId.startsWith(dbtProject_1.DBTProject.RESOURCE_TYPE_MODEL) && "seed" !== value.config.materialized && "ephemeral" !== value.config.materialized && !value.patch_path) {
       const errMessage = `Documentation missing for model: ${value.name}`;
       let projDiagnostic = projectDiagnostics[value.path];
       void 0 === projDiagnostic && (projectDiagnostics[value.path] = projDiagnostic = []), 
       projDiagnostic.push(new vscode_1.Diagnostic(new vscode_1.Range(0, 0, 0, 0), errMessage, vscode_1.DiagnosticSeverity.Information));
       let missingDocsDict = scanResults.missingDoc;
       void 0 === missingDocsDict && (scanResults.missingDoc = missingDocsDict = new Set), 
       missingDocsDict.add(value.uniqueId);
      }
     }));
    }
   };
   MissingSchemaTest = MissingSchemaTest_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(MissingSchemaTest_1) ], MissingSchemaTest), 
   exports.MissingSchemaTest = MissingSchemaTest;
  },
  83335: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ScanContext = void 0;
   exports.ScanContext = class {
    constructor(project, eventMap) {
     this.catalog = {}, this.scanResults = {}, this.project = project, this.catalog = {}, 
     this.eventMap = eventMap, this.diagnostics = {};
    }
   };
  },
  50894: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var StaleModelColumnTest_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.StaleModelColumnTest = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), fs_1 = __webpack_require__(57147), utils_1 = __webpack_require__(78593), parsers_1 = __webpack_require__(70564);
   let StaleModelColumnTest = StaleModelColumnTest_1 = class {
    getTextLocation(modelname, colname, schemaPath) {
     const docContent = (0, fs_1.readFileSync)(schemaPath, "utf-8"), modelRegex = new RegExp(`\\bname\\:\\s*?${modelname}\\b`), modelMatch = docContent.match(modelRegex);
     if (!modelMatch) return;
     const colRegex = new RegExp(`\\bname\\:\\s*?${colname}\\b|\\balias\\:\\s*?${colname}\\b`, "g");
     let colMatch;
     for (;null !== (colMatch = colRegex.exec(docContent)); ) if (colMatch.index > (modelMatch.index || 0)) {
      const lines = docContent.substring(0, colMatch.index).split("\n"), line = lines.length - 1, char = lines[line].length, matchLength = colMatch[0].length;
      return new vscode_1.Range(line, char + matchLength - colname.length, line, char + matchLength);
     }
    }
    run(scanContext) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {project, catalog: altimateCatalog, eventMap: projectEventMap, diagnostics: projectDiagnostics} = scanContext, projectName = project.getProjectName(), projectRootUri = project.projectRoot;
      if (void 0 === projectEventMap) return;
      const {nodeMetaMap} = projectEventMap;
      for (const [key, value] of nodeMetaMap) {
       if ("ephemeral" === value.config.materialized) continue;
       const modelKey = JSON.stringify({
        projectroot: projectRootUri.fsPath,
        project: projectName,
        database: value.database.toLowerCase(),
        schema: value.schema.toLowerCase(),
        name: value.alias.toLowerCase()
       });
       if (Object.keys(altimateCatalog[projectName + projectRootUri]).includes(modelKey)) {
        const modelDict = altimateCatalog[projectName + projectRootUri][modelKey], allDBColumns = (Object.keys(value.columns).map((key => key.toLowerCase())), 
        modelDict.map((({column_name}) => column_name.toLowerCase()))), packagePath = project.getPackageInstallPath();
        if (void 0 === packagePath) throw new Error("packagePath is not defined in " + project.projectRoot.fsPath);
        for (const existingCol of Object.keys(value.columns)) if (!allDBColumns.includes(existingCol.toLowerCase())) {
         const errMessage = `Column ${existingCol} listed in model ${value.name} is not found in the database.\n            It may be outdated or misspelled.`, schemaPath = (0, 
         parsers_1.createFullPathForNode)(projectName, projectRootUri.fsPath, value.package_name, packagePath, value.patch_path.split("://")[1]) || vscode_1.Uri.joinPath(project.projectRoot, value.patch_path.split("://")[1]).fsPath, colInDocRange = this.getTextLocation(value.name, existingCol, schemaPath);
         let schemaDiagnostics = projectDiagnostics[schemaPath];
         void 0 === schemaDiagnostics && (projectDiagnostics[schemaPath] = schemaDiagnostics = []), 
         schemaDiagnostics.push(new vscode_1.Diagnostic(colInDocRange || new vscode_1.Range(0, 0, 0, 0), errMessage, vscode_1.DiagnosticSeverity.Warning));
        }
       }
      }
     }));
    }
   };
   StaleModelColumnTest = StaleModelColumnTest_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(StaleModelColumnTest_1) ], StaleModelColumnTest), 
   exports.StaleModelColumnTest = StaleModelColumnTest;
  },
  64603: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var UndocumentedModelColumnTest_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.UndocumentedModelColumnTest = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593);
   let UndocumentedModelColumnTest = UndocumentedModelColumnTest_1 = class {
    run(scanContext) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {project, catalog: altimateCatalog, eventMap: projectEventMap, diagnostics: projectDiagnostics, scanResults} = scanContext, projectName = project.getProjectName(), projectRootUri = project.projectRoot;
      if (void 0 === projectEventMap) return;
      const {nodeMetaMap} = projectEventMap;
      for (const [key, value] of nodeMetaMap) {
       if (void 0 !== scanResults.missingDoc && scanResults.missingDoc.has(value.uniqueId) || "seed" === value.config.materialized || "ephemeral" === value.config.materialized) continue;
       const modelKey = JSON.stringify({
        projectroot: projectRootUri.fsPath,
        project: projectName,
        database: value.database.toLowerCase(),
        schema: value.schema.toLowerCase(),
        name: value.alias.toLowerCase()
       });
       if (Object.keys(altimateCatalog[projectName + projectRootUri]).includes(modelKey)) {
        const modelDict = altimateCatalog[projectName + projectRootUri][modelKey], existingColumnsLowered = Object.keys(value.columns).map((key => key.toLowerCase()));
        for (const column of modelDict) if (!existingColumnsLowered.includes(column.column_name.toLowerCase())) {
         const errMessage = `Column ${column.column_name} is undocumented in model: ${value.name}`;
         let modelDiagnostics = projectDiagnostics[value.path];
         void 0 === modelDiagnostics && (projectDiagnostics[value.path] = modelDiagnostics = []), 
         modelDiagnostics.push(new vscode_1.Diagnostic(new vscode_1.Range(0, 0, 0, 0), errMessage, vscode_1.DiagnosticSeverity.Information));
        }
       }
      }
     }));
    }
   };
   UndocumentedModelColumnTest = UndocumentedModelColumnTest_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(UndocumentedModelColumnTest_1) ], UndocumentedModelColumnTest), 
   exports.UndocumentedModelColumnTest = UndocumentedModelColumnTest;
  },
  32855: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var UnmaterializedModelTest_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.UnmaterializedModelTest = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593);
   let UnmaterializedModelTest = UnmaterializedModelTest_1 = class {
    run(scanContext) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {project, catalog: altimateCatalog, eventMap: projectEventMap, diagnostics: projectDiagnostics} = scanContext, projectName = project.getProjectName(), projectRootUri = project.projectRoot;
      if (void 0 === projectEventMap) return;
      const {nodeMetaMap} = projectEventMap;
      for (const [key, value] of nodeMetaMap) {
       if ("ephemeral" === value.config.materialized) continue;
       const modelKey = JSON.stringify({
        projectroot: projectRootUri.fsPath,
        project: projectName,
        database: value.database.toLowerCase(),
        schema: value.schema.toLowerCase(),
        name: value.alias.toLowerCase()
       });
       if (!Object.keys(altimateCatalog[projectName + projectRootUri]).includes(modelKey)) {
        const errMessage = `Model ${value.name} does not exist in the database`;
        let modelDiagnostics = projectDiagnostics[value.path];
        void 0 === modelDiagnostics && (projectDiagnostics[value.path] = modelDiagnostics = []), 
        modelDiagnostics.push(new vscode_1.Diagnostic(new vscode_1.Range(0, 0, 0, 0), errMessage, vscode_1.DiagnosticSeverity.Information));
       }
      }
     }));
    }
   };
   UnmaterializedModelTest = UnmaterializedModelTest_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(UnmaterializedModelTest_1) ], UnmaterializedModelTest), 
   exports.UnmaterializedModelTest = UnmaterializedModelTest;
  },
  25695: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ValidateSql_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ValidateSql = void 0;
   const tslib_1 = __webpack_require__(70655), path_1 = __webpack_require__(71017), altimate_1 = __webpack_require__(99160), dbtProjectContainer_1 = __webpack_require__(37343), telemetry_1 = __webpack_require__(27407), utils_1 = __webpack_require__(78593), vscode_1 = __webpack_require__(66828), dbtProject_1 = __webpack_require__(49827), vscode_2 = __webpack_require__(66828), sqlPreviewContentProvider_1 = __webpack_require__(17179), python_bridge_1 = __webpack_require__(1438);
   let ValidateSql = ValidateSql_1 = class {
    constructor(dbtProjectContainer, telemetry, altimate) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.altimate = altimate, 
     this.eventMap = new Map, dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))), 
     this.diagnosticsCollection = vscode_2.languages.createDiagnosticCollection();
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
       this.eventMap.set(added.project.projectRoot.fsPath, added);
      })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
       this.eventMap.delete(removed.projectRoot.fsPath);
      }));
     }));
    }
    showError(exc) {
     if (exc instanceof python_bridge_1.PythonException) return vscode_1.window.showErrorMessage((0, 
     utils_1.extendErrorWithSupportLinks)("An error occured while trying to compile your model: " + exc.exception.message + ".")), 
     this.telemetry.sendTelemetryError("validateSQLCompileNodePythonError", exc), console.error("Error encountered while compiling/retrieving schema for model: "), 
     void console.error("Exception: " + exc.exception.message + "\n\nDetailed error information:\n" + exc);
     this.telemetry.sendTelemetryError("validateSQLCompileNodeUnknownError", exc), vscode_1.window.showErrorMessage((0, 
     utils_1.extendErrorWithSupportLinks)("Encountered an unknown issue: " + exc + " while compiling/retrieving schema for nodes."));
    }
    validateSql() {
     var _a, _b, _c, _d;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (this.telemetry.sendTelemetryEvent("validateSql"), !vscode_1.window.activeTextEditor) return;
      const currentFilePath = vscode_1.window.activeTextEditor.document.uri, project = this.dbtProjectContainer.findDBTProject(currentFilePath);
      if (!project) return void (yield vscode_1.window.showErrorMessage("Unable to build project"));
      const modelName = (0, path_1.basename)(currentFilePath.fsPath, ".sql"), event = this.getEvent();
      if (!event) return;
      const {graphMetaMap} = event, node = event.nodeMetaMap.get(modelName);
      if (!node) return;
      const parentNodes = null === (_a = graphMetaMap.parents.get(node.uniqueId)) || void 0 === _a ? void 0 : _a.nodes;
      if (!parentNodes) return;
      const parentModels = [], relationsWithoutColumns = [];
      let compiledQuery;
      if (yield vscode_1.window.withProgress({
       location: vscode_1.ProgressLocation.Notification,
       title: "Fetching metadata",
       cancellable: !1
      }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       var _e, _f;
       try {
        const fileContentBytes = yield vscode_2.workspace.fs.readFile(currentFilePath);
        try {
         compiledQuery = yield project.unsafeCompileQuery(fileContentBytes.toString());
        } catch (error) {
         return void vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Unable to compile query for model " + node.name + " : " + error));
        }
        const queue = parentNodes.map((n => n.key)), visited = {};
        for (;queue.length > 0; ) {
         const curr = queue.shift();
         if (visited[curr]) continue;
         visited[curr] = !0;
         const model = yield this.getNodeWithDBColumns(curr);
         if (!model) continue;
         const {node, isEphemeral, dbColumnAdded} = model;
         isEphemeral ? queue.push(...(null === (_f = null === (_e = graphMetaMap.parents.get(curr)) || void 0 === _e ? void 0 : _e.nodes) || void 0 === _f ? void 0 : _f.map((n => n.key))) || []) : dbColumnAdded ? parentModels.push(node) : relationsWithoutColumns.push(curr);
        }
       } catch (exc) {
        this.showError(exc);
       }
      })))), !compiledQuery) return;
      0 !== relationsWithoutColumns.length && vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Failed to fetch columns for " + relationsWithoutColumns.join(", ") + ". Probably the dbt models are not yet materialized."));
      const request = {
       sql: compiledQuery,
       dialect: project.getAdapterType(),
       models: parentModels
      }, response = yield null === (_b = this.getProject()) || void 0 === _b ? void 0 : _b.validateSql(request), activeUri = null === (_c = vscode_1.window.activeTextEditor) || void 0 === _c ? void 0 : _c.document.uri;
      if (activeUri.scheme === sqlPreviewContentProvider_1.SqlPreviewContentProvider.SCHEME) return;
      const compileSQLUri = activeUri.with({
       scheme: sqlPreviewContentProvider_1.SqlPreviewContentProvider.SCHEME
      }), isOpen = !!vscode_1.window.visibleTextEditors.find((item => item.document.uri === compileSQLUri));
      if (!response || !(null == response ? void 0 : response.error_type)) {
       const tabGroup = vscode_1.window.tabGroups.all.find((tabGroup => {
        var _a, _b;
        return (null === (_b = null === (_a = tabGroup.activeTab) || void 0 === _a ? void 0 : _a.input) || void 0 === _b ? void 0 : _b.uri.toString()) === compileSQLUri.toString();
       }));
       return tabGroup && (yield vscode_1.window.tabGroups.close(tabGroup)), vscode_1.window.showInformationMessage("SQL is valid."), 
       void this.diagnosticsCollection.set(compileSQLUri, []);
      }
      if ("sql_unknown_error" === response.error_type) return vscode_1.window.showErrorMessage("Unable to validate SQL."), 
      this.telemetry.sendTelemetryError("validateSQLError", response.errors[0].description), 
      void this.diagnosticsCollection.set(compileSQLUri, []);
      if (("sql_parse_error" === response.error_type || response.errors.length > 0 && response.errors[0].start_position) && !isOpen) {
       const doc = yield vscode_2.workspace.openTextDocument(compileSQLUri);
       yield vscode_1.window.showTextDocument(doc, vscode_1.ViewColumn.Beside, !0), yield vscode_2.languages.setTextDocumentLanguage(doc, "sql");
      }
      vscode_2.commands.executeCommand("workbench.action.problems.focus");
      const diagnostics = null === (_d = null == response ? void 0 : response.errors) || void 0 === _d ? void 0 : _d.map((({description, start_position, end_position}) => {
       let startPos = new vscode_2.Position(0, 1), endPos = new vscode_2.Position(0, 1);
       return start_position && (startPos = new vscode_2.Position(start_position[0], start_position[1])), 
       end_position && (endPos = new vscode_2.Position(end_position[0], end_position[1])), 
       new vscode_2.Diagnostic(new vscode_2.Range(startPos, endPos), description, vscode_2.DiagnosticSeverity.Error);
      }));
      this.diagnosticsCollection.set(compileSQLUri, diagnostics);
     }));
    }
    getProject() {
     var _a;
     const currentFilePath = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
     if (currentFilePath) return this.dbtProjectContainer.findDBTProject(currentFilePath);
    }
    getEvent() {
     if (void 0 === vscode_1.window.activeTextEditor || void 0 === this.eventMap) return;
     const currentFilePath = vscode_1.window.activeTextEditor.document.uri, projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (void 0 === projectRootpath) return;
     const event = this.eventMap.get(projectRootpath.fsPath);
     return void 0 !== event ? event : void 0;
    }
    addModelColumnsFromDB(project, node) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const columnsFromDB = yield project.getColumnsOfModel(node.name);
      if (console.log("addColumnsFromDB: ", node.name, " -> ", columnsFromDB), !columnsFromDB || 0 === columnsFromDB.length) return !1;
      columnsFromDB.length > 100 && this.telemetry.sendTelemetryEvent("validateSQLExcessiveColumnsFetchedFromDB");
      const columns = {};
      return Object.entries(node.columns).forEach((([k, v]) => {
       columns[k.toLowerCase()] = v;
      })), columnsFromDB.forEach((c => {
       const existing_column = columns[c.column.toLowerCase()];
       existing_column ? existing_column.data_type = existing_column.data_type || c.dtype : node.columns[c.column] = {
        name: c.column,
        data_type: c.dtype,
        description: ""
       };
      })), Object.keys(node.columns).length > columnsFromDB.length && this.telemetry.sendTelemetryEvent("validateSQLPossibleStaleSchema"), 
      !0;
     }));
    }
    addSourceColumnsFromDB(project, nodeName, table) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      Date.now();
      const columnsFromDB = yield project.getColumnsOfSource(nodeName, table.name);
      if (console.log("addColumnsFromDB: ", nodeName, " -> ", columnsFromDB), !columnsFromDB || 0 === columnsFromDB.length) return !1;
      columnsFromDB.length > 100 && this.telemetry.sendTelemetryEvent("validateSQLExcessiveColumnsFetchedFromDB");
      const columns = {};
      return Object.entries(table.columns).forEach((([k, v]) => {
       columns[k.toLowerCase()] = v;
      })), columnsFromDB.forEach((c => {
       const existing_column = columns[c.column.toLowerCase()];
       existing_column ? existing_column.data_type = existing_column.data_type || c.dtype : table.columns[c.column] = {
        name: c.column,
        data_type: c.dtype,
        description: ""
       };
      })), Object.keys(table.columns).length > columnsFromDB.length && this.telemetry.sendTelemetryEvent("validateSQLPossibleStaleSchema"), 
      !0;
     }));
    }
    getNodeWithDBColumns(key) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const event = this.getEvent();
      if (!event) return;
      const project = this.getProject();
      if (!project) return;
      const splits = key.split("."), nodeType = splits[0], {nodeMetaMap, sourceMetaMap} = event;
      if (nodeType === dbtProject_1.DBTProject.RESOURCE_TYPE_SOURCE) {
       const source = sourceMetaMap.get(splits[2]), tableName = splits[3];
       if (!source) return;
       const table = null == source ? void 0 : source.tables.find((t => t.name === tableName));
       if (!table) return;
       return {
        dbColumnAdded: yield this.addSourceColumnsFromDB(project, source.name, table),
        node: {
         database: source.database,
         schema: source.schema,
         name: table.name,
         alias: table.name,
         uniqueId: key,
         columns: table.columns
        }
       };
      }
      const node = nodeMetaMap.get(splits[2]);
      if (!node) return;
      if ("ephemeral" === node.config.materialized) return {
       dbColumnAdded: !1,
       node,
       isEphemeral: !0
      };
      return {
       dbColumnAdded: yield this.addModelColumnsFromDB(project, node),
       node
      };
     }));
    }
   };
   ValidateSql = ValidateSql_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(ValidateSql_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService, altimate_1.AltimateRequest ]) ], ValidateSql), 
   exports.ValidateSql = ValidateSql;
  },
  28129: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var WalkthroughCommands_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.WalkthroughCommands = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593), dbtProjectContainer_1 = __webpack_require__(37343), telemetry_1 = __webpack_require__(27407), commandProcessExecution_1 = __webpack_require__(11986), pythonEnvironment_1 = __webpack_require__(53003), dbtTerminal_1 = __webpack_require__(26684);
   var PromptAnswer, DbtInstallationPromptAnswer;
   !function(PromptAnswer) {
    PromptAnswer.YES = "Yes", PromptAnswer.NO = "No";
   }(PromptAnswer || (PromptAnswer = {})), function(DbtInstallationPromptAnswer) {
    DbtInstallationPromptAnswer.INSTALL = "Install dbt";
   }(DbtInstallationPromptAnswer || (DbtInstallationPromptAnswer = {}));
   let WalkthroughCommands = WalkthroughCommands_1 = class {
    constructor(dbtProjectContainer, telemetry, commandProcessExecutionFactory, pythonEnvironment, dbtTerminal) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.commandProcessExecutionFactory = commandProcessExecutionFactory, 
     this.pythonEnvironment = pythonEnvironment, this.dbtTerminal = dbtTerminal;
    }
    validateProjects(projectContext) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (void 0 === projectContext) return void vscode_1.window.showErrorMessage("No project was selected, please select a project in the step 'Pick a dbt project' above.");
      if ((yield vscode_1.window.showInformationMessage(`Do you want to validate the project: ${projectContext.label}? This will run the command 'dbt debug' inside this project. Do you want to continue?`, PromptAnswer.YES, PromptAnswer.NO)) === PromptAnswer.YES) try {
       this.telemetry.sendTelemetryEvent("validateProject");
       const project = this.dbtProjectContainer.findDBTProject(projectContext.uri);
       if (void 0 === project) return void vscode_1.window.showErrorMessage(`Project ${projectContext.label} was not found`);
       const runModelOutput = yield project.debug();
       if (runModelOutput.includes("ERROR")) throw new Error(runModelOutput);
      } catch (err) {
       console.log(err), this.telemetry.sendTelemetryError("validateProjectError", err), 
       vscode_1.window.showErrorMessage("Error running dbt debug for project " + projectContext.label + ". Please check the output tab for more details.");
      }
     }));
    }
    installDeps(projectContext) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (void 0 === projectContext) return void vscode_1.window.showErrorMessage("No project was selected, please select a project in the step 'Pick a dbt project' above.");
      if ((yield vscode_1.window.showInformationMessage(`Do you want to install packages for the project: ${projectContext.label}? This will run the command 'dbt deps' inside this project. Do you want to continue?`, PromptAnswer.YES, PromptAnswer.NO)) === PromptAnswer.YES) try {
       this.telemetry.sendTelemetryEvent("installDeps");
       const project = this.dbtProjectContainer.findDBTProject(projectContext.uri);
       if (void 0 === project) return void vscode_1.window.showErrorMessage(`Project ${projectContext.label} was not found`);
       yield project.installDeps();
      } catch (err) {
       console.log(err), this.telemetry.sendTelemetryError("installDepsError", err), vscode_1.window.showErrorMessage("Error installing dbt dependencies for project " + projectContext.label + ". Please check the output tab for more details.");
      }
     }));
    }
    installDbt() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const dbtVersion = yield vscode_1.window.showQuickPick([ "1.0", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7" ].map((value => ({
       label: value
      }))), {
       title: "Select your dbt version",
       canPickMany: !1
      });
      if (!dbtVersion) return;
      const adapter = yield vscode_1.window.showQuickPick([ "snowflake", "bigquery", "redshift", "postgres", "databricks", "sqlserver", "duckdb", "athena", "spark", "clickhouse", "trino", "synapse" ].map((value => ({
       label: value
      }))), {
       title: "Select your adapter",
       canPickMany: !1
      });
      if (!adapter || !adapter.label) return;
      const packageVersion = dbtVersion.label, packageName = this.mapToAdapterPackage(adapter.label);
      let error;
      if (yield vscode_1.window.withProgress({
       title: `Installing ${packageName} ${packageVersion}...`,
       location: vscode_1.ProgressLocation.Notification,
       cancellable: !1
      }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       try {
        yield this.commandProcessExecutionFactory.createCommandProcessExecution({
         command: this.pythonEnvironment.pythonPath,
         args: [ "-m", "pip", "install", `${packageName}==${packageVersion}` ],
         cwd: (0, utils_1.getFirstWorkspacePath)(),
         envVars: this.pythonEnvironment.environmentVariables
        }).completeWithTerminalOutput(this.dbtTerminal);
        yield this.dbtProjectContainer.detectDBT(), this.dbtProjectContainer.initialize();
       } catch (err) {
        error = err;
       }
      })))), error) {
       (yield vscode_1.window.showErrorMessage("Could not install dbt: " + error.message, DbtInstallationPromptAnswer.INSTALL)) === DbtInstallationPromptAnswer.INSTALL && vscode_1.commands.executeCommand("dbtPowerUser.installDbt");
      }
     }));
    }
    mapToAdapterPackage(adapter) {
     switch (adapter) {
     case "snowflake":
      return "dbt-snowflake";

     case "bigquery":
      return "dbt-bigquery";

     case "redshift":
      return "dbt-redshift";

     case "postgres":
      return "dbt-postgres";

     case "databricks":
      return "dbt-databricks";

     case "sqlserver":
      return "dbt-sqlserver";

     case "duckdb":
      return "dbt-duckdb";

     case "athena":
      return "dbt-athena-community";

     case "spark":
      return "dbt-spark";

     case "clickhouse":
      return "dbt-clickhouse";

     case "trino":
      return "dbt-trino";

     case "synapse":
      return "dbt-synapse";
     }
     throw new Error("Adapter is not supported" + adapter);
    }
   };
   WalkthroughCommands = WalkthroughCommands_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(WalkthroughCommands_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService, commandProcessExecution_1.CommandProcessExecutionFactory, pythonEnvironment_1.PythonEnvironment, dbtTerminal_1.DBTTerminal ]) ], WalkthroughCommands), 
   exports.WalkthroughCommands = WalkthroughCommands;
  },
  30762: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ContentProviders_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ContentProviders = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593), sqlPreviewContentProvider_1 = __webpack_require__(17179);
   let ContentProviders = ContentProviders_1 = class {
    constructor(sqlPreviewContentProvider) {
     this.sqlPreviewContentProvider = sqlPreviewContentProvider, this.disposables = [], 
     this.disposables.push(vscode_1.workspace.registerTextDocumentContentProvider(sqlPreviewContentProvider_1.SqlPreviewContentProvider.SCHEME, this.sqlPreviewContentProvider));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   ContentProviders = ContentProviders_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(ContentProviders_1), tslib_1.__metadata("design:paramtypes", [ sqlPreviewContentProvider_1.SqlPreviewContentProvider ]) ], ContentProviders), 
   exports.ContentProviders = ContentProviders;
  },
  17179: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var SqlPreviewContentProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SqlPreviewContentProvider = void 0;
   const tslib_1 = __webpack_require__(70655), fs_1 = __webpack_require__(57147), vscode_1 = __webpack_require__(66828), dbtProjectContainer_1 = __webpack_require__(37343), utils_1 = __webpack_require__(78593), telemetry_1 = __webpack_require__(27407);
   let SqlPreviewContentProvider = SqlPreviewContentProvider_1 = class {
    constructor(dbtProjectContainer, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this._onDidChange = new vscode_1.EventEmitter, 
     this.compilationDocs = new Map, this.watchers = [], this.subscriptions = vscode_1.workspace.onDidCloseTextDocument((compilationDoc => this.compilationDocs.delete(compilationDoc.uri.toString())));
    }
    dispose() {
     for (this._onDidChange.dispose(), this.subscriptions.dispose(); this.watchers.length; ) {
      const x = this.watchers.pop();
      x && x.dispose();
     }
    }
    get onDidChange() {
     return this._onDidChange.event;
    }
    provideTextDocumentContent(uri) {
     if (void 0 === this.compilationDocs.get(uri.toString())) {
      this.compilationDocs.set(uri.toString(), uri);
      const watcher = vscode_1.workspace.createFileSystemWatcher(new vscode_1.RelativePattern(uri, "*"));
      this.watchers.push(watcher), watcher.onDidChange((0, utils_1.debounce)((() => this._onDidChange.fire(uri)), 500));
     }
     return this.requestCompilation(uri);
    }
    requestCompilation(uri) {
     try {
      const fsPath = decodeURI(uri.fsPath), query = (0, fs_1.readFileSync)(fsPath, "utf8"), project = this.dbtProjectContainer.findDBTProject(vscode_1.Uri.file(fsPath));
      return void 0 === project ? (this.telemetry.sendTelemetryError("sqlPreviewNotLoadingError"), 
      "Still loading dbt project, please try again later...") : (this.telemetry.sendTelemetryEvent("requestCompilation"), 
      project.unsafeCompileQuery(query));
     } catch (error) {
      return error;
     }
    }
   };
   SqlPreviewContentProvider.SCHEME = "query-preview", SqlPreviewContentProvider = SqlPreviewContentProvider_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(SqlPreviewContentProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], SqlPreviewContentProvider), 
   exports.SqlPreviewContentProvider = SqlPreviewContentProvider;
  },
  92182: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DBTPowerUserExtension_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DBTPowerUserExtension = void 0;
   const tslib_1 = __webpack_require__(70655), autocompletion_provider_1 = __webpack_require__(8403), code_lens_provider_1 = __webpack_require__(90475), commands_1 = __webpack_require__(45885), content_provider_1 = __webpack_require__(30762), definition_provider_1 = __webpack_require__(68740), document_formatting_edit_provider_1 = __webpack_require__(68998), dbtProjectContainer_1 = __webpack_require__(37343), statusbar_1 = __webpack_require__(65256), treeview_provider_1 = __webpack_require__(8961), utils_1 = __webpack_require__(78593), webview_provider_1 = __webpack_require__(47888), telemetry_1 = __webpack_require__(27407), hover_provider_1 = __webpack_require__(23867), quickpick_1 = __webpack_require__(83213), validation_provider_1 = __webpack_require__(12497);
   let DBTPowerUserExtension = DBTPowerUserExtension_1 = class {
    constructor(dbtProjectContainer, webviewViewProviders, autocompletionProviders, definitionProviders, vscodeCommands, treeviewProviders, contentProviders, codeLensProviders, documentFormattingEditProviders, statusBars, puStatusBars, telemetry, hoverProviders, validationProvider) {
     this.dbtProjectContainer = dbtProjectContainer, this.webviewViewProviders = webviewViewProviders, 
     this.autocompletionProviders = autocompletionProviders, this.definitionProviders = definitionProviders, 
     this.vscodeCommands = vscodeCommands, this.treeviewProviders = treeviewProviders, 
     this.contentProviders = contentProviders, this.codeLensProviders = codeLensProviders, 
     this.documentFormattingEditProviders = documentFormattingEditProviders, this.statusBars = statusBars, 
     this.puStatusBars = puStatusBars, this.telemetry = telemetry, this.hoverProviders = hoverProviders, 
     this.validationProvider = validationProvider, this.disposables = [], this.disposables.push(this.dbtProjectContainer, this.webviewViewProviders, this.definitionProviders, this.autocompletionProviders, this.treeviewProviders, this.contentProviders, this.codeLensProviders, this.vscodeCommands, this.documentFormattingEditProviders, this.statusBars, this.puStatusBars, this.telemetry, this.hoverProviders, this.validationProvider);
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    activate(context) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.dbtProjectContainer.setContext(context), this.dbtProjectContainer.initializeWalkthrough(), 
      yield this.dbtProjectContainer.detectDBT(), yield this.dbtProjectContainer.initializeDBTProjects();
     }));
    }
   };
   DBTPowerUserExtension.DBT_SQL_SELECTOR = [ {
    language: "jinja-sql",
    scheme: "file"
   }, {
    language: "sql",
    scheme: "file"
   } ], DBTPowerUserExtension.DBT_YAML_SELECTOR = [ {
    language: "yaml",
    scheme: "file"
   }, {
    language: "jinja-yaml",
    scheme: "file"
   } ], DBTPowerUserExtension.DBT_YAML_SQL_SELECTOR = [ {
    language: "jinja-sql",
    scheme: "file"
   }, {
    language: "sql",
    scheme: "file"
   }, {
    language: "yaml",
    scheme: "file"
   }, {
    language: "jinja-yaml",
    scheme: "file"
   } ], DBTPowerUserExtension = DBTPowerUserExtension_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DBTPowerUserExtension_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, webview_provider_1.WebviewViewProviders, autocompletion_provider_1.AutocompletionProviders, definition_provider_1.DefinitionProviders, commands_1.VSCodeCommands, treeview_provider_1.TreeviewProviders, content_provider_1.ContentProviders, code_lens_provider_1.CodeLensProviders, document_formatting_edit_provider_1.DocumentFormattingEditProviders, statusbar_1.StatusBars, quickpick_1.DbtPowerUserActionsCenter, telemetry_1.TelemetryService, hover_provider_1.HoverProviders, validation_provider_1.ValidationProvider ]) ], DBTPowerUserExtension), 
   exports.DBTPowerUserExtension = DBTPowerUserExtension;
  },
  16413: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DBTCoreDetection_1, DBTCoreProjectDetection_1, DBTCoreProjectIntegration_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DBTCoreProjectIntegration = exports.DBTCoreProjectDetection = exports.DBTCoreDetection = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593), dbtIntegration_1 = __webpack_require__(64889), pythonEnvironment_1 = __webpack_require__(53003), commandProcessExecution_1 = __webpack_require__(11986), python_bridge_1 = __webpack_require__(1438), path = __webpack_require__(71017), dbtProject_1 = __webpack_require__(49827), telemetry_1 = __webpack_require__(27407), dbtProjectContainer_1 = __webpack_require__(37343);
   let DBTCoreDetection = DBTCoreDetection_1 = class {
    constructor(pythonEnvironment, commandProcessExecutionFactory) {
     this.pythonEnvironment = pythonEnvironment, this.commandProcessExecutionFactory = commandProcessExecutionFactory;
    }
    detectDBT() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const checkDBTInstalledProcess = this.commandProcessExecutionFactory.createCommandProcessExecution({
        command: this.pythonEnvironment.pythonPath,
        args: [ "-c", "import dbt" ],
        cwd: (0, utils_1.getFirstWorkspacePath)(),
        envVars: this.pythonEnvironment.environmentVariables
       });
       return yield checkDBTInstalledProcess.complete(), !0;
      } catch (error) {
       return !1;
      }
     }));
    }
   };
   DBTCoreDetection = DBTCoreDetection_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DBTCoreDetection_1), tslib_1.__metadata("design:paramtypes", [ pythonEnvironment_1.PythonEnvironment, commandProcessExecution_1.CommandProcessExecutionFactory ]) ], DBTCoreDetection), 
   exports.DBTCoreDetection = DBTCoreDetection;
   let DBTCoreProjectDetection = DBTCoreProjectDetection_1 = class {
    constructor(executionInfrastructure) {
     this.executionInfrastructure = executionInfrastructure;
    }
    discoverProjects(projectDirectories) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      let python, packagesInstallPaths = projectDirectories.map((projectDirectory => path.join(projectDirectory.fsPath, "dbt_packages")));
      try {
       python = this.executionInfrastructure.createPythonBridge((0, utils_1.getFirstWorkspacePath)()), 
       yield python.ex`from dbt_integration import *`;
       const packagesInstallPathsFromPython = yield python.lock((python => python`to_dict(find_package_paths(${projectDirectories.map((projectDirectory => projectDirectory.fsPath))}))`));
       packagesInstallPaths = packagesInstallPaths.map(((packageInstallPath, index) => {
        const packageInstallPathFromPython = packagesInstallPathsFromPython[index];
        return packageInstallPathFromPython ? vscode_1.Uri.file(packageInstallPathFromPython).fsPath : packageInstallPath;
       }));
      } catch (error) {
       console.log("An error occured while finding package paths: " + error);
      } finally {
       python && this.executionInfrastructure.closePythonBridge(python);
      }
      const filteredProjectFiles = projectDirectories.filter((uri => !packagesInstallPaths.some((packageInstallPath => uri.fsPath.startsWith(packageInstallPath)))));
      return filteredProjectFiles.length > 20 && vscode_1.window.showWarningMessage(`dbt Power User detected ${filteredProjectFiles.length} projects in your work space, this will negatively affect performance.`), 
      filteredProjectFiles;
     }));
    }
    dispose() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {}));
    }
   };
   DBTCoreProjectDetection = DBTCoreProjectDetection_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DBTCoreProjectDetection_1), tslib_1.__metadata("design:paramtypes", [ dbtIntegration_1.DBTCommandExecutionInfrastructure ]) ], DBTCoreProjectDetection), 
   exports.DBTCoreProjectDetection = DBTCoreProjectDetection;
   let DBTCoreProjectIntegration = DBTCoreProjectIntegration_1 = class {
    constructor(executionInfrastructure, pythonEnvironment, telemetry, pythonDBTCommandExecutionStrategy, dbtProjectContainer, projectRoot, projectConfigDiagnostics) {
     this.executionInfrastructure = executionInfrastructure, this.pythonEnvironment = pythonEnvironment, 
     this.telemetry = telemetry, this.pythonDBTCommandExecutionStrategy = pythonDBTCommandExecutionStrategy, 
     this.dbtProjectContainer = dbtProjectContainer, this.projectRoot = projectRoot, 
     this.projectConfigDiagnostics = projectConfigDiagnostics, this.disposables = [], 
     this.rebuildManifestDiagnostics = vscode_1.languages.createDiagnosticCollection("dbt"), 
     this.pythonBridgeDiagnostics = vscode_1.languages.createDiagnosticCollection("dbt"), 
     this.python = this.executionInfrastructure.createPythonBridge(this.projectRoot.fsPath), 
     console.log(`Registering project ${this.projectRoot}`), this.disposables.push(this.pythonEnvironment.onPythonEnvironmentChanged((() => {
      this.python = this.executionInfrastructure.createPythonBridge(this.projectRoot.fsPath);
     })), this.rebuildManifestDiagnostics, this.pythonBridgeDiagnostics);
    }
    removeTrailingSlashes(input) {
     return null == input ? void 0 : input.replace(/\\+$/, "");
    }
    refreshProjectConfig() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.createPythonDbtProject(), yield this.python.ex`project.init_project()`, 
      this.targetPath = yield this.findTargetPath(), this.modelPaths = yield this.findModelPaths(), 
      this.macroPaths = yield this.findMacroPaths(), this.packagesInstallPath = yield this.findPackagesInstallPath(), 
      this.version = yield this.findVersion(), this.adapterType = yield this.findAdapterType();
     }));
    }
    executeSQL(query) {
     return this.python.lock((python => python`to_dict(project.execute_sql(${query}))`));
    }
    createPythonDbtProject() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.python.ex`from dbt_integration import *`;
      const targetPath = this.removeTrailingSlashes(yield this.python.lock((python => python`target_path(${this.projectRoot.fsPath})`)));
      yield this.python.ex`project = DbtProject(project_dir=${this.projectRoot.fsPath}, profiles_dir=${this.profilesDir}, target_path=${targetPath}) if 'project' not in locals() else project`;
     }));
    }
    initializeProject() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       if (yield this.python.ex`from dbt_integration import default_profiles_dir`, this.profilesDir = this.removeTrailingSlashes(yield this.python.lock((python => python`default_profiles_dir(${this.projectRoot.fsPath})`))), 
       this.profilesDir) {
        const dbtProfileWatcher = vscode_1.workspace.createFileSystemWatcher(new vscode_1.RelativePattern(this.profilesDir, DBTCoreProjectIntegration_1.DBT_PROFILES_FILE));
        this.disposables.push(dbtProfileWatcher, ...(0, utils_1.setupWatcherHandler)(dbtProfileWatcher, (() => this.rebuildManifest())));
       }
       yield this.createPythonDbtProject(), this.pythonBridgeDiagnostics.clear();
      } catch (exc) {
       if (exc instanceof python_bridge_1.PythonException) {
        if (exc.message.includes("No module named 'dbt'")) return;
        let errorMessage = "An error occured while initializing the dbt project: " + exc.exception.message;
        "dbt.exceptions" === exc.exception.type.module && (errorMessage = "An error occured while initializing the dbt project, dbt found following issue: " + exc.exception.message), 
        this.pythonBridgeDiagnostics.set(vscode_1.Uri.joinPath(this.projectRoot, dbtProject_1.DBTProject.DBT_PROJECT_FILE), [ new vscode_1.Diagnostic(new vscode_1.Range(0, 0, 999, 999), errorMessage) ]), 
        this.telemetry.sendTelemetryError("pythonBridgeInitPythonError", exc);
       } else vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("An unexpected error occured while initializing the dbt project at " + this.projectRoot + ": " + exc + ".")), 
       this.telemetry.sendTelemetryError("pythonBridgeInitError", exc);
      }
     }));
    }
    getTargetPath() {
     return this.targetPath;
    }
    getModelPaths() {
     return this.modelPaths;
    }
    getMacroPaths() {
     return this.macroPaths;
    }
    getPackageInstallPath() {
     return this.packagesInstallPath;
    }
    getAdapterType() {
     return this.adapterType;
    }
    getVersion() {
     return this.version;
    }
    findAdapterType() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.python.lock((python => python`project.config.credentials.type`));
     }));
    }
    rebuildManifest() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const errors = this.projectConfigDiagnostics.get(vscode_1.Uri.joinPath(this.projectRoot, dbtProject_1.DBTProject.DBT_PROJECT_FILE));
      if (!(void 0 !== errors && errors.length > 0)) try {
       yield this.python.lock((python => python`to_dict(project.safe_parse_project())`)), 
       this.rebuildManifestDiagnostics.clear();
      } catch (exc) {
       if (exc instanceof python_bridge_1.PythonException) return this.rebuildManifestDiagnostics.set(vscode_1.Uri.joinPath(this.projectRoot, dbtProject_1.DBTProject.DBT_PROJECT_FILE), [ new vscode_1.Diagnostic(new vscode_1.Range(0, 0, 999, 999), "There is a problem in your dbt project. Compilation failed: " + exc.exception.message) ]), 
       void this.telemetry.sendTelemetryEvent("pythonBridgeCannotParseProjectUserError", {
        error: exc.exception.message,
        adapter: this.getAdapterType() || "unknown"
       });
       this.telemetry.sendTelemetryError("pythonBridgeCannotParseProjectUnknownError", exc, {
        adapter: this.adapterType || "unknown"
       }), vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("An error occured while rebuilding the dbt manifest: " + exc + "."));
      }
     }));
    }
    runModel(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.addCommandToQueue(this.dbtCoreCommand(command));
     }));
    }
    buildModel(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.addCommandToQueue(this.dbtCoreCommand(command));
     }));
    }
    runTest(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.addCommandToQueue(this.dbtCoreCommand(command));
     }));
    }
    runModelTest(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.addCommandToQueue(this.dbtCoreCommand(command));
     }));
    }
    compileModel(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.addCommandToQueue(this.dbtCoreCommand(command));
     }));
    }
    generateDocs(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.addCommandToQueue(this.dbtCoreCommand(command));
     }));
    }
    deps(command) {
     return this.dbtCoreCommand(command).execute();
    }
    debug(command) {
     return this.dbtCoreCommand(command).execute();
    }
    addCommandToQueue(command) {
     this.dbtProjectContainer.showErrorIfDbtOrPythonNotInstalled() && this.executionInfrastructure.addCommandToQueue(command);
    }
    dbtCoreCommand(command) {
     return command.addArgument("--project-dir"), command.addArgument(this.projectRoot.fsPath), 
     this.profilesDir && (command.addArgument("--profiles-dir"), command.addArgument(this.profilesDir)), 
     command.setExecutionStrategy(this.pythonDBTCommandExecutionStrategy), command;
    }
    unsafeCompileNode(modelName) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwBridgeErrorIfAvailable();
      return (yield null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(project.compile_node(project.get_ref_node(${modelName})))`))).compiled_sql;
     }));
    }
    unsafeCompileQuery(query) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwBridgeErrorIfAvailable();
      return (yield null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(project.compile_sql(${query}))`))).compiled_sql;
     }));
    }
    validateSql(query, dialect, models) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwBridgeErrorIfAvailable();
      return yield null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(validate_sql(${query}, ${dialect}, ${models}))`));
     }));
    }
    validateSQLDryRun(query) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwBridgeErrorIfAvailable();
      return yield null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(project.validate_sql_dry_run(${query}))`));
     }));
    }
    getColumnsOfModel(modelName) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwBridgeErrorIfAvailable();
      const node = yield null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(project.get_ref_node(${modelName}))`));
      return node ? this.getColumsOfRelation(node.database, node.schema, node.alias || modelName) : [];
     }));
    }
    getColumnsOfSource(sourceName, tableName) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwBridgeErrorIfAvailable();
      const node = yield null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(project.get_source_node(${sourceName}, ${tableName}))`));
      return node ? this.getColumsOfRelation(node.database, node.schema, node.identifier) : [];
     }));
    }
    getColumsOfRelation(database, schema, objectName) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.throwBridgeErrorIfAvailable(), null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(project.get_columns_in_relation(project.create_relation(${database}, ${schema}, ${objectName})))`));
     }));
    }
    getCatalog() {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.throwBridgeErrorIfAvailable(), yield null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(project.get_catalog())`));
     }));
    }
    findModelPaths() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      let modelPaths = yield this.python.lock((python => python`to_dict(project.config.model_paths)`));
      return modelPaths = modelPaths.map((modelPath => path.isAbsolute(modelPath) ? modelPath : path.join(this.projectRoot.fsPath, modelPath))), 
      modelPaths;
     }));
    }
    findMacroPaths() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      let macroPaths = yield this.python.lock((python => python`to_dict(project.config.macro_paths)`));
      return macroPaths = macroPaths.map((macroPath => path.isAbsolute(macroPath) ? macroPath : path.join(this.projectRoot.fsPath, macroPath))), 
      macroPaths;
     }));
    }
    findTargetPath() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      let targetPath = yield this.python.lock((python => python`to_dict(project.config.target_path)`));
      return path.isAbsolute(targetPath) || (targetPath = path.join(this.projectRoot.fsPath, targetPath)), 
      targetPath;
     }));
    }
    findPackagesInstallPath() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      let packageInstallPath = yield this.python.lock((python => python`to_dict(project.config.packages_install_path)`));
      return path.isAbsolute(packageInstallPath) || (packageInstallPath = path.join(this.projectRoot.fsPath, packageInstallPath)), 
      packageInstallPath;
     }));
    }
    findVersion() {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(project.get_dbt_version())`));
     }));
    }
    throwBridgeErrorIfAvailable() {
     const allDiagnostics = [ this.pythonBridgeDiagnostics, this.rebuildManifestDiagnostics ];
     for (const diagnosticCollection of allDiagnostics) for (const [_, diagnostics] of diagnosticCollection) if (diagnostics.length > 0) {
      const firstError = diagnostics[0];
      throw new Error(firstError.message);
     }
    }
    dispose() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       yield this.executionInfrastructure.closePythonBridge(this.python);
      } catch (error) {}
      for (this.rebuildManifestDiagnostics.clear(), this.pythonBridgeDiagnostics.clear(); this.disposables.length; ) {
       const x = this.disposables.pop();
       x && x.dispose();
      }
     }));
    }
   };
   DBTCoreProjectIntegration.DBT_PROFILES_FILE = "profiles.yml", DBTCoreProjectIntegration = DBTCoreProjectIntegration_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DBTCoreProjectIntegration_1), tslib_1.__metadata("design:paramtypes", [ dbtIntegration_1.DBTCommandExecutionInfrastructure, pythonEnvironment_1.PythonEnvironment, telemetry_1.TelemetryService, dbtIntegration_1.PythonDBTCommandExecutionStrategy, dbtProjectContainer_1.DBTProjectContainer, vscode_1.Uri, Object ]) ], DBTCoreProjectIntegration), 
   exports.DBTCoreProjectIntegration = DBTCoreProjectIntegration;
  },
  64889: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var CLIDBTCommandExecutionStrategy_1, PythonDBTCommandExecutionStrategy_1, DBTCommandExecutionInfrastructure_1, DBTCommandFactory_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DBTCommandFactory = exports.DBTCommandExecutionInfrastructure = exports.DBTIntegrationUnknownError = exports.DBTIntegrationError = exports.DBTCommand = exports.PythonDBTCommandExecutionStrategy = exports.CLIDBTCommandExecutionStrategy = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593), python_bridge_1 = __webpack_require__(1438), inversify_binding_decorators_1 = __webpack_require__(84904), commandProcessExecution_1 = __webpack_require__(11986), pythonEnvironment_1 = __webpack_require__(53003), fs_1 = __webpack_require__(57147), telemetry_1 = __webpack_require__(27407), dbtTerminal_1 = __webpack_require__(26684);
   let CLIDBTCommandExecutionStrategy = CLIDBTCommandExecutionStrategy_1 = class {
    constructor(commandProcessExecutionFactory, pythonEnvironment, terminal, telemetry) {
     this.commandProcessExecutionFactory = commandProcessExecutionFactory, this.pythonEnvironment = pythonEnvironment, 
     this.terminal = terminal, this.telemetry = telemetry;
    }
    execute(command, token) {
     return this.executeCommand(command, token).completeWithTerminalOutput(this.terminal);
    }
    executeCommand(command, token) {
     this.terminal.log(`> Executing task: ${command.getCommandAsString()}\n\r`), this.telemetry.sendTelemetryEvent("dbtCommand", {
      command: command.getCommandAsString()
     }), command.focus && this.terminal.show(!0);
     const {args} = command;
     if (!this.pythonEnvironment.pythonPath || !this.pythonEnvironment.environmentVariables) throw Error("Could not launch command as python environment is not available");
     return this.commandProcessExecutionFactory.createCommandProcessExecution({
      command: "dbt",
      args,
      token,
      cwd: (0, utils_1.getFirstWorkspacePath)(),
      envVars: this.pythonEnvironment.environmentVariables
     });
    }
   };
   CLIDBTCommandExecutionStrategy = CLIDBTCommandExecutionStrategy_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(CLIDBTCommandExecutionStrategy_1), tslib_1.__metadata("design:paramtypes", [ commandProcessExecution_1.CommandProcessExecutionFactory, pythonEnvironment_1.PythonEnvironment, dbtTerminal_1.DBTTerminal, telemetry_1.TelemetryService ]) ], CLIDBTCommandExecutionStrategy), 
   exports.CLIDBTCommandExecutionStrategy = CLIDBTCommandExecutionStrategy;
   let PythonDBTCommandExecutionStrategy = PythonDBTCommandExecutionStrategy_1 = class {
    constructor(commandProcessExecutionFactory, pythonEnvironment, terminal, telemetry) {
     this.commandProcessExecutionFactory = commandProcessExecutionFactory, this.pythonEnvironment = pythonEnvironment, 
     this.terminal = terminal, this.telemetry = telemetry;
    }
    execute(command, token) {
     return this.executeCommand(command, token).completeWithTerminalOutput(this.terminal);
    }
    executeCommand(command, token) {
     this.terminal.log(`> Executing task: ${command.getCommandAsString()}\n\r`), this.telemetry.sendTelemetryEvent("dbtCommand", {
      command: command.getCommandAsString()
     }), command.focus && this.terminal.show(!0);
     const {args} = command;
     if (!this.pythonEnvironment.pythonPath || !this.pythonEnvironment.environmentVariables) throw Error("Could not launch command as python environment is not available");
     return this.commandProcessExecutionFactory.createCommandProcessExecution({
      command: this.pythonEnvironment.pythonPath,
      args: [ "-c", this.dbtCommand(args) ],
      token,
      cwd: (0, utils_1.getFirstWorkspacePath)(),
      envVars: this.pythonEnvironment.environmentVariables
     });
    }
    dbtCommand(args) {
     args = args.map((arg => `r'${arg}'`));
     return `has_dbt_runner = True\ntry: \n    ${vscode_1.workspace.getConfiguration("dbt").get("dbtCustomRunnerImport", "from dbt.cli.main import dbtRunner")}\nexcept:\n    has_dbt_runner = False\nif has_dbt_runner:\n    dbt_cli = dbtRunner()\n    dbt_cli.invoke([${args}])\nelse:\n    import dbt.main\n    dbt.main.main([${args}])`;
    }
   };
   PythonDBTCommandExecutionStrategy = PythonDBTCommandExecutionStrategy_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(PythonDBTCommandExecutionStrategy_1), tslib_1.__metadata("design:paramtypes", [ commandProcessExecution_1.CommandProcessExecutionFactory, pythonEnvironment_1.PythonEnvironment, dbtTerminal_1.DBTTerminal, telemetry_1.TelemetryService ]) ], PythonDBTCommandExecutionStrategy), 
   exports.PythonDBTCommandExecutionStrategy = PythonDBTCommandExecutionStrategy;
   class DBTCommand {
    constructor(statusMessage, args, focus = !1, executionStrategy) {
     this.statusMessage = statusMessage, this.args = args, this.focus = focus, this.executionStrategy = executionStrategy;
    }
    addArgument(arg) {
     this.args.push(arg);
    }
    getCommandAsString() {
     return "dbt " + this.args.join(" ");
    }
    setExecutionStrategy(executionStrategy) {
     this.executionStrategy = executionStrategy;
    }
    execute(token) {
     if (void 0 === this.executionStrategy) throw new Error("Execution strategy is required to run dbt commands");
     return this.executionStrategy.execute(this, token);
    }
   }
   exports.DBTCommand = DBTCommand;
   class DBTIntegrationError extends Error {}
   exports.DBTIntegrationError = DBTIntegrationError;
   class DBTIntegrationUnknownError extends Error {}
   exports.DBTIntegrationUnknownError = DBTIntegrationUnknownError;
   let DBTCommandExecutionInfrastructure = DBTCommandExecutionInfrastructure_1 = class {
    constructor(pythonEnvironment, telemetry) {
     this.pythonEnvironment = pythonEnvironment, this.telemetry = telemetry, this.queue = [], 
     this.running = !1;
    }
    createPythonBridge(cwd) {
     let pythonPath = this.pythonEnvironment.pythonPath;
     const envVars = this.pythonEnvironment.environmentVariables;
     if (pythonPath.endsWith("python.exe")) {
      const pythonwPath = pythonPath.replace("python.exe", "pythonw.exe");
      (0, fs_1.existsSync)(pythonwPath) && (pythonPath = pythonwPath);
     }
     return (0, python_bridge_1.pythonBridge)({
      python: pythonPath,
      cwd,
      env: Object.assign(Object.assign({}, envVars), {
       PYTHONPATH: __dirname
      }),
      detached: !0
     });
    }
    closePythonBridge(bridge) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       yield bridge.disconnect(), yield bridge.end();
      } catch (_) {}
     }));
    }
    addCommandToQueue(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.queue.push({
       command: token => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        yield command.execute(token);
       })),
       statusMessage: command.statusMessage,
       focus: command.focus
      }), this.pickCommandToRun();
     }));
    }
    pickCommandToRun() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (!this.running && this.queue.length > 0) {
       this.running = !0;
       const {command, statusMessage, focus} = this.queue.shift();
       yield vscode_1.window.withProgress({
        location: focus ? vscode_1.ProgressLocation.Notification : vscode_1.ProgressLocation.Window,
        cancellable: !0,
        title: statusMessage
       }, ((_, token) => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        try {
         yield command(token);
        } catch (error) {
         vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)(`Could not run command '${statusMessage}': ` + error.message + ".")), 
         this.telemetry.sendTelemetryError("queueRunCommandError", error, {
          command: statusMessage
         });
        }
       })))), this.running = !1, this.pickCommandToRun();
      }
     }));
    }
   };
   DBTCommandExecutionInfrastructure = DBTCommandExecutionInfrastructure_1 = tslib_1.__decorate([ (0, 
   inversify_binding_decorators_1.provide)(DBTCommandExecutionInfrastructure_1), tslib_1.__metadata("design:paramtypes", [ pythonEnvironment_1.PythonEnvironment, telemetry_1.TelemetryService ]) ], DBTCommandExecutionInfrastructure), 
   exports.DBTCommandExecutionInfrastructure = DBTCommandExecutionInfrastructure;
   let DBTCommandFactory = DBTCommandFactory_1 = class {
    createVersionCommand() {
     return new DBTCommand("Detecting dbt version...", [ "--version" ]);
    }
    createRunModelCommand(params) {
     const {plusOperatorLeft, modelName, plusOperatorRight} = params, buildModelCommandAdditionalParams = vscode_1.workspace.getConfiguration("dbt").get("runModelCommandAdditionalParams", []);
     return new DBTCommand("Running dbt model...", [ "run", "--select", `${plusOperatorLeft}${modelName}${plusOperatorRight}`, ...buildModelCommandAdditionalParams ], !0);
    }
    createBuildModelCommand(params) {
     const {plusOperatorLeft, modelName, plusOperatorRight} = params, buildModelCommandAdditionalParams = vscode_1.workspace.getConfiguration("dbt").get("buildModelCommandAdditionalParams", []);
     return new DBTCommand("Building dbt model...", [ "build", "--select", `${plusOperatorLeft}${modelName}${plusOperatorRight}`, ...buildModelCommandAdditionalParams ], !0);
    }
    createTestModelCommand(testName) {
     const testModelCommandAdditionalParams = vscode_1.workspace.getConfiguration("dbt").get("testModelCommandAdditionalParams", []);
     return new DBTCommand("Testing dbt model...", [ "test", "--select", testName, ...testModelCommandAdditionalParams ], !0);
    }
    createCompileModelCommand(params) {
     const {plusOperatorLeft, modelName, plusOperatorRight} = params;
     return new DBTCommand("Compiling dbt models...", [ "compile", "--select", `${plusOperatorLeft}${modelName}${plusOperatorRight}` ], !0);
    }
    createDocsGenerateCommand() {
     return new DBTCommand("Generating dbt Docs...", [ "docs", "generate" ], !0);
    }
    createInstallDepsCommand() {
     return new DBTCommand("Installing packages...", [ "deps" ], !0);
    }
    createDebugCommand() {
     return new DBTCommand("Debugging...", [ "debug" ], !0);
    }
   };
   DBTCommandFactory = DBTCommandFactory_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DBTCommandFactory_1) ], DBTCommandFactory), 
   exports.DBTCommandFactory = DBTCommandFactory;
  },
  26684: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DBTTerminal_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DBTTerminal = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593), telemetry_1 = __webpack_require__(27407);
   let DBTTerminal = DBTTerminal_1 = class {
    constructor(telemetry) {
     this.telemetry = telemetry, this.disposables = [], this.writeEmitter = new vscode_1.EventEmitter, 
     this.outputChannel = vscode_1.window.createOutputChannel("Log - dbt", {
      log: !0
     });
    }
    show(status) {
     status && (this.requireTerminal(), this.terminal.show(!status));
    }
    log(message) {
     this.outputChannel.info((0, utils_1.stripANSI)(message)), void 0 !== this.terminal && this.writeEmitter.fire(message);
    }
    trace(message) {
     var _a;
     null === (_a = this.outputChannel) || void 0 === _a || _a.appendLine((0, utils_1.stripANSI)(message)), 
     console.log(message);
    }
    debug(message) {
     var _a;
     null === (_a = this.outputChannel) || void 0 === _a || _a.debug((0, utils_1.stripANSI)(message)), 
     console.debug(message);
    }
    info(name, message, sendTelemetry = !0) {
     var _a;
     null === (_a = this.outputChannel) || void 0 === _a || _a.info((0, utils_1.stripANSI)(message)), 
     console.info(`${name}:${message}`), sendTelemetry && this.telemetry.sendTelemetryEvent(name, {
      message
     });
    }
    warn(e, sendTelemetry = !0) {
     var _a;
     const message = e.getMessage();
     null === (_a = this.outputChannel) || void 0 === _a || _a.warn((0, utils_1.stripANSI)(message)), 
     console.warn(`${e.name}:${message}`), sendTelemetry && this.telemetry.sendTelemetryError(e.name, e.error, {
      message
     });
    }
    error(e, sendTelemetry = !0) {
     var _a;
     const message = e.getMessage();
     null === (_a = this.outputChannel) || void 0 === _a || _a.error((0, utils_1.stripANSI)(message)), 
     console.error(`${e.name}:${message}`), sendTelemetry && this.telemetry.sendTelemetryError(e.name, e.error, {
      message
     });
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      null == x || x.dispose();
     }
    }
    requireTerminal() {
     void 0 === this.terminal && (this.terminal = vscode_1.window.createTerminal({
      name: "Tasks - dbt",
      pty: {
       onDidWrite: this.writeEmitter.event,
       open: () => this.writeEmitter.fire(""),
       close: () => {
        var _a;
        null === (_a = this.terminal) || void 0 === _a || _a.dispose(), this.terminal = void 0;
       }
      }
     }));
    }
   };
   DBTTerminal = DBTTerminal_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DBTTerminal_1), tslib_1.__metadata("design:paramtypes", [ telemetry_1.TelemetryService ]) ], DBTTerminal), 
   exports.DBTTerminal = DBTTerminal;
  },
  29759: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.CustomUnknownException = exports.CustomPythonException = exports.CustomException = void 0;
   class CustomException {
    constructor(name, error) {
     this.name = name, this.error = error;
    }
   }
   exports.CustomException = CustomException;
   exports.CustomPythonException = class extends CustomException {
    constructor(name, error) {
     super(name, error), this.name = name, this.error = error;
    }
    getMessage() {
     return this.error.exception.message;
    }
   };
   exports.CustomUnknownException = class extends CustomException {
    constructor(name, error) {
     super(name, error), this.name = name, this.error = error;
    }
    getMessage() {
     return this.error && this.error instanceof Error ? this.error.message : `${this.error}`;
    }
   };
  },
  86119: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DBTClient_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DBTClient = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), pythonEnvironment_1 = __webpack_require__(53003), utils_1 = __webpack_require__(78593), fs_1 = __webpack_require__(57147), dbtCoreIntegration_1 = __webpack_require__(16413);
   var DbtInstallationPromptAnswer, PythonInterpreterPromptAnswer;
   !function(DbtInstallationPromptAnswer) {
    DbtInstallationPromptAnswer.INSTALL = "Install dbt";
   }(DbtInstallationPromptAnswer || (DbtInstallationPromptAnswer = {})), function(PythonInterpreterPromptAnswer) {
    PythonInterpreterPromptAnswer.SELECT = "Select Python interpreter";
   }(PythonInterpreterPromptAnswer || (PythonInterpreterPromptAnswer = {}));
   let DBTClient = DBTClient_1 = class {
    constructor(pythonEnvironment, dbtCoreDetection) {
     this.pythonEnvironment = pythonEnvironment, this.dbtCoreDetection = dbtCoreDetection, 
     this._onDBTInstallationVerificationEvent = new vscode_1.EventEmitter, this.onDBTInstallationVerification = this._onDBTInstallationVerificationEvent.event, 
     this.disposables = [ this._onDBTInstallationVerificationEvent ], this.shownError = !1;
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    detectDBT() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.pythonEnvironment.initialize(), this.disposables.push(this.pythonEnvironment.onPythonEnvironmentChanged((() => {
       this.checkAllInstalled();
      }))), yield this.checkAllInstalled();
     }));
    }
    checkAllInstalled() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._onDBTInstallationVerificationEvent.fire({
       inProgress: !0
      }), this.shownError = !1, this.dbtInstalled = void 0, this.pythonInstalled = this.pythonPathExists(), 
      this.dbtInstalled = yield this.dbtCoreDetection.detectDBT(), this._onDBTInstallationVerificationEvent.fire({
       inProgress: !1,
       installed: this.dbtInstalled
      }), vscode_1.commands.executeCommand("setContext", "dbtPowerUser.dbtInstalled", this.dbtInstalled), 
      this.dbtInstalled || this.showErrorIfDbtOrPythonNotInstalled();
     }));
    }
    showErrorIfDbtOrPythonNotInstalled() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (!this.pythonInstalled) {
       if (!this.shownError) {
        this.shownError = !0;
        (yield vscode_1.window.showErrorMessage("No Python interpreter is selected or Python is not installed", PythonInterpreterPromptAnswer.SELECT)) === PythonInterpreterPromptAnswer.SELECT && vscode_1.commands.executeCommand("python.setInterpreter");
       }
       return !1;
      }
      return this.showErrorIfDbtIsNotInstalled();
     }));
    }
    showErrorIfDbtIsNotInstalled() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (!this.dbtInstalled) {
       if (!this.shownError) {
        this.shownError = !0;
        (yield vscode_1.window.showErrorMessage("Please ensure dbt is installed.", DbtInstallationPromptAnswer.INSTALL)) === DbtInstallationPromptAnswer.INSTALL && vscode_1.commands.executeCommand("dbtPowerUser.installDbt");
       }
       return !1;
      }
      return !0;
     }));
    }
    getPythonEnvironment() {
     return this.pythonEnvironment;
    }
    pythonPathExists() {
     return void 0 !== this.pythonEnvironment.pythonPath && (0, fs_1.existsSync)(this.pythonEnvironment.pythonPath);
    }
   };
   DBTClient = DBTClient_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DBTClient_1), tslib_1.__metadata("design:paramtypes", [ pythonEnvironment_1.PythonEnvironment, dbtCoreIntegration_1.DBTCoreDetection ]) ], DBTClient), 
   exports.DBTClient = DBTClient;
  },
  72672: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DocDefinitionProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DocDefinitionProvider = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), dbtProjectContainer_1 = __webpack_require__(37343), utils_1 = __webpack_require__(78593), telemetry_1 = __webpack_require__(27407);
   let DocDefinitionProvider = DocDefinitionProvider_1 = class {
    constructor(dbtProjectContainer, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.docToLocationMap = new Map, 
     this.disposables = [], this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    provideDefinition(document, position) {
     return new Promise((resolve => {
      const range = document.getWordRangeAtPosition(position, DocDefinitionProvider_1.IS_DOC), word = document.getText(range);
      if (word) {
       this.dbtProjectContainer.getPackageName(document.uri);
       const docName = word.match(DocDefinitionProvider_1.GET_DOC_INFO);
       if (null == docName) return void resolve(void 0);
       const definition = this.getDocDefinition(docName[0], document.uri);
       if (void 0 !== definition) return resolve(definition), void this.telemetry.sendTelemetryEvent("provideDocDefinition");
      }
      resolve(void 0);
     }));
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.docToLocationMap.set(added.project.projectRoot.fsPath, added.docMetaMap);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.docToLocationMap.delete(removed.projectRoot.fsPath);
     }));
    }
    getDocDefinition(docName, currentFilePath) {
     const projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (void 0 === projectRootpath) return;
     const docMap = this.docToLocationMap.get(projectRootpath.fsPath);
     if (void 0 === docMap) return;
     const location = docMap.get(docName);
     return location ? new vscode_1.Location(vscode_1.Uri.file(location.path), new vscode_1.Position(location.line, location.character)) : void 0;
    }
   };
   DocDefinitionProvider.IS_DOC = /(doc)\([^)]*\)/, DocDefinitionProvider.GET_DOC_INFO = /(?!['"])(\w+)(?=['"])/g, 
   DocDefinitionProvider = DocDefinitionProvider_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DocDefinitionProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], DocDefinitionProvider), 
   exports.DocDefinitionProvider = DocDefinitionProvider;
  },
  68740: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DefinitionProviders_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DefinitionProviders = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), dbtPowerUserExtension_1 = __webpack_require__(92182), utils_1 = __webpack_require__(78593), docDefinitionProvider_1 = __webpack_require__(72672), macroDefinitionProvider_1 = __webpack_require__(93386), modelDefinitionProvider_1 = __webpack_require__(78992), sourceDefinitionProvider_1 = __webpack_require__(22121);
   let DefinitionProviders = DefinitionProviders_1 = class {
    constructor(modelDefinitionProvider, macroDefinitionProvider, sourceDefinitionProvider, docDefinitionsProvider) {
     this.modelDefinitionProvider = modelDefinitionProvider, this.macroDefinitionProvider = macroDefinitionProvider, 
     this.sourceDefinitionProvider = sourceDefinitionProvider, this.docDefinitionsProvider = docDefinitionsProvider, 
     this.disposables = [], this.disposables.push(vscode_1.languages.registerDefinitionProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_YAML_SQL_SELECTOR, this.modelDefinitionProvider), vscode_1.languages.registerDefinitionProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_SQL_SELECTOR, this.macroDefinitionProvider), vscode_1.languages.registerDefinitionProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_YAML_SQL_SELECTOR, this.sourceDefinitionProvider), vscode_1.languages.registerDefinitionProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_YAML_SQL_SELECTOR, this.docDefinitionsProvider));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   DefinitionProviders = DefinitionProviders_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DefinitionProviders_1), tslib_1.__metadata("design:paramtypes", [ modelDefinitionProvider_1.ModelDefinitionProvider, macroDefinitionProvider_1.MacroDefinitionProvider, sourceDefinitionProvider_1.SourceDefinitionProvider, docDefinitionProvider_1.DocDefinitionProvider ]) ], DefinitionProviders), 
   exports.DefinitionProviders = DefinitionProviders;
  },
  93386: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var MacroDefinitionProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.MacroDefinitionProvider = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), dbtProjectContainer_1 = __webpack_require__(37343), utils_1 = __webpack_require__(78593), telemetry_1 = __webpack_require__(27407);
   let MacroDefinitionProvider = MacroDefinitionProvider_1 = class {
    constructor(dbtProjectContainer, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.macroToLocationMap = new Map, 
     this.disposables = [], this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    provideDefinition(document, position) {
     return new Promise((resolve => {
      const textLine = document.lineAt(position).text, range = document.getWordRangeAtPosition(position, MacroDefinitionProvider_1.IS_MACRO), word = document.getText(range);
      if (range && "(" === textLine[range.end.character] && (0, utils_1.isEnclosedWithinCodeBlock)(document, range)) {
       const packageName = this.dbtProjectContainer.getPackageName(document.uri), macroName = void 0 === packageName || word.includes(".") ? word : `${packageName}.${word}`, definition = this.getMacroDefinition(macroName, document.uri);
       if (void 0 !== definition) return resolve(definition), void this.telemetry.sendTelemetryEvent("provideMacroDefinition");
      }
      resolve(void 0);
     }));
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.macroToLocationMap.set(added.project.projectRoot.fsPath, added.macroMetaMap);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.macroToLocationMap.delete(removed.projectRoot.fsPath);
     }));
    }
    getMacroDefinition(macroName, currentFilePath) {
     const projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (void 0 === projectRootpath) return;
     const macroMap = this.macroToLocationMap.get(projectRootpath.fsPath);
     if (void 0 === macroMap) return;
     const location = macroMap.get(macroName);
     return location ? new vscode_1.Location(vscode_1.Uri.file(location.path), new vscode_1.Position(location.line, location.character)) : void 0;
    }
   };
   MacroDefinitionProvider.IS_MACRO = /\w+\.?\w+/, MacroDefinitionProvider = MacroDefinitionProvider_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(MacroDefinitionProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], MacroDefinitionProvider), 
   exports.MacroDefinitionProvider = MacroDefinitionProvider;
  },
  78992: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ModelDefinitionProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ModelDefinitionProvider = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), dbtProjectContainer_1 = __webpack_require__(37343), utils_1 = __webpack_require__(78593), telemetry_1 = __webpack_require__(27407);
   let ModelDefinitionProvider = ModelDefinitionProvider_1 = class {
    constructor(dbtProjectContainer, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.modelToLocationMap = new Map, 
     this.disposables = [], this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    provideDefinition(document, position, token) {
     return new Promise((resolve => {
      const hover = document.getText(document.getWordRangeAtPosition(position)), word = document.getText(document.getWordRangeAtPosition(position, ModelDefinitionProvider_1.IS_REF)), project = this.dbtProjectContainer.findDBTProject(document.uri);
      if (project) {
       if (void 0 !== word && "ref" !== hover) {
        const dbtModel = word.match(ModelDefinitionProvider_1.GET_DBT_MODEL);
        if (dbtModel && 1 === dbtModel.length) {
         return resolve(this.getDefinitionFor(project.getProjectName(), dbtModel[0], document.uri)), 
         void this.telemetry.sendTelemetryEvent("provideModelDefinition", {
          type: "single"
         });
        }
        if (dbtModel && 3 === dbtModel.length) {
         const definition = this.getDefinitionFor(dbtModel[0], dbtModel[2], document.uri);
         return this.telemetry.sendTelemetryEvent("provideModelDefinition", {
          type: "dual"
         }), void resolve(definition);
        }
       }
       resolve(void 0);
      } else console.error("Could not load definition provider, project not found in container for " + document.uri.fsPath);
     }));
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.modelToLocationMap.set(added.project.projectRoot.fsPath, added.nodeMetaMap);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.modelToLocationMap.delete(removed.projectRoot.fsPath);
     }));
    }
    getDefinitionFor(projectName, modelName, currentFilePath) {
     const projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (void 0 === projectRootpath) return;
     const nodeMap = this.modelToLocationMap.get(projectRootpath.fsPath);
     if (void 0 === nodeMap) return;
     const location = nodeMap.get(modelName);
     return location ? new vscode_1.Location(vscode_1.Uri.file(location.path), new vscode_1.Range(0, 0, 999, 999)) : void 0;
    }
   };
   ModelDefinitionProvider.IS_REF = /(ref)\([^)]*\)/, ModelDefinitionProvider.GET_DBT_MODEL = /(?!'|")([^(?!'|")]*)(?='|")/gi, 
   ModelDefinitionProvider = ModelDefinitionProvider_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(ModelDefinitionProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], ModelDefinitionProvider), 
   exports.ModelDefinitionProvider = ModelDefinitionProvider;
  },
  22121: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var SourceDefinitionProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SourceDefinitionProvider = void 0;
   const tslib_1 = __webpack_require__(70655), fs_1 = __webpack_require__(57147), vscode_1 = __webpack_require__(66828), dbtProjectContainer_1 = __webpack_require__(37343), utils_1 = __webpack_require__(78593), telemetry_1 = __webpack_require__(27407);
   let SourceDefinitionProvider = SourceDefinitionProvider_1 = class {
    constructor(dbtProjectContainer, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.sourceMetaMap = new Map, 
     this.disposables = [], this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    provideDefinition(document, position, token) {
     return new Promise((resolve => {
      const hover = document.getText(document.getWordRangeAtPosition(position)), range = document.getWordRangeAtPosition(position, SourceDefinitionProvider_1.IS_SOURCE), word = document.getText(range), linePrefix = document.lineAt(position).text.substr(0, position.character);
      if (!(0, utils_1.isEnclosedWithinCodeBlock)(document, position) || !linePrefix.includes("source") || "source" === hover) return void resolve(void 0);
      const source = word.match(SourceDefinitionProvider_1.GET_SOURCE_INFO);
      if (null == source) return void resolve(void 0);
      if (source.length < 2) return void resolve(void 0);
      const definition = this.getSourceDefinition(source[0], document.uri, source[1]);
      this.telemetry.sendTelemetryEvent("provideSourceDefinition"), resolve(definition);
     }));
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.sourceMetaMap.set(added.project.projectRoot.fsPath, added.sourceMetaMap);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.sourceMetaMap.delete(removed.projectRoot.fsPath);
     }));
    }
    getSourceDefinition(sourceName, currentFilePath, tableName) {
     var _a;
     const projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (void 0 === projectRootpath) return;
     const sourceMap = this.sourceMetaMap.get(projectRootpath.fsPath);
     if (void 0 === sourceMap) return;
     const location = null === (_a = sourceMap.get(sourceName)) || void 0 === _a ? void 0 : _a.tables.find((table => table.name === tableName));
     if (location) {
      const sourceFileLines = (0, fs_1.readFileSync)(location.path).toString("utf8").split("\n");
      for (let index = 0; index < sourceFileLines.length; index++) {
       const currentLine = sourceFileLines[index];
       if (currentLine.includes(tableName)) return new vscode_1.Location(vscode_1.Uri.file(location.path), new vscode_1.Position(index, currentLine.indexOf(tableName)));
      }
     }
    }
   };
   SourceDefinitionProvider.IS_SOURCE = /(source)\([^)]*\)/, SourceDefinitionProvider.GET_SOURCE_INFO = /(?!['"])(\w+)(?=['"])/g, 
   SourceDefinitionProvider = SourceDefinitionProvider_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(SourceDefinitionProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], SourceDefinitionProvider), 
   exports.SourceDefinitionProvider = SourceDefinitionProvider;
  },
  91006: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DbtDocumentFormattingEditProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DbtDocumentFormattingEditProvider = void 0;
   const tslib_1 = __webpack_require__(70655), parseDiff = __webpack_require__(23145), vscode_1 = __webpack_require__(66828), which = __webpack_require__(22674), commandProcessExecution_1 = __webpack_require__(11986), utils_1 = __webpack_require__(78593), telemetry_1 = __webpack_require__(27407);
   let DbtDocumentFormattingEditProvider = DbtDocumentFormattingEditProvider_1 = class {
    constructor(commandProcessExecutionFactory, telemetry) {
     this.commandProcessExecutionFactory = commandProcessExecutionFactory, this.telemetry = telemetry;
    }
    provideDocumentFormattingEdits(document, options, token) {
     return this.executeSqlFmt(document);
    }
    getSqlFmtPathSetting() {
     const value = vscode_1.workspace.getConfiguration("dbt").get("sqlFmtPath", "");
     return value ? (0, utils_1.substituteSettingsVariables)(value) : void 0;
    }
    executeSqlFmt(document) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const sqlFmtPathSetting = this.getSqlFmtPathSetting(), sqlFmtArgs = [ "-", "--diff", "--no-progressbar", "--quiet", ...vscode_1.workspace.getConfiguration("dbt").get("sqlFmtAdditionalParams", []).join(" ").split(" ").filter((s => "" !== s)) ];
      try {
       const sqlFmtPath = sqlFmtPathSetting || (yield which("sqlfmt"));
       this.telemetry.sendTelemetryEvent("formatDbtModel", {
        sqlFmtPath: sqlFmtPathSetting ? "setting" : "path"
       });
       try {
        return yield this.commandProcessExecutionFactory.createCommandProcessExecution({
         command: sqlFmtPath,
         args: sqlFmtArgs,
         stdin: document.getText()
        }).complete(), [];
       } catch (diffOutput) {
        try {
         return this.processDiffOutput(document, diffOutput);
        } catch (error) {
         this.telemetry.sendTelemetryError("formatDbtModelApplyDiffFailed", error), vscode_1.window.showErrorMessage((0, 
         utils_1.extendErrorWithSupportLinks)("Could not process difference output from sqlfmt. Detailed error: " + error + "."));
        }
       }
      } catch (error) {
       this.telemetry.sendTelemetryError("formatDbtModelApplyDiffFailed", error), vscode_1.window.showErrorMessage((0, 
       utils_1.extendErrorWithSupportLinks)("Could not run sqlfmt. Did you install sqlfmt? Detailed error: " + error + "."));
      }
      return [];
     }));
    }
    processDiffOutput(document, diffOutput) {
     const textEdits = [];
     return parseDiff(diffOutput).forEach((diff => {
      diff.chunks.forEach((chunk => {
       const oldBoundChunk = chunk.oldLines + chunk.oldStart - 1;
       chunk.changes.forEach((change => {
        this.isAddChange(change) && textEdits.push(vscode_1.TextEdit.insert(document.lineAt(Math.min(change.ln, oldBoundChunk) - 1).range.start, change.content.slice(1) + "\n")), 
        this.isNormalChange(change) && (textEdits.push(vscode_1.TextEdit.delete(document.lineAt(change.ln1 - 1).rangeIncludingLineBreak)), 
        textEdits.push(vscode_1.TextEdit.insert(document.lineAt(Math.min(change.ln2, oldBoundChunk) - 1).range.start, change.content.slice(1) + "\n"))), 
        this.isDeleteChange(change) && textEdits.push(vscode_1.TextEdit.delete(document.lineAt(change.ln - 1).rangeIncludingLineBreak));
       }));
      }));
     })), textEdits;
    }
    isAddChange(change) {
     return "add" === change.type;
    }
    isNormalChange(change) {
     return "normal" === change.type;
    }
    isDeleteChange(change) {
     return "del" === change.type && "\\ No newline at end of file" !== change.content;
    }
   };
   DbtDocumentFormattingEditProvider = DbtDocumentFormattingEditProvider_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DbtDocumentFormattingEditProvider_1), tslib_1.__metadata("design:paramtypes", [ commandProcessExecution_1.CommandProcessExecutionFactory, telemetry_1.TelemetryService ]) ], DbtDocumentFormattingEditProvider), 
   exports.DbtDocumentFormattingEditProvider = DbtDocumentFormattingEditProvider;
  },
  68998: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DocumentFormattingEditProviders_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DocumentFormattingEditProviders = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), dbtPowerUserExtension_1 = __webpack_require__(92182), utils_1 = __webpack_require__(78593), dbtDocumentFormattingEditProvider_1 = __webpack_require__(91006);
   let DocumentFormattingEditProviders = DocumentFormattingEditProviders_1 = class {
    constructor(dbtDocumentFormattingProvider) {
     this.dbtDocumentFormattingProvider = dbtDocumentFormattingProvider, this.disposables = [], 
     this.disposables.push(vscode_1.languages.registerDocumentFormattingEditProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_SQL_SELECTOR, this.dbtDocumentFormattingProvider));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   DocumentFormattingEditProviders = DocumentFormattingEditProviders_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DocumentFormattingEditProviders_1), tslib_1.__metadata("design:paramtypes", [ dbtDocumentFormattingEditProvider_1.DbtDocumentFormattingEditProvider ]) ], DocumentFormattingEditProviders), 
   exports.DocumentFormattingEditProviders = DocumentFormattingEditProviders;
  },
  37512: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.RunModelType = exports.Source = exports.Snapshot = exports.Exposure = exports.Analysis = exports.Test = exports.Seed = exports.Model = exports.Node = void 0;
   const path = __webpack_require__(71017);
   class Node {
    constructor(label, key, url) {
     this.iconPath = {
      light: path.join(path.resolve(__dirname), "../media/images/model_light.svg"),
      dark: path.join(path.resolve(__dirname), "../media/images/model_dark.svg")
     }, this.displayInModelTree = !0, this.label = label, this.key = key, this.url = url;
    }
   }
   exports.Node = Node;
   exports.Model = class extends Node {};
   exports.Seed = class extends Node {};
   exports.Test = class extends Node {
    constructor() {
     super(...arguments), this.iconPath = {
      light: path.join(path.resolve(__dirname), "../media/images/source_light.svg"),
      dark: path.join(path.resolve(__dirname), "../media/images/source_dark.svg")
     };
    }
   };
   exports.Analysis = class extends Node {
    constructor() {
     super(...arguments), this.displayInModelTree = !0;
    }
   };
   exports.Exposure = class extends Node {
    constructor() {
     super(...arguments), this.displayInModelTree = !0;
    }
   };
   exports.Snapshot = class extends Node {};
   exports.Source = class extends Node {
    constructor() {
     super(...arguments), this.iconPath = {
      light: path.join(path.resolve(__dirname), "../media/images/source_light.svg"),
      dark: path.join(path.resolve(__dirname), "../media/images/source_dark.svg")
     };
    }
   }, function(RunModelType) {
    RunModelType[RunModelType.RUN_PARENTS = 0] = "RUN_PARENTS", RunModelType[RunModelType.RUN_CHILDREN = 1] = "RUN_CHILDREN", 
    RunModelType[RunModelType.BUILD_PARENTS = 2] = "BUILD_PARENTS", RunModelType[RunModelType.BUILD_CHILDREN = 3] = "BUILD_CHILDREN", 
    RunModelType[RunModelType.BUILD_CHILDREN_PARENTS = 4] = "BUILD_CHILDREN_PARENTS", 
    RunModelType[RunModelType.TEST = 5] = "TEST", RunModelType[RunModelType.SNAPSHOT = 6] = "SNAPSHOT";
   }(exports.RunModelType || (exports.RunModelType = {}));
  },
  62633: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   __webpack_require__(70655).__exportStar(__webpack_require__(60874), exports);
  },
  60874: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.RateLimitException = void 0;
   class RateLimitException extends Error {
    constructor(msg, retryAfter) {
     super(msg), this.retryAfter = retryAfter, Object.setPrototypeOf(this, RateLimitException.prototype);
    }
   }
   exports.RateLimitException = RateLimitException;
  },
  23867: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var HoverProviders_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.HoverProviders = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), dbtPowerUserExtension_1 = __webpack_require__(92182), utils_1 = __webpack_require__(78593), modelHoverProvider_1 = __webpack_require__(62523), sourceHoverProvider_1 = __webpack_require__(95854);
   let HoverProviders = HoverProviders_1 = class {
    constructor(modelHoverProvider, sourceHoverProvider) {
     this.modelHoverProvider = modelHoverProvider, this.sourceHoverProvider = sourceHoverProvider, 
     this.disposables = [], this.disposables.push(vscode_1.languages.registerHoverProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_SQL_SELECTOR, this.modelHoverProvider)), 
     this.disposables.push(vscode_1.languages.registerHoverProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_SQL_SELECTOR, this.sourceHoverProvider));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   HoverProviders = HoverProviders_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(HoverProviders_1), tslib_1.__metadata("design:paramtypes", [ modelHoverProvider_1.ModelHoverProvider, sourceHoverProvider_1.SourceHoverProvider ]) ], HoverProviders), 
   exports.HoverProviders = HoverProviders;
  },
  62523: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ModelHoverProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ModelHoverProvider = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), dbtProjectContainer_1 = __webpack_require__(37343), utils_1 = __webpack_require__(78593), telemetry_1 = __webpack_require__(27407), utils_2 = __webpack_require__(94830);
   let ModelHoverProvider = ModelHoverProvider_1 = class {
    constructor(dbtProjectContainer, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.modelToLocationMap = new Map, 
     this.disposables = [], this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    provideHover(document, position, token) {
     return new Promise((resolve => {
      const hover = document.getText(document.getWordRangeAtPosition(position)), word = document.getText(document.getWordRangeAtPosition(position, ModelHoverProvider_1.IS_REF)), project = this.dbtProjectContainer.findDBTProject(document.uri);
      if (project) {
       if (void 0 !== word && "ref" !== hover) {
        const dbtModel = word.match(ModelHoverProvider_1.GET_DBT_MODEL);
        if (dbtModel && 1 === dbtModel.length) {
         const mdString = this.getHoverMarkdownFor(project.getProjectName(), dbtModel[0], document.uri);
         if (void 0 !== mdString) {
          resolve(new vscode_1.Hover(mdString, new vscode_1.Range(position, position)));
         }
         return void this.telemetry.sendTelemetryEvent("provideModelHover", {
          type: "single"
         });
        }
        if (dbtModel && 3 === dbtModel.length) {
         const mdString = this.getHoverMarkdownFor(dbtModel[0], dbtModel[2], document.uri);
         if (void 0 !== mdString) {
          resolve(new vscode_1.Hover(mdString, new vscode_1.Range(position, position)));
         }
         return void this.telemetry.sendTelemetryEvent("provideModelHover", {
          type: "dual"
         });
        }
       }
       resolve(void 0);
      } else console.error("Could not load hover provider, project not found in container for " + document.uri.fsPath);
     }));
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.modelToLocationMap.set(added.project.projectRoot.fsPath, added.nodeMetaMap);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.modelToLocationMap.delete(removed.projectRoot.fsPath);
     }));
    }
    getHoverMarkdownFor(projectName, modelName, currentFilePath) {
     const projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (void 0 === projectRootpath) return;
     const nodeMap = this.modelToLocationMap.get(projectRootpath.fsPath);
     if (void 0 === nodeMap) return;
     const node = nodeMap.get(modelName);
     return node ? (0, utils_2.generateHoverMarkdownString)(node, "ref") : void 0;
    }
   };
   ModelHoverProvider.IS_REF = /(ref)\([^)]*\)/, ModelHoverProvider.GET_DBT_MODEL = /(?!'|")([^(?!'|")]*)(?='|")/gi, 
   ModelHoverProvider = ModelHoverProvider_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(ModelHoverProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], ModelHoverProvider), 
   exports.ModelHoverProvider = ModelHoverProvider;
  },
  95854: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var SourceHoverProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SourceHoverProvider = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), dbtProjectContainer_1 = __webpack_require__(37343), utils_1 = __webpack_require__(78593), telemetry_1 = __webpack_require__(27407), utils_2 = __webpack_require__(94830);
   let SourceHoverProvider = SourceHoverProvider_1 = class {
    constructor(dbtProjectContainer, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.sourceMetaMap = new Map, 
     this.disposables = [], this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    provideHover(document, position, token) {
     return new Promise((resolve => {
      const hover = document.getText(document.getWordRangeAtPosition(position)), range = document.getWordRangeAtPosition(position, SourceHoverProvider_1.IS_SOURCE), word = document.getText(range), linePrefix = document.lineAt(position).text.substr(0, position.character);
      if (!(0, utils_1.isEnclosedWithinCodeBlock)(document, position) || !linePrefix.includes("source") || "source" === hover) return void resolve(void 0);
      const source = word.match(SourceHoverProvider_1.GET_SOURCE_INFO);
      if (null == source) return void resolve(void 0);
      if (source.length < 2) return void resolve(void 0);
      const mdString = this.getSourceHover(source[0], document.uri, source[1]);
      if (void 0 !== mdString) {
       resolve(new vscode_1.Hover(mdString));
      }
      this.telemetry.sendTelemetryEvent("provideSourceHover");
     }));
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.sourceMetaMap.set(added.project.projectRoot.fsPath, added.sourceMetaMap);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.sourceMetaMap.delete(removed.projectRoot.fsPath);
     }));
    }
    getSourceHover(sourceName, currentFilePath, tableName) {
     var _a;
     const projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (void 0 === projectRootpath) return;
     const sourceMap = this.sourceMetaMap.get(projectRootpath.fsPath);
     if (void 0 === sourceMap) return;
     const node = null === (_a = sourceMap.get(sourceName)) || void 0 === _a ? void 0 : _a.tables.find((table => table.name === tableName));
     return node ? (0, utils_2.generateHoverMarkdownString)(node, "source") : void 0;
    }
   };
   SourceHoverProvider.IS_SOURCE = /(source)\([^)]*\)/, SourceHoverProvider.GET_SOURCE_INFO = /(?!['"])(\w+)(?=['"])/g, 
   SourceHoverProvider = SourceHoverProvider_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(SourceHoverProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], SourceHoverProvider), 
   exports.SourceHoverProvider = SourceHoverProvider;
  },
  94830: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.generateHoverMarkdownString = void 0;
   const vscode_1 = __webpack_require__(66828);
   exports.generateHoverMarkdownString = function(node, nodeType) {
    const content = new vscode_1.MarkdownString;
    content.supportHtml = !0, content.isTrusted = !0, content.appendMarkdown(`<span style="color:#347890;">(${nodeType})&nbsp;</span><span><strong>${node.name}</strong></span>`), 
    "" !== node.description && content.appendMarkdown(`</br><span>${node.description}</span>`), 
    content.appendText("\n"), content.appendText("\n"), content.appendMarkdown("---"), 
    content.appendText("\n"), content.appendText("\n");
    for (const colKey in node.columns) {
     const column = node.columns[colKey];
     content.appendMarkdown(`<span style="color:#347890;">(column)&nbsp;</span><span>${column.name} &nbsp;</span>`), 
     null !== column.data_type && content.appendMarkdown(`<span>-&nbsp;${column.data_type.toUpperCase()}</span>`), 
     "" !== column.description && content.appendMarkdown(`<br/><span><em>${column.description}</em></span>`), 
     content.appendMarkdown("</br>");
    }
    return content;
   };
  },
  81908: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.container = void 0;
   const inversify_1 = __webpack_require__(26594), inversify_binding_decorators_1 = __webpack_require__(84904), dbtTerminal_1 = __webpack_require__(26684), dbtProject_1 = __webpack_require__(49827), dbtProjectContainer_1 = __webpack_require__(37343), dbtWorkspaceFolder_1 = __webpack_require__(48084), dbtProjectLog_1 = __webpack_require__(12759), sourceFileWatchers_1 = __webpack_require__(35572), targetWatchers_1 = __webpack_require__(15557), pythonEnvironment_1 = __webpack_require__(53003), queryResultPanel_1 = __webpack_require__(11054), telemetry_1 = __webpack_require__(27407), dbtCoreIntegration_1 = __webpack_require__(16413), dbtIntegration_1 = __webpack_require__(64889);
   exports.container = new inversify_1.Container, exports.container.load((0, inversify_binding_decorators_1.buildProviderModule)()), 
   exports.container.bind("Factory<DBTWorkspaceFolder>").toFactory((context => (workspaceFolder, _onManifestChanged, _onProjectRegisteredUnregistered) => {
    const {container} = context;
    return new dbtWorkspaceFolder_1.DBTWorkspaceFolder(container.get("Factory<DBTProject>"), container.get(dbtCoreIntegration_1.DBTCoreProjectDetection), container.get(telemetry_1.TelemetryService), workspaceFolder, _onManifestChanged, _onProjectRegisteredUnregistered);
   })), exports.container.bind("Factory<DBTCoreProjectIntegration>").toFactory((context => (projectRoot, projectConfigDiagnostics) => {
    const {container} = context;
    return new dbtCoreIntegration_1.DBTCoreProjectIntegration(container.get(dbtIntegration_1.DBTCommandExecutionInfrastructure), container.get(pythonEnvironment_1.PythonEnvironment), container.get(telemetry_1.TelemetryService), container.get(dbtIntegration_1.PythonDBTCommandExecutionStrategy), container.get(dbtProjectContainer_1.DBTProjectContainer), projectRoot, projectConfigDiagnostics);
   })), exports.container.bind("Factory<DBTProject>").toFactory((context => (path, projectConfig, _onManifestChanged) => {
    const {container} = context;
    return new dbtProject_1.DBTProject(container.get(pythonEnvironment_1.PythonEnvironment), container.get(sourceFileWatchers_1.SourceFileWatchersFactory), container.get(dbtProjectLog_1.DBTProjectLogFactory), container.get(targetWatchers_1.TargetWatchersFactory), container.get(dbtIntegration_1.DBTCommandFactory), container.get(dbtTerminal_1.DBTTerminal), container.get(queryResultPanel_1.QueryResultPanel), container.get(telemetry_1.TelemetryService), container.get("Factory<DBTCoreProjectIntegration>"), path, projectConfig, _onManifestChanged);
   }));
  },
  49827: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DBTProject = void 0;
   const tslib_1 = __webpack_require__(70655), fs_1 = __webpack_require__(57147), path = __webpack_require__(71017), python_bridge_1 = __webpack_require__(1438), vscode_1 = __webpack_require__(66828), yaml_1 = __webpack_require__(93419), utils_1 = __webpack_require__(78593), projectConfigChangedEvent_1 = __webpack_require__(5579), crypto = __webpack_require__(6113);
   class DBTProject {
    constructor(PythonEnvironment, sourceFileWatchersFactory, dbtProjectLogFactory, targetWatchersFactory, dbtCommandFactory, terminal, queryResultPanel, telemetry, dbtCoreIntegrationFactory, path, projectConfig, _onManifestChanged) {
     this.PythonEnvironment = PythonEnvironment, this.sourceFileWatchersFactory = sourceFileWatchersFactory, 
     this.dbtProjectLogFactory = dbtProjectLogFactory, this.targetWatchersFactory = targetWatchersFactory, 
     this.dbtCommandFactory = dbtCommandFactory, this.terminal = terminal, this.queryResultPanel = queryResultPanel, 
     this.telemetry = telemetry, this.dbtCoreIntegrationFactory = dbtCoreIntegrationFactory, 
     this._onProjectConfigChanged = new vscode_1.EventEmitter, this.onProjectConfigChanged = this._onProjectConfigChanged.event, 
     this.disposables = [ this._onProjectConfigChanged ], this.projectConfigDiagnostics = vscode_1.languages.createDiagnosticCollection("dbt"), 
     this.projectHealth = vscode_1.languages.createDiagnosticCollection("dbt"), this.projectRoot = path, 
     this.projectConfig = projectConfig, this.sourceFileWatchers = this.sourceFileWatchersFactory.createSourceFileWatchers(this.onProjectConfigChanged), 
     this.onSourceFileChanged = this.sourceFileWatchers.onSourceFileChanged, this.dbtProjectIntegration = this.dbtCoreIntegrationFactory(this.projectRoot, this.projectConfigDiagnostics), 
     this.disposables.push(this.dbtProjectIntegration, this.targetWatchersFactory.createTargetWatchers(_onManifestChanged, this.onProjectConfigChanged), this.PythonEnvironment.onPythonEnvironmentChanged((() => this.onPythonEnvironmentChanged())), this.sourceFileWatchers, this.projectConfigDiagnostics);
    }
    getProjectName() {
     return this.projectConfig.name;
    }
    getTargetPath() {
     return this.dbtProjectIntegration.getTargetPath();
    }
    getPackageInstallPath() {
     return this.dbtProjectIntegration.getPackageInstallPath();
    }
    getModelPaths() {
     return this.dbtProjectIntegration.getModelPaths();
    }
    getMacroPaths() {
     return this.dbtProjectIntegration.getMacroPaths();
    }
    initialize() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const dbtProjectConfigWatcher = vscode_1.workspace.createFileSystemWatcher(new vscode_1.RelativePattern(this.projectRoot, DBTProject.DBT_PROJECT_FILE));
      (0, utils_1.setupWatcherHandler)(dbtProjectConfigWatcher, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       yield this.refreshProjectConfig(), this.rebuildManifest();
      })))), yield this.dbtProjectIntegration.initializeProject(), yield this.refreshProjectConfig(), 
      this.rebuildManifest(), this.dbtProjectLog = this.dbtProjectLogFactory.createDBTProjectLog(this.onProjectConfigChanged), 
      this.disposables.push(this.dbtProjectLog, dbtProjectConfigWatcher, this.onSourceFileChanged((0, 
      utils_1.debounce)((() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       return yield this.rebuildManifest();
      }))), 2e3)));
     }));
    }
    onPythonEnvironmentChanged() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.initialize();
     }));
    }
    refreshProjectConfig() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       this.projectConfig = DBTProject.readAndParseProjectConfig(this.projectRoot), yield this.dbtProjectIntegration.refreshProjectConfig(), 
       this.projectConfigDiagnostics.clear();
      } catch (error) {
       error instanceof yaml_1.YAMLError ? this.projectConfigDiagnostics.set(vscode_1.Uri.joinPath(this.projectRoot, DBTProject.DBT_PROJECT_FILE), [ new vscode_1.Diagnostic(new vscode_1.Range(0, 0, 999, 999), "dbt_project.yml is invalid : " + error.message) ]) : error instanceof python_bridge_1.PythonException && this.projectConfigDiagnostics.set(vscode_1.Uri.joinPath(this.projectRoot, DBTProject.DBT_PROJECT_FILE), [ new vscode_1.Diagnostic(new vscode_1.Range(0, 0, 999, 999), "dbt configuration is invalid : " + error.exception.message) ]), 
       console.warn(`An error occurred while trying to refresh the project "${this.getProjectName()}" at ${this.projectRoot} configuration`, error), 
       this.terminal.log(`An error occurred while trying to refresh the project "${this.getProjectName()}" at ${this.projectRoot} configuration: ${error}`), 
       this.telemetry.sendTelemetryError("projectConfigRefreshError", error);
      }
      const event = new projectConfigChangedEvent_1.ProjectConfigChangedEvent(this);
      this._onProjectConfigChanged.fire(event);
     }));
    }
    getAdapterType() {
     return this.dbtProjectIntegration.getAdapterType() || "unknown";
    }
    findPackageName(uri) {
     const pathSegments = uri.path.replace(new RegExp(this.projectRoot.path + "/", "g"), "").split("/"), packagesInstallPath = this.getPackageInstallPath();
     if (packagesInstallPath && uri.fsPath.startsWith(packagesInstallPath)) return pathSegments[1];
    }
    contains(uri) {
     return uri.fsPath === this.projectRoot.fsPath || uri.fsPath.startsWith(this.projectRoot.fsPath + path.sep);
    }
    rebuildManifest() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.dbtProjectIntegration.rebuildManifest();
     }));
    }
    runModel(runModelParams) {
     const runModelCommand = this.dbtCommandFactory.createRunModelCommand(runModelParams);
     this.dbtProjectIntegration.runModel(runModelCommand), this.telemetry.sendTelemetryEvent("runModel");
    }
    buildModel(runModelParams) {
     const buildModelCommand = this.dbtCommandFactory.createBuildModelCommand(runModelParams);
     this.dbtProjectIntegration.buildModel(buildModelCommand), this.telemetry.sendTelemetryEvent("buildModel");
    }
    runTest(testName) {
     const testModelCommand = this.dbtCommandFactory.createTestModelCommand(testName);
     this.dbtProjectIntegration.runTest(testModelCommand), this.telemetry.sendTelemetryEvent("runTest");
    }
    runModelTest(modelName) {
     const testModelCommand = this.dbtCommandFactory.createTestModelCommand(modelName);
     this.dbtProjectIntegration.runModelTest(testModelCommand), this.telemetry.sendTelemetryEvent("runModelTest");
    }
    compileModel(runModelParams) {
     const compileModelCommand = this.dbtCommandFactory.createCompileModelCommand(runModelParams);
     this.dbtProjectIntegration.compileModel(compileModelCommand), this.telemetry.sendTelemetryEvent("compileModel");
    }
    generateDocs() {
     const docsGenerateCommand = this.dbtCommandFactory.createDocsGenerateCommand();
     this.dbtProjectIntegration.generateDocs(docsGenerateCommand), this.telemetry.sendTelemetryEvent("generateDocs");
    }
    debug() {
     const debugCommand = this.dbtCommandFactory.createDebugCommand();
     return this.telemetry.sendTelemetryEvent("debug"), this.dbtProjectIntegration.debug(debugCommand);
    }
    installDeps() {
     this.telemetry.sendTelemetryEvent("installDeps");
     const installDepsCommand = this.dbtCommandFactory.createInstallDepsCommand();
     return this.dbtProjectIntegration.deps(installDepsCommand);
    }
    compileNode(modelName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.telemetry.sendTelemetryEvent("compileNode");
      try {
       return this.dbtProjectIntegration.unsafeCompileNode(modelName);
      } catch (exc) {
       return exc instanceof python_bridge_1.PythonException ? (vscode_1.window.showErrorMessage((0, 
       utils_1.extendErrorWithSupportLinks)(`An error occured while trying to compile your node: ${modelName}` + exc.exception.message + ".")), 
       this.telemetry.sendTelemetryError("compileNodePythonError", exc), "Exception: " + exc.exception.message + "\n\nDetailed error information:\n" + exc) : (this.telemetry.sendTelemetryError("compileNodeUnknownError", exc), 
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Encountered an unknown issue: " + exc + ".")), 
       "Detailed error information:\n" + exc);
      }
     }));
    }
    validateSql(request) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const {sql, dialect, models} = request;
       return this.dbtProjectIntegration.validateSql(sql, dialect, models);
      } catch (exc) {
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Could not validate sql." + exc)), 
       this.telemetry.sendTelemetryError("validateSQLError", {
        error: exc
       });
      }
     }));
    }
    validateSQLDryRun(query) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       return this.dbtProjectIntegration.validateSQLDryRun(query);
      } catch (exc) {
       const exception = exc;
       vscode_1.window.showErrorMessage(exception.exception.message || "Could not validate sql with dry run."), 
       this.telemetry.sendTelemetryError("validateSQLDryRunError", {
        error: exc
       });
      }
     }));
    }
    getDBTVersion() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       return this.dbtProjectIntegration.getVersion();
      } catch (exc) {
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Could not get dbt version." + exc)), 
       this.telemetry.sendTelemetryError("getDBTVersionError", {
        error: exc
       });
      }
     }));
    }
    compileQuery(query) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.telemetry.sendTelemetryEvent("compileQuery");
      try {
       return this.dbtProjectIntegration.unsafeCompileQuery(query);
      } catch (exc) {
       return exc instanceof python_bridge_1.PythonException ? (vscode_1.window.showErrorMessage((0, 
       utils_1.extendErrorWithSupportLinks)("An error occured while trying to compile your query: " + exc.exception.message + ".")), 
       void this.telemetry.sendTelemetryError("compileQueryPythonError", exc)) : (this.telemetry.sendTelemetryError("compileQueryUnknownError", exc), 
       void vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Encountered an unknown issue: " + exc + ".")));
      }
     }));
    }
    showCompiledSql(modelPath) {
     this.findModelInTargetfolder(modelPath, "compiled");
    }
    showRunSQL(modelPath) {
     this.findModelInTargetfolder(modelPath, "run");
    }
    createYMLContent(columnsInRelation, modelName) {
     let yamlString = "version: 2\n\nmodels:\n";
     yamlString += `  - name: ${modelName}\n    description: ""\n    columns:\n`;
     for (const item of columnsInRelation) yamlString += `    - name: ${item.column}\n      description: ""\n`;
     return yamlString;
    }
    unsafeCompileQuery(query) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.dbtProjectIntegration.unsafeCompileQuery(query);
     }));
    }
    getColumnsOfModel(modelName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.dbtProjectIntegration.getColumnsOfModel(modelName);
     }));
    }
    getColumnsOfSource(sourceName, tableName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.dbtProjectIntegration.getColumnsOfSource(sourceName, tableName);
     }));
    }
    getCatalog() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       return this.dbtProjectIntegration.getCatalog();
      } catch (exc) {
       return exc instanceof python_bridge_1.PythonException ? (this.telemetry.sendTelemetryError("catalogPythonError", exc, {
        adapter: this.getAdapterType()
       }), vscode_1.window.showErrorMessage("Some of the scans could not run as connectivity to database for the project " + this.getProjectName() + " is not available. "), 
       []) : (this.telemetry.sendTelemetryError("catalogUnknownError", exc, {
        adapter: this.getAdapterType()
       }), vscode_1.window.showErrorMessage("Some of the scans could not run as connectivity to database for the project " + this.getProjectName() + " is not available. "), 
       []);
      }
     }));
    }
    generateSchemaYML(modelPath, modelName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const currentDir = path.dirname(modelPath.fsPath), location = path.join(currentDir, modelName + "_schema.yml");
       if ((0, fs_1.existsSync)(location)) vscode_1.window.showErrorMessage(`A file called ${modelName}_schema.yml already exists in ${currentDir}. If you want to generate the schema yml, please rename the other file or delete it if you want to generate the yml again.`); else {
        this.telemetry.sendTelemetryEvent("generateSchemaYML", {
         adapter: this.getAdapterType()
        });
        const columnsInRelation = yield this.getColumnsOfModel(modelName), fileContents = this.createYMLContent(columnsInRelation, modelName);
        (0, fs_1.writeFileSync)(location, fileContents);
        const doc = yield vscode_1.workspace.openTextDocument(vscode_1.Uri.file(location));
        vscode_1.window.showTextDocument(doc);
       }
      } catch (exc) {
       exc instanceof python_bridge_1.PythonException && (this.telemetry.sendTelemetryError("generateSchemaYMLPythonError", exc, {
        adapter: this.getAdapterType()
       }), vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("An error occured while trying to generate the schema yml " + exc.exception.message + "."))), 
       this.telemetry.sendTelemetryError("generateSchemaYMLUnknownError", exc, {
        adapter: this.getAdapterType()
       }), vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Encountered an unknown issue:" + exc + "."));
      }
     }));
    }
    generateModel(sourceName, tableName, sourcePath) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const prefix = vscode_1.workspace.getConfiguration("dbt").get("prefixGenerateModel", "base"), fileNameTemplateMap = {
        "{prefix}_{sourceName}_{tableName}": `${prefix}_${sourceName}_${tableName}`,
        "{prefix}_{sourceName}__{tableName}": `${prefix}_${sourceName}__${tableName}`,
        "{prefix}_{tableName}": `${prefix}_${tableName}`,
        "{tableName}": `${tableName}`
       };
       let fileName = `${prefix}_${sourceName}_${tableName}`;
       const fileNameTemplate = vscode_1.workspace.getConfiguration("dbt").get("fileNameTemplateGenerateModel", "{prefix}_{sourceName}_{tableName}");
       this.telemetry.sendTelemetryEvent("generateModel", {
        prefix,
        filenametemplate: fileNameTemplate,
        adapter: this.getAdapterType()
       }), fileNameTemplate in fileNameTemplateMap && (fileName = fileNameTemplateMap[fileNameTemplate]);
       const location = path.join(sourcePath, fileName + ".sql");
       if ((0, fs_1.existsSync)(location)) vscode_1.window.showErrorMessage(`A model called ${fileName} already exists in ${sourcePath}. If you want to generate the model, please rename the other model or delete it if you want to generate the model again.`); else {
        const columnsInRelation = yield this.getColumnsOfSource(sourceName, tableName);
        console.log(columnsInRelation);
        const fileContents = `with source as (\n      select * from {{ source('${sourceName}', '${tableName}') }}\n),\nrenamed as (\n    select\n        ${columnsInRelation.map((column => `{{ adapter.quote("${column.column}") }}`)).join(",\n        ")}\n\n    from source\n)\nselect * from renamed\n  `;
        (0, fs_1.writeFileSync)(location, fileContents);
        const doc = yield vscode_1.workspace.openTextDocument(vscode_1.Uri.file(location));
        vscode_1.window.showTextDocument(doc);
       }
      } catch (exc) {
       exc instanceof python_bridge_1.PythonException && (this.telemetry.sendTelemetryError("generateModelPythonError", exc, {
        adapter: this.getAdapterType()
       }), vscode_1.window.showErrorMessage("An error occured while trying to generate the model " + exc.exception.message)), 
       this.telemetry.sendTelemetryError("generateModelUnknownError", exc, {
        adapter: this.getAdapterType()
       }), vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("An error occured while trying to generate the model:" + exc + "."));
      }
     }));
    }
    getSummary(query) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.telemetry.sendTelemetryEvent("getSummary");
      const compiledSql = yield this.compileQuery(query);
      void 0 !== compiledSql && this.queryResultPanel.getSummary(compiledSql, this.getAdapterType());
     }));
    }
    executeSQL(query) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const limit = vscode_1.workspace.getConfiguration("dbt").get("queryLimit", 500);
      if (limit <= 0) return void vscode_1.window.showErrorMessage("Please enter a positive number for query limit");
      const queryTemplate = vscode_1.workspace.getConfiguration("dbt").get("queryTemplate", "select * from ({query}\n) as query limit {limit}"), limitQuery = queryTemplate.replace("{query}", (() => query)).replace("{limit}", (() => limit.toString()));
      this.telemetry.sendTelemetryEvent("executeSQL", {
       queryTemplate,
       adapter: this.getAdapterType()
      }, {
       limit
      }), this.queryResultPanel.executeQuery(query, this.dbtProjectIntegration.executeSQL(limitQuery), this.getAdapterType());
     }));
    }
    dispose() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      for (;this.disposables.length; ) {
       const x = this.disposables.pop();
       x && x.dispose();
      }
     }));
    }
    static readAndParseProjectConfig(projectRoot) {
     const dbtProjectConfigLocation = path.join(projectRoot.fsPath, DBTProject.DBT_PROJECT_FILE), dbtProjectYamlFile = (0, 
     fs_1.readFileSync)(dbtProjectConfigLocation, "utf8");
     return (0, yaml_1.parse)(dbtProjectYamlFile, {
      strict: !1,
      uniqueKeys: !1,
      maxAliasCount: -1
     });
    }
    static hashProjectRoot(projectRoot) {
     return crypto.createHash("md5").update(projectRoot).digest("hex");
    }
    findModelInTargetfolder(modelPath, type) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const targetPath = this.getTargetPath();
      if (!targetPath) return;
      const baseName = path.basename(modelPath.fsPath), targetModels = yield vscode_1.workspace.findFiles(new vscode_1.RelativePattern(targetPath, `${type}/**/${baseName}`));
      targetModels.length > 0 && vscode_1.commands.executeCommand("vscode.open", targetModels[0], {
       preview: !1,
       preserveFocus: !0,
       viewColumn: vscode_1.ViewColumn.Beside
      });
     }));
    }
   }
   exports.DBTProject = DBTProject, DBTProject.DBT_PROJECT_FILE = "dbt_project.yml", 
   DBTProject.MANIFEST_FILE = "manifest.json", DBTProject.RESOURCE_TYPE_MODEL = "model", 
   DBTProject.RESOURCE_TYPE_ANALYSIS = "analysis", DBTProject.RESOURCE_TYPE_SOURCE = "source", 
   DBTProject.RESOURCE_TYPE_EXPOSURE = "exposure", DBTProject.RESOURCE_TYPE_SEED = "seed", 
   DBTProject.RESOURCE_TYPE_SNAPSHOT = "snapshot", DBTProject.RESOURCE_TYPE_TEST = "test";
  },
  37343: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DBTProjectContainer_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DBTProjectContainer = void 0;
   const tslib_1 = __webpack_require__(70655), inversify_1 = __webpack_require__(26594), path_1 = __webpack_require__(71017), vscode_1 = __webpack_require__(66828), dbt_client_1 = __webpack_require__(86119), domain_1 = __webpack_require__(37512), utils_1 = __webpack_require__(78593);
   var PromptAnswer;
   !function(PromptAnswer) {
    PromptAnswer.YES = "Yes", PromptAnswer.IGNORE = "Ignore";
   }(PromptAnswer || (PromptAnswer = {}));
   let DBTProjectContainer = DBTProjectContainer_1 = class {
    constructor(dbtClient, dbtWorkspaceFolderFactory) {
     this.dbtClient = dbtClient, this.dbtWorkspaceFolderFactory = dbtWorkspaceFolderFactory, 
     this.onDBTInstallationVerification = this.dbtClient.onDBTInstallationVerification, 
     this.dbtWorkspaceFolders = [], this._onManifestChanged = new vscode_1.EventEmitter, 
     this._onProjectRegisteredUnregistered = new vscode_1.EventEmitter, this.onManifestChanged = this._onManifestChanged.event, 
     this.disposables = [ this._onManifestChanged, this._onProjectRegisteredUnregistered ], 
     this.projects = new Map, this.getPackageName = uri => {
      var _a;
      return null === (_a = this.findDBTProject(uri)) || void 0 === _a ? void 0 : _a.findPackageName(uri);
     }, this.getProjectRootpath = uri => {
      var _a;
      return null === (_a = this.findDBTProject(uri)) || void 0 === _a ? void 0 : _a.projectRoot;
     }, this.disposables.push(vscode_1.workspace.onDidChangeWorkspaceFolders((event => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {added, removed} = event;
      yield Promise.all(added.map((folder => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       return yield this.registerWorkspaceFolder(folder);
      }))))), removed.forEach((removedWorkspaceFolder => this.unregisterWorkspaceFolder(removedWorkspaceFolder)));
     }))))), this._onProjectRegisteredUnregistered.event((event => {
      event.registered ? this.projects.set(event.root, event.name) : this.projects.delete(event.root);
      const projects = Array.from(this.projects.entries());
      vscode_1.commands.executeCommand("setContext", "dbtPowerUser.projectCount", projects.length), 
      1 === projects.length ? (this.setToWorkspaceState("dbtPowerUser.projectSelected", {
       label: projects[0][1],
       description: projects[0][0].fsPath,
       uri: projects[0][0]
      }), vscode_1.commands.executeCommand("setContext", "dbtPowerUser.walkthroughProjectSelected", !0)) : (this.setToWorkspaceState("dbtPowerUser.projectSelected", null), 
      vscode_1.commands.executeCommand("setContext", "dbtPowerUser.walkthroughProjectSelected", !1));
     }));
    }
    setContext(context) {
     this.context = context;
    }
    showErrorIfDbtOrPythonNotInstalled() {
     return this.dbtClient.showErrorIfDbtOrPythonNotInstalled();
    }
    showErrorIfDbtIsNotInstalled() {
     return this.dbtClient.showErrorIfDbtIsNotInstalled();
    }
    initializeDBTProjects() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const folders = vscode_1.workspace.workspaceFolders;
      void 0 !== folders && (yield Promise.all(folders.map((folder => this.registerWorkspaceFolder(folder)))));
     }));
    }
    showWalkthrough() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const answer = yield vscode_1.window.showInformationMessage("Thanks for installing dbt Power User. Do you need help setting up the extension?", PromptAnswer.YES, PromptAnswer.IGNORE);
      vscode_1.commands.executeCommand("setContext", "dbtPowerUser.showSetupWalkthrough", !1), 
      answer === PromptAnswer.YES && vscode_1.commands.executeCommand("dbtPowerUser.openSetupWalkthrough"), 
      this.setToGlobalState("showSetupWalkthrough", !1);
     }));
    }
    initializeWalkthrough() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const showSetupWalkthrough = this.getFromGlobalState("showSetupWalkthrough");
      void 0 !== showSetupWalkthrough && !0 !== showSetupWalkthrough || this.showWalkthrough();
      const allProjects = yield this.getProjects();
      vscode_1.commands.executeCommand("setContext", "dbtPowerUser.projectCount", allProjects.length);
      const existingAssociations = vscode_1.workspace.getConfiguration("files").get("associations", {});
      let showFileAssociationsStep = !1;
      Object.entries({
       "*.sql": [ "jinja-sql", "sql" ],
       "*.yml": [ "jinja-yaml", "yaml" ]
      }).forEach((([key, value]) => {
       void 0 === existingAssociations[key] && (showFileAssociationsStep || (showFileAssociationsStep = !0)), 
       showFileAssociationsStep || (showFileAssociationsStep = !value.includes(existingAssociations[key]));
      })), vscode_1.commands.executeCommand("setContext", "dbtPowerUser.showFileAssociationStep", showFileAssociationsStep);
     }));
    }
    get extensionUri() {
     return this.context.extensionUri;
    }
    get extensionVersion() {
     return this.context.extension.packageJSON.version;
    }
    setToWorkspaceState(key, value) {
     this.context.workspaceState.update(key, value);
    }
    getFromWorkspaceState(key) {
     return this.context.workspaceState.get(key);
    }
    setToGlobalState(key, value) {
     this.context.globalState.update(key, value);
    }
    getFromGlobalState(key) {
     return this.context.globalState.get(key);
    }
    get extensionId() {
     var _a;
     return (null === (_a = this.context) || void 0 === _a ? void 0 : _a.extension.id.toString()) || "";
    }
    detectDBT() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.dbtClient.detectDBT();
     }));
    }
    initialize() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.getProjects().forEach((project => project.initialize()));
     }));
    }
    executeSQL(uri, query) {
     var _a;
     null === (_a = this.findDBTProject(uri)) || void 0 === _a || _a.executeSQL(query);
    }
    getSummary(uri, query) {
     var _a;
     null === (_a = this.findDBTProject(uri)) || void 0 === _a || _a.getSummary(query);
    }
    runModel(modelPath, type) {
     var _a;
     null === (_a = this.findDBTProject(modelPath)) || void 0 === _a || _a.runModel(this.createModelParams(modelPath, type));
    }
    buildModel(modelPath, type) {
     var _a;
     null === (_a = this.findDBTProject(modelPath)) || void 0 === _a || _a.buildModel(this.createModelParams(modelPath, type));
    }
    runTest(modelPath, testName) {
     var _a;
     null === (_a = this.findDBTProject(modelPath)) || void 0 === _a || _a.runTest(testName);
    }
    runModelTest(modelPath, modelName) {
     var _a;
     null === (_a = this.findDBTProject(modelPath)) || void 0 === _a || _a.runModelTest(modelName);
    }
    compileModel(modelPath, type) {
     var _a;
     null === (_a = this.findDBTProject(modelPath)) || void 0 === _a || _a.compileModel(this.createModelParams(modelPath, type));
    }
    generateDocs(modelPath) {
     var _a;
     null === (_a = this.findDBTProject(modelPath)) || void 0 === _a || _a.generateDocs();
    }
    compileQuery(modelPath, query) {
     var _a;
     null === (_a = this.findDBTProject(modelPath)) || void 0 === _a || _a.compileQuery(query);
    }
    showRunSQL(modelPath) {
     var _a;
     null === (_a = this.findDBTProject(modelPath)) || void 0 === _a || _a.showRunSQL(modelPath);
    }
    showCompiledSQL(modelPath) {
     var _a;
     null === (_a = this.findDBTProject(modelPath)) || void 0 === _a || _a.showCompiledSql(modelPath);
    }
    generateSchemaYML(modelPath, modelName) {
     var _a;
     null === (_a = this.findDBTProject(modelPath)) || void 0 === _a || _a.generateSchemaYML(modelPath, modelName);
    }
    findDBTProject(uri) {
     var _a;
     return null === (_a = this.findDBTWorkspaceFolder(uri)) || void 0 === _a ? void 0 : _a.findDBTProject(uri);
    }
    getProjects() {
     return this.dbtWorkspaceFolders.flatMap((workspaceFolder => workspaceFolder.getProjects()));
    }
    getAdapters() {
     return Array.from(new Set(this.dbtWorkspaceFolders.flatMap((workspaceFolder => workspaceFolder.getAdapters()))));
    }
    getPythonEnvironment() {
     return this.dbtClient.getPythonEnvironment();
    }
    dispose() {
     for (this.dbtWorkspaceFolders.forEach((workspaceFolder => workspaceFolder.dispose())); this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    createModelParams(modelPath, type) {
     const modelName = (0, path_1.basename)(modelPath.fsPath, ".sql");
     return {
      plusOperatorLeft: type === domain_1.RunModelType.RUN_PARENTS || type === domain_1.RunModelType.BUILD_PARENTS || type === domain_1.RunModelType.BUILD_CHILDREN_PARENTS ? "+" : "",
      modelName,
      plusOperatorRight: type === domain_1.RunModelType.RUN_CHILDREN || type === domain_1.RunModelType.BUILD_CHILDREN || type === domain_1.RunModelType.BUILD_CHILDREN_PARENTS ? "+" : ""
     };
    }
    registerWorkspaceFolder(workspaceFolder) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const dbtProjectWorkspaceFolder = this.dbtWorkspaceFolderFactory(workspaceFolder, this._onManifestChanged, this._onProjectRegisteredUnregistered);
      this.dbtWorkspaceFolders.push(dbtProjectWorkspaceFolder), yield dbtProjectWorkspaceFolder.discoverProjects();
     }));
    }
    unregisterWorkspaceFolder(workspaceFolder) {
     const folderToDelete = this.findDBTWorkspaceFolder(workspaceFolder.uri);
     void 0 !== folderToDelete && (this.dbtWorkspaceFolders.splice(this.dbtWorkspaceFolders.indexOf(folderToDelete)), 
     folderToDelete.dispose());
    }
    findDBTWorkspaceFolder(uri) {
     return this.dbtWorkspaceFolders.find((folder => folder.contains(uri)));
    }
   };
   DBTProjectContainer = DBTProjectContainer_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DBTProjectContainer_1), tslib_1.__param(1, (0, 
   inversify_1.inject)("Factory<DBTWorkspaceFolder>")), tslib_1.__metadata("design:paramtypes", [ dbt_client_1.DBTClient, Function ]) ], DBTProjectContainer), 
   exports.DBTProjectContainer = DBTProjectContainer;
  },
  48084: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DBTWorkspaceFolder = void 0;
   const tslib_1 = __webpack_require__(70655), fs_1 = __webpack_require__(57147), inversify_1 = __webpack_require__(26594), path = __webpack_require__(71017), vscode_1 = __webpack_require__(66828), dbtProject_1 = __webpack_require__(49827), telemetry_1 = __webpack_require__(27407), yaml_1 = __webpack_require__(93419), dbtCoreIntegration_1 = __webpack_require__(16413);
   let DBTWorkspaceFolder = class {
    constructor(dbtProjectFactory, dbtCoreProjectDetection, telemetry, workspaceFolder, _onManifestChanged, _onProjectRegisteredUnregistered) {
     this.dbtProjectFactory = dbtProjectFactory, this.dbtCoreProjectDetection = dbtCoreProjectDetection, 
     this.telemetry = telemetry, this.workspaceFolder = workspaceFolder, this._onManifestChanged = _onManifestChanged, 
     this._onProjectRegisteredUnregistered = _onProjectRegisteredUnregistered, this.projectDiscoveryDiagnostics = vscode_1.languages.createDiagnosticCollection("dbt"), 
     this.dbtProjects = [], this.disposables = [], this.watcher = this.createConfigWatcher(), 
     this.disposables.push(this.watcher);
    }
    getAllowListFolders() {
     const nonFilteredAlolowListFolders = vscode_1.workspace.getConfiguration("dbt").get("allowListFolders", []).map((folder => path.isAbsolute(folder) ? folder : path.join(this.workspaceFolder.uri.fsPath, folder))), allowListFolders = nonFilteredAlolowListFolders.filter((folder => (0, 
     fs_1.existsSync)(folder)));
     return nonFilteredAlolowListFolders.length === allowListFolders.length && (console.warn("filtered out non-existing allowListFolders", allowListFolders, nonFilteredAlolowListFolders), 
     this.telemetry.sendTelemetryEvent("nonExistingAllowListFolders")), allowListFolders;
    }
    discoverProjects() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const dbtProjectFiles = yield vscode_1.workspace.findFiles(new vscode_1.RelativePattern(this.workspaceFolder, `**/${dbtProject_1.DBTProject.DBT_PROJECT_FILE}`)), allowListFolders = this.getAllowListFolders(), projectDirectories = dbtProjectFiles.filter((uri => (0, 
      fs_1.statSync)(uri.fsPath).isFile())).filter((uri => this.notInVenv(uri.fsPath))).filter((uri => 0 === allowListFolders.length || allowListFolders.some((folder => uri.fsPath.startsWith(folder))))).map((uri => vscode_1.Uri.file(uri.path.split("/").slice(0, -1).join("/"))));
      this.telemetry.sendTelemetryEvent("discoverProjects", {}, {
       numProjects: projectDirectories.length
      });
      const filteredProjects = yield this.dbtCoreProjectDetection.discoverProjects(projectDirectories);
      yield Promise.all(filteredProjects.map((uri => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       yield this.registerDBTProject(uri);
      })))));
     }));
    }
    findDBTProject(uri) {
     return this.dbtProjects.find((project => project.contains(uri)));
    }
    getProjects() {
     return this.dbtProjects;
    }
    contains(uri) {
     return uri.fsPath === this.workspaceFolder.uri.fsPath || uri.fsPath.startsWith(this.workspaceFolder.uri.fsPath + path.sep);
    }
    getAdapters() {
     return Array.from(new Set(this.dbtProjects.map((project => project.getAdapterType()))));
    }
    dispose() {
     for (this.dbtProjects.forEach((project => project.dispose())); this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    registerDBTProject(uri) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const projectConfig = dbtProject_1.DBTProject.readAndParseProjectConfig(uri), dbtProject = this.dbtProjectFactory(uri, projectConfig, this._onManifestChanged);
       yield dbtProject.initialize(), this.dbtProjects.push(dbtProject), this.dbtProjects.sort(((a, b) => -a.projectRoot.fsPath.localeCompare(b.projectRoot.fsPath))), 
       this.projectDiscoveryDiagnostics.clear(), this._onProjectRegisteredUnregistered.fire({
        root: uri,
        name: dbtProject.getProjectName(),
        registered: !0
       });
      } catch (error) {
       error instanceof yaml_1.YAMLError && this.projectDiscoveryDiagnostics.set(vscode_1.Uri.joinPath(uri, dbtProject_1.DBTProject.DBT_PROJECT_FILE), [ new vscode_1.Diagnostic(new vscode_1.Range(0, 0, 999, 999), error.message) ]), 
       vscode_1.window.showErrorMessage(`Skipping project: could not parse dbt_project_config.yml at '${uri}': ${error}`), 
       this.telemetry.sendTelemetryError("registerDBTProjectError", error);
      }
     }));
    }
    unregisterDBTProject(uri) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const projectToDelete = this.dbtProjects.find((dbtProject => dbtProject.projectRoot.fsPath === uri.fsPath));
      void 0 !== projectToDelete && (this.dbtProjects.splice(this.dbtProjects.indexOf(projectToDelete), 1), 
      this._onProjectRegisteredUnregistered.fire({
       root: uri,
       name: projectToDelete.getProjectName(),
       registered: !1
      }), yield projectToDelete.dispose());
     }));
    }
    createConfigWatcher() {
     const watcher = vscode_1.workspace.createFileSystemWatcher(new vscode_1.RelativePattern(this.workspaceFolder, `**/${dbtProject_1.DBTProject.DBT_PROJECT_FILE}`)), dirName = uri => vscode_1.Uri.file(path.dirname(uri.fsPath));
     return watcher.onDidCreate((uri => {
      const allowListFolders = this.getAllowListFolders();
      (0, fs_1.statSync)(uri.fsPath).isFile() && this.notInVenv(uri.fsPath) && this.notInDBtPackages(uri.fsPath, this.dbtProjects.map((project => project.getPackageInstallPath()))) && (0 === allowListFolders.length || allowListFolders.some((folder => uri.fsPath.startsWith(folder)))) && this.registerDBTProject(dirName(uri));
     })), watcher.onDidDelete((uri => this.unregisterDBTProject(dirName(uri)))), this.disposables.push(watcher), 
     watcher;
    }
    notInVenv(path) {
     return !path.includes("site-packages");
    }
    notInDBtPackages(uri, packagesInstallPaths) {
     for (const packagesInstallPath of packagesInstallPaths) if (packagesInstallPath && uri.startsWith(packagesInstallPath)) return !1;
     return !0;
    }
   };
   DBTWorkspaceFolder = tslib_1.__decorate([ tslib_1.__param(0, (0, inversify_1.inject)("DBTProjectFactory")), tslib_1.__metadata("design:paramtypes", [ Function, dbtCoreIntegration_1.DBTCoreProjectDetection, telemetry_1.TelemetryService, Object, vscode_1.EventEmitter, vscode_1.EventEmitter ]) ], DBTWorkspaceFolder), 
   exports.DBTWorkspaceFolder = DBTWorkspaceFolder;
  },
  5579: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ProjectConfigChangedEvent = void 0;
   exports.ProjectConfigChangedEvent = class {
    constructor(project) {
     this.project = project;
    }
   };
  },
  12759: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DBTProjectLogFactory_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DBTProjectLog = exports.DBTProjectLogFactory = void 0;
   const tslib_1 = __webpack_require__(70655), fs_1 = __webpack_require__(57147), path = __webpack_require__(71017), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593);
   let DBTProjectLogFactory = DBTProjectLogFactory_1 = class {
    createDBTProjectLog(onProjectConfigChanged) {
     return new DBTProjectLog(onProjectConfigChanged);
    }
   };
   DBTProjectLogFactory = DBTProjectLogFactory_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DBTProjectLogFactory_1) ], DBTProjectLogFactory), 
   exports.DBTProjectLogFactory = DBTProjectLogFactory;
   class DBTProjectLog {
    constructor(onProjectConfigChanged) {
     this.logPosition = 0, this.disposables = [], this.disposables.push(onProjectConfigChanged((event => this.onProjectConfigChanged(event))));
    }
    onProjectConfigChanged(event) {
     const projectRoot = event.project.projectRoot, projectName = event.project.getProjectName();
     void 0 === this.outputChannel && (this.outputChannel = vscode_1.window.createOutputChannel(`${projectName} dbt logs`), 
     this.readLogFileFromLastPosition(event), this.logFileWatcher = vscode_1.workspace.createFileSystemWatcher(new vscode_1.RelativePattern(projectRoot.path, `${DBTProjectLog.LOG_PATH}/${DBTProjectLog.LOG_FILE}`)), 
     (0, utils_1.setupWatcherHandler)(this.logFileWatcher, (() => this.readLogFileFromLastPosition(event))), 
     this.currentProjectName = projectName), this.currentProjectName !== projectName && (this.outputChannel.dispose(), 
     this.outputChannel = vscode_1.window.createOutputChannel(`${projectName} dbt logs`), 
     this.logPosition = 0, this.readLogFileFromLastPosition(event), this.currentProjectName = projectName);
    }
    readLogFileFromLastPosition(event) {
     const {project: {projectRoot}} = event, logPath = path.join(projectRoot.fsPath, DBTProjectLog.LOG_PATH, DBTProjectLog.LOG_FILE);
     if (this.outputChannel && (0, fs_1.existsSync)(logPath)) {
      let fileHandle;
      try {
       fileHandle = (0, fs_1.openSync)(logPath, "r");
       const chunkSize = 1048576, buffer = Buffer.alloc(chunkSize);
       for (;;) {
        const bytesRead = (0, fs_1.readSync)(fileHandle, buffer, 0, buffer.length, this.logPosition);
        if (!bytesRead) break;
        this.logPosition += bytesRead, this.outputChannel.appendLine((0, utils_1.stripANSI)(buffer.toString("utf8", 0, bytesRead)));
       }
      } catch (error) {
       console.log("Could not read log file", error);
      } finally {
       fileHandle && (0, fs_1.closeSync)(fileHandle);
      }
     }
    }
    dispose() {
     for (void 0 !== this.outputChannel && this.outputChannel.dispose(); this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   }
   exports.DBTProjectLog = DBTProjectLog, DBTProjectLog.LOG_PATH = "logs", DBTProjectLog.LOG_FILE = "dbt.log";
  },
  35572: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var SourceFileWatchersFactory_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SourceFileWatchers = exports.SourceFileWatchersFactory = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593);
   let SourceFileWatchersFactory = SourceFileWatchersFactory_1 = class {
    createSourceFileWatchers(onProjectConfigChanged) {
     return new SourceFileWatchers(onProjectConfigChanged);
    }
   };
   SourceFileWatchersFactory = SourceFileWatchersFactory_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(SourceFileWatchersFactory_1) ], SourceFileWatchersFactory), 
   exports.SourceFileWatchersFactory = SourceFileWatchersFactory;
   class SourceFileWatchers {
    constructor(onProjectConfigChanged) {
     this._onSourceFileChanged = new vscode_1.EventEmitter, this.onSourceFileChanged = this._onSourceFileChanged.event, 
     this.watchers = [], this.disposables = [ this._onSourceFileChanged ], this.disposables.push(onProjectConfigChanged((event => this.onProjectConfigChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
     this.disposeWatchers();
    }
    disposeWatchers() {
     this.watchers.forEach((watcher => watcher.dispose()));
    }
    onProjectConfigChanged(event) {
     const project = event.project, sourcePaths = project.getModelPaths();
     if (void 0 === sourcePaths) throw new Error("sourcePaths is not defined in project in " + project.projectRoot.fsPath);
     const macroPaths = project.getMacroPaths();
     if (void 0 === macroPaths) throw new Error("macroPaths is not defined in " + project.projectRoot.fsPath);
     const paths = sourcePaths.concat(macroPaths);
     void 0 !== this.currentSourcePaths && (0, utils_1.arrayEquals)(this.currentSourcePaths, sourcePaths) || (this.disposeWatchers(), 
     this.watchers = [], paths.forEach((sourcePath => {
      const sourceFolderWatcher = vscode_1.workspace.createFileSystemWatcher(new vscode_1.RelativePattern(sourcePath, "**/*.{sql,yml,yaml}")), debouncedSourceFileChangedEvent = (0, 
      utils_1.debounce)((() => this._onSourceFileChanged.fire()), 2e3);
      sourceFolderWatcher.onDidChange((() => debouncedSourceFileChangedEvent())), this.watchers.push(sourceFolderWatcher);
     })), this.currentSourcePaths = sourcePaths);
    }
   }
   exports.SourceFileWatchers = SourceFileWatchers;
  },
  15557: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var TargetWatchersFactory_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.TargetWatchers = exports.TargetWatchersFactory = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593), dbtProject_1 = __webpack_require__(49827), parsers_1 = __webpack_require__(70564);
   let TargetWatchersFactory = TargetWatchersFactory_1 = class {
    constructor(manifestParser) {
     this.manifestParser = manifestParser;
    }
    createTargetWatchers(_onManifestChanged, onProjectConfigChanged) {
     return new TargetWatchers(_onManifestChanged, onProjectConfigChanged, this.manifestParser);
    }
   };
   TargetWatchersFactory = TargetWatchersFactory_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(TargetWatchersFactory_1), tslib_1.__metadata("design:paramtypes", [ parsers_1.ManifestParser ]) ], TargetWatchersFactory), 
   exports.TargetWatchersFactory = TargetWatchersFactory;
   class TargetWatchers {
    constructor(_onManifestChanged, onProjectConfigChanged, manifestParser) {
     this.manifestParser = manifestParser, this.disposables = [], this.watchers = [], 
     this._onManifestChanged = _onManifestChanged, this.disposables.push(onProjectConfigChanged((event => this.onProjectConfigChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
     this.disposeWatchers();
    }
    disposeWatchers() {
     this.watchers.forEach((watcher => watcher.dispose()));
    }
    onProjectConfigChanged(event) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const projectName = event.project.getProjectName(), targetPath = event.project.getTargetPath();
      if (targetPath) {
       if (void 0 === this.currentTargetPath || this.currentTargetPath !== targetPath || void 0 === this.currentProjectName || this.currentProjectName !== projectName) {
        this.disposeWatchers(), this.watchers = [];
        const handler = () => tslib_1.__awaiter(this, void 0, void 0, (function*() {
         const manifestCacheChangedEvent = yield this.manifestParser.parseManifest(event.project);
         manifestCacheChangedEvent && this._onManifestChanged.fire(manifestCacheChangedEvent);
        }));
        this.manifestWatcher = this.createManifestWatcher(event), (0, utils_1.setupWatcherHandler)(this.manifestWatcher, (() => handler())), 
        this.targetFolderWatcher = this.createTargetFolderWatcher(event), this.targetFolderWatcher.onDidDelete((() => () => handler())), 
        this.currentTargetPath = targetPath, this.currentProjectName = projectName, this.watchers.push(this.manifestWatcher, this.targetFolderWatcher);
        const manifestCacheChangedEvent = yield this.manifestParser.parseManifest(event.project);
        manifestCacheChangedEvent && this._onManifestChanged.fire(manifestCacheChangedEvent);
       }
      } else console.error("targetPath should be defined at this stage for project " + event.project.projectRoot.fsPath);
     }));
    }
    createManifestWatcher(event) {
     const targetPath = event.project.getTargetPath();
     if (!targetPath) throw console.error("targetPath is undefined"), new Error("targetPath is undefined in " + event.project.projectRoot.fsPath);
     event.project.projectRoot;
     return vscode_1.workspace.createFileSystemWatcher(new vscode_1.RelativePattern(targetPath, dbtProject_1.DBTProject.MANIFEST_FILE));
    }
    createTargetFolderWatcher(event) {
     const targetPath = event.project.getTargetPath();
     if (!targetPath) throw console.error("targetPath is undefined"), new Error("targetPath is undefined in " + event.project.projectRoot.fsPath);
     return vscode_1.workspace.createFileSystemWatcher(new vscode_1.RelativePattern(targetPath, "*"));
    }
   }
   exports.TargetWatchers = TargetWatchers;
  },
  51350: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DocParser_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DocParser = void 0;
   const tslib_1 = __webpack_require__(70655), fs_1 = __webpack_require__(57147), inversify_binding_decorators_1 = __webpack_require__(84904), dbtTerminal_1 = __webpack_require__(26684), _1 = __webpack_require__(70564);
   let DocParser = DocParser_1 = class {
    constructor(terminal) {
     this.terminal = terminal;
    }
    createDocMetaMap(docs, project) {
     return new Promise((resolve => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const docMetaMap = new Map;
      if (null != docs) if ("function" == typeof docs[Symbol.iterator]) {
       for (const doc of docs) {
        const {package_name, name, original_file_path} = doc, packageName = package_name, projectName = project.getProjectName(), packagePath = project.getPackageInstallPath();
        if (void 0 === packagePath) throw new Error("packagePath is not defined in " + project.projectRoot.fsPath);
        const docName = packageName === projectName ? name : `${packageName}.${name}`, fullPath = (0, 
        _1.createFullPathForNode)(projectName, project.projectRoot.fsPath, packageName, packagePath, original_file_path);
        if (!fullPath) return;
        try {
         const macroFileLines = (0, fs_1.readFileSync)(fullPath).toString("utf8").split("\n");
         for (let index = 0; index < macroFileLines.length; index++) {
          const currentLine = macroFileLines[index];
          if (currentLine.match(new RegExp(`docs\\s${name}`))) {
           docMetaMap.set(docName, {
            path: fullPath,
            line: index,
            character: currentLine.indexOf(name)
           });
           break;
          }
         }
        } catch (error) {
         console.log(`File not found at '${fullPath}', project may need to be recompiled.`, error), 
         this.terminal.log(`File not found at '${fullPath}', probably compiled is outdated. ${error}`);
        }
       }
       resolve(docMetaMap);
      } else resolve(docMetaMap); else resolve(docMetaMap);
     }))));
    }
   };
   DocParser = DocParser_1 = tslib_1.__decorate([ (0, inversify_binding_decorators_1.provide)(DocParser_1), tslib_1.__metadata("design:paramtypes", [ dbtTerminal_1.DBTTerminal ]) ], DocParser), 
   exports.DocParser = DocParser;
  },
  36237: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ExposureParser_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ExposureParser = void 0;
   const tslib_1 = __webpack_require__(70655), inversify_binding_decorators_1 = __webpack_require__(84904), path = __webpack_require__(71017), dbtProject_1 = __webpack_require__(49827);
   let ExposureParser = ExposureParser_1 = class {
    createExposureMetaMap(exposuresMap, rootPath) {
     return new Promise((resolve => {
      const exposureMetaMap = new Map;
      null == exposuresMap && resolve(exposureMetaMap), Object.values(exposuresMap).filter((exposure => exposure.resource_type === dbtProject_1.DBTProject.RESOURCE_TYPE_EXPOSURE)).forEach((exposure => {
       const fullPath = path.join(rootPath, exposure.original_file_path);
       exposureMetaMap.set(exposure.name, Object.assign(Object.assign({}, exposure), {
        path: fullPath
       }));
      })), resolve(exposureMetaMap);
     }));
    }
   };
   ExposureParser = ExposureParser_1 = tslib_1.__decorate([ (0, inversify_binding_decorators_1.provide)(ExposureParser_1) ], ExposureParser), 
   exports.ExposureParser = ExposureParser;
  },
  21266: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var GraphParser_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.GraphParser = void 0;
   const tslib_1 = __webpack_require__(70655), inversify_binding_decorators_1 = __webpack_require__(84904), domain_1 = __webpack_require__(37512), utils_1 = __webpack_require__(78593);
   let GraphParser = GraphParser_1 = class {
    createGraphMetaMap(parentMap, childrenMap, nodeMetaMap, sourceMetaMap, testMetaMap) {
     const unique = nodes => Array.from(new Set(nodes));
     return {
      parents: Object.entries(parentMap).reduce(((map, [nodeName, nodes]) => {
       const currentNodes = unique(nodes).map(this.mapToNode(sourceMetaMap, nodeMetaMap, testMetaMap)).filter(utils_1.notEmpty);
       return map.set(nodeName, {
        nodes: currentNodes
       }), map;
      }), new Map),
      children: Object.entries(childrenMap).reduce(((map, [nodeName, nodes]) => {
       const currentNodes = unique(nodes).map(this.mapToNode(sourceMetaMap, nodeMetaMap, testMetaMap)).filter((n => !(n instanceof domain_1.Test))).filter(utils_1.notEmpty);
       return map.set(nodeName, {
        nodes: currentNodes
       }), map;
      }), new Map),
      tests: Object.entries(childrenMap).reduce(((map, [nodeName, nodes]) => {
       const currentNodes = unique(nodes).map(this.mapToNode(sourceMetaMap, nodeMetaMap, testMetaMap)).filter((n => n instanceof domain_1.Test)).filter(utils_1.notEmpty);
       return map.set(nodeName, {
        nodes: currentNodes
       }), map;
      }), new Map)
     };
    }
    mapToNode(sourceMetaMap, nodeMetaMap, testMetaMap) {
     return parentNodeName => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const [nodeType, nodePackage, ...restNodeName] = parentNodeName.split("."), nodeName = restNodeName.join(".");
      switch (nodeType) {
      case "source":
       {
        const [sourceName, tableName] = nodeName.split("."), url = null === (_b = null === (_a = sourceMetaMap.get(sourceName)) || void 0 === _a ? void 0 : _a.tables.find((table => table.name === tableName))) || void 0 === _b ? void 0 : _b.path;
        return new domain_1.Source(`${tableName} (${sourceName})`, parentNodeName, url);
       }

      case "model":
       {
        const url = null === (_c = nodeMetaMap.get(nodeName)) || void 0 === _c ? void 0 : _c.path;
        return new domain_1.Model(nodeName, parentNodeName, url);
       }

      case "seed":
       {
        const url = null === (_d = nodeMetaMap.get(nodeName)) || void 0 === _d ? void 0 : _d.path;
        return new domain_1.Seed(nodeName, parentNodeName, url);
       }

      case "test":
       {
        const url = null === (_e = testMetaMap.get(nodeName.split(".")[0])) || void 0 === _e ? void 0 : _e.path;
        return new domain_1.Test(nodeName, parentNodeName, null != url ? url : "");
       }

      case "analysis":
       {
        const url = null === (_f = nodeMetaMap.get(nodeName)) || void 0 === _f ? void 0 : _f.path;
        return new domain_1.Analysis(nodeName, parentNodeName, url);
       }

      case "snapshot":
       {
        const url = null === (_g = nodeMetaMap.get(nodeName)) || void 0 === _g ? void 0 : _g.path;
        return new domain_1.Snapshot(nodeName, parentNodeName, url);
       }

      case "exposure":
       {
        const url = null === (_h = nodeMetaMap.get(nodeName)) || void 0 === _h ? void 0 : _h.path;
        return new domain_1.Exposure(nodeName, parentNodeName, url);
       }

      default:
       return void console.log(`Node Type '${nodeType}' not implemented!`);
      }
     };
    }
   };
   GraphParser = GraphParser_1 = tslib_1.__decorate([ (0, inversify_binding_decorators_1.provide)(GraphParser_1) ], GraphParser), 
   exports.GraphParser = GraphParser;
  },
  70564: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ManifestParser_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.createFullPathForNode = exports.ManifestParser = void 0;
   const tslib_1 = __webpack_require__(70655), fs_1 = __webpack_require__(57147), inversify_binding_decorators_1 = __webpack_require__(84904), path = __webpack_require__(71017), dbtTerminal_1 = __webpack_require__(26684), dbtProject_1 = __webpack_require__(49827), docParser_1 = __webpack_require__(51350), graphParser_1 = __webpack_require__(21266), macroParser_1 = __webpack_require__(39626), nodeParser_1 = __webpack_require__(20951), sourceParser_1 = __webpack_require__(17096), testParser_1 = __webpack_require__(11299), telemetry_1 = __webpack_require__(27407), exposureParser_1 = __webpack_require__(36237);
   let ManifestParser = ManifestParser_1 = class {
    constructor(nodeParser, macroParser, graphParser, sourceParser, testParser, exposureParser, docParser, terminal, telemetry) {
     this.nodeParser = nodeParser, this.macroParser = macroParser, this.graphParser = graphParser, 
     this.sourceParser = sourceParser, this.testParser = testParser, this.exposureParser = exposureParser, 
     this.docParser = docParser, this.terminal = terminal, this.telemetry = telemetry;
    }
    parseManifest(project) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const targetPath = project.getTargetPath();
      if (!targetPath) return void console.error("targetPath should be defined at this stage for project " + project.projectRoot.fsPath);
      const projectRoot = project.projectRoot, manifest = this.readAndParseManifest(projectRoot, targetPath);
      if (void 0 === manifest) {
       return {
        added: [ {
         project,
         nodeMetaMap: new Map,
         macroMetaMap: new Map,
         sourceMetaMap: new Map,
         testMetaMap: new Map,
         graphMetaMap: {
          parents: new Map,
          children: new Map,
          tests: new Map
         },
         docMetaMap: new Map,
         exposureMetaMap: new Map
        } ]
       };
      }
      const {nodes, sources, macros, parent_map, child_map, docs, exposures} = manifest, rootPath = projectRoot.fsPath, nodeMetaMapPromise = this.nodeParser.createNodeMetaMap(nodes, project), macroMetaMapPromise = this.macroParser.createMacroMetaMap(macros, project), sourceMetaMapPromise = this.sourceParser.createSourceMetaMap(sources, project), testMetaMapPromise = this.testParser.createTestMetaMap(nodes, project), exposuresMetaMapPromise = this.exposureParser.createExposureMetaMap(exposures, rootPath), docMetaMapPromise = this.docParser.createDocMetaMap(docs, project), [nodeMetaMap, macroMetaMap, sourceMetaMap, testMetaMap, docMetaMap, exposureMetaMap] = yield Promise.all([ nodeMetaMapPromise, macroMetaMapPromise, sourceMetaMapPromise, testMetaMapPromise, docMetaMapPromise, exposuresMetaMapPromise ]), graphMetaMap = this.graphParser.createGraphMetaMap(parent_map, child_map, nodeMetaMap, sourceMetaMap, testMetaMap), nodeCounts = Object.values(nodes).reduce(((map, node) => {
       const key = node.resource_type + "_count";
       return map.has(key) || map.set(key, 0), map.set(key, map.get(key) + 1), map;
      }), new Map), parseManifestProps = Object.assign(Object.assign({}, Object.fromEntries(nodeCounts.entries())), {
       sources_count: sourceMetaMap.size,
       macros_count: macroMetaMap.size
      });
      void 0 !== this.lastSentParseManifestProps && Object.entries(this.lastSentParseManifestProps).toString() === Object.entries(parseManifestProps).toString() || (this.telemetry.sendTelemetryEvent("parseManifest", {
       project: dbtProject_1.DBTProject.hashProjectRoot(projectRoot.fsPath)
      }, parseManifestProps), this.lastSentParseManifestProps = parseManifestProps);
      return {
       added: [ {
        project,
        nodeMetaMap,
        macroMetaMap,
        sourceMetaMap,
        graphMetaMap,
        testMetaMap,
        docMetaMap,
        exposureMetaMap
       } ]
      };
     }));
    }
    readAndParseManifest(projectRoot, targetPath) {
     const pathParts = [ targetPath ];
     path.isAbsolute(targetPath) || pathParts.unshift(projectRoot.fsPath);
     const manifestLocation = path.join(...pathParts, dbtProject_1.DBTProject.MANIFEST_FILE);
     try {
      const manifestFile = (0, fs_1.readFileSync)(manifestLocation, "utf8");
      return JSON.parse(manifestFile);
     } catch (error) {
      this.terminal.log(`Could not read manifest file at ${manifestLocation}: ${error}`);
     }
    }
   };
   ManifestParser = ManifestParser_1 = tslib_1.__decorate([ (0, inversify_binding_decorators_1.provide)(ManifestParser_1), tslib_1.__metadata("design:paramtypes", [ nodeParser_1.NodeParser, macroParser_1.MacroParser, graphParser_1.GraphParser, sourceParser_1.SourceParser, testParser_1.TestParser, exposureParser_1.ExposureParser, docParser_1.DocParser, dbtTerminal_1.DBTTerminal, telemetry_1.TelemetryService ]) ], ManifestParser), 
   exports.ManifestParser = ManifestParser;
   exports.createFullPathForNode = (projectName, rootPath, packageName, packagePath, relativeFilePath) => {
    if (packageName !== projectName) {
     const rootPathWithPackage = path.join(packagePath, packageName, relativeFilePath);
     return (0, fs_1.existsSync)(rootPathWithPackage) ? rootPathWithPackage : void 0;
    }
    return path.join(rootPath, relativeFilePath);
   };
  },
  39626: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var MacroParser_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.MacroParser = void 0;
   const tslib_1 = __webpack_require__(70655), fs_1 = __webpack_require__(57147), inversify_binding_decorators_1 = __webpack_require__(84904), dbtTerminal_1 = __webpack_require__(26684), _1 = __webpack_require__(70564);
   let MacroParser = MacroParser_1 = class {
    constructor(terminal) {
     this.terminal = terminal;
    }
    createMacroMetaMap(macros, project) {
     return new Promise((resolve => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const macroMetaMap = new Map;
      null == macros && resolve(macroMetaMap);
      const rootPath = project.projectRoot.fsPath, projectName = project.getProjectName(), packagePath = project.getPackageInstallPath();
      if (void 0 === packagePath) throw new Error("packagePath is not defined in " + project.projectRoot.fsPath);
      for (const key in macros) {
       const macro = macros[key], {package_name, name, original_file_path} = macro, packageName = package_name, macroName = packageName === projectName ? name : `${packageName}.${name}`, fullPath = (0, 
       _1.createFullPathForNode)(projectName, rootPath, packageName, packagePath, original_file_path);
       if (fullPath) try {
        const macroFileLines = (0, fs_1.readFileSync)(fullPath).toString("utf8").split("\n");
        for (let index = 0; index < macroFileLines.length; index++) {
         const currentLine = macroFileLines[index];
         if (currentLine.match(new RegExp(`macro\\s${name}\\(`))) {
          macroMetaMap.set(macroName, {
           path: fullPath,
           line: index,
           character: currentLine.indexOf(name)
          });
          break;
         }
        }
       } catch (error) {
        console.log(`File not found at '${fullPath}', project may need to be recompiled.`, error), 
        this.terminal.log(`File not found at '${fullPath}', probably compiled is outdated. ${error}`);
       }
      }
      resolve(macroMetaMap);
     }))));
    }
   };
   MacroParser = MacroParser_1 = tslib_1.__decorate([ (0, inversify_binding_decorators_1.provide)(MacroParser_1), tslib_1.__metadata("design:paramtypes", [ dbtTerminal_1.DBTTerminal ]) ], MacroParser), 
   exports.MacroParser = MacroParser;
  },
  20951: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var NodeParser_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.NodeParser = void 0;
   const tslib_1 = __webpack_require__(70655), inversify_binding_decorators_1 = __webpack_require__(84904), dbtProject_1 = __webpack_require__(49827), _1 = __webpack_require__(70564);
   let NodeParser = NodeParser_1 = class {
    createNodeMetaMap(nodesMap, project) {
     return new Promise((resolve => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const modelMetaMap = new Map;
      null == nodesMap && resolve(modelMetaMap);
      const nodesMaps = Object.values(nodesMap).filter((model => model.resource_type === dbtProject_1.DBTProject.RESOURCE_TYPE_MODEL || model.resource_type === dbtProject_1.DBTProject.RESOURCE_TYPE_SEED || model.resource_type === dbtProject_1.DBTProject.RESOURCE_TYPE_ANALYSIS || model.resource_type === dbtProject_1.DBTProject.RESOURCE_TYPE_SNAPSHOT)), rootPath = project.projectRoot.fsPath, projectName = project.getProjectName(), packagePath = project.getPackageInstallPath();
      if (void 0 === packagePath) throw new Error("packagePath is not defined " + project.projectRoot.fsPath);
      for (const nodesMap of nodesMaps) {
       const {name, original_file_path, database, schema, alias, package_name, unique_id, columns, description, patch_path, config, resource_type} = nodesMap, fullPath = (0, 
       _1.createFullPathForNode)(projectName, rootPath, package_name, packagePath, original_file_path);
       if (!fullPath) return;
       modelMetaMap.set(name, {
        path: fullPath,
        database,
        schema,
        alias,
        name,
        package_name,
        uniqueId: unique_id,
        columns,
        description,
        patch_path,
        config,
        resource_type
       });
      }
      resolve(modelMetaMap);
     }))));
    }
   };
   NodeParser = NodeParser_1 = tslib_1.__decorate([ (0, inversify_binding_decorators_1.provide)(NodeParser_1) ], NodeParser), 
   exports.NodeParser = NodeParser;
  },
  17096: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var SourceParser_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SourceParser = void 0;
   const tslib_1 = __webpack_require__(70655), inversify_binding_decorators_1 = __webpack_require__(84904), path = __webpack_require__(71017), dbtTerminal_1 = __webpack_require__(26684), dbtProject_1 = __webpack_require__(49827);
   let SourceParser = SourceParser_1 = class {
    constructor(terminal) {
     this.terminal = terminal;
    }
    createSourceMetaMap(sourcesMap, project) {
     return new Promise((resolve => {
      const sourceMetaMap = new Map;
      null == sourcesMap && resolve(sourceMetaMap);
      const rootPath = project.projectRoot.fsPath;
      project.getProjectName();
      if (void 0 === project.getPackageInstallPath()) throw new Error("packagePath is not defined in " + project.projectRoot.fsPath);
      Object.values(sourcesMap).filter((source => source.resource_type === dbtProject_1.DBTProject.RESOURCE_TYPE_SOURCE)).reduce(((previousValue, {source_name, database, schema, name, original_file_path, unique_id, description, columns, identifier}) => {
       let source = previousValue.get(source_name);
       source || (source = {
        tables: [],
        uniqueId: unique_id,
        name: source_name,
        database,
        schema
       }, previousValue.set(source_name, source));
       const fullPath = path.join(rootPath, original_file_path);
       return source.tables.push({
        name,
        identifier,
        path: fullPath,
        description,
        columns
       }), previousValue;
      }), sourceMetaMap), resolve(sourceMetaMap);
     }));
    }
   };
   SourceParser = SourceParser_1 = tslib_1.__decorate([ (0, inversify_binding_decorators_1.provide)(SourceParser_1), tslib_1.__metadata("design:paramtypes", [ dbtTerminal_1.DBTTerminal ]) ], SourceParser), 
   exports.SourceParser = SourceParser;
  },
  11299: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var TestParser_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.TestParser = void 0;
   const tslib_1 = __webpack_require__(70655), inversify_binding_decorators_1 = __webpack_require__(84904), path = __webpack_require__(71017), dbtProject_1 = __webpack_require__(49827);
   let TestParser = TestParser_1 = class {
    createTestMetaMap(testsMap, project) {
     return new Promise((resolve => {
      const testMetaMap = new Map;
      null == testsMap && resolve(testMetaMap);
      const rootPath = project.projectRoot.fsPath;
      Object.values(testsMap).filter((test => test.resource_type === dbtProject_1.DBTProject.RESOURCE_TYPE_TEST)).forEach((({name, raw_sql, original_file_path, database, schema, alias, column_name}) => {
       const fullPath = path.join(rootPath, original_file_path);
       testMetaMap.set(name, {
        path: fullPath,
        raw_sql,
        database,
        schema,
        alias,
        column_name
       });
      })), resolve(testMetaMap);
     }));
    }
   };
   TestParser = TestParser_1 = tslib_1.__decorate([ (0, inversify_binding_decorators_1.provide)(TestParser_1) ], TestParser), 
   exports.TestParser = TestParser;
  },
  53003: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var PythonEnvironment_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.PythonEnvironment = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593), telemetry_1 = __webpack_require__(27407), commandProcessExecution_1 = __webpack_require__(11986);
   let PythonEnvironment = PythonEnvironment_1 = class {
    constructor(telemetry, commandProcessExecutionFactory) {
     this.telemetry = telemetry, this.commandProcessExecutionFactory = commandProcessExecutionFactory, 
     this.disposables = [], this.parseEnvVarsFromUserSettings = vsCodeEnv => Object.keys(vsCodeEnv).reduce(((prev, key) => (prev[key] = (0, 
     utils_1.substituteSettingsVariables)(vsCodeEnv[key]), prev)), vsCodeEnv);
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    get pythonPath() {
     return this.getPythonPathFromConfig() || this.executionDetails.getPythonPath();
    }
    get environmentVariables() {
     return this.executionDetails.getEnvVars();
    }
    get onPythonEnvironmentChanged() {
     return this.executionDetails.onDidChangeExecutionDetails;
    }
    initialize() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      void 0 === this.executionDetails && (this.executionDetails = yield this.activatePythonExtension());
     }));
    }
    getPythonPathFromConfig() {
     const value = vscode_1.workspace.getConfiguration("dbt").get("dbtPythonPathOverride");
     return value ? (0, utils_1.substituteSettingsVariables)(value) : void 0;
    }
    activatePythonExtension() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const extension = vscode_1.extensions.getExtension("ms-python.python");
      extension.isActive || (yield extension.activate()), yield extension.exports.ready;
      const api = extension.exports, dbtInstalledPythonPath = [];
      return this.executionDetails = {
       getPythonPath: () => dbtInstalledPythonPath.length > 0 ? dbtInstalledPythonPath[0] : api.settings.getExecutionDetails(vscode_1.workspace.workspaceFile).execCommand[0],
       onDidChangeExecutionDetails: api.settings.onDidChangeExecutionDetails,
       getEnvVars: () => {
        const configText = vscode_1.workspace.getConfiguration(), config = JSON.parse(JSON.stringify(configText));
        let envVars = {};
        if (void 0 !== config.terminal && void 0 !== config.terminal.integrated && void 0 !== config.terminal.integrated.env) {
         const env = config.terminal.integrated.env;
         for (const prop in env) {
          const vsCodeEnv = env[prop];
          envVars = Object.assign(Object.assign(Object.assign({}, process.env), envVars), this.parseEnvVarsFromUserSettings(vsCodeEnv));
         }
        }
        try {
         api.environment && (envVars = Object.assign(Object.assign({}, envVars), api.environments.getEnvironmentVariables(vscode_1.workspace.workspaceFolders[0])));
        } catch (e) {
         this.telemetry.sendTelemetryError("vsCodeApiEnvironmentVariablesNotLoading", e), 
         console.error("Could not call environment api", e);
        }
        return envVars;
       }
      };
     }));
    }
   };
   PythonEnvironment = PythonEnvironment_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(PythonEnvironment_1), tslib_1.__metadata("design:paramtypes", [ telemetry_1.TelemetryService, commandProcessExecution_1.CommandProcessExecutionFactory ]) ], PythonEnvironment), 
   exports.PythonEnvironment = PythonEnvironment;
  },
  83213: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DbtPowerUserActionsCenter_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DbtPowerUserActionsCenter = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593), puQuickPick_1 = __webpack_require__(36862), projectQuickPick_1 = __webpack_require__(47310), dbtProjectContainer_1 = __webpack_require__(37343), sqlQuickPick_1 = __webpack_require__(68429);
   let DbtPowerUserActionsCenter = DbtPowerUserActionsCenter_1 = class {
    constructor(puLaunchQuickPick, projectQuickPick, dbtProjectContainer, sqlQuickPick) {
     this.puLaunchQuickPick = puLaunchQuickPick, this.projectQuickPick = projectQuickPick, 
     this.dbtProjectContainer = dbtProjectContainer, this.sqlQuickPick = sqlQuickPick, 
     this.disposables = [], vscode_1.commands.registerCommand("dbtPowerUser.puQuickPick", (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.puLaunchQuickPick.openPuQuickPick();
     })))), vscode_1.commands.registerCommand("dbtPowerUser.sqlQuickPick", (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.sqlQuickPick.openQuickPick();
     })))), vscode_1.commands.registerCommand("dbtPowerUser.pickProject", (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const pickedProject = yield this.projectQuickPick.projectPicker(yield this.dbtProjectContainer.getProjects());
      pickedProject && (this.dbtProjectContainer.setToWorkspaceState("dbtPowerUser.projectSelected", pickedProject), 
      vscode_1.commands.executeCommand("setContext", "dbtPowerUser.walkthroughProjectSelected", !0), 
      vscode_1.window.showInformationMessage("You have succesfully selected " + pickedProject.label + "."));
     }))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   DbtPowerUserActionsCenter = DbtPowerUserActionsCenter_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DbtPowerUserActionsCenter_1), tslib_1.__metadata("design:paramtypes", [ puQuickPick_1.DbtPowerUserControlCenterAction, projectQuickPick_1.ProjectQuickPick, dbtProjectContainer_1.DBTProjectContainer, sqlQuickPick_1.DbtSQLAction ]) ], DbtPowerUserActionsCenter), 
   exports.DbtPowerUserActionsCenter = DbtPowerUserActionsCenter;
  },
  47310: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ProjectQuickPick_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ProjectQuickPick = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593);
   let ProjectQuickPick = ProjectQuickPick_1 = class {
    projectPicker(projects) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const options = projects.map((item => ({
       label: item.getProjectName(),
       description: item.projectRoot.fsPath,
       uri: item.projectRoot
      }))), pick = yield vscode_1.window.showQuickPick(options, {
       title: "Select a Project",
       canPickMany: !1
      });
      if (pick) return pick;
     }));
    }
   };
   ProjectQuickPick = ProjectQuickPick_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(ProjectQuickPick_1) ], ProjectQuickPick), 
   exports.ProjectQuickPick = ProjectQuickPick;
  },
  36862: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DbtPowerUserControlCenterAction_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DbtPowerUserControlCenterAction = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593);
   let DbtPowerUserControlCenterAction = DbtPowerUserControlCenterAction_1 = class {
    openPuQuickPick() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const disposables = [];
      try {
       return yield new Promise(((resolve, reject) => {
        const dbtpuquickpick = vscode_1.window.createQuickPick();
        dbtpuquickpick.title = "dbt Power User Control Panel", dbtpuquickpick.items = [ new DbtPowerUserControlPanelItem("Setup Extension", "debug", "Open the extension setup walkthrough", "dbtPowerUser.openSetupWalkthrough"), new DbtPowerUserControlPanelItem("dbt Power User Tutorials", "book", "Open the dbt Power User Tutorials", "dbtPowerUser.openTutorialWalkthrough"), new DbtPowerUserControlPanelItem("Documentation", "link-external", "View the detailed Documentation for the extension", "vscode.open", [ vscode_1.Uri.parse("https://docs.myaltimate.com") ]), {
         label: "",
         kind: vscode_1.QuickPickItemKind.Separator
        }, new DbtPowerUserControlPanelItem("Run Project Healthcheck", "debug-start", "Run the Project healthcheck", "dbtPowerUser.altimateScan"), new DbtPowerUserControlPanelItem("Clear Healthcheck Results", "debug-stop", "Clear all problems", "dbtPowerUser.clearAltimateScanResults"), {
         label: "",
         kind: vscode_1.QuickPickItemKind.Separator
        }, new DbtPowerUserControlPanelItem("Join the Community", "add", "Join our slack community", "vscode.open", [ vscode_1.Uri.parse("https://getdbt.slack.com/archives/C05KPDGRMDW") ]), new DbtPowerUserControlPanelItem("Feedback", "feed", "Give us Feedback!", "vscode.open", [ vscode_1.Uri.parse("https://docs.google.com/forms/d/e/1FAIpQLSf7X2nQ3cfqpP6-uYSTE-mFg41ZKigCh2ytPUuX1jz7FoZOnw/viewform?usp=sf_link") ]) ], 
        disposables.push(dbtpuquickpick.onDidChangeValue((value => {
         dbtpuquickpick.busy = !0;
        })), dbtpuquickpick.onDidChangeSelection((items => {
         const item = items[0];
         item instanceof DbtPowerUserControlPanelItem && (vscode_1.commands.executeCommand(item.command, ...item.commandArgs), 
         dbtpuquickpick.hide());
        })), dbtpuquickpick.onDidHide((() => {
         resolve(void 0), dbtpuquickpick.dispose();
        }))), dbtpuquickpick.show();
       }));
      } finally {
       disposables.forEach((d => d.dispose()));
      }
     }));
    }
   };
   DbtPowerUserControlCenterAction = DbtPowerUserControlCenterAction_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DbtPowerUserControlCenterAction_1) ], DbtPowerUserControlCenterAction), 
   exports.DbtPowerUserControlCenterAction = DbtPowerUserControlCenterAction;
   class DbtPowerUserControlPanelItem {
    constructor(label, iconPath = "", description, commandStr, commandArgs) {
     this.label = label, this.iconPath = new vscode_1.ThemeIcon(iconPath), this.description = description || "", 
     this.command = commandStr || "", this.commandArgs = commandArgs || [];
    }
   }
  },
  68429: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DbtSQLAction_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DbtSQLAction = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593), dbtProjectContainer_1 = __webpack_require__(37343), path = __webpack_require__(71017);
   let DbtSQLAction = DbtSQLAction_1 = class {
    constructor(dbtProjectContainer) {
     this.dbtProjectContainer = dbtProjectContainer;
    }
    getProject() {
     var _a;
     const currentFilePath = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
     if (currentFilePath) return this.dbtProjectContainer.findDBTProject(currentFilePath);
    }
    openQuickPick() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const disposables = [];
      try {
       return yield new Promise(((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        const dbtpuquickpick = vscode_1.window.createQuickPick();
        dbtpuquickpick.title = "SQL Actions";
        const items = [ new SQLActionItem("Validate SQL", new vscode_1.ThemeIcon("check-all"), "Validate the sql query", "dbtPowerUser.validateSql"), new SQLActionItem("Explain query", {
         light: vscode_1.Uri.file(path.join(path.resolve(__dirname), "../media/images/lightbulb_light.svg")),
         dark: vscode_1.Uri.file(path.join(path.resolve(__dirname), "../media/images/lightbulb_dark.svg"))
        }, "Explain the sql query (Preview feature)", "dbtPowerUser.summarizeQuery"), new SQLActionItem("Sql to Model", {
         light: vscode_1.Uri.file(path.join(path.resolve(__dirname), "../media/images/preview-dbt-light.svg")),
         dark: vscode_1.Uri.file(path.join(path.resolve(__dirname), "../media/images/preview-dbt-dark.svg"))
        }, "Convert sql to dbt model (Preview feature)", "dbtPowerUser.sqlToModel") ], project = this.getProject();
        if (project) {
         const adapter = yield project.getAdapterType(), dbtVersion = yield project.getDBTVersion();
         "bigquery" === adapter && dbtVersion && dbtVersion[0] >= 1 && dbtVersion[1] >= 6 && items.push(new SQLActionItem("BigQuery Cost Estimate", new vscode_1.ThemeIcon("dashboard"), "Estimate cost for BigQuery", "dbtPowerUser.bigqueryCostEstimate"));
        }
        dbtpuquickpick.items = items, disposables.push(dbtpuquickpick.onDidChangeValue((value => {
         dbtpuquickpick.busy = !0;
        })), dbtpuquickpick.onDidChangeSelection((items => {
         const item = items[0];
         item instanceof SQLActionItem && (vscode_1.commands.executeCommand(item.command, ...item.commandArgs), 
         dbtpuquickpick.hide());
        })), dbtpuquickpick.onDidHide((() => {
         resolve(void 0), dbtpuquickpick.dispose();
        }))), dbtpuquickpick.show();
       }))));
      } finally {
       disposables.forEach((d => d.dispose()));
      }
     }));
    }
   };
   DbtSQLAction = DbtSQLAction_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DbtSQLAction_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer ]) ], DbtSQLAction), 
   exports.DbtSQLAction = DbtSQLAction;
   class SQLActionItem {
    constructor(label, iconPath, description, commandStr, commandArgs) {
     this.label = label, this.iconPath = iconPath, this.description = description || "", 
     this.command = commandStr || "", this.commandArgs = commandArgs || [];
    }
   }
  },
  81143: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var SharedStateService_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SharedStateService = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593);
   let SharedStateService = SharedStateService_1 = class {
    constructor() {
     this.eventEmitter = new vscode_1.EventEmitter;
    }
    fire(data) {
     this.eventEmitter.fire(data);
    }
   };
   SharedStateService = SharedStateService_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(SharedStateService_1), tslib_1.__metadata("design:paramtypes", []) ], SharedStateService), 
   exports.SharedStateService = SharedStateService;
  },
  68029: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DocGenService_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DocGenService = void 0;
   const tslib_1 = __webpack_require__(70655), path = __webpack_require__(71017), vscode_1 = __webpack_require__(66828), altimate_1 = __webpack_require__(99160), exceptions_1 = __webpack_require__(62633), dbtProjectContainer_1 = __webpack_require__(37343), telemetry_1 = __webpack_require__(27407), utils_1 = __webpack_require__(78593), docsEditPanel_1 = __webpack_require__(12240);
   let DocGenService = DocGenService_1 = class {
    constructor(altimateRequest, dbtProjectContainer, telemetry) {
     this.altimateRequest = altimateRequest, this.dbtProjectContainer = dbtProjectContainer, 
     this.telemetry = telemetry;
    }
    generateDocsForColumn(documentation, compiledSql, adapter, message, columns) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return new Promise((resolve => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       if (!documentation) return resolve(void 0);
       const enableNewDocsPanel = vscode_1.workspace.getConfiguration("dbt").get("enableNewDocsPanel", !1), baseRequest = {
        columns,
        dbt_model: {
         model_name: documentation.name,
         model_description: message.description,
         compiled_sql: compiledSql,
         columns: message.columns.map((column => ({
          column_name: column.name,
          description: column.description,
          data_type: column.type
         }))),
         adapter
        },
        gen_model_description: !1
       };
       try {
        const result = enableNewDocsPanel ? yield this.altimateRequest.generateModelDocsV2(Object.assign(Object.assign({}, baseRequest), {
         user_instructions: message.user_instructions,
         follow_up_instructions: message.follow_up_instructions
        })) : yield this.altimateRequest.generateModelDocs(baseRequest);
        return resolve(result);
       } catch (err) {
        console.error("error while generating column doc", err, columns), err instanceof exceptions_1.RateLimitException && setTimeout((() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
         return console.debug("retrying generating column doc", columns), resolve(yield this.generateDocsForColumn(documentation, compiledSql, adapter, message, columns));
        }))), err.retryAfter);
       }
      }))));
     }));
    }
    transmitAIGeneratedColumnDocs(panel, generatedColumnDescriptions, syncRequestId) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (panel) {
       const result = syncRequestId ? {
        command: "response",
        args: {
         body: {
          columns: generatedColumnDescriptions
         },
         syncRequestId,
         status: !0
        }
       } : {
        command: "renderAIGeneratedColumnDocs",
        columns: generatedColumnDescriptions
       };
       yield panel.webview.postMessage(result);
      }
     }));
    }
    transmitError(panel) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      panel && (yield panel.webview.postMessage({
       command: "renderError"
      }));
     }));
    }
    transmitAIGeneratedModelDocs(description, syncRequestId, panel) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (panel) {
       const result = syncRequestId ? {
        command: "response",
        args: {
         body: {
          description
         },
         syncRequestId,
         status: !0
        }
       } : {
        command: "renderAIGeneratedModelDocs",
        description
       };
       yield panel.webview.postMessage(result);
      }
     }));
    }
    getProject() {
     if (!vscode_1.window.activeTextEditor) return;
     const currentFilePath = vscode_1.window.activeTextEditor.document.uri;
     return this.dbtProjectContainer.findDBTProject(currentFilePath);
    }
    getDocumentation(eventMap) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (void 0 === vscode_1.window.activeTextEditor || void 0 === eventMap) return;
      const currentFilePath = vscode_1.window.activeTextEditor.document.uri, project = this.getProject();
      if (void 0 === project) return;
      const event = eventMap.get(project.projectRoot.fsPath);
      if (void 0 === event) return;
      const modelName = path.basename(currentFilePath.fsPath, ".sql"), currentNode = event.nodeMetaMap.get(modelName);
      if (void 0 === currentNode) return;
      const docColumns = currentNode.columns;
      return {
       aiEnabled: this.altimateRequest.enabled(),
       name: modelName,
       patchPath: currentNode.patch_path,
       description: currentNode.description,
       generated: !1,
       columns: Object.values(docColumns).map((column => ({
        name: column.name,
        description: column.description,
        generated: !1,
        source: docsEditPanel_1.Source.YAML
       })))
      };
     }));
    }
    chunk(a, n) {
     return [ ...Array(Math.ceil(a.length / n)) ].map(((_, i) => a.slice(n * i, n + n * i)));
    }
    generateDocsForColumns({project, message, documentation, panel}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (!this.altimateRequest.handlePreviewFeatures()) return;
      if (!project || !vscode_1.window.activeTextEditor) return;
      const queryText = vscode_1.window.activeTextEditor.document.getText(), columns = message.columnName ? [ message.columnName ] : message.columnNames, chunks = this.chunk(columns, 3);
      this.telemetry.sendTelemetryEvent("altimateGenerateDocsForColumn", {
       model: (null == documentation ? void 0 : documentation.name) || "",
       columns: columns.join(",")
      }), vscode_1.window.withProgress({
       title: "",
       location: vscode_1.ProgressLocation.Notification,
       cancellable: !1
      }, (progress => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       if (void 0 !== documentation) try {
        const results = [], progressMessage = columns.length > 3 ? `Generating documentation for ${columns.length} columns` : `Generating documentation for ${columns.length > 1 ? "columns" : "column"} ${columns.join(", ")}`;
        progress.report({
         message: progressMessage,
         increment: 0
        });
        const startTime = Date.now(), compiledSql = yield project.unsafeCompileQuery(queryText);
        yield Promise.all(chunks.map(((chunk, i) => tslib_1.__awaiter(this, void 0, void 0, (function*() {
         const chunkResult = yield this.generateDocsForColumn(documentation, compiledSql, project.getAdapterType(), message, chunk);
         results.push(chunkResult), console.log("generate docs for columns chunk result", chunkResult), 
         progress.report({
          message: `Generated docs for ${Math.min(3 * results.length, columns.length)} of ${columns.length} columns`,
          increment: chunk.length / columns.length * 100
         });
        })))));
        const generatedDocsForColumn = {
         column_descriptions: results.map((response => null == response ? void 0 : response.column_descriptions)).filter((item => !!item)).flatMap((r => r))
        };
        if (!generatedDocsForColumn || !generatedDocsForColumn.column_descriptions) return;
        this.transmitAIGeneratedColumnDocs(panel, generatedDocsForColumn.column_descriptions.map((entry => ({
         name: entry.column_name,
         description: entry.column_description
        }))), message.syncRequestId), this.telemetry.sendTelemetryEvent("altimateGenerateDocsForColumn", {
         model: (null == documentation ? void 0 : documentation.name) || "",
         columns: columns.join(",")
        }, {
         timeTaken: Date.now() - startTime
        });
       } catch (error) {
        this.transmitError(panel), vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("An unexpected error occurred while generating documentation: " + error)), 
        this.telemetry.sendTelemetryError("generateDocsForColumnError", error);
       }
      }))));
     }));
    }
    generateDocsForModel({documentation, queryText, project, message, panel}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.altimateRequest.handlePreviewFeatures() && project && (this.telemetry.sendTelemetryEvent("altimateGenerateDocsForModel", {
       model: (null == documentation ? void 0 : documentation.name) || ""
      }), vscode_1.window.withProgress({
       title: `Generating documentation for model ${null == documentation ? void 0 : documentation.name}`,
       location: vscode_1.ProgressLocation.Notification,
       cancellable: !1
      }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       if (void 0 !== documentation) try {
        const startTime = Date.now(), compiledSql = yield project.unsafeCompileQuery(queryText), enableNewDocsPanel = vscode_1.workspace.getConfiguration("dbt").get("enableNewDocsPanel", !1), baseRequest = {
         columns: [],
         dbt_model: {
          model_name: null == documentation ? void 0 : documentation.name,
          model_description: message.description,
          compiled_sql: compiledSql,
          columns: message.columns.map((column => ({
           column_name: column.name,
           description: column.description,
           data_type: column.type,
           modelName: null == documentation ? void 0 : documentation.name
          }))),
          adapter: project.getAdapterType()
         },
         prompt_hint: message.promptHint || "generate",
         gen_model_description: !0
        }, generateDocsForModel = enableNewDocsPanel ? yield this.altimateRequest.generateModelDocsV2(Object.assign(Object.assign({}, baseRequest), {
         user_instructions: Object.assign(Object.assign({}, message.user_instructions), {
          prompt_hint: message.user_instructions.prompt_hint || "generate"
         }),
         follow_up_instructions: message.follow_up_instructions
        })) : yield this.altimateRequest.generateModelDocs(baseRequest);
        if (!generateDocsForModel || !generateDocsForModel.model_description) return;
        this.transmitAIGeneratedModelDocs(generateDocsForModel.model_description, message.syncRequestId, panel), 
        this.telemetry.sendTelemetryEvent("altimateGenerateDocsForModel", {
         model: (null == documentation ? void 0 : documentation.name) || ""
        }, {
         timeTaken: Date.now() - startTime
        });
       } catch (error) {
        this.transmitError(panel), vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("An unexpected error occurred while generating documentation: " + error)), 
        this.telemetry.sendTelemetryError("generateDocsForModelError", error);
       }
      })))));
     }));
    }
    sendFeedback({queryText, message, eventMap, panel}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.telemetry.sendTelemetryEvent("altimateGenerateDocsSendFeedback"), vscode_1.window.withProgress({
       title: "Sending feedback",
       location: vscode_1.ProgressLocation.Notification,
       cancellable: !1
      }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       try {
        const project = this.getProject();
        if (!project) throw new Error("Unable to find project");
        const documentation = yield this.getDocumentation(eventMap), compiledSql = yield project.unsafeCompileQuery(queryText), request = message.data;
        request.feedback_text = message.comment, request.additional_prompt_inputs = {
         model_name: null == documentation ? void 0 : documentation.name,
         model_description: null == documentation ? void 0 : documentation.description,
         compiled_sql: compiledSql,
         columns: null == documentation ? void 0 : documentation.columns.map((column => ({
          column_name: column.name,
          description: column.description,
          data_type: column.type
         })))
        }, yield this.altimateRequest.sendFeedback({
         data: request,
         feedback_src: "dbtpu-extension",
         feedback_text: message.comment,
         feedback_value: message.rating
        });
       } catch (error) {
        this.transmitError(panel), vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("An unexpected error occurred while sending feedback: " + error)), 
        this.telemetry.sendTelemetryError("altimateGenerateDocsSendFeedbackError", error);
       }
      }))));
     }));
    }
   };
   DocGenService = DocGenService_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DocGenService_1), tslib_1.__metadata("design:paramtypes", [ altimate_1.AltimateRequest, dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], DocGenService), 
   exports.DocGenService = DocGenService;
  },
  65256: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var StatusBars_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.StatusBars = void 0;
   const tslib_1 = __webpack_require__(70655), utils_1 = __webpack_require__(78593), versionStatusBar_1 = __webpack_require__(66041);
   let StatusBars = StatusBars_1 = class {
    constructor(dbtStatusBar) {
     this.dbtStatusBar = dbtStatusBar, this.disposables = [], this.disposables.push(this.dbtStatusBar);
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   StatusBars = StatusBars_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(StatusBars_1), tslib_1.__metadata("design:paramtypes", [ versionStatusBar_1.VersionStatusBar ]) ], StatusBars), 
   exports.StatusBars = StatusBars;
  },
  66041: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var VersionStatusBar_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.VersionStatusBar = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), dbtProjectContainer_1 = __webpack_require__(37343), utils_1 = __webpack_require__(78593);
   let VersionStatusBar = VersionStatusBar_1 = class {
    constructor(dbtProjectContainer) {
     this.dbtProjectContainer = dbtProjectContainer, this.statusBar = vscode_1.window.createStatusBarItem(vscode_1.StatusBarAlignment.Left, 10), 
     this.defaultColor = "statusBarItem.activeBackground", this.disposables = [], this.disposables.push(this.dbtProjectContainer.onDBTInstallationVerification((e => this.onDBTInstallationVerification(e))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
     this.statusBar.dispose();
    }
    onDBTInstallationVerification(event) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      !0 !== event.inProgress ? event.installed ? this.showTextInStatusBar("$(check) dbt") : this.showTextInStatusBar("$(error) dbt is not installed") : this.showTextInStatusBar("$(sync~spin) Detecting dbt");
     }));
    }
    showTextInStatusBar(text, command) {
     this.statusBar.text = text, this.statusBar.command = command || {
      title: "Open Pu Control Panel",
      command: "dbtPowerUser.puQuickPick"
     }, this.statusBar.show();
    }
    setStatusBarColor(color) {
     this.statusBar.backgroundColor = new vscode_1.ThemeColor(color);
    }
    resetStatusBarColor() {
     this.statusBar.backgroundColor = new vscode_1.ThemeColor(this.defaultColor);
    }
   };
   VersionStatusBar = VersionStatusBar_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(VersionStatusBar_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer ]) ], VersionStatusBar), 
   exports.VersionStatusBar = VersionStatusBar;
  },
  27407: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var TelemetryService_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.TelemetryService = void 0;
   const tslib_1 = __webpack_require__(70655), extension_telemetry_1 = __webpack_require__(92291), vscode = __webpack_require__(66828), utils_1 = __webpack_require__(78593);
   let TelemetryService = TelemetryService_1 = class {
    constructor() {
     this.telemetryReporter = new extension_telemetry_1.default("50598369-dd83-4f9a-9a65-ca1fa6f1785c");
    }
    sendTelemetryEvent(eventName, properties, measurements) {
     this.telemetryReporter.sendTelemetryEvent(eventName, Object.assign(Object.assign({}, properties), {
      instanceName: vscode.workspace.getConfiguration("dbt").get("altimateInstanceName")
     }), measurements);
    }
    sendTelemetryError(eventName, error, properties, measurements) {
     this.telemetryReporter.sendTelemetryErrorEvent(eventName, Object.assign(Object.assign({}, properties), {
      instanceName: vscode.workspace.getConfiguration("dbt").get("altimateInstanceName"),
      stack: void 0 !== error && error instanceof Error ? error.stack : JSON.stringify(error)
     }), measurements);
    }
    dispose() {
     var _a;
     null === (_a = this.telemetryReporter) || void 0 === _a || _a.dispose();
    }
   };
   TelemetryService = TelemetryService_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(TelemetryService_1) ], TelemetryService), 
   exports.TelemetryService = TelemetryService;
  },
  8961: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var TreeviewProviders_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.TreeviewProviders = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593), modelTreeviewProvider_1 = __webpack_require__(24037);
   let TreeviewProviders = TreeviewProviders_1 = class {
    constructor(childrenModelTreeview, parentModelTreeview, testModelTreeview, documentationTreeView, iconActionsTreeview) {
     this.childrenModelTreeview = childrenModelTreeview, this.parentModelTreeview = parentModelTreeview, 
     this.testModelTreeview = testModelTreeview, this.documentationTreeView = documentationTreeView, 
     this.iconActionsTreeview = iconActionsTreeview, this.disposables = [], this.disposables.push(vscode_1.window.registerTreeDataProvider("model_test_treeview", this.testModelTreeview), vscode_1.window.registerTreeDataProvider("parent_model_treeview", this.parentModelTreeview), vscode_1.window.registerTreeDataProvider("children_model_treeview", this.childrenModelTreeview), vscode_1.window.registerTreeDataProvider("documentation_treeview", this.documentationTreeView), vscode_1.window.registerTreeDataProvider("icon_actions_treeview", this.iconActionsTreeview));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   TreeviewProviders = TreeviewProviders_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(TreeviewProviders_1), tslib_1.__metadata("design:paramtypes", [ modelTreeviewProvider_1.ChildrenModelTreeview, modelTreeviewProvider_1.ParentModelTreeview, modelTreeviewProvider_1.ModelTestTreeview, modelTreeviewProvider_1.DocumentationTreeview, modelTreeviewProvider_1.IconActionsTreeview ]) ], TreeviewProviders), 
   exports.TreeviewProviders = TreeviewProviders;
  },
  24037: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ModelTreeviewProvider_1, DocumentationTreeviewProvider_1, IconActionsTreeviewProvider_1, ModelTestTreeview_1, ParentModelTreeview_1, ChildrenModelTreeview_1, DocumentationTreeview_1, IconActionsTreeview_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.IconActionsTreeview = exports.DocumentationTreeview = exports.ChildrenModelTreeview = exports.ParentModelTreeview = exports.ModelTestTreeview = exports.ActionTreeItem = exports.NodeTreeItem = exports.DocNode = void 0;
   const tslib_1 = __webpack_require__(70655), inversify_1 = __webpack_require__(26594), inversify_binding_decorators_1 = __webpack_require__(84904), path = __webpack_require__(71017), vscode_1 = __webpack_require__(66828), domain_1 = __webpack_require__(37512), dbtProjectContainer_1 = __webpack_require__(37343), utils_1 = __webpack_require__(78593);
   let ModelTreeviewProvider = ModelTreeviewProvider_1 = class {
    constructor(dbtProjectContainer, treeType) {
     this.dbtProjectContainer = dbtProjectContainer, this.treeType = treeType, this.eventMap = new Map, 
     this._onDidChangeTreeData = new vscode_1.EventEmitter, this.onDidChangeTreeData = this._onDidChangeTreeData.event, 
     this.disposables = [ this._onDidChangeTreeData ], this.treeType = treeType, this.disposables.push(vscode_1.window.onDidChangeActiveTextEditor((() => {
      this._onDidChangeTreeData.fire();
     })), this.dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.eventMap.set(added.project.projectRoot.fsPath, added);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.eventMap.delete(removed.projectRoot.fsPath);
     })), this._onDidChangeTreeData.fire();
    }
    getTreeItem(element) {
     return element;
    }
    getChildren(element) {
     if (void 0 === vscode_1.window.activeTextEditor || void 0 === this.eventMap) return Promise.resolve([]);
     const currentFilePath = vscode_1.window.activeTextEditor.document.uri, projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (void 0 === projectRootpath) return Promise.resolve([]);
     const event = this.eventMap.get(projectRootpath.fsPath);
     if (void 0 === event) return Promise.resolve([]);
     if (null == element ? void 0 : element.key.startsWith("test.")) return Promise.resolve([]);
     if (element) return Promise.resolve(this.getTreeItems(element.key, event));
     const {project} = event, fileName = path.basename(vscode_1.window.activeTextEditor.document.fileName, ".sql"), packageName = this.dbtProjectContainer.getPackageName(currentFilePath) || project.getProjectName();
     return Promise.resolve(this.getTreeItems(`model.${packageName}.${fileName}`, event));
    }
    getNodeTreeItem(node) {
     return node instanceof domain_1.Snapshot ? new SnapshotTreeItem(node) : node instanceof domain_1.Exposure ? new ExposureTreeItem(node) : node instanceof domain_1.Analysis ? new AnalysisTreeItem(node) : node instanceof domain_1.Test ? new TestTreeItem(node) : node instanceof domain_1.Source ? new SourceTreeItem(node) : node instanceof domain_1.Seed ? new SeedTreeItem(node) : new ModelTreeItem(node);
    }
    getTreeItems(elementName, event) {
     const {graphMetaMap} = event, parentModels = graphMetaMap[this.treeType].get(elementName);
     return void 0 === parentModels ? [] : parentModels.nodes.filter((node => node.displayInModelTree)).map((node => {
      var _a;
      const childNodes = null === (_a = graphMetaMap[this.treeType].get(node.key)) || void 0 === _a ? void 0 : _a.nodes.filter((node => node.displayInModelTree)), treeItem = this.getNodeTreeItem(node);
      return treeItem.collapsibleState = 0 !== (null == childNodes ? void 0 : childNodes.length) ? vscode_1.TreeItemCollapsibleState.Collapsed : vscode_1.TreeItemCollapsibleState.None, 
      treeItem;
     }));
    }
   };
   ModelTreeviewProvider = ModelTreeviewProvider_1 = tslib_1.__decorate([ (0, inversify_binding_decorators_1.provide)(ModelTreeviewProvider_1), tslib_1.__param(1, (0, 
   inversify_1.unmanaged)()), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, Object ]) ], ModelTreeviewProvider);
   let DocumentationTreeviewProvider = DocumentationTreeviewProvider_1 = class {
    constructor(dbtProjectContainer) {
     this.dbtProjectContainer = dbtProjectContainer, this.eventMap = new Map, this._onDidChangeTreeData = new vscode_1.EventEmitter, 
     this.onDidChangeTreeData = this._onDidChangeTreeData.event, this.disposables = [ this._onDidChangeTreeData ], 
     this.disposables.push(vscode_1.window.onDidChangeActiveTextEditor((() => {
      this._onDidChangeTreeData.fire();
     })), this.dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.eventMap.set(added.project.projectRoot.fsPath, added);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.eventMap.delete(removed.projectRoot.fsPath);
     })), this._onDidChangeTreeData.fire();
    }
    getTreeItem(element) {
     return {
      label: element.label,
      description: element.description,
      command: element.command,
      collapsibleState: element.children ? vscode_1.TreeItemCollapsibleState.Expanded : vscode_1.TreeItemCollapsibleState.None
     };
    }
    getChildren(element) {
     if (void 0 === vscode_1.window.activeTextEditor || void 0 === this.eventMap) return Promise.resolve([]);
     const currentFilePath = vscode_1.window.activeTextEditor.document.uri, projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (!projectRootpath) return Promise.resolve([]);
     const event = this.eventMap.get(projectRootpath.fsPath);
     if (void 0 === event) return Promise.resolve([]);
     const {nodeMetaMap} = event;
     if (!element) {
      const modelName = path.basename(vscode_1.window.activeTextEditor.document.fileName, ".sql"), currentNode = nodeMetaMap.get(modelName);
      if (void 0 === currentNode) return Promise.resolve([]);
      const children = [];
      if (0 !== Object.keys(currentNode.columns).length) {
       for (const columnName in currentNode.columns) if (currentNode.columns.hasOwnProperty(columnName)) {
        const column = currentNode.columns[columnName], {description} = column, child = {
         label: columnName,
         description
        };
        children.push(child);
       }
       const url = null !== currentNode.patch_path ? path.join(projectRootpath.path, currentNode.patch_path.split("://")[1]) : " ";
       0 === Object.keys(currentNode.columns).length && vscode_1.window.showWarningMessage(`Documentation View Warning: No columns found in manifest.json for ${modelName}, go edit the documentation in the documentation editor panel and run dbt docs generate`);
       const key = currentNode.uniqueId, label = currentNode.alias, description = `[ ${currentNode.config.materialized.toUpperCase()} ]  -  schema : ${currentNode.schema}`, nodeItem = new DocNode(label, key, url, description), treeItem = new DocTreeItem(nodeItem);
       return treeItem.children = children, [ treeItem ];
      }
      return [];
     }
     return element.children;
    }
    refresh() {
     this._onDidChangeTreeData.fire();
    }
   };
   DocumentationTreeviewProvider = DocumentationTreeviewProvider_1 = tslib_1.__decorate([ (0, 
   inversify_binding_decorators_1.provide)(DocumentationTreeviewProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer ]) ], DocumentationTreeviewProvider);
   class DocTreeItem extends vscode_1.TreeItem {
    constructor(node) {
     super(node.label, vscode_1.TreeItemCollapsibleState.Collapsed), this.collapsibleState = vscode_1.TreeItemCollapsibleState.Collapsed, 
     this.description = void 0 !== node.description ? node.description : " ", this.command = {
      command: "vscode.open",
      title: "Open YML",
      arguments: [ vscode_1.Uri.file(node.url) ]
     }, void 0 !== node.iconPath && (this.iconPath = node.iconPath);
    }
   }
   class DocNode extends domain_1.Node {
    constructor(label, key, url, description) {
     super(label, key, url), this.description = description;
    }
   }
   exports.DocNode = DocNode;
   class NodeTreeItem extends vscode_1.TreeItem {
    constructor(node) {
     super(node.label), this.collapsibleState = vscode_1.TreeItemCollapsibleState.Collapsed, 
     this.key = node.key, this.url = node.url, void 0 !== node.iconPath && (this.iconPath = node.iconPath), 
     node.url && (this.command = {
      command: "vscode.open",
      title: "Select Node",
      arguments: [ vscode_1.Uri.file(node.url) ]
     });
    }
   }
   exports.NodeTreeItem = NodeTreeItem;
   class ActionTreeItem extends vscode_1.TreeItem {
    constructor(label, icon, command, tooltip) {
     super(label), this.collapsibleState = vscode_1.TreeItemCollapsibleState.Collapsed, 
     this.iconPath = icon, this.command = command, this.tooltip = tooltip;
    }
   }
   exports.ActionTreeItem = ActionTreeItem;
   let IconActionsTreeviewProvider = IconActionsTreeviewProvider_1 = class {
    constructor() {
     this.collapsibleState = vscode_1.TreeItemCollapsibleState.Collapsed;
    }
    getTreeItem(element) {
     return element.collapsibleState = element.children ? vscode_1.TreeItemCollapsibleState.Collapsed : vscode_1.TreeItemCollapsibleState.None, 
     element.iconPath = element.children ? void 0 : element.iconPath, element;
    }
    getChildren(element) {
     if (!element) {
      const scanItem = new ActionTreeItem("Project Health Check", void 0, void 0, "Find issues in dbt projects");
      return scanItem.children = [ new ActionTreeItem("Start Scan", new vscode_1.ThemeIcon("search-view-icon"), {
       command: "dbtPowerUser.altimateScan",
       title: "Project Health Check",
       arguments: []
      }, "Scan all projects for issues"), new ActionTreeItem("Clear Problems", new vscode_1.ThemeIcon("search-stop"), {
       command: "dbtPowerUser.clearAltimateScanResults",
       title: "Clear All Problems",
       arguments: []
      }, "Clear issues from problems panel"), new ActionTreeItem("Send Feedback", void 0, {
       command: "vscode.open",
       title: "Send Feedback",
       arguments: [ vscode_1.Uri.parse("https://docs.google.com/forms/d/e/1FAIpQLSdw7QEvM84FX0KQT1ADhxVsdHk81cdDp_a930Ggym5_Fk1vWg/viewform") ]
      }) ], Promise.resolve([ scanItem ]);
     }
     return element.children;
    }
   };
   IconActionsTreeviewProvider = IconActionsTreeviewProvider_1 = tslib_1.__decorate([ (0, 
   inversify_binding_decorators_1.provide)(IconActionsTreeviewProvider_1) ], IconActionsTreeviewProvider);
   class ModelTreeItem extends NodeTreeItem {
    constructor() {
     super(...arguments), this.contextValue = "model";
    }
   }
   class SourceTreeItem extends NodeTreeItem {
    constructor() {
     super(...arguments), this.iconPath = {
      light: path.join(path.resolve(__dirname), "../media/images/source_light.svg"),
      dark: path.join(path.resolve(__dirname), "../media/images/source_dark.svg")
     }, this.contextValue = "source";
    }
   }
   class SeedTreeItem extends NodeTreeItem {
    constructor() {
     super(...arguments), this.iconPath = {
      light: path.join(path.resolve(__dirname), "../media/images/seed_light.svg"),
      dark: path.join(path.resolve(__dirname), "../media/images/seed_dark.svg")
     }, this.contextValue = "seed";
    }
   }
   class SnapshotTreeItem extends NodeTreeItem {
    constructor() {
     super(...arguments), this.contextValue = "snapshot", this.iconPath = {
      light: path.join(path.resolve(__dirname), "../media/images/snapshot_light.svg"),
      dark: path.join(path.resolve(__dirname), "../media/images/snapshot_dark.svg")
     };
    }
   }
   class ExposureTreeItem extends NodeTreeItem {
    constructor() {
     super(...arguments), this.contextValue = "exposure", this.iconPath = {
      light: path.join(path.resolve(__dirname), "../media/images/exposure_light.svg"),
      dark: path.join(path.resolve(__dirname), "../media/images/exposure_dark.svg")
     };
    }
   }
   class AnalysisTreeItem extends NodeTreeItem {
    constructor() {
     super(...arguments), this.contextValue = "analysis";
    }
   }
   class TestTreeItem extends NodeTreeItem {
    constructor() {
     super(...arguments), this.iconPath = {
      light: path.join(path.resolve(__dirname), "../media/images/tests_light.svg"),
      dark: path.join(path.resolve(__dirname), "../media/images/tests_dark.svg")
     }, this.contextValue = "test";
    }
   }
   let ModelTestTreeview = ModelTestTreeview_1 = class extends ModelTreeviewProvider {
    constructor(dbtProjectContainer) {
     super(dbtProjectContainer, "tests");
    }
   };
   ModelTestTreeview = ModelTestTreeview_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(ModelTestTreeview_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer ]) ], ModelTestTreeview), 
   exports.ModelTestTreeview = ModelTestTreeview;
   let ParentModelTreeview = ParentModelTreeview_1 = class extends ModelTreeviewProvider {
    constructor(dbtProjectContainer) {
     super(dbtProjectContainer, "parents");
    }
   };
   ParentModelTreeview = ParentModelTreeview_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(ParentModelTreeview_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer ]) ], ParentModelTreeview), 
   exports.ParentModelTreeview = ParentModelTreeview;
   let ChildrenModelTreeview = ChildrenModelTreeview_1 = class extends ModelTreeviewProvider {
    constructor(dbtProjectContainer) {
     super(dbtProjectContainer, "children");
    }
   };
   ChildrenModelTreeview = ChildrenModelTreeview_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(ChildrenModelTreeview_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer ]) ], ChildrenModelTreeview), 
   exports.ChildrenModelTreeview = ChildrenModelTreeview;
   let DocumentationTreeview = DocumentationTreeview_1 = class extends DocumentationTreeviewProvider {
    constructor(dbtProjectContainer) {
     super(dbtProjectContainer);
    }
   };
   DocumentationTreeview = DocumentationTreeview_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DocumentationTreeview_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer ]) ], DocumentationTreeview), 
   exports.DocumentationTreeview = DocumentationTreeview;
   let IconActionsTreeview = IconActionsTreeview_1 = class extends IconActionsTreeviewProvider {};
   IconActionsTreeview = IconActionsTreeview_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(IconActionsTreeview_1) ], IconActionsTreeview), 
   exports.IconActionsTreeview = IconActionsTreeview;
  },
  78593: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.getProjectRelativePath = exports.getFirstWorkspacePath = exports.stripANSI = exports.extendErrorWithSupportLinks = exports.substituteSettingsVariables = exports.provideSingleton = exports.setupWatcherHandler = exports.debounce = exports.arrayEquals = exports.notEmpty = exports.isEnclosedWithinCodeBlock = void 0;
   const inversify_binding_decorators_1 = __webpack_require__(84904), path = __webpack_require__(71017), vscode_1 = __webpack_require__(66828);
   exports.isEnclosedWithinCodeBlock = (document, rangeOrPosition) => {
    const isWithinCodeBlock = (startPosition, direction, lookupChar, stopChar) => {
     const increment = "desc" === direction ? -1 : 1;
     let characterPosition = startPosition.character, lineNumber = startPosition.line;
     for (;lineNumber >= 0 && lineNumber < document.lineCount; ) {
      const line = document.lineAt(lineNumber).text;
      for (void 0 === characterPosition && (characterPosition = "desc" === direction ? line.length - 1 : 0); "desc" === direction ? characterPosition >= 0 : characterPosition <= line.length - 1; ) {
       if ([ "#", "%", stopChar ].includes(line[characterPosition]) && characterPosition + increment >= 0 && line[characterPosition + increment] === stopChar) return !1;
       if ([ "#", "%", lookupChar ].includes(line[characterPosition]) && characterPosition + increment >= 0 && line[characterPosition + increment] === lookupChar) return !0;
       characterPosition += increment;
      }
      lineNumber += increment, characterPosition = void 0;
     }
     return !1;
    }, {start, end} = rangeOrPosition instanceof vscode_1.Position ? {
     start: rangeOrPosition,
     end: rangeOrPosition
    } : rangeOrPosition;
    return isWithinCodeBlock(start, "desc", "{", "}") && isWithinCodeBlock(end, "asc", "}", "{");
   };
   exports.notEmpty = value => null != value;
   exports.arrayEquals = (a, b) => a.sort().toString() === b.sort().toString();
   exports.debounce = (fn, wait) => {
    let timeout;
    return () => {
     clearTimeout(timeout), timeout = setTimeout(fn, wait);
    };
   };
   exports.setupWatcherHandler = (watcher, handler) => [ watcher.onDidChange((() => handler())), watcher.onDidCreate((() => handler())), watcher.onDidDelete((() => handler())) ];
   exports.provideSingleton = identifier => (0, inversify_binding_decorators_1.fluentProvide)(identifier).inSingletonScope().done(), 
   exports.substituteSettingsVariables = function(value) {
    if ("string" != typeof value) return value;
    const regexVsCodeEnv = /\$\{env\:(.*?)\}/gm;
    let matchResult;
    for (;null !== (matchResult = regexVsCodeEnv.exec(value)); ) matchResult.index === regexVsCodeEnv.lastIndex && regexVsCodeEnv.lastIndex++, 
    void 0 !== process.env[matchResult[1]] && (value = value.replace(new RegExp(`\\$\\{env\\:${matchResult[1]}\\}`, "gm"), process.env[matchResult[1]]));
    return value = value.replace("${workspaceFolder}", vscode_1.workspace.workspaceFolders[0].uri.fsPath);
   }, exports.extendErrorWithSupportLinks = function(error) {
    return (" " === error[-1] ? error : error + " ") + "If the issue persists, please [contact us](https://www.altimate.ai/support) via chat or Slack";
   }, exports.stripANSI = function(src) {
    return src.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, "");
   }, exports.getFirstWorkspacePath = function() {
    const folders = vscode_1.workspace.workspaceFolders;
    return folders ? folders[0].uri.fsPath : vscode_1.Uri.file("./").fsPath;
   };
   exports.getProjectRelativePath = projectRoot => {
    const ws = vscode_1.workspace.getWorkspaceFolder(projectRoot);
    return path.relative((null == ws ? void 0 : ws.uri.fsPath) || "", projectRoot.fsPath);
   };
  },
  12497: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ValidationProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ValidationProvider = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593), altimate_1 = __webpack_require__(99160), validTenantRegex = new RegExp(/^[a-z_][a-z0-9_]*$/);
   let ValidationProvider = ValidationProvider_1 = class {
    constructor(altimate) {
     this.altimate = altimate, this.disposables = [];
     const config = this.altimate.getConfig();
     this.currInstanceName = null == config ? void 0 : config.instance, this.currAPIKey = null == config ? void 0 : config.key, 
     this.disposables.push(vscode_1.workspace.onDidChangeConfiguration((e => {
      e.affectsConfiguration("dbt") && this.validateCredentials();
     }), this, this.disposables));
    }
    validateCredentials() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const config = this.altimate.getConfig();
      if (!config) return;
      const {key, instance} = config;
      if (!key || !instance) return;
      if (instance === this.currInstanceName && key === this.currAPIKey) return;
      this.currInstanceName = instance, this.currAPIKey = key;
      let message = "";
      if (validTenantRegex.exec(instance) ? 32 !== key.length && (message = "API key is not valid") : message = "Instance name must not be URL.", 
      message) return void vscode_1.window.showErrorMessage(message);
      const validation = yield this.altimate.validateCredentials(instance, key);
      (null == validation ? void 0 : validation.ok) || vscode_1.window.showErrorMessage("Credentials are invalid. " + (null == validation ? void 0 : validation.detail));
     }));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   ValidationProvider = ValidationProvider_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(ValidationProvider_1), tslib_1.__metadata("design:paramtypes", [ altimate_1.AltimateRequest ]) ], ValidationProvider), 
   exports.ValidationProvider = ValidationProvider;
  },
  9447: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var AltimateWebviewProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.AltimateWebviewProvider = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593), dbtProjectContainer_1 = __webpack_require__(37343), telemetry_1 = __webpack_require__(27407), path = __webpack_require__(71017), altimate_1 = __webpack_require__(99160), SharedStateService_1 = __webpack_require__(81143);
   let AltimateWebviewProvider = AltimateWebviewProvider_1 = class {
    constructor(dbtProjectContainer, altimateRequest, telemetry, emitterService) {
     this.dbtProjectContainer = dbtProjectContainer, this.altimateRequest = altimateRequest, 
     this.telemetry = telemetry, this.emitterService = emitterService, this.viewType = "dbtPowerUser.Default", 
     this.viewPath = "/", this.panelDescription = "Altimate default webview", this._panel = void 0, 
     this._disposables = [], this.eventMap = new Map, this.isWebviewReady = !1, dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event)));
     const t = this;
     this._disposables.push(emitterService.eventEmitter.event((d => t.onEvent(d))));
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.eventMap.set(added.project.projectRoot.fsPath, added);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.eventMap.delete(removed.projectRoot.fsPath);
     }));
    }
    onEvent(data) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {}));
    }
    renderWebviewView(context) {
     const webview = this._panel.webview;
     this._panel.webview.onDidReceiveMessage(this.handleCommand, this, []), webview.html = this.getHtml(webview, this.dbtProjectContainer.extensionUri.fsPath);
    }
    isUpdateConfigProps(data) {
     return void 0 !== data.key;
    }
    onWebviewReady() {
     this.isWebviewReady = !0;
    }
    handleCommand(message) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {command, syncRequestId} = message, params = tslib_1.__rest(message, [ "command", "syncRequestId" ]);
      try {
       switch (command) {
       case "webview:ready":
        this.onWebviewReady();
        break;

       case "openURL":
        if (!params.url) return;
        vscode_1.env.openExternal(vscode_1.Uri.parse(params.url));
        break;

       case "datapilot:toggle":
        params.open && this.emitterService.eventEmitter.fire({
         command: "datapilot:toggle",
         payload: params
        });
        break;

       case "datapilot:message":
        this.emitterService.eventEmitter.fire({
         command: "datapilot:message",
         payload: message
        });
        break;

       case "validateCredentials":
        const isValid = yield this.altimateRequest.handlePreviewFeatures();
        this._panel.webview.postMessage({
         command: "response",
         args: {
          syncRequestId,
          body: {
           isValid
          },
          status: !0
         }
        });
        break;

       case "sendTelemetryEvent":
        this.telemetry.sendTelemetryEvent(params.eventName, params.properties, params.measurements);
        break;

       case "sendTelemetryError":
        this.telemetry.sendTelemetryError(params.eventName, params.error, params.properties);
        break;

       case "updateConfig":
        if (!this.isUpdateConfigProps(params)) return;
        console.log("Updating config", params.key, params.value);
        const shouldUpdate = !params.isPreviewFeature || this.altimateRequest.handlePreviewFeatures();
        shouldUpdate && (yield vscode_1.workspace.getConfiguration("dbt").update(params.key, params.value)), 
        syncRequestId && this._panel.webview.postMessage({
         command: "response",
         args: {
          syncRequestId,
          body: {
           updated: shouldUpdate
          },
          status: !0
         }
        });
       }
      } catch (err) {
       console.error("error while handling command", err);
      }
     }));
    }
    resolveWebviewView(panel, context, _token) {
     console.log("AltimateWebviewProvider:resolveWebviewView -> "), this._panel = panel, 
     this.setupWebviewOptions(context), this.renderWebviewView(context);
    }
    setupWebviewOptions(context) {
     this._panel.description = this.panelDescription, this._panel.webview.options = {
      enableScripts: !0,
      localResourceRoots: [ vscode_1.Uri.file(path.join(this.dbtProjectContainer.extensionUri.fsPath, "webview_panels", "dist", "assets")) ]
     };
    }
    getHtml(webview, extensionUri) {
     const indexJs = webview.asWebviewUri(vscode_1.Uri.file(path.join(extensionUri, "webview_panels", "dist", "assets", "main.js"))), indexCss = webview.asWebviewUri(vscode_1.Uri.file(path.join(extensionUri, "webview_panels", "dist", "assets", "main.css"))), insightsCss = webview.asWebviewUri(vscode_1.Uri.file(path.join(extensionUri, "webview_panels", "dist", "assets", "Insights.css"))), nonce = function() {
      let text = "";
      const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      for (let i = 0; i < 32; i++) text += possible.charAt(Math.floor(Math.random() * possible.length));
      return text;
     }();
     return `\n        <!DOCTYPE html>\n          <html lang="en">\n          <head>\n            <meta charset="UTF-8">\n            <meta name="viewport" content="width=device-width, initial-scale=1.0">\n            \x3c!--\n              Use a content security policy to only allow loading images from https or from our extension directory,\n              and only allow scripts that have a specific nonce.\n              Added unsafe-inline for css due to csp issue: https://github.com/JedWatson/react-select/issues/4631\n              --\x3e\n            <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'unsafe-inline' ${webview.cspSource}; img-src ${webview.cspSource} https: data:; script-src 'nonce-${nonce}';">\n            <title>VSCode DBT Power user extension</title>\n            <link rel="stylesheet" type="text/css" href="${indexCss}">\n            <link rel="stylesheet" type="text/css" href="${insightsCss}">\n          </head>\n      \n          <body>\n            <div id="root"></div>\n            <script nonce="${nonce}" >\n              window.viewPath = "${this.viewPath}";\n            <\/script>\n            \n            <script nonce="${nonce}" type="module" src="${indexJs}"><\/script>\n          </body>\n        </html>\n      `;
    }
    dispose() {
     for (;this._disposables.length; ) {
      const x = this._disposables.pop();
      x && x.dispose();
     }
    }
   };
   AltimateWebviewProvider = AltimateWebviewProvider_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(AltimateWebviewProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, altimate_1.AltimateRequest, telemetry_1.TelemetryService, SharedStateService_1.SharedStateService ]) ], AltimateWebviewProvider), 
   exports.AltimateWebviewProvider = AltimateWebviewProvider;
  },
  81334: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DataPilotPanel_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DataPilotPanel = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593), dbtProjectContainer_1 = __webpack_require__(37343), telemetry_1 = __webpack_require__(27407), altimateWebviewProvider_1 = __webpack_require__(9447), docGenService_1 = __webpack_require__(68029), altimate_1 = __webpack_require__(99160), SharedStateService_1 = __webpack_require__(81143);
   let DataPilotPanel = DataPilotPanel_1 = class extends altimateWebviewProvider_1.AltimateWebviewProvider {
    constructor(dbtProjectContainer, telemetry, altimateRequest, docGenService, emitterService) {
     super(dbtProjectContainer, altimateRequest, telemetry, emitterService), this.altimateRequest = altimateRequest, 
     this.docGenService = docGenService, this.emitterService = emitterService, this.viewPath = "/datapilot", 
     this.panelDescription = "Datapilot view", this.incomingMessages = [], vscode_1.commands.registerCommand("dbtPowerUser.resetDatapilot", (() => {
      var _a;
      return null === (_a = this._panel) || void 0 === _a ? void 0 : _a.webview.postMessage({
       command: "datapilot:reset",
       args: {}
      });
     }));
    }
    handleCommand(message) {
     const _super = Object.create(null, {
      handleCommand: {
       get: () => super.handleCommand
      }
     });
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {command, syncRequestId} = message, params = tslib_1.__rest(message, [ "command", "syncRequestId" ]), queryText = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.getText();
      switch (command) {
      case "getNewDocsPanelState":
       const newDocsPanelState = vscode_1.workspace.getConfiguration("dbt").get("enableNewDocsPanel", !1);
       this._panel.webview.postMessage({
        command: "response",
        args: {
         syncRequestId,
         body: {
          enabled: newDocsPanelState
         },
         status: !0
        }
       });
       break;

      case "enableNewDocsPanel":
       this.emitterService.fire({
        command: "enableNewDocsPanel",
        payload: params
       });
       break;

      case "sendFeedback":
       if (!queryText) return;
       this.docGenService.sendFeedback({
        queryText,
        message,
        eventMap: this.eventMap,
        panel: this._panel
       });
       break;

      case "generateDocsForModel":
       if (!queryText) return;
       this.docGenService.generateDocsForModel({
        queryText,
        documentation: yield this.docGenService.getDocumentation(this.eventMap),
        message,
        panel: this._panel,
        project: this.docGenService.getProject()
       });
       break;

      case "generateDocsForColumn":
       yield this.docGenService.generateDocsForColumns({
        documentation: yield this.docGenService.getDocumentation(this.eventMap),
        panel: this._panel,
        message,
        project: this.docGenService.getProject()
       });
       break;

      case "docgen:insert":
       this.emitterService.eventEmitter.fire({
        command: "docgen:insert",
        payload: params
       });
       break;

      default:
       _super.handleCommand.call(this, message);
      }
     }));
    }
    onEvent({command, payload}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      switch (command) {
      case "datapilot:toggle":
       yield vscode_1.commands.executeCommand("dbtPowerUser.datapilot-webview.focus");
       break;

      case "datapilot:message":
       if (yield vscode_1.commands.executeCommand("dbtPowerUser.datapilot-webview.focus"), 
       !this.isWebviewReady) return void this.incomingMessages.push(payload);
       this.postToWebview(payload);
      }
     }));
    }
    onWebviewReady() {
     if (super.onWebviewReady(), this._panel) for (;this.incomingMessages.length; ) this.postToWebview(this.incomingMessages.pop());
    }
    postToWebview(message) {
     this._panel && this._panel.webview.postMessage({
      command: "datapilot:message",
      args: message
     });
    }
   };
   DataPilotPanel.viewType = "dbtPowerUser.datapilot-webview", DataPilotPanel = DataPilotPanel_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DataPilotPanel_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService, altimate_1.AltimateRequest, docGenService_1.DocGenService, SharedStateService_1.SharedStateService ]) ], DataPilotPanel), 
   exports.DataPilotPanel = DataPilotPanel;
  },
  12240: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DocsEditViewPanel_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DocsEditViewPanel = exports.Source = void 0;
   const tslib_1 = __webpack_require__(70655), fs_1 = __webpack_require__(57147), vscode_1 = __webpack_require__(66828), dbtProjectContainer_1 = __webpack_require__(37343), utils_1 = __webpack_require__(78593), path = __webpack_require__(71017), python_bridge_1 = __webpack_require__(1438), telemetry_1 = __webpack_require__(27407), altimate_1 = __webpack_require__(99160), yaml_1 = __webpack_require__(93419), newDocsGenPanel_1 = __webpack_require__(53080), docGenService_1 = __webpack_require__(68029), dbtTerminal_1 = __webpack_require__(26684), exception_1 = __webpack_require__(29759);
   !function(Source) {
    Source.YAML = "YAML", Source.DATABASE = "DATABASE";
   }(exports.Source || (exports.Source = {}));
   let DocsEditViewPanel = DocsEditViewPanel_1 = class {
    constructor(dbtProjectContainer, altimateRequest, telemetry, newDocsPanel, docGenService, terminal) {
     this.dbtProjectContainer = dbtProjectContainer, this.altimateRequest = altimateRequest, 
     this.telemetry = telemetry, this.newDocsPanel = newDocsPanel, this.docGenService = docGenService, 
     this.terminal = terminal, this._panel = void 0, this.loadedFromManifest = !1, this.eventMap = new Map, 
     this._disposables = [], this.legacyDocsPanel = this, this.init = () => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.resolveWebviewView(this.panel, this.context, this.token);
     })), dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))), 
     vscode_1.window.onDidChangeActiveColorTheme((e => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel && this.updateGraphStyle();
     }))), null, this._disposables), vscode_1.window.onDidChangeActiveTextEditor((event => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.documentation = void 0, void 0 !== event && (this.documentation = yield this.docGenService.getDocumentation(this.eventMap), 
      this._panel && (this.transmitData(), this.updateGraphStyle()));
     })))), this._disposables.push(vscode_1.workspace.onDidChangeConfiguration((e => {
      e.affectsConfiguration("dbt.enableNewDocsPanel") && this._panel && this.context && this.token && this.getPanel().resolveWebview(this._panel, this.context, this.token);
     }), this, this._disposables));
    }
    getPanel() {
     return vscode_1.workspace.getConfiguration("dbt").get("enableNewDocsPanel", !1) ? this.newDocsPanel : this.legacyDocsPanel;
    }
    getProject() {
     if (!vscode_1.window.activeTextEditor) return;
     const currentFilePath = vscode_1.window.activeTextEditor.document.uri;
     return this.dbtProjectContainer.findDBTProject(currentFilePath);
    }
    transmitError() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel && (yield this._panel.webview.postMessage({
       command: "renderError"
      }));
     }));
    }
    transmitData() {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel && (yield this._panel.webview.postMessage({
       command: "renderDocumentation",
       docs: this.documentation,
       project: null === (_a = this.getProject()) || void 0 === _a ? void 0 : _a.getProjectName()
      }));
     }));
    }
    transmitColumns(columns) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel && (yield this._panel.webview.postMessage({
       command: "renderColumnsFromMetadataFetch",
       columns
      }));
     }));
    }
    transmitConfig() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel && (yield this._panel.webview.postMessage({
       command: "updateConfig",
       config: {
        aiEnabled: this.altimateRequest.enabled()
       }
      }));
     }));
    }
    updateGraphStyle() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const theme = [ vscode_1.ColorThemeKind.Light, vscode_1.ColorThemeKind.HighContrastLight ].includes(vscode_1.window.activeColorTheme.kind) ? "light" : "dark";
      this._panel && (yield this._panel.webview.postMessage({
       command: "setStylesByTheme",
       theme
      }));
     }));
    }
    resolveWebviewView(panel, context, token) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.panel = panel, this.context = context, this.token = token, this._panel = panel, 
      this.getPanel().resolveWebview(panel, context, token), this.setupWebviewHooks(context), 
      this.transmitConfig(), this.documentation = yield this.docGenService.getDocumentation(this.eventMap), 
      this.transmitData();
     }));
    }
    resolveWebview(panel, context, _token) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel = panel, this.setupWebviewOptions(context), this.renderWebviewView(context), 
      this.updateGraphStyle();
     }));
    }
    renderWebviewView(context) {
     const webview = this._panel.webview;
     webview.html = function(webview, extensionUri) {
      const indexPath = getUri(webview, extensionUri, [ "docs_edit_panel", "index.html" ]), resourceDir = getUri(webview, extensionUri, [ "docs_edit_panel" ]), theme = [ vscode_1.ColorThemeKind.Light, vscode_1.ColorThemeKind.HighContrastLight ].includes(vscode_1.window.activeColorTheme.kind) ? "light" : "dark";
      return (0, fs_1.readFileSync)(indexPath.fsPath).toString().replace(/__ROOT__/g, resourceDir.toString()).replace(/__THEME__/g, theme).replace(/__NONCE__/g, function() {
       let text = "";
       const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
       for (let i = 0; i < 32; i++) text += possible.charAt(Math.floor(Math.random() * possible.length));
       return text;
      }()).replace(/__CSPSOURCE__/g, webview.cspSource);
     }(webview, this.dbtProjectContainer.extensionUri);
    }
    setupWebviewOptions(context) {
     this._panel.title = "", this._panel.description = "Edit model documentation", this._panel.webview.options = {
      enableScripts: !0
     };
    }
    setupWebviewHooks(context) {
     this.onMessageDisposable && (this.onMessageDisposable.dispose(), this.onMessageDisposable = void 0), 
     this.onMessageDisposable = this._panel.webview.onDidReceiveMessage((message => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (console.log(message), void 0 === vscode_1.window.activeTextEditor || void 0 === this.eventMap) return;
      const queryText = vscode_1.window.activeTextEditor.document.getText(), currentFilePath = vscode_1.window.activeTextEditor.document.uri, project = this.getProject();
      if (void 0 === project) return;
      const {command, syncRequestId, args} = message;
      switch (command) {
      case "enableNewDocsPanel":
       yield vscode_1.workspace.getConfiguration("dbt").update("enableNewDocsPanel", message.enable), 
       this.init(), this.telemetry.sendTelemetryEvent(message.enable ? "NewDocsPanelEnabled" : "NewDocsPanelDisabled");
       break;

      case "fetchMetadataFromDatabase":
       this.telemetry.sendTelemetryEvent("syncColumnsFromDatabaseForDocs"), vscode_1.window.withProgress({
        title: "Syncing columns with metadata from database",
        location: vscode_1.ProgressLocation.Notification,
        cancellable: !1
       }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        const modelName = path.basename(currentFilePath.fsPath, ".sql");
        try {
         const columns = (yield project.getColumnsOfModel(modelName)).map((column => ({
          name: column.column,
          type: column.dtype
         })));
         this.transmitColumns(columns);
        } catch (exc) {
         if (this.transmitError(), exc instanceof python_bridge_1.PythonException) return vscode_1.window.showErrorMessage(`An error occured while fetching metadata for ${modelName} from the database: ` + exc.exception.message), 
         void this.terminal.error(new exception_1.CustomPythonException("docsEditPanelLoadPythonError", exc));
         vscode_1.window.showErrorMessage(`An error occured while fetching metadata for ${modelName} from the database: ` + exc), 
         this.terminal.error(new exception_1.CustomUnknownException("docsEditPanelLoadError", exc));
        }
       }))));
       break;

      case "generateDocsForModel":
       this.docGenService.generateDocsForModel({
        queryText,
        documentation: this.documentation,
        message,
        panel: this._panel,
        project
       });
       break;

      case "generateDocsForColumn":
       yield this.docGenService.generateDocsForColumns({
        documentation: this.documentation,
        panel: this._panel,
        message,
        project
       });
       break;

      case "sendFeedback":
       this.docGenService.sendFeedback({
        queryText,
        message,
        eventMap: this.eventMap,
        panel: this._panel
       });
       break;

      case "saveDocumentation":
       this.telemetry.sendTelemetryEvent("saveDocumentation");
       let patchPath = message.patchPath;
       vscode_1.window.withProgress({
        title: "Saving documentation",
        location: vscode_1.ProgressLocation.Notification,
        cancellable: !1
       }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        try {
         if (patchPath) patchPath = path.join(project.projectRoot.fsPath, patchPath.split("://")[1]); else switch (message.dialogType) {
         case "Existing file":
          const openDialog = yield vscode_1.window.showOpenDialog({
           filters: {
            Yaml: [ "yml" ]
           },
           canSelectMany: !1
          });
          if (void 0 === openDialog || 0 === openDialog.length) return;
          patchPath = openDialog[0].fsPath;
          break;

         case "New file":
          const saveDialog = yield vscode_1.window.showSaveDialog({
           filters: {
            Yaml: [ "yml" ]
           }
          });
          if (!saveDialog) return;
          patchPath = saveDialog.fsPath;
         }
         (0, fs_1.existsSync)(patchPath) || (0, fs_1.writeFileSync)(patchPath, "");
         const docFile = (0, fs_1.readFileSync)(patchPath).toString("utf8"), parsedDocFile = (0, 
         yaml_1.parse)(docFile, {
          strict: !1,
          uniqueKeys: !1,
          maxAliasCount: -1
         }) || {};
         void 0 === parsedDocFile.models && (parsedDocFile.models = []), void 0 === parsedDocFile.models.find((model => model.name === message.name)) ? parsedDocFile.models.push({
          name: message.name,
          description: message.description,
          columns: message.columns.map((column => Object.assign({
           name: column.name,
           description: column.description
          }, (null == column ? void 0 : column.type) ? {
           data_type: column.type
          } : {})))
         }) : parsedDocFile.models = parsedDocFile.models.map((model => (model.name === message.name && (model.description = message.description, 
         model.columns = message.columns.map((column => {
          const existingColumn = model.columns && model.columns.find((yamlColumn => yamlColumn.name === column.name));
          return void 0 !== existingColumn ? Object.assign(Object.assign(Object.assign({}, existingColumn), (null == column ? void 0 : column.type) && !(null == existingColumn ? void 0 : existingColumn.data_type) ? {
           data_type: column.type
          } : {}), {
           description: column.description
          }) : Object.assign({
           name: column.name,
           description: column.description
          }, (null == column ? void 0 : column.type) ? {
           data_type: column.type
          } : {});
         }))), model))), this.loadedFromManifest = !1, (0, fs_1.writeFileSync)(patchPath, (0, 
         yaml_1.stringify)(parsedDocFile)), this.documentation = yield this.docGenService.getDocumentation(this.eventMap), 
         syncRequestId && this._panel.webview.postMessage({
          command: "response",
          args: {
           syncRequestId,
           body: {
            saved: !0
           },
           status: !0
          }
         });
        } catch (error) {
         this.transmitError(), vscode_1.window.showErrorMessage(`Could not save documentation to ${patchPath}: ${error}`), 
         this.terminal.error(new exception_1.CustomUnknownException("saveDocumentationError", error)), 
         syncRequestId && this._panel.webview.postMessage({
          command: "response",
          args: {
           syncRequestId,
           body: {
            saved: !1
           },
           status: !0
          }
         });
        }
       }))));
      }
     }))), null, this._disposables);
     const sendDocPanelViewEvent = () => {
      this._panel.visible && this.telemetry.sendTelemetryEvent("DocsPanelActive");
     };
     sendDocPanelViewEvent(), this._panel.onDidChangeVisibility(sendDocPanelViewEvent);
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
       this.eventMap.set(added.project.projectRoot.fsPath, added);
      })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
       this.eventMap.delete(removed.projectRoot.fsPath);
      })), void 0 !== this.documentation && this.loadedFromManifest || (this.documentation = yield this.docGenService.getDocumentation(this.eventMap), 
      this.loadedFromManifest = !0, this._panel && (this.transmitData(), this.updateGraphStyle()));
     }));
    }
   };
   function getUri(webview, extensionUri, pathList) {
    return webview.asWebviewUri(vscode_1.Uri.joinPath(extensionUri, ...pathList));
   }
   DocsEditViewPanel.viewType = "dbtPowerUser.DocsEdit", DocsEditViewPanel = DocsEditViewPanel_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DocsEditViewPanel_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, altimate_1.AltimateRequest, telemetry_1.TelemetryService, newDocsGenPanel_1.NewDocsGenPanel, docGenService_1.DocGenService, dbtTerminal_1.DBTTerminal ]) ], DocsEditViewPanel), 
   exports.DocsEditViewPanel = DocsEditViewPanel;
  },
  47888: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var WebviewViewProviders_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.WebviewViewProviders = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593), queryResultPanel_1 = __webpack_require__(11054), docsEditPanel_1 = __webpack_require__(12240), lineagePanel_1 = __webpack_require__(38213), datapilotPanel_1 = __webpack_require__(81334);
   let WebviewViewProviders = WebviewViewProviders_1 = class {
    constructor(queryResultPanel, docsEditPanel, lineagePanel, dataPilotPanel) {
     this.queryResultPanel = queryResultPanel, this.docsEditPanel = docsEditPanel, this.lineagePanel = lineagePanel, 
     this.dataPilotPanel = dataPilotPanel, this.disposables = [], this.disposables.push(vscode_1.window.registerWebviewViewProvider(queryResultPanel_1.QueryResultPanel.viewType, this.queryResultPanel, {
      webviewOptions: {
       retainContextWhenHidden: !0
      }
     }), vscode_1.window.registerWebviewViewProvider(docsEditPanel_1.DocsEditViewPanel.viewType, this.docsEditPanel, {
      webviewOptions: {
       retainContextWhenHidden: !0
      }
     }), vscode_1.window.registerWebviewViewProvider(lineagePanel_1.LineagePanel.viewType, this.lineagePanel, {
      webviewOptions: {
       retainContextWhenHidden: !0
      }
     }), vscode_1.window.registerWebviewViewProvider(datapilotPanel_1.DataPilotPanel.viewType, this.dataPilotPanel, {
      webviewOptions: {
       retainContextWhenHidden: !0
      }
     }));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   WebviewViewProviders = WebviewViewProviders_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(WebviewViewProviders_1), tslib_1.__metadata("design:paramtypes", [ queryResultPanel_1.QueryResultPanel, docsEditPanel_1.DocsEditViewPanel, lineagePanel_1.LineagePanel, datapilotPanel_1.DataPilotPanel ]) ], WebviewViewProviders), 
   exports.WebviewViewProviders = WebviewViewProviders;
  },
  38213: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var LineagePanel_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.LineagePanel = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), utils_1 = __webpack_require__(78593), telemetry_1 = __webpack_require__(27407), dbtProjectContainer_1 = __webpack_require__(37343), modelGraphViewPanel_1 = __webpack_require__(21593), newLineagePanel_1 = __webpack_require__(72270);
   let LineagePanel = LineagePanel_1 = class {
    constructor(lineagePanel, legacyLineagePanel, dbtProjectContainer, telemetry) {
     this.lineagePanel = lineagePanel, this.legacyLineagePanel = legacyLineagePanel, 
     this.telemetry = telemetry, this.eventMap = new Map, this.disposables = [], this.init = () => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.getPanel().resolveWebviewView(this.panel, this.context, this.token), 
      this.getPanel().eventMapChanged(this.eventMap);
     })), this.handleWebviewMessage = message => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      var _a;
      console.log("lineagePanelHost:message -> ", message);
      const {command, args} = message;
      if ("openFile" !== command) {
       if ("setNewLineageView" === command) return yield vscode_1.workspace.getConfiguration("dbt").update("enableNewLineagePanel", !0), 
       this.init(), void this.telemetry.sendTelemetryEvent("NewLineagePanelSelected");
       if ("setLegacyLineageView" === command) return yield vscode_1.workspace.getConfiguration("dbt").update("enableNewLineagePanel", !1), 
       this.init(), void this.telemetry.sendTelemetryEvent("LegacyLineagePanelSelected");
       if ("init" !== command) if ("openURL" !== command) {
        if ("reactError" === command) {
         const typeMapper = {
          generic: "Generic"
         }, {type} = args;
         this.telemetry.sendTelemetryEvent("ReactError:" + typeMapper[type] || 0);
        }
        this.telemetry.sendTelemetryEvent(command), this.getPanel().handleCommand(message);
       } else {
        if (!args.url) return;
        vscode_1.env.openExternal(vscode_1.Uri.parse(args.url));
       } else null === (_a = this.getPanel()) || void 0 === _a || _a.init();
      } else {
       const {url} = args;
       if (!url) return;
       yield vscode_1.commands.executeCommand("vscode.open", vscode_1.Uri.file(url), {
        preview: !1,
        preserveFocus: !0
       });
      }
     })), this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event)))), 
     vscode_1.window.onDidChangeActiveColorTheme((e => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.getPanel().changedActiveColorTheme();
     }))), null, this.disposables), vscode_1.window.onDidChangeActiveTextEditor((event => {
      this.getPanel().changedActiveTextEditor(event);
     }));
    }
    getPanel() {
     return vscode_1.workspace.getConfiguration("dbt").get("enableNewLineagePanel", !1) ? this.lineagePanel : this.legacyLineagePanel;
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.eventMap.set(added.project.projectRoot.fsPath, added);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.eventMap.delete(removed.projectRoot.fsPath);
     })), this.getPanel().eventMapChanged(this.eventMap);
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    resolveWebviewView(panel, context, token) {
     console.log("abstract:resolveWebviewView -> "), this.panel = panel, this.context = context, 
     this.token = token;
     const panelType = vscode_1.workspace.getConfiguration("dbt").get("enableNewLineagePanel", !1);
     this.init(), panel.webview.onDidReceiveMessage(this.handleWebviewMessage, null, []);
     const sendLineageViewEvent = () => {
      this.panel.visible && this.telemetry.sendTelemetryEvent(panelType ? "NewLineagePanelActive" : "LineagePanelActive");
     };
     sendLineageViewEvent(), panel.onDidChangeVisibility(sendLineageViewEvent);
    }
   };
   LineagePanel.viewType = "dbtPowerUser.Lineage", LineagePanel = LineagePanel_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(LineagePanel_1), tslib_1.__metadata("design:paramtypes", [ newLineagePanel_1.NewLineagePanel, modelGraphViewPanel_1.ModelGraphViewPanel, dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], LineagePanel), 
   exports.LineagePanel = LineagePanel;
  },
  21593: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ModelGraphViewPanel_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ModelGraphViewPanel = void 0;
   const tslib_1 = __webpack_require__(70655), fs_1 = __webpack_require__(57147), path = __webpack_require__(71017), vscode_1 = __webpack_require__(66828), dbtProjectContainer_1 = __webpack_require__(37343), utils_1 = __webpack_require__(78593), colors_black = "#000", colors_purple = "#88447D", colors_white = "#FFFFFF", nodeConfigurations = {
    children: {
     style: {
      lineWidth: 2,
      fill: "#EFB27B",
      stroke: colors_black,
      radius: 6
     }
    },
    parents: {
     style: {
      lineWidth: 2,
      fill: "#8DAAE8",
      stroke: colors_black,
      radius: 6
     }
    },
    tests: {
     style: {
      lineWidth: 2,
      fill: "#8DE88E",
      stroke: colors_black,
      radius: 6
     }
    }
   };
   let ModelGraphViewPanel = ModelGraphViewPanel_1 = class {
    constructor(dbtProjectContainer) {
     this.dbtProjectContainer = dbtProjectContainer, this._panel = void 0, this.eventMap = new Map, 
     this.parseGraphData = () => {
      if (void 0 === vscode_1.window.activeTextEditor || void 0 === this.eventMap) return;
      const currentFilePath = vscode_1.window.activeTextEditor.document.uri, projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
      if (void 0 === projectRootpath) return;
      const event = this.eventMap.get(projectRootpath.fsPath);
      if (void 0 === event) return;
      const {graphMetaMap} = event, fileName = path.basename(vscode_1.window.activeTextEditor.document.fileName, ".sql");
      return this.mapParentsAndChildren(graphMetaMap, fileName);
     }, this.mapParentsAndChildren = (graphMetaMap, fileName) => {
      let nodes = [];
      const edges = [];
      return Object.keys(nodeConfigurations).forEach((type => {
       const dependencyNodes = graphMetaMap[type];
       Array.from(dependencyNodes.keys()).forEach((key => {
        if (key.endsWith(`.${fileName}`) && key.startsWith("model.")) {
         const currentNode = dependencyNodes.get(key);
         nodes = this.addCurrentNode(key, nodes), void 0 !== currentNode && currentNode.nodes.map((childrenNode => {
          let edge = {
           target: childrenNode.key,
           source: key
          };
          "parents" === type && (edge = {
           target: key,
           source: childrenNode.key
          }), edges.push(edge), nodes.push({
           id: childrenNode.key,
           label: fitLabelToNodeWidth(childrenNode.label, 280, 14),
           style: nodeConfigurations[type].style,
           url: childrenNode.url
          });
         }));
        }
       }));
      })), {
       nodes,
       edges
      };
     };
    }
    eventMapChanged(eventMap) {
     this.eventMap = eventMap, this.init();
    }
    changedActiveColorTheme() {
     this.updateGraphStyle();
    }
    changedActiveTextEditor(event) {
     void 0 !== event && this.init();
    }
    transmitData(graphInfo) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel && (yield this._panel.webview.postMessage({
       command: "renderGraph",
       graph: graphInfo
      }));
     }));
    }
    updateGraphStyle() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (!this._panel) return;
      const theme = [ vscode_1.ColorThemeKind.Light, vscode_1.ColorThemeKind.HighContrastLight ].includes(vscode_1.window.activeColorTheme.kind) ? "light" : "dark";
      yield this._panel.webview.postMessage({
       command: "setStylesByTheme",
       theme
      });
     }));
    }
    resolveWebviewView(panel, context, _token) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      console.log("graph:resolveWebviewView  -> ", this._panel), this._panel = panel, 
      this.setupWebviewOptions(context), this.renderWebviewView(context);
     }));
    }
    renderWebviewView(context) {
     const webview = this._panel.webview;
     webview.html = function(webview, extensionUri) {
      const indexPath = getUri(webview, extensionUri, [ "lineage_panel", "index.html" ]), resourceDir = getUri(webview, extensionUri, [ "lineage_panel" ]), theme = [ vscode_1.ColorThemeKind.Light, vscode_1.ColorThemeKind.HighContrastLight ].includes(vscode_1.window.activeColorTheme.kind) ? "light" : "dark";
      return (0, fs_1.readFileSync)(indexPath.fsPath).toString().replace(/__ROOT__/g, resourceDir.toString()).replace(/__THEME__/g, theme).replace(/__NONCE__/g, function() {
       let text = "";
       const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
       for (let i = 0; i < 32; i++) text += possible.charAt(Math.floor(Math.random() * possible.length));
       return text;
      }()).replace(/__CSPSOURCE__/g, webview.cspSource);
     }(webview, this.dbtProjectContainer.extensionUri);
    }
    setupWebviewOptions(context) {
     this._panel.title = "", this._panel.description = "View dbt graph", this._panel.webview.options = {
      enableScripts: !0
     };
    }
    init() {
     console.log("graph:init  -> ", this._panel), this.g6Data = this.parseGraphData(), 
     this.transmitData(this.g6Data), this.updateGraphStyle();
    }
    handleCommand(message) {
     console.error("Unsupported mssage", message);
    }
    addCurrentNode(nodeKey, nodes) {
     const nodeLabel = nodeKey.split(".").pop() || "";
     return [ ...nodes, {
      id: nodeKey,
      label: fitLabelToNodeWidth(nodeLabel, 280, 14),
      labelCfg: {
       style: {
        fill: colors_white
       }
      },
      style: {
       fill: colors_purple,
       stroke: "black",
       radius: 6,
       lineWidth: 2
      }
     } ];
    }
   };
   ModelGraphViewPanel.viewType = "dbtPowerUser.ModelViewGraph", ModelGraphViewPanel = ModelGraphViewPanel_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(ModelGraphViewPanel_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer ]) ], ModelGraphViewPanel), 
   exports.ModelGraphViewPanel = ModelGraphViewPanel;
   const fitLabelToNodeWidth = (label, maxWidth, fontSize) => {
    const fontWidth = 1.3 * fontSize;
    maxWidth *= 2;
    const width = (label => {
     let len = 0;
     for (let i = 0; i < label.length; i++) label.charCodeAt(i) > 0 && label.charCodeAt(i) < 128 ? len++ : len += 2;
     return len;
    })(label) * fontWidth;
    if (width > maxWidth) {
     const actualLen = Math.floor((maxWidth - 10) / fontWidth);
     return label.substring(0, actualLen) + "…";
    }
    return label;
   };
   function getUri(webview, extensionUri, pathList) {
    return webview.asWebviewUri(vscode_1.Uri.joinPath(extensionUri, ...pathList));
   }
  },
  53080: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var NewDocsGenPanel_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.NewDocsGenPanel = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), altimate_1 = __webpack_require__(99160), dbtProjectContainer_1 = __webpack_require__(37343), docGenService_1 = __webpack_require__(68029), SharedStateService_1 = __webpack_require__(81143), telemetry_1 = __webpack_require__(27407), utils_1 = __webpack_require__(78593), altimateWebviewProvider_1 = __webpack_require__(9447);
   let NewDocsGenPanel = NewDocsGenPanel_1 = class extends altimateWebviewProvider_1.AltimateWebviewProvider {
    constructor(dbtProjectContainer, altimateRequest, telemetry, docGenService, emitterService) {
     super(dbtProjectContainer, altimateRequest, telemetry, emitterService), this.altimateRequest = altimateRequest, 
     this.docGenService = docGenService, this.emitterService = emitterService, this.viewPath = "/docs-generator", 
     this.panelDescription = "Generate documentation for your models";
    }
    resolveWebview(panel, context, token) {
     super.resolveWebviewView(panel, context, token);
    }
    handleCommand(message) {
     const _super = Object.create(null, {
      handleCommand: {
       get: () => super.handleCommand
      }
     });
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {command, args} = message;
      switch (command) {
      case "enableNewDocsPanel":
       this.toggleDocsPanel(args);
       break;

      case "getCurrentModelDocumentation":
       if (!this.eventMap || !this._panel) return;
       const documentation = yield this.docGenService.getDocumentation(this.eventMap);
       yield this._panel.webview.postMessage({
        command: "renderDocumentation",
        docs: documentation,
        project: null === (_a = this.docGenService.getProject()) || void 0 === _a ? void 0 : _a.getProjectName()
       });

      default:
       _super.handleCommand.call(this, message);
      }
     }));
    }
    onEvent({command, payload}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      switch (command) {
      case "docgen:insert":
       this._panel.webview.postMessage(Object.assign({
        command
       }, payload));
       break;

      case "enableNewDocsPanel":
       this.toggleDocsPanel(payload);
      }
     }));
    }
    toggleDocsPanel({enable}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield vscode_1.workspace.getConfiguration("dbt").update("enableNewDocsPanel", enable), 
      this.telemetry.sendTelemetryEvent(enable ? "NewDocsPanelEnabled" : "NewDocsPanelDisabled");
     }));
    }
   };
   NewDocsGenPanel.viewType = "dbtPowerUser.DocsEdit", NewDocsGenPanel = NewDocsGenPanel_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(NewDocsGenPanel_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, altimate_1.AltimateRequest, telemetry_1.TelemetryService, docGenService_1.DocGenService, SharedStateService_1.SharedStateService ]) ], NewDocsGenPanel), 
   exports.NewDocsGenPanel = NewDocsGenPanel;
  },
  72270: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var NewLineagePanel_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.NewLineagePanel = void 0;
   const tslib_1 = __webpack_require__(70655), fs_1 = __webpack_require__(57147), path = __webpack_require__(71017), vscode_1 = __webpack_require__(66828), altimate_1 = __webpack_require__(99160), dbtProjectContainer_1 = __webpack_require__(37343), utils_1 = __webpack_require__(78593), dbtProject_1 = __webpack_require__(49827), telemetry_1 = __webpack_require__(27407), python_bridge_1 = __webpack_require__(1438), node_fetch_1 = __webpack_require__(74126);
   var CllEvents;
   !function(CllEvents) {
    CllEvents.START = "start", CllEvents.END = "end", CllEvents.CANCEL = "cancel";
   }(CllEvents || (CllEvents = {}));
   const CAN_COMPILE_SQL_NODE = [ dbtProject_1.DBTProject.RESOURCE_TYPE_MODEL, dbtProject_1.DBTProject.RESOURCE_TYPE_SNAPSHOT, dbtProject_1.DBTProject.RESOURCE_TYPE_ANALYSIS ];
   let NewLineagePanel = NewLineagePanel_1 = class {
    constructor(dbtProjectContainer, altimate, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.altimate = altimate, this.telemetry = telemetry, 
     this.eventMap = new Map, this.cllIsCancelled = !1, this.cllProgressResolve = () => {};
    }
    changedActiveTextEditor(event) {
     void 0 !== event && this._panel && this.renderStartingNode();
    }
    eventMapChanged(eventMap) {
     this.eventMap = eventMap, this.init();
    }
    changedActiveColorTheme() {
     if (!this._panel) return;
     const theme = [ vscode_1.ColorThemeKind.Light, vscode_1.ColorThemeKind.HighContrastLight ].includes(vscode_1.window.activeColorTheme.kind) ? "light" : "dark";
     this._panel.webview.postMessage({
      command: "setTheme",
      args: {
       theme
      }
     });
    }
    init() {
     console.log("lineage:init -> ", this._panel), this.changedActiveColorTheme(), this.renderStartingNode();
    }
    renderStartingNode() {
     this._panel && this._panel.webview.postMessage({
      command: "render",
      args: this.getStartingNode()
     });
    }
    resolveWebviewView(panel, context, _token) {
     console.log("lineage:resolveWebviewView -> "), this._panel = panel, this.setupWebviewOptions(context), 
     this.renderWebviewView(context);
    }
    handleCommand(message) {
     var _a, _b, _c, _d, _e, _f, _g;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {command, args} = message, {id, params} = args;
      if ("upstreamTables" !== command) if ("downstreamTables" !== command) if ("getColumns" !== command) if ("getExposureDetails" !== command) if ("getConnectedColumns" !== command) if ("sendFeedback" !== command) "columnLineage" !== command ? "telemetryEvents" !== command ? "previewFeature" !== command ? "showInfoNotification" !== command ? console.error("Unsupported mssage", message) : vscode_1.window.showInformationMessage(args.message) : this.altimate.handlePreviewFeatures() : this.telemetry.sendTelemetryEvent(id, params) : this.handleColumnLineage(args); else try {
       yield this.altimate.sendFeedback({
        feedback_src: "dbtpu-extension",
        feedback_text: params.feedback_text,
        feedback_value: params.feedback_value,
        data: {}
       }), null === (_f = this._panel) || void 0 === _f || _f.webview.postMessage({
        command: "response",
        args: {
         id,
         status: !0
        }
       });
      } catch (error) {
       null === (_g = this._panel) || void 0 === _g || _g.webview.postMessage({
        command: "response",
        args: {
         id,
         status: !1
        }
       }), vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("An unexpected error occurred while sending feedback: " + error)), 
       this.telemetry.sendTelemetryError("altimateLineageSendFeedbackError", error);
      } else {
       const body = yield this.getConnectedColumns(params);
       null === (_e = this._panel) || void 0 === _e || _e.webview.postMessage({
        command: "response",
        args: {
         id,
         body,
         status: !!body
        }
       });
      } else {
       const body = yield this.getExposureDetails(params);
       null === (_d = this._panel) || void 0 === _d || _d.webview.postMessage({
        command: "response",
        args: {
         id,
         body,
         status: !0
        }
       });
      } else {
       const body = yield this.getColumns(params);
       null === (_c = this._panel) || void 0 === _c || _c.webview.postMessage({
        command: "response",
        args: {
         id,
         body,
         status: !0
        }
       });
      } else {
       const body = yield this.getDownstreamTables(params);
       null === (_b = this._panel) || void 0 === _b || _b.webview.postMessage({
        command: "response",
        args: {
         id,
         body,
         status: !0
        }
       });
      } else {
       const body = yield this.getUpstreamTables(params);
       null === (_a = this._panel) || void 0 === _a || _a.webview.postMessage({
        command: "response",
        args: {
         id,
         body,
         status: !0
        }
       });
      }
     }));
    }
    handleColumnLineage({event}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (event !== CllEvents.START) {
       if (event !== CllEvents.END) return event === CllEvents.CANCEL ? (this.cllProgressResolve(), 
       void (this.cllIsCancelled = !0)) : void 0;
       this.cllProgressResolve();
      } else vscode_1.window.withProgress({
       title: "Processing column level lineage",
       location: vscode_1.ProgressLocation.Notification,
       cancellable: !0
      }, ((_, token) => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       yield new Promise((resolve => {
        this.cllIsCancelled = !1, this.cllProgressResolve = resolve, token.onCancellationRequested((() => {
         var _a;
         this.cllIsCancelled = !0, null === (_a = this._panel) || void 0 === _a || _a.webview.postMessage({
          command: "columnLineage",
          args: {
           event: CllEvents.CANCEL
          }
         });
        }));
       }));
      }))));
     }));
    }
    addModelColumnsFromDB(project, node) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const columnsFromDB = yield project.getColumnsOfModel(node.name);
      if (console.log("addColumnsFromDB: ", node.name, " -> ", columnsFromDB), !columnsFromDB || 0 === columnsFromDB.length) return !1;
      columnsFromDB.length > 100 && this.telemetry.sendTelemetryEvent("columnLineageExcessiveColumnsFetchedFromDB");
      const columns = {};
      return Object.entries(node.columns).forEach((([k, v]) => {
       columns[k.toLowerCase()] = v;
      })), columnsFromDB.forEach((c => {
       const existing_column = columns[c.column.toLowerCase()];
       existing_column ? existing_column.data_type = existing_column.data_type || c.dtype : node.columns[c.column] = {
        name: c.column,
        data_type: c.dtype,
        description: ""
       };
      })), Object.keys(node.columns).length > columnsFromDB.length && this.telemetry.sendTelemetryEvent("columnLineagePossibleStaleSchema"), 
      !0;
     }));
    }
    addSourceColumnsFromDB(project, nodeName, table) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      Date.now();
      const columnsFromDB = yield project.getColumnsOfSource(nodeName, table.name);
      if (console.log("addColumnsFromDB: ", nodeName, " -> ", columnsFromDB), !columnsFromDB || 0 === columnsFromDB.length) return !1;
      columnsFromDB.length > 100 && this.telemetry.sendTelemetryEvent("columnLineageExcessiveColumnsFetchedFromDB");
      const columns = {};
      return Object.entries(table.columns).forEach((([k, v]) => {
       columns[k.toLowerCase()] = v;
      })), columnsFromDB.forEach((c => {
       const existing_column = columns[c.column.toLowerCase()];
       existing_column ? existing_column.data_type = existing_column.data_type || c.dtype : table.columns[c.column] = {
        name: c.column,
        data_type: c.dtype,
        description: ""
       };
      })), Object.keys(table.columns).length > columnsFromDB.length && this.telemetry.sendTelemetryEvent("columnLineagePossibleStaleSchema"), 
      !0;
     }));
    }
    getExposureDetails({name}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const event = this.getEvent();
      if (!event) return;
      if (!this.getProject()) return;
      const {exposureMetaMap} = event;
      return exposureMetaMap.get(name);
     }));
    }
    getColumns({table, refresh}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const event = this.getEvent();
      if (!event) return;
      const project = this.getProject();
      if (!project) return;
      const splits = table.split(".");
      if (splits[0] === dbtProject_1.DBTProject.RESOURCE_TYPE_SOURCE) {
       const {sourceMetaMap} = event, sourceName = splits[2], tableName = splits[3], node = sourceMetaMap.get(sourceName);
       if (!node) return;
       const _table = node.tables.find((t => t.name === tableName));
       if (!_table) return;
       if (refresh) {
        if (!(yield vscode_1.window.withProgress({
         title: "Fetching metadata",
         location: vscode_1.ProgressLocation.Notification,
         cancellable: !1
        }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
         return yield this.addSourceColumnsFromDB(project, node.name, _table);
        })))))) return void vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Unable to get columns from DB for model: " + node.name + " table: " + _table.name + "."));
       }
       return {
        id: table,
        purpose: _table.description,
        columns: Object.values(_table.columns).map((c => ({
         table,
         name: c.name,
         datatype: c.data_type || "",
         can_lineage_expand: !1,
         description: c.description
        }))).sort(((a, b) => a.name.localeCompare(b.name)))
       };
      }
      const tableName = splits[2], {nodeMetaMap} = event, node = nodeMetaMap.get(tableName);
      if (node) {
       if (refresh) {
        if ("ephemeral" === node.config.materialized) return void vscode_1.window.showInformationMessage("Cannot fetch columns for ephemeral models.");
        if (!(yield vscode_1.window.withProgress({
         title: "Fetching metadata",
         location: vscode_1.ProgressLocation.Notification,
         cancellable: !1
        }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
         return yield this.addModelColumnsFromDB(project, node);
        })))))) return void vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Unable to get columns from DB for model: " + node.name + " table: " + table + "."));
       }
       return {
        id: table,
        purpose: node.description,
        columns: Object.values(node.columns).map((c => ({
         table,
         name: c.name,
         datatype: c.data_type || "",
         can_lineage_expand: !1,
         description: c.description
        }))).sort(((a, b) => a.name.localeCompare(b.name)))
       };
      }
     }));
    }
    getNodeWithDBColumns(key) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const event = this.getEvent();
      if (!event) return;
      const project = this.getProject();
      if (!project) return;
      const splits = key.split("."), nodeType = splits[0], {nodeMetaMap, sourceMetaMap} = event;
      if (nodeType === dbtProject_1.DBTProject.RESOURCE_TYPE_SOURCE) {
       const source = sourceMetaMap.get(splits[2]), tableName = splits[3];
       if (!source) return;
       const table = null == source ? void 0 : source.tables.find((t => t.name === tableName));
       if (!table) return;
       return {
        dbColumnAdded: yield this.addSourceColumnsFromDB(project, source.name, table),
        node: {
         database: source.database,
         schema: source.schema,
         name: table.name,
         alias: table.identifier,
         uniqueId: key,
         columns: table.columns
        }
       };
      }
      const node = nodeMetaMap.get(splits[2]);
      if (!node) return;
      if ("ephemeral" === node.config.materialized) return {
       dbColumnAdded: !1,
       node,
       isEphemeral: !0
      };
      return {
       dbColumnAdded: yield this.addModelColumnsFromDB(project, node),
       node
      };
     }));
    }
    getConnectedColumns({targets, upstreamExpansion, currAnd1HopTables, selectedColumn, sessionId}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const event = this.getEvent();
      if (!event) return;
      const {graphMetaMap} = event, project = this.getProject();
      if (!project) return;
      const modelInfos = [], relationsWithoutColumns = [];
      let selected_column;
      const parent_models = [];
      let auxiliaryTables = [];
      if (currAnd1HopTables = Array.from(new Set(currAnd1HopTables)), upstreamExpansion) {
       const currTables = new Set(targets.map((t => t[0]))), dependencyNodes = graphMetaMap.parents, parentSet = new Set, hop1Tables = currAnd1HopTables.filter((t => !currTables.has(t))), visited = {}, {nodeMetaMap} = event;
       for (;hop1Tables.length > 0; ) {
        const curr = hop1Tables.shift();
        if (visited[curr]) continue;
        visited[curr] = !0;
        const parent = dependencyNodes.get(curr);
        parent && parent.nodes.forEach((n => {
         var _a;
         const splits = n.key.split(".");
         splits[0] === dbtProject_1.DBTProject.RESOURCE_TYPE_MODEL && "ephemeral" === (null === (_a = nodeMetaMap.get(splits[2])) || void 0 === _a ? void 0 : _a.config.materialized) ? hop1Tables.push(n.key) : parentSet.add(n.key);
        }));
       }
       auxiliaryTables = Array.from(parentSet);
      }
      const commandQueue = [];
      try {
       currAnd1HopTables.forEach((key => {
        commandQueue.push((() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
         const result = yield this.getNodeWithDBColumns(key);
         if (!result) return;
         const {node, dbColumnAdded, isEphemeral} = result;
         if (isEphemeral) return void this.telemetry.sendTelemetryError("columnLineageProcessingEphemeral");
         if (!dbColumnAdded) return void relationsWithoutColumns.push(key);
         if (!(nodeType => CAN_COMPILE_SQL_NODE.includes(nodeType))(key.split(".")[0])) return void modelInfos.push({
          model_node: node
         });
         const compiledSql = yield project.compileNode(node.name);
         compiledSql && modelInfos.push({
          compiled_sql: compiledSql,
          model_node: node
         });
        }))));
       })), commandQueue.push((() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        const result = yield this.getNodeWithDBColumns(selectedColumn.table);
        if (!result) return;
        const {node, dbColumnAdded} = result;
        dbColumnAdded ? selected_column = {
         model_node: node,
         column: selectedColumn.name
        } : relationsWithoutColumns.push(selectedColumn.table);
       })))), auxiliaryTables.forEach((key => {
        commandQueue.push((() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
         const result = yield this.getNodeWithDBColumns(key);
         if (!result) return;
         const {node, dbColumnAdded, isEphemeral} = result;
         isEphemeral || (dbColumnAdded ? parent_models.push({
          model_node: node
         }) : relationsWithoutColumns.push(key));
        }))));
       }));
       for (const fn of commandQueue) {
        if (this.cllIsCancelled) return {
         column_lineage: []
        };
        yield fn();
       }
      } catch (exc) {
       return exc instanceof python_bridge_1.PythonException ? (vscode_1.window.showErrorMessage((0, 
       utils_1.extendErrorWithSupportLinks)("An error occured while trying to compute lineage of your model: " + exc.exception.message + ".")), 
       this.telemetry.sendTelemetryError("columnLineageCompileNodePythonError", exc), console.error("Error encountered while compiling/retrieving schema for model: "), 
       void console.error("Exception: " + exc.exception.message + "\n\nDetailed error information:\n" + exc)) : (this.telemetry.sendTelemetryError("columnLineageCompileNodeUnknownError", exc), 
       void vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Encountered an unknown issue: " + exc + " while compiling/retrieving schema for nodes.")));
      }
      0 !== relationsWithoutColumns.length && vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Failed to fetch columns for " + relationsWithoutColumns.join(", ") + ". Probably the dbt models are not yet materialized."));
      const targetTables = Array.from(new Set(targets.map((t => t[0]))));
      if (0 === targets.length || modelInfos.length < targetTables.length) return this.telemetry.sendTelemetryError("columnLineageLogicError", {
       targets,
       modelInfos,
       upstreamExpansion,
       currAnd1HopTables,
       selectedColumn
      }), {
       column_lineage: []
      };
      if (modelInfos.length === targetTables.length) return {
       column_lineage: []
      };
      const models = modelInfos.map((m => m.model_node.uniqueId));
      if (!targets.every((t => models.includes(t[0])))) return {
       column_lineage: []
      };
      const modelDialect = project.getAdapterType();
      try {
       if (this.cllIsCancelled) return {
        column_lineage: []
       };
       const request = {
        model_dialect: modelDialect,
        model_info: modelInfos,
        upstream_expansion: upstreamExpansion,
        targets: targets.map((t => ({
         uniqueId: t[0],
         column_name: t[1]
        }))),
        selected_column,
        parent_models,
        session_id: sessionId
       };
       console.log("cll:request -> ", request);
       const result = yield this.altimate.getColumnLevelLineage(request);
       if (console.log("cll:response -> ", result), result.column_lineage) {
        return {
         column_lineage: (null == result ? void 0 : result.column_lineage.map((c => ({
          source: [ c.source.uniqueId, c.source.column_name ],
          target: [ c.target.uniqueId, c.target.column_name ],
          type: c.type
         })))) || [],
         confindence: null == result ? void 0 : result.confidence
        };
       }
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("An unexpected error occured while fetching column level lineage.")), 
       this.telemetry.sendTelemetryEvent("columnLevelLineageInvalidResponse", result);
      } catch (error) {
       return error instanceof node_fetch_1.AbortError ? (vscode_1.window.showErrorMessage((0, 
       utils_1.extendErrorWithSupportLinks)("Fetching column level lineage timed out.")), 
       void this.telemetry.sendTelemetryError("columnLevelLineageRequestTimeout", error)) : (vscode_1.window.showErrorMessage((0, 
       utils_1.extendErrorWithSupportLinks)("An unexpected error occured while fetching column level lineage.")), 
       void this.telemetry.sendTelemetryError("ColumnLevelLineageError", error));
      }
     }));
    }
    getConnectedTables(key, table) {
     const event = this.getEvent();
     if (!event) return;
     const {graphMetaMap} = event, node = graphMetaMap[key].get(table);
     if (!node) return;
     const tables = new Map;
     return node.nodes.forEach((({url, key}) => {
      const _node = this.createTable(event, url, key);
      _node && (tables.has(_node.table) || tables.set(_node.table, _node));
     })), Array.from(tables.values()).sort(((a, b) => a.table.localeCompare(b.table)));
    }
    createTable(event, tableUrl, key) {
     var _a, _b, _c;
     const nodeType = key.split(".")[0], {graphMetaMap, testMetaMap} = event, upstreamCount = this.getConnectedNodeCount(graphMetaMap.children, key), downstreamCount = this.getConnectedNodeCount(graphMetaMap.parents, key);
     if (nodeType === dbtProject_1.DBTProject.RESOURCE_TYPE_SOURCE) {
      const {sourceMetaMap} = event, splits = key.split("."), schema = splits[2], table = splits[3], _node = sourceMetaMap.get(schema);
      if (!_node) return;
      if (!_node.tables.find((t => t.name === table))) return;
      return {
       table: key,
       label: table,
       url: tableUrl,
       upstreamCount,
       downstreamCount,
       nodeType,
       tests: ((null === (_a = graphMetaMap.tests.get(key)) || void 0 === _a ? void 0 : _a.nodes) || []).map((n => {
        const testKey = n.label.split(".")[0];
        return Object.assign(Object.assign({}, testMetaMap.get(testKey)), {
         key: testKey
        });
       }))
      };
     }
     const {nodeMetaMap} = event, table = key.split(".")[2];
     if (nodeType === dbtProject_1.DBTProject.RESOURCE_TYPE_EXPOSURE) return {
      table: key,
      label: table,
      url: tableUrl,
      upstreamCount,
      downstreamCount,
      nodeType,
      materialization: void 0,
      tests: ((null === (_b = graphMetaMap.tests.get(key)) || void 0 === _b ? void 0 : _b.nodes) || []).map((n => {
       const testKey = n.label.split(".")[0];
       return Object.assign(Object.assign({}, testMetaMap.get(testKey)), {
        key: testKey
       });
      }))
     };
     const node = nodeMetaMap.get(table);
     if (!node) return;
     return {
      table: key,
      label: table,
      url: tableUrl,
      upstreamCount,
      downstreamCount,
      nodeType,
      materialization: node.config.materialized,
      tests: ((null === (_c = graphMetaMap.tests.get(key)) || void 0 === _c ? void 0 : _c.nodes) || []).map((n => {
       const testKey = n.label.split(".")[0];
       return Object.assign(Object.assign({}, testMetaMap.get(testKey)), {
        key: testKey
       });
      }))
     };
    }
    getUpstreamTables({table}) {
     return {
      tables: this.getConnectedTables("children", table)
     };
    }
    getDownstreamTables({table}) {
     return {
      tables: this.getConnectedTables("parents", table)
     };
    }
    getEvent() {
     if (void 0 === vscode_1.window.activeTextEditor || void 0 === this.eventMap) return;
     const currentFilePath = vscode_1.window.activeTextEditor.document.uri, projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (void 0 === projectRootpath) return;
     const event = this.eventMap.get(projectRootpath.fsPath);
     return void 0 !== event ? event : void 0;
    }
    getConnectedNodeCount(g, key) {
     var _a;
     return (null === (_a = g.get(key)) || void 0 === _a ? void 0 : _a.nodes.length) || 0;
    }
    getFilename() {
     return path.basename(vscode_1.window.activeTextEditor.document.fileName, ".sql");
    }
    getProject() {
     var _a;
     const currentFilePath = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
     if (currentFilePath) return this.dbtProjectContainer.findDBTProject(currentFilePath);
    }
    getStartingNode() {
     var _a;
     const event = this.getEvent();
     if (!event) return;
     const {nodeMetaMap, graphMetaMap, testMetaMap} = event, tableName = this.getFilename(), _node = nodeMetaMap.get(tableName);
     if (!_node) return;
     const key = _node.uniqueId, nodeType = key.split(".")[0], downstreamCount = this.getConnectedNodeCount(graphMetaMap.parents, key), upstreamCount = this.getConnectedNodeCount(graphMetaMap.children, key), materialization = _node.config.materialized;
     return {
      node: {
       table: key,
       label: tableName,
       url: vscode_1.window.activeTextEditor.document.uri.path,
       upstreamCount,
       downstreamCount,
       nodeType,
       materialization,
       tests: ((null === (_a = graphMetaMap.tests.get(key)) || void 0 === _a ? void 0 : _a.nodes) || []).map((n => {
        const testKey = n.label.split(".")[0];
        return Object.assign(Object.assign({}, testMetaMap.get(testKey)), {
         key: testKey
        });
       }))
      },
      aiEnabled: this.altimate.enabled()
     };
    }
    setupWebviewOptions(context) {
     this._panel.description = "Show table level and column level lineage SQL queries", 
     this._panel.webview.options = {
      enableScripts: !0
     };
    }
    renderWebviewView(context) {
     const webview = this._panel.webview;
     this._panel.webview.html = function(webview, extensionUri) {
      const indexJs = getUri(webview, extensionUri, [ "new_lineage_panel", "dist", "assets", "index.js" ]), resourceDir = getUri(webview, extensionUri, [ "new_lineage_panel", "dist" ]).toString();
      !function(filename, searchString, replacementString) {
       tslib_1.__awaiter(this, void 0, void 0, (function*() {
        const replacedContents = (0, fs_1.readFileSync)(filename.fsPath, "utf8").replace(searchString, replacementString);
        (0, fs_1.writeFileSync)(filename.fsPath, replacedContents, "utf8");
       }));
      }(indexJs, "/__ROOT__/", resourceDir + "/");
      const indexPath = getUri(webview, extensionUri, [ "new_lineage_panel", "dist", "index.html" ]);
      return (0, fs_1.readFileSync)(indexPath.fsPath).toString().replace(/\/__ROOT__/g, resourceDir).replace(/__ROOT__/g, resourceDir).replace(/__NONCE__/g, function() {
       let text = "";
       const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
       for (let i = 0; i < 32; i++) text += possible.charAt(Math.floor(Math.random() * possible.length));
       return text;
      }()).replace(/__CSPSOURCE__/g, webview.cspSource);
     }(webview, this.dbtProjectContainer.extensionUri);
    }
   };
   function getUri(webview, extensionUri, pathList) {
    return webview.asWebviewUri(vscode_1.Uri.joinPath(extensionUri, ...pathList));
   }
   NewLineagePanel = NewLineagePanel_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(NewLineagePanel_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, altimate_1.AltimateRequest, telemetry_1.TelemetryService ]) ], NewLineagePanel), 
   exports.NewLineagePanel = NewLineagePanel;
  },
  11054: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var QueryResultPanel_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.QueryResultPanel = void 0;
   const tslib_1 = __webpack_require__(70655), vscode_1 = __webpack_require__(66828), fs_1 = __webpack_require__(57147), python_bridge_1 = __webpack_require__(1438), dbtProjectContainer_1 = __webpack_require__(37343), utils_1 = __webpack_require__(78593), telemetry_1 = __webpack_require__(27407), altimate_1 = __webpack_require__(99160);
   var OutboundCommand, InboundCommand;
   !function(OutboundCommand) {
    OutboundCommand.RenderQuery = "renderQuery", OutboundCommand.RenderLoading = "renderLoading", 
    OutboundCommand.RenderError = "renderError", OutboundCommand.InjectConfig = "injectConfig", 
    OutboundCommand.ResetState = "resetState", OutboundCommand.RenderSummary = "renderSummary";
   }(OutboundCommand || (OutboundCommand = {})), function(InboundCommand) {
    InboundCommand.Info = "info", InboundCommand.Error = "error", InboundCommand.UpdateConfig = "updateConfig", 
    InboundCommand.OpenUrl = "openUrl", InboundCommand.GetSummary = "getSummary";
   }(InboundCommand || (InboundCommand = {}));
   let QueryResultPanel = QueryResultPanel_1 = class {
    constructor(dbtProjectContainer, telemetry, altimate) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.altimate = altimate, 
     this._disposables = [], this.adapter = "unknown", vscode_1.window.onDidChangeActiveColorTheme((e => {
      this._panel && (this._panel.webview.html = getHtml(this._panel.webview, this.dbtProjectContainer.extensionUri), 
      this.transmitConfig());
     }), null, this._disposables);
    }
    resolveWebviewView(panel, context, _token) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel = panel, this.setupWebviewOptions(context), this.renderWebviewView(context), 
      this.setupWebviewHooks(context), this.transmitConfig(), _token.onCancellationRequested((() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       yield this.transmitReset();
      }))));
     }));
    }
    setupWebviewOptions(context) {
     this._panel.title = "Query Results", this._panel.description = "Preview dbt SQL Results", 
     this._panel.webview.options = {
      enableScripts: !0
     };
    }
    setupWebviewHooks(context) {
     this._panel.webview.onDidReceiveMessage((message => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      switch (message.command) {
      case InboundCommand.Error:
       const error = message;
       vscode_1.window.showErrorMessage(error.text);
       break;

      case InboundCommand.Info:
       const info = message;
       vscode_1.window.withProgress({
        title: info.text,
        location: vscode_1.ProgressLocation.Notification,
        cancellable: !1
       }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        yield new Promise((timer => setTimeout(timer, 3e3)));
       }))));
       break;

      case InboundCommand.UpdateConfig:
       const configMessage = message;
       void 0 !== configMessage.limit && vscode_1.workspace.getConfiguration("dbt").update("queryLimit", configMessage.limit), 
       configMessage.scale && vscode_1.workspace.getConfiguration("dbt").update("queryScale", configMessage.scale), 
       "enableNewQueryPanel" in configMessage && vscode_1.workspace.getConfiguration("dbt").update("enableNewQueryPanel", configMessage.enableNewQueryPanel);
       break;

      case InboundCommand.OpenUrl:
       const config = message;
       vscode_1.env.openExternal(vscode_1.Uri.parse(config.url));
       break;

      case InboundCommand.GetSummary:
       const summary = message;
       yield this.getSummary(summary.compiledSql, this.adapter);
      }
     }))), null, this._disposables);
     const sendQueryPanelViewEvent = () => {
      this._panel.visible && this.telemetry.sendTelemetryEvent("QueryPanelActive");
     };
     sendQueryPanelViewEvent(), this._panel.onDidChangeVisibility(sendQueryPanelViewEvent);
    }
    renderWebviewView(context) {
     const webview = this._panel.webview;
     this._panel.webview.html = getHtml(webview, this.dbtProjectContainer.extensionUri);
    }
    transmitData(columnNames, columnTypes, rows, raw_sql, compiled_sql) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel && (yield this._panel.webview.postMessage(Object.assign({
       command: OutboundCommand.RenderQuery
      }, {
       columnNames,
       columnTypes,
       rows,
       raw_sql,
       compiled_sql
      })));
     }));
    }
    transmitSummary(compiled_sql, summary) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel && (yield this._panel.webview.postMessage(Object.assign({
       command: OutboundCommand.RenderSummary
      }, {
       compiled_sql,
       summary
      })));
     }));
    }
    transmitError(error, raw_sql, compiled_sql) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel && (yield this._panel.webview.postMessage(Object.assign({
       command: OutboundCommand.RenderError
      }, Object.assign(Object.assign({}, error), {
       raw_sql,
       compiled_sql
      }))));
     }));
    }
    transmitConfig() {
     const limit = vscode_1.workspace.getConfiguration("dbt").get("queryLimit"), enableNewQueryPanel = vscode_1.workspace.getConfiguration("dbt").get("enableNewQueryPanel", !0), queryTemplate = vscode_1.workspace.getConfiguration("dbt").get("queryTemplate", "select * from ({query}) as query limit {limit}");
     this._panel && this._panel.webview.postMessage(Object.assign({
      command: OutboundCommand.InjectConfig
     }, {
      limit,
      queryTemplate,
      enableNewQueryPanel,
      darkMode: ![ vscode_1.ColorThemeKind.Light, vscode_1.ColorThemeKind.HighContrastLight ].includes(vscode_1.window.activeColorTheme.kind),
      aiEnabled: this.altimate.enabled()
     }));
    }
    transmitLoading() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel && (yield this._panel.webview.postMessage({
       command: OutboundCommand.RenderLoading
      }));
     }));
    }
    transmitReset() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel && (yield this._panel.webview.postMessage({
       command: OutboundCommand.ResetState
      }));
     }));
    }
    transmitDataWrapper(result, query) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const rows = [];
      for (let i = 0; i < result.table.rows.length; i++) result.table.rows[i].forEach(((value, j) => {
       rows[i] = Object.assign(Object.assign({}, rows[i]), {
        [result.table.column_names[j]]: value
       });
      }));
      yield this.transmitData(result.table.column_names, result.table.column_types, rows, query, result.compiled_sql);
     }));
    }
    getSummary(query, adapter) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.altimate.handlePreviewFeatures() && (yield vscode_1.commands.executeCommand("dbtPowerUser.PreviewResults.focus"), 
      this.telemetry.sendTelemetryEvent("getQuerySummary"), vscode_1.window.withProgress({
       title: "Getting query explanation",
       location: vscode_1.ProgressLocation.Notification,
       cancellable: !1
      }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       this._panel && (this._panel.show(), this._panel.webview.postMessage({
        command: "focus"
       }));
       try {
        const response = yield this.altimate.getQuerySummary(query, adapter);
        if (void 0 === response || void 0 === response.explanation) return vscode_1.window.showErrorMessage((0, 
        utils_1.extendErrorWithSupportLinks)("Could not get summary.")), void this.telemetry.sendTelemetryError("getQuerySummaryAltimateError");
        yield this.transmitSummary(query, response.explanation);
       } catch (err) {
        vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Could not get summary: " + err + ".")), 
        this.telemetry.sendTelemetryError("getQuerySummaryAltimateError");
       }
      })))));
     }));
    }
    executeQuery(query, queryExecution, adapter) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield vscode_1.commands.executeCommand("dbtPowerUser.PreviewResults.focus"), this._panel && (this._panel.show(), 
      this._panel.webview.postMessage({
       command: "focus"
      }), this.adapter = adapter, this.transmitLoading());
      try {
       const output = yield queryExecution;
       yield this.transmitDataWrapper(output, query);
      } catch (exc) {
       if (exc instanceof python_bridge_1.PythonException) return vscode_1.window.showErrorMessage("An error occured while trying to execute your query: " + exc.exception.message), 
       void (yield this.transmitError({
        error: {
         code: -1,
         message: exc.exception.message,
         data: JSON.stringify(exc.stack, null, 2)
        }
       }, query, query));
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Encountered an unknown issue: " + exc.message + ".")), 
       yield this.transmitError({
        error: {
         code: -1,
         message: exc.message,
         data: {}
        }
       }, query, query);
      }
     }));
    }
   };
   function getHtml(webview, extensionUri) {
    const indexPath = getUri(webview, extensionUri, [ "query_panel", "index.html" ]), resourceDir = getUri(webview, extensionUri, [ "query_panel" ]), theme = [ vscode_1.ColorThemeKind.Light, vscode_1.ColorThemeKind.HighContrastLight ].includes(vscode_1.window.activeColorTheme.kind) ? "light" : "dark";
    return (0, fs_1.readFileSync)(indexPath.fsPath).toString().replace(/__ROOT__/g, resourceDir.toString()).replace(/__THEME__/g, theme).replace(/__NONCE__/g, function() {
     let text = "";
     const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
     for (let i = 0; i < 32; i++) text += possible.charAt(Math.floor(Math.random() * possible.length));
     return text;
    }()).replace(/__CSPSOURCE__/g, webview.cspSource);
   }
   function getUri(webview, extensionUri, pathList) {
    return webview.asWebviewUri(vscode_1.Uri.joinPath(extensionUri, ...pathList));
   }
   QueryResultPanel.viewType = "dbtPowerUser.PreviewResults", QueryResultPanel = QueryResultPanel_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(QueryResultPanel_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService, altimate_1.AltimateRequest ]) ], QueryResultPanel), 
   exports.QueryResultPanel = QueryResultPanel;
  },
  70655: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    __assign: () => __assign,
    __asyncDelegator: () => __asyncDelegator,
    __asyncGenerator: () => __asyncGenerator,
    __asyncValues: () => __asyncValues,
    __await: () => __await,
    __awaiter: () => __awaiter,
    __classPrivateFieldGet: () => __classPrivateFieldGet,
    __classPrivateFieldSet: () => __classPrivateFieldSet,
    __createBinding: () => __createBinding,
    __decorate: () => __decorate,
    __exportStar: () => __exportStar,
    __extends: () => __extends,
    __generator: () => __generator,
    __importDefault: () => __importDefault,
    __importStar: () => __importStar,
    __makeTemplateObject: () => __makeTemplateObject,
    __metadata: () => __metadata,
    __param: () => __param,
    __read: () => __read,
    __rest: () => __rest,
    __spread: () => __spread,
    __spreadArrays: () => __spreadArrays,
    __values: () => __values
   });
   var extendStatics = function(d, b) {
    return extendStatics = Object.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
    }, extendStatics(d, b);
   };
   function __extends(d, b) {
    function __() {
     this.constructor = d;
    }
    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
    new __);
   }
   var __assign = function() {
    return __assign = Object.assign || function(t) {
     for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
     return t;
    }, __assign.apply(this, arguments);
   };
   function __rest(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
     var i = 0;
     for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
   }
   function __decorate(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
   }
   function __param(paramIndex, decorator) {
    return function(target, key) {
     decorator(target, key, paramIndex);
    };
   }
   function __metadata(metadataKey, metadataValue) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(metadataKey, metadataValue);
   }
   function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }
   function __generator(thisArg, body) {
    var f, y, t, g, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    };
    return g = {
     next: verb(0),
     throw: verb(1),
     return: verb(2)
    }, "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;_; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   }
   function __createBinding(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }
   function __exportStar(m, exports) {
    for (var p in m) "default" === p || exports.hasOwnProperty(p) || (exports[p] = m[p]);
   }
   function __values(o) {
    var s = "function" == typeof Symbol && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && "number" == typeof o.length) return {
     next: function() {
      return o && i >= o.length && (o = void 0), {
       value: o && o[i++],
       done: !o
      };
     }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
   }
   function __read(o, n) {
    var m = "function" == typeof Symbol && o[Symbol.iterator];
    if (!m) return o;
    var r, e, i = m.call(o), ar = [];
    try {
     for (;(void 0 === n || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
    } catch (error) {
     e = {
      error
     };
    } finally {
     try {
      r && !r.done && (m = i.return) && m.call(i);
     } finally {
      if (e) throw e.error;
     }
    }
    return ar;
   }
   function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
   }
   function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    var r = Array(s), k = 0;
    for (i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, 
    k++) r[k] = a[j];
    return r;
   }
   function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
   }
   function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var i, g = generator.apply(thisArg, _arguments || []), q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
     return this;
    }, i;
    function verb(n) {
     g[n] && (i[n] = function(v) {
      return new Promise((function(a, b) {
       q.push([ n, v, a, b ]) > 1 || resume(n, v);
      }));
     });
    }
    function resume(n, v) {
     try {
      (r = g[n](v)).value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
     } catch (e) {
      settle(q[0][3], e);
     }
     var r;
    }
    function fulfill(value) {
     resume("next", value);
    }
    function reject(value) {
     resume("throw", value);
    }
    function settle(f, v) {
     f(v), q.shift(), q.length && resume(q[0][0], q[0][1]);
    }
   }
   function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", (function(e) {
     throw e;
    })), verb("return"), i[Symbol.iterator] = function() {
     return this;
    }, i;
    function verb(n, f) {
     i[n] = o[n] ? function(v) {
      return (p = !p) ? {
       value: __await(o[n](v)),
       done: "return" === n
      } : f ? f(v) : v;
     } : f;
    }
   }
   function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var i, m = o[Symbol.asyncIterator];
    return m ? m.call(o) : (o = __values(o), i = {}, verb("next"), verb("throw"), verb("return"), 
    i[Symbol.asyncIterator] = function() {
     return this;
    }, i);
    function verb(n) {
     i[n] = o[n] && function(v) {
      return new Promise((function(resolve, reject) {
       (function(resolve, reject, d, v) {
        Promise.resolve(v).then((function(v) {
         resolve({
          value: v,
          done: d
         });
        }), reject);
       })(resolve, reject, (v = o[n](v)).done, v.value);
      }));
     };
    }
   }
   function __makeTemplateObject(cooked, raw) {
    return Object.defineProperty ? Object.defineProperty(cooked, "raw", {
     value: raw
    }) : cooked.raw = raw, cooked;
   }
   function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
    return result.default = mod, result;
   }
   function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
     default: mod
    };
   }
   function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) throw new TypeError("attempted to get private field on non-instance");
    return privateMap.get(receiver);
   }
   function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) throw new TypeError("attempted to set private field on non-instance");
    return privateMap.set(receiver, value), value;
   }
  },
  42660: function(__unused_webpack_module, exports) {
   var factory;
   factory = function(exports) {
    "use strict";
    const SymbolPolyfill = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? Symbol : description => `Symbol(${description})`;
    function noop() {}
    const globals = "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : void 0;
    function typeIsObject(x) {
     return "object" == typeof x && null !== x || "function" == typeof x;
    }
    const rethrowAssertionErrorRejection = noop, originalPromise = Promise, originalPromiseThen = Promise.prototype.then, originalPromiseResolve = Promise.resolve.bind(originalPromise), originalPromiseReject = Promise.reject.bind(originalPromise);
    function newPromise(executor) {
     return new originalPromise(executor);
    }
    function promiseResolvedWith(value) {
     return originalPromiseResolve(value);
    }
    function promiseRejectedWith(reason) {
     return originalPromiseReject(reason);
    }
    function PerformPromiseThen(promise, onFulfilled, onRejected) {
     return originalPromiseThen.call(promise, onFulfilled, onRejected);
    }
    function uponPromise(promise, onFulfilled, onRejected) {
     PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
    }
    function uponFulfillment(promise, onFulfilled) {
     uponPromise(promise, onFulfilled);
    }
    function uponRejection(promise, onRejected) {
     uponPromise(promise, void 0, onRejected);
    }
    function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
     return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
    }
    function setPromiseIsHandledToTrue(promise) {
     PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
    }
    const queueMicrotask = (() => {
     const globalQueueMicrotask = globals && globals.queueMicrotask;
     if ("function" == typeof globalQueueMicrotask) return globalQueueMicrotask;
     const resolvedPromise = promiseResolvedWith(void 0);
     return fn => PerformPromiseThen(resolvedPromise, fn);
    })();
    function reflectCall(F, V, args) {
     if ("function" != typeof F) throw new TypeError("Argument is not a function");
     return Function.prototype.apply.call(F, V, args);
    }
    function promiseCall(F, V, args) {
     try {
      return promiseResolvedWith(reflectCall(F, V, args));
     } catch (value) {
      return promiseRejectedWith(value);
     }
    }
    class SimpleQueue {
     constructor() {
      this._cursor = 0, this._size = 0, this._front = {
       _elements: [],
       _next: void 0
      }, this._back = this._front, this._cursor = 0, this._size = 0;
     }
     get length() {
      return this._size;
     }
     push(element) {
      const oldBack = this._back;
      let newBack = oldBack;
      16383 === oldBack._elements.length && (newBack = {
       _elements: [],
       _next: void 0
      }), oldBack._elements.push(element), newBack !== oldBack && (this._back = newBack, 
      oldBack._next = newBack), ++this._size;
     }
     shift() {
      const oldFront = this._front;
      let newFront = oldFront;
      const oldCursor = this._cursor;
      let newCursor = oldCursor + 1;
      const elements = oldFront._elements, element = elements[oldCursor];
      return 16384 === newCursor && (newFront = oldFront._next, newCursor = 0), --this._size, 
      this._cursor = newCursor, oldFront !== newFront && (this._front = newFront), elements[oldCursor] = void 0, 
      element;
     }
     forEach(callback) {
      let i = this._cursor, node = this._front, elements = node._elements;
      for (;!(i === elements.length && void 0 === node._next || i === elements.length && (node = node._next, 
      elements = node._elements, i = 0, 0 === elements.length)); ) callback(elements[i]), 
      ++i;
     }
     peek() {
      const front = this._front, cursor = this._cursor;
      return front._elements[cursor];
     }
    }
    function ReadableStreamReaderGenericInitialize(reader, stream) {
     reader._ownerReadableStream = stream, stream._reader = reader, "readable" === stream._state ? defaultReaderClosedPromiseInitialize(reader) : "closed" === stream._state ? function(reader) {
      defaultReaderClosedPromiseInitialize(reader), defaultReaderClosedPromiseResolve(reader);
     }(reader) : defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
    }
    function ReadableStreamReaderGenericCancel(reader, reason) {
     return ReadableStreamCancel(reader._ownerReadableStream, reason);
    }
    function ReadableStreamReaderGenericRelease(reader) {
     "readable" === reader._ownerReadableStream._state ? defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : function(reader, reason) {
      defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
     }(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), 
     reader._ownerReadableStream._reader = void 0, reader._ownerReadableStream = void 0;
    }
    function readerLockException(name) {
     return new TypeError("Cannot " + name + " a stream using a released reader");
    }
    function defaultReaderClosedPromiseInitialize(reader) {
     reader._closedPromise = newPromise(((resolve, reject) => {
      reader._closedPromise_resolve = resolve, reader._closedPromise_reject = reject;
     }));
    }
    function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
     defaultReaderClosedPromiseInitialize(reader), defaultReaderClosedPromiseReject(reader, reason);
    }
    function defaultReaderClosedPromiseReject(reader, reason) {
     void 0 !== reader._closedPromise_reject && (setPromiseIsHandledToTrue(reader._closedPromise), 
     reader._closedPromise_reject(reason), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0);
    }
    function defaultReaderClosedPromiseResolve(reader) {
     void 0 !== reader._closedPromise_resolve && (reader._closedPromise_resolve(void 0), 
     reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0);
    }
    const AbortSteps = SymbolPolyfill("[[AbortSteps]]"), ErrorSteps = SymbolPolyfill("[[ErrorSteps]]"), CancelSteps = SymbolPolyfill("[[CancelSteps]]"), PullSteps = SymbolPolyfill("[[PullSteps]]"), NumberIsFinite = Number.isFinite || function(x) {
     return "number" == typeof x && isFinite(x);
    }, MathTrunc = Math.trunc || function(v) {
     return v < 0 ? Math.ceil(v) : Math.floor(v);
    };
    function assertDictionary(obj, context) {
     if (void 0 !== obj && "object" != typeof (x = obj) && "function" != typeof x) throw new TypeError(`${context} is not an object.`);
     var x;
    }
    function assertFunction(x, context) {
     if ("function" != typeof x) throw new TypeError(`${context} is not a function.`);
    }
    function assertObject(x, context) {
     if (!function(x) {
      return "object" == typeof x && null !== x || "function" == typeof x;
     }(x)) throw new TypeError(`${context} is not an object.`);
    }
    function assertRequiredArgument(x, position, context) {
     if (void 0 === x) throw new TypeError(`Parameter ${position} is required in '${context}'.`);
    }
    function assertRequiredField(x, field, context) {
     if (void 0 === x) throw new TypeError(`${field} is required in '${context}'.`);
    }
    function convertUnrestrictedDouble(value) {
     return Number(value);
    }
    function censorNegativeZero(x) {
     return 0 === x ? 0 : x;
    }
    function convertUnsignedLongLongWithEnforceRange(value, context) {
     const upperBound = Number.MAX_SAFE_INTEGER;
     let x = Number(value);
     if (x = censorNegativeZero(x), !NumberIsFinite(x)) throw new TypeError(`${context} is not a finite number`);
     if (x = function(x) {
      return censorNegativeZero(MathTrunc(x));
     }(x), x < 0 || x > upperBound) throw new TypeError(`${context} is outside the accepted range of 0 to ${upperBound}, inclusive`);
     return NumberIsFinite(x) && 0 !== x ? x : 0;
    }
    function assertReadableStream(x, context) {
     if (!IsReadableStream(x)) throw new TypeError(`${context} is not a ReadableStream.`);
    }
    function AcquireReadableStreamDefaultReader(stream) {
     return new ReadableStreamDefaultReader(stream);
    }
    function ReadableStreamAddReadRequest(stream, readRequest) {
     stream._reader._readRequests.push(readRequest);
    }
    function ReadableStreamFulfillReadRequest(stream, chunk, done) {
     const readRequest = stream._reader._readRequests.shift();
     done ? readRequest._closeSteps() : readRequest._chunkSteps(chunk);
    }
    function ReadableStreamGetNumReadRequests(stream) {
     return stream._reader._readRequests.length;
    }
    function ReadableStreamHasDefaultReader(stream) {
     const reader = stream._reader;
     return void 0 !== reader && !!IsReadableStreamDefaultReader(reader);
    }
    class ReadableStreamDefaultReader {
     constructor(stream) {
      if (assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader"), assertReadableStream(stream, "First parameter"), 
      IsReadableStreamLocked(stream)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
      ReadableStreamReaderGenericInitialize(this, stream), this._readRequests = new SimpleQueue;
     }
     get closed() {
      return IsReadableStreamDefaultReader(this) ? this._closedPromise : promiseRejectedWith(defaultReaderBrandCheckException("closed"));
     }
     cancel(reason = void 0) {
      return IsReadableStreamDefaultReader(this) ? void 0 === this._ownerReadableStream ? promiseRejectedWith(readerLockException("cancel")) : ReadableStreamReaderGenericCancel(this, reason) : promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
     }
     read() {
      if (!IsReadableStreamDefaultReader(this)) return promiseRejectedWith(defaultReaderBrandCheckException("read"));
      if (void 0 === this._ownerReadableStream) return promiseRejectedWith(readerLockException("read from"));
      let resolvePromise, rejectPromise;
      const promise = newPromise(((resolve, reject) => {
       resolvePromise = resolve, rejectPromise = reject;
      }));
      return ReadableStreamDefaultReaderRead(this, {
       _chunkSteps: chunk => resolvePromise({
        value: chunk,
        done: !1
       }),
       _closeSteps: () => resolvePromise({
        value: void 0,
        done: !0
       }),
       _errorSteps: e => rejectPromise(e)
      }), promise;
     }
     releaseLock() {
      if (!IsReadableStreamDefaultReader(this)) throw defaultReaderBrandCheckException("releaseLock");
      if (void 0 !== this._ownerReadableStream) {
       if (this._readRequests.length > 0) throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
       ReadableStreamReaderGenericRelease(this);
      }
     }
    }
    function IsReadableStreamDefaultReader(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_readRequests") && x instanceof ReadableStreamDefaultReader;
    }
    function ReadableStreamDefaultReaderRead(reader, readRequest) {
     const stream = reader._ownerReadableStream;
     stream._disturbed = !0, "closed" === stream._state ? readRequest._closeSteps() : "errored" === stream._state ? readRequest._errorSteps(stream._storedError) : stream._readableStreamController[PullSteps](readRequest);
    }
    function defaultReaderBrandCheckException(name) {
     return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
    }
    Object.defineProperties(ReadableStreamDefaultReader.prototype, {
     cancel: {
      enumerable: !0
     },
     read: {
      enumerable: !0
     },
     releaseLock: {
      enumerable: !0
     },
     closed: {
      enumerable: !0
     }
    }), "symbol" == typeof SymbolPolyfill.toStringTag && Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
     value: "ReadableStreamDefaultReader",
     configurable: !0
    });
    const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf((async function*() {})).prototype);
    class ReadableStreamAsyncIteratorImpl {
     constructor(reader, preventCancel) {
      this._ongoingPromise = void 0, this._isFinished = !1, this._reader = reader, this._preventCancel = preventCancel;
     }
     next() {
      const nextSteps = () => this._nextSteps();
      return this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps(), 
      this._ongoingPromise;
     }
     return(value) {
      const returnSteps = () => this._returnSteps(value);
      return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
     }
     _nextSteps() {
      if (this._isFinished) return Promise.resolve({
       value: void 0,
       done: !0
      });
      const reader = this._reader;
      if (void 0 === reader._ownerReadableStream) return promiseRejectedWith(readerLockException("iterate"));
      let resolvePromise, rejectPromise;
      const promise = newPromise(((resolve, reject) => {
       resolvePromise = resolve, rejectPromise = reject;
      }));
      return ReadableStreamDefaultReaderRead(reader, {
       _chunkSteps: chunk => {
        this._ongoingPromise = void 0, queueMicrotask((() => resolvePromise({
         value: chunk,
         done: !1
        })));
       },
       _closeSteps: () => {
        this._ongoingPromise = void 0, this._isFinished = !0, ReadableStreamReaderGenericRelease(reader), 
        resolvePromise({
         value: void 0,
         done: !0
        });
       },
       _errorSteps: reason => {
        this._ongoingPromise = void 0, this._isFinished = !0, ReadableStreamReaderGenericRelease(reader), 
        rejectPromise(reason);
       }
      }), promise;
     }
     _returnSteps(value) {
      if (this._isFinished) return Promise.resolve({
       value,
       done: !0
      });
      this._isFinished = !0;
      const reader = this._reader;
      if (void 0 === reader._ownerReadableStream) return promiseRejectedWith(readerLockException("finish iterating"));
      if (!this._preventCancel) {
       const result = ReadableStreamReaderGenericCancel(reader, value);
       return ReadableStreamReaderGenericRelease(reader), transformPromiseWith(result, (() => ({
        value,
        done: !0
       })));
      }
      return ReadableStreamReaderGenericRelease(reader), promiseResolvedWith({
       value,
       done: !0
      });
     }
    }
    const ReadableStreamAsyncIteratorPrototype = {
     next() {
      return IsReadableStreamAsyncIterator(this) ? this._asyncIteratorImpl.next() : promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
     },
     return(value) {
      return IsReadableStreamAsyncIterator(this) ? this._asyncIteratorImpl.return(value) : promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
     }
    };
    function IsReadableStreamAsyncIterator(x) {
     if (!typeIsObject(x)) return !1;
     if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl")) return !1;
     try {
      return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
     } catch (_a) {
      return !1;
     }
    }
    function streamAsyncIteratorBrandCheckException(name) {
     return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
    }
    void 0 !== AsyncIteratorPrototype && Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
    const NumberIsNaN = Number.isNaN || function(x) {
     return x != x;
    };
    function CreateArrayFromList(elements) {
     return elements.slice();
    }
    function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
     new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
    }
    function ArrayBufferSlice(buffer, begin, end) {
     if (buffer.slice) return buffer.slice(begin, end);
     const length = end - begin, slice = new ArrayBuffer(length);
     return CopyDataBlockBytes(slice, 0, buffer, begin, length), slice;
    }
    function CloneAsUint8Array(O) {
     const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
     return new Uint8Array(buffer);
    }
    function DequeueValue(container) {
     const pair = container._queue.shift();
     return container._queueTotalSize -= pair.size, container._queueTotalSize < 0 && (container._queueTotalSize = 0), 
     pair.value;
    }
    function EnqueueValueWithSize(container, value, size) {
     if ("number" != typeof (v = size) || NumberIsNaN(v) || v < 0 || size === 1 / 0) throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
     var v;
     container._queue.push({
      value,
      size
     }), container._queueTotalSize += size;
    }
    function ResetQueue(container) {
     container._queue = new SimpleQueue, container._queueTotalSize = 0;
    }
    class ReadableStreamBYOBRequest {
     constructor() {
      throw new TypeError("Illegal constructor");
     }
     get view() {
      if (!IsReadableStreamBYOBRequest(this)) throw byobRequestBrandCheckException("view");
      return this._view;
     }
     respond(bytesWritten) {
      if (!IsReadableStreamBYOBRequest(this)) throw byobRequestBrandCheckException("respond");
      if (assertRequiredArgument(bytesWritten, 1, "respond"), bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter"), 
      void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
      this._view.buffer, ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
     }
     respondWithNewView(view) {
      if (!IsReadableStreamBYOBRequest(this)) throw byobRequestBrandCheckException("respondWithNewView");
      if (assertRequiredArgument(view, 1, "respondWithNewView"), !ArrayBuffer.isView(view)) throw new TypeError("You can only respond with array buffer views");
      if (void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
      view.buffer, ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
     }
    }
    Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
     respond: {
      enumerable: !0
     },
     respondWithNewView: {
      enumerable: !0
     },
     view: {
      enumerable: !0
     }
    }), "symbol" == typeof SymbolPolyfill.toStringTag && Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
     value: "ReadableStreamBYOBRequest",
     configurable: !0
    });
    class ReadableByteStreamController {
     constructor() {
      throw new TypeError("Illegal constructor");
     }
     get byobRequest() {
      if (!IsReadableByteStreamController(this)) throw byteStreamControllerBrandCheckException("byobRequest");
      return ReadableByteStreamControllerGetBYOBRequest(this);
     }
     get desiredSize() {
      if (!IsReadableByteStreamController(this)) throw byteStreamControllerBrandCheckException("desiredSize");
      return ReadableByteStreamControllerGetDesiredSize(this);
     }
     close() {
      if (!IsReadableByteStreamController(this)) throw byteStreamControllerBrandCheckException("close");
      if (this._closeRequested) throw new TypeError("The stream has already been closed; do not close it again!");
      const state = this._controlledReadableByteStream._state;
      if ("readable" !== state) throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
      ReadableByteStreamControllerClose(this);
     }
     enqueue(chunk) {
      if (!IsReadableByteStreamController(this)) throw byteStreamControllerBrandCheckException("enqueue");
      if (assertRequiredArgument(chunk, 1, "enqueue"), !ArrayBuffer.isView(chunk)) throw new TypeError("chunk must be an array buffer view");
      if (0 === chunk.byteLength) throw new TypeError("chunk must have non-zero byteLength");
      if (0 === chunk.buffer.byteLength) throw new TypeError("chunk's buffer must have non-zero byteLength");
      if (this._closeRequested) throw new TypeError("stream is closed or draining");
      const state = this._controlledReadableByteStream._state;
      if ("readable" !== state) throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
      ReadableByteStreamControllerEnqueue(this, chunk);
     }
     error(e = void 0) {
      if (!IsReadableByteStreamController(this)) throw byteStreamControllerBrandCheckException("error");
      ReadableByteStreamControllerError(this, e);
     }
     [CancelSteps](reason) {
      ReadableByteStreamControllerClearPendingPullIntos(this), ResetQueue(this);
      const result = this._cancelAlgorithm(reason);
      return ReadableByteStreamControllerClearAlgorithms(this), result;
     }
     [PullSteps](readRequest) {
      const stream = this._controlledReadableByteStream;
      if (this._queueTotalSize > 0) {
       const entry = this._queue.shift();
       this._queueTotalSize -= entry.byteLength, ReadableByteStreamControllerHandleQueueDrain(this);
       const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
       return void readRequest._chunkSteps(view);
      }
      const autoAllocateChunkSize = this._autoAllocateChunkSize;
      if (void 0 !== autoAllocateChunkSize) {
       let buffer;
       try {
        buffer = new ArrayBuffer(autoAllocateChunkSize);
       } catch (bufferE) {
        return void readRequest._errorSteps(bufferE);
       }
       const pullIntoDescriptor = {
        buffer,
        bufferByteLength: autoAllocateChunkSize,
        byteOffset: 0,
        byteLength: autoAllocateChunkSize,
        bytesFilled: 0,
        elementSize: 1,
        viewConstructor: Uint8Array,
        readerType: "default"
       };
       this._pendingPullIntos.push(pullIntoDescriptor);
      }
      ReadableStreamAddReadRequest(stream, readRequest), ReadableByteStreamControllerCallPullIfNeeded(this);
     }
    }
    function IsReadableByteStreamController(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream") && x instanceof ReadableByteStreamController;
    }
    function IsReadableStreamBYOBRequest(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController") && x instanceof ReadableStreamBYOBRequest;
    }
    function ReadableByteStreamControllerCallPullIfNeeded(controller) {
     const shouldPull = function(controller) {
      const stream = controller._controlledReadableByteStream;
      if ("readable" !== stream._state) return !1;
      if (controller._closeRequested) return !1;
      if (!controller._started) return !1;
      if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) return !0;
      if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) return !0;
      const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
      return desiredSize > 0;
     }(controller);
     shouldPull && (controller._pulling ? controller._pullAgain = !0 : (controller._pulling = !0, 
     uponPromise(controller._pullAlgorithm(), (() => {
      controller._pulling = !1, controller._pullAgain && (controller._pullAgain = !1, 
      ReadableByteStreamControllerCallPullIfNeeded(controller));
     }), (e => {
      ReadableByteStreamControllerError(controller, e);
     }))));
    }
    function ReadableByteStreamControllerClearPendingPullIntos(controller) {
     ReadableByteStreamControllerInvalidateBYOBRequest(controller), controller._pendingPullIntos = new SimpleQueue;
    }
    function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
     let done = !1;
     "closed" === stream._state && (done = !0);
     const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
     "default" === pullIntoDescriptor.readerType ? ReadableStreamFulfillReadRequest(stream, filledView, done) : function(stream, chunk, done) {
      const reader = stream._reader, readIntoRequest = reader._readIntoRequests.shift();
      done ? readIntoRequest._closeSteps(chunk) : readIntoRequest._chunkSteps(chunk);
     }(stream, filledView, done);
    }
    function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
     const bytesFilled = pullIntoDescriptor.bytesFilled, elementSize = pullIntoDescriptor.elementSize;
     return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
    }
    function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
     controller._queue.push({
      buffer,
      byteOffset,
      byteLength
     }), controller._queueTotalSize += byteLength;
    }
    function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
     const elementSize = pullIntoDescriptor.elementSize, currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize, maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled), maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy, maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
     let totalBytesToCopyRemaining = maxBytesToCopy, ready = !1;
     maxAlignedBytes > currentAlignedBytes && (totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled, 
     ready = !0);
     const queue = controller._queue;
     for (;totalBytesToCopyRemaining > 0; ) {
      const headOfQueue = queue.peek(), bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength), destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
      CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy), 
      headOfQueue.byteLength === bytesToCopy ? queue.shift() : (headOfQueue.byteOffset += bytesToCopy, 
      headOfQueue.byteLength -= bytesToCopy), controller._queueTotalSize -= bytesToCopy, 
      ReadableByteStreamControllerFillHeadPullIntoDescriptor(0, bytesToCopy, pullIntoDescriptor), 
      totalBytesToCopyRemaining -= bytesToCopy;
     }
     return ready;
    }
    function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
     pullIntoDescriptor.bytesFilled += size;
    }
    function ReadableByteStreamControllerHandleQueueDrain(controller) {
     0 === controller._queueTotalSize && controller._closeRequested ? (ReadableByteStreamControllerClearAlgorithms(controller), 
     ReadableStreamClose(controller._controlledReadableByteStream)) : ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
     null !== controller._byobRequest && (controller._byobRequest._associatedReadableByteStreamController = void 0, 
     controller._byobRequest._view = null, controller._byobRequest = null);
    }
    function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
     for (;controller._pendingPullIntos.length > 0; ) {
      if (0 === controller._queueTotalSize) return;
      const pullIntoDescriptor = controller._pendingPullIntos.peek();
      ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) && (ReadableByteStreamControllerShiftPendingPullInto(controller), 
      ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor));
     }
    }
    function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
     const firstDescriptor = controller._pendingPullIntos.peek();
     ReadableByteStreamControllerInvalidateBYOBRequest(controller), "closed" === controller._controlledReadableByteStream._state ? function(controller, firstDescriptor) {
      const stream = controller._controlledReadableByteStream;
      if (ReadableStreamHasBYOBReader(stream)) for (;ReadableStreamGetNumReadIntoRequests(stream) > 0; ) ReadableByteStreamControllerCommitPullIntoDescriptor(stream, ReadableByteStreamControllerShiftPendingPullInto(controller));
     }(controller) : function(controller, bytesWritten, pullIntoDescriptor) {
      if (ReadableByteStreamControllerFillHeadPullIntoDescriptor(0, bytesWritten, pullIntoDescriptor), 
      pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) return;
      ReadableByteStreamControllerShiftPendingPullInto(controller);
      const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
      if (remainderSize > 0) {
       const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled, remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
       ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
      }
      pullIntoDescriptor.bytesFilled -= remainderSize, ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor), 
      ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
     }(controller, bytesWritten, firstDescriptor), ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerShiftPendingPullInto(controller) {
     return controller._pendingPullIntos.shift();
    }
    function ReadableByteStreamControllerClearAlgorithms(controller) {
     controller._pullAlgorithm = void 0, controller._cancelAlgorithm = void 0;
    }
    function ReadableByteStreamControllerClose(controller) {
     const stream = controller._controlledReadableByteStream;
     if (!controller._closeRequested && "readable" === stream._state) if (controller._queueTotalSize > 0) controller._closeRequested = !0; else {
      if (controller._pendingPullIntos.length > 0 && controller._pendingPullIntos.peek().bytesFilled > 0) {
       const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
       throw ReadableByteStreamControllerError(controller, e), e;
      }
      ReadableByteStreamControllerClearAlgorithms(controller), ReadableStreamClose(stream);
     }
    }
    function ReadableByteStreamControllerEnqueue(controller, chunk) {
     const stream = controller._controlledReadableByteStream;
     if (controller._closeRequested || "readable" !== stream._state) return;
     const buffer = chunk.buffer, byteOffset = chunk.byteOffset, byteLength = chunk.byteLength, transferredBuffer = buffer;
     if (controller._pendingPullIntos.length > 0) {
      const firstPendingPullInto = controller._pendingPullIntos.peek();
      firstPendingPullInto.buffer, firstPendingPullInto.buffer = firstPendingPullInto.buffer;
     }
     ReadableByteStreamControllerInvalidateBYOBRequest(controller), ReadableStreamHasDefaultReader(stream) ? 0 === ReadableStreamGetNumReadRequests(stream) ? ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength) : (controller._pendingPullIntos.length > 0 && ReadableByteStreamControllerShiftPendingPullInto(controller), 
     ReadableStreamFulfillReadRequest(stream, new Uint8Array(transferredBuffer, byteOffset, byteLength), !1)) : ReadableStreamHasBYOBReader(stream) ? (ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength), 
     ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller)) : ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength), 
     ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerError(controller, e) {
     const stream = controller._controlledReadableByteStream;
     "readable" === stream._state && (ReadableByteStreamControllerClearPendingPullIntos(controller), 
     ResetQueue(controller), ReadableByteStreamControllerClearAlgorithms(controller), 
     ReadableStreamError(stream, e));
    }
    function ReadableByteStreamControllerGetBYOBRequest(controller) {
     if (null === controller._byobRequest && controller._pendingPullIntos.length > 0) {
      const firstDescriptor = controller._pendingPullIntos.peek(), view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled), byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
      !function(request, controller, view) {
       request._associatedReadableByteStreamController = controller, request._view = view;
      }(byobRequest, controller, view), controller._byobRequest = byobRequest;
     }
     return controller._byobRequest;
    }
    function ReadableByteStreamControllerGetDesiredSize(controller) {
     const state = controller._controlledReadableByteStream._state;
     return "errored" === state ? null : "closed" === state ? 0 : controller._strategyHWM - controller._queueTotalSize;
    }
    function ReadableByteStreamControllerRespond(controller, bytesWritten) {
     const firstDescriptor = controller._pendingPullIntos.peek();
     if ("closed" === controller._controlledReadableByteStream._state) {
      if (0 !== bytesWritten) throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
     } else {
      if (0 === bytesWritten) throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
      if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) throw new RangeError("bytesWritten out of range");
     }
     firstDescriptor.buffer = firstDescriptor.buffer, ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
    }
    function ReadableByteStreamControllerRespondWithNewView(controller, view) {
     const firstDescriptor = controller._pendingPullIntos.peek();
     if ("closed" === controller._controlledReadableByteStream._state) {
      if (0 !== view.byteLength) throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
     } else if (0 === view.byteLength) throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
     if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) throw new RangeError("The region specified by view does not match byobRequest");
     if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) throw new RangeError("The buffer of view has different capacity than byobRequest");
     if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) throw new RangeError("The region specified by view is larger than byobRequest");
     const viewByteLength = view.byteLength;
     firstDescriptor.buffer = view.buffer, ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
    }
    function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
     controller._controlledReadableByteStream = stream, controller._pullAgain = !1, controller._pulling = !1, 
     controller._byobRequest = null, controller._queue = controller._queueTotalSize = void 0, 
     ResetQueue(controller), controller._closeRequested = !1, controller._started = !1, 
     controller._strategyHWM = highWaterMark, controller._pullAlgorithm = pullAlgorithm, 
     controller._cancelAlgorithm = cancelAlgorithm, controller._autoAllocateChunkSize = autoAllocateChunkSize, 
     controller._pendingPullIntos = new SimpleQueue, stream._readableStreamController = controller, 
     uponPromise(promiseResolvedWith(startAlgorithm()), (() => {
      controller._started = !0, ReadableByteStreamControllerCallPullIfNeeded(controller);
     }), (r => {
      ReadableByteStreamControllerError(controller, r);
     }));
    }
    function byobRequestBrandCheckException(name) {
     return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
    }
    function byteStreamControllerBrandCheckException(name) {
     return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
    }
    function AcquireReadableStreamBYOBReader(stream) {
     return new ReadableStreamBYOBReader(stream);
    }
    function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
     stream._reader._readIntoRequests.push(readIntoRequest);
    }
    function ReadableStreamGetNumReadIntoRequests(stream) {
     return stream._reader._readIntoRequests.length;
    }
    function ReadableStreamHasBYOBReader(stream) {
     const reader = stream._reader;
     return void 0 !== reader && !!IsReadableStreamBYOBReader(reader);
    }
    Object.defineProperties(ReadableByteStreamController.prototype, {
     close: {
      enumerable: !0
     },
     enqueue: {
      enumerable: !0
     },
     error: {
      enumerable: !0
     },
     byobRequest: {
      enumerable: !0
     },
     desiredSize: {
      enumerable: !0
     }
    }), "symbol" == typeof SymbolPolyfill.toStringTag && Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
     value: "ReadableByteStreamController",
     configurable: !0
    });
    class ReadableStreamBYOBReader {
     constructor(stream) {
      if (assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader"), assertReadableStream(stream, "First parameter"), 
      IsReadableStreamLocked(stream)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
      if (!IsReadableByteStreamController(stream._readableStreamController)) throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
      ReadableStreamReaderGenericInitialize(this, stream), this._readIntoRequests = new SimpleQueue;
     }
     get closed() {
      return IsReadableStreamBYOBReader(this) ? this._closedPromise : promiseRejectedWith(byobReaderBrandCheckException("closed"));
     }
     cancel(reason = void 0) {
      return IsReadableStreamBYOBReader(this) ? void 0 === this._ownerReadableStream ? promiseRejectedWith(readerLockException("cancel")) : ReadableStreamReaderGenericCancel(this, reason) : promiseRejectedWith(byobReaderBrandCheckException("cancel"));
     }
     read(view) {
      if (!IsReadableStreamBYOBReader(this)) return promiseRejectedWith(byobReaderBrandCheckException("read"));
      if (!ArrayBuffer.isView(view)) return promiseRejectedWith(new TypeError("view must be an array buffer view"));
      if (0 === view.byteLength) return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
      if (0 === view.buffer.byteLength) return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));
      if (view.buffer, void 0 === this._ownerReadableStream) return promiseRejectedWith(readerLockException("read from"));
      let resolvePromise, rejectPromise;
      const promise = newPromise(((resolve, reject) => {
       resolvePromise = resolve, rejectPromise = reject;
      }));
      return ReadableStreamBYOBReaderRead(this, view, {
       _chunkSteps: chunk => resolvePromise({
        value: chunk,
        done: !1
       }),
       _closeSteps: chunk => resolvePromise({
        value: chunk,
        done: !0
       }),
       _errorSteps: e => rejectPromise(e)
      }), promise;
     }
     releaseLock() {
      if (!IsReadableStreamBYOBReader(this)) throw byobReaderBrandCheckException("releaseLock");
      if (void 0 !== this._ownerReadableStream) {
       if (this._readIntoRequests.length > 0) throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
       ReadableStreamReaderGenericRelease(this);
      }
     }
    }
    function IsReadableStreamBYOBReader(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests") && x instanceof ReadableStreamBYOBReader;
    }
    function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
     const stream = reader._ownerReadableStream;
     stream._disturbed = !0, "errored" === stream._state ? readIntoRequest._errorSteps(stream._storedError) : function(controller, view, readIntoRequest) {
      const stream = controller._controlledReadableByteStream;
      let elementSize = 1;
      view.constructor !== DataView && (elementSize = view.constructor.BYTES_PER_ELEMENT);
      const ctor = view.constructor, buffer = view.buffer, pullIntoDescriptor = {
       buffer,
       bufferByteLength: buffer.byteLength,
       byteOffset: view.byteOffset,
       byteLength: view.byteLength,
       bytesFilled: 0,
       elementSize,
       viewConstructor: ctor,
       readerType: "byob"
      };
      if (controller._pendingPullIntos.length > 0) return controller._pendingPullIntos.push(pullIntoDescriptor), 
      void ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
      if ("closed" !== stream._state) {
       if (controller._queueTotalSize > 0) {
        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
         const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
         return ReadableByteStreamControllerHandleQueueDrain(controller), void readIntoRequest._chunkSteps(filledView);
        }
        if (controller._closeRequested) {
         const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
         return ReadableByteStreamControllerError(controller, e), void readIntoRequest._errorSteps(e);
        }
       }
       controller._pendingPullIntos.push(pullIntoDescriptor), ReadableStreamAddReadIntoRequest(stream, readIntoRequest), 
       ReadableByteStreamControllerCallPullIfNeeded(controller);
      } else {
       const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
       readIntoRequest._closeSteps(emptyView);
      }
     }(stream._readableStreamController, view, readIntoRequest);
    }
    function byobReaderBrandCheckException(name) {
     return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
    }
    function ExtractHighWaterMark(strategy, defaultHWM) {
     const {highWaterMark} = strategy;
     if (void 0 === highWaterMark) return defaultHWM;
     if (NumberIsNaN(highWaterMark) || highWaterMark < 0) throw new RangeError("Invalid highWaterMark");
     return highWaterMark;
    }
    function ExtractSizeAlgorithm(strategy) {
     const {size} = strategy;
     return size || (() => 1);
    }
    function convertQueuingStrategy(init, context) {
     assertDictionary(init, context);
     const highWaterMark = null == init ? void 0 : init.highWaterMark, size = null == init ? void 0 : init.size;
     return {
      highWaterMark: void 0 === highWaterMark ? void 0 : convertUnrestrictedDouble(highWaterMark),
      size: void 0 === size ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
     };
    }
    function convertQueuingStrategySize(fn, context) {
     return assertFunction(fn, context), chunk => convertUnrestrictedDouble(fn(chunk));
    }
    function convertUnderlyingSinkAbortCallback(fn, original, context) {
     return assertFunction(fn, context), reason => promiseCall(fn, original, [ reason ]);
    }
    function convertUnderlyingSinkCloseCallback(fn, original, context) {
     return assertFunction(fn, context), () => promiseCall(fn, original, []);
    }
    function convertUnderlyingSinkStartCallback(fn, original, context) {
     return assertFunction(fn, context), controller => reflectCall(fn, original, [ controller ]);
    }
    function convertUnderlyingSinkWriteCallback(fn, original, context) {
     return assertFunction(fn, context), (chunk, controller) => promiseCall(fn, original, [ chunk, controller ]);
    }
    function assertWritableStream(x, context) {
     if (!IsWritableStream(x)) throw new TypeError(`${context} is not a WritableStream.`);
    }
    Object.defineProperties(ReadableStreamBYOBReader.prototype, {
     cancel: {
      enumerable: !0
     },
     read: {
      enumerable: !0
     },
     releaseLock: {
      enumerable: !0
     },
     closed: {
      enumerable: !0
     }
    }), "symbol" == typeof SymbolPolyfill.toStringTag && Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
     value: "ReadableStreamBYOBReader",
     configurable: !0
    });
    const supportsAbortController = "function" == typeof AbortController;
    class WritableStream {
     constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
      void 0 === rawUnderlyingSink ? rawUnderlyingSink = null : assertObject(rawUnderlyingSink, "First parameter");
      const strategy = convertQueuingStrategy(rawStrategy, "Second parameter"), underlyingSink = function(original, context) {
       assertDictionary(original, context);
       const abort = null == original ? void 0 : original.abort, close = null == original ? void 0 : original.close, start = null == original ? void 0 : original.start, type = null == original ? void 0 : original.type, write = null == original ? void 0 : original.write;
       return {
        abort: void 0 === abort ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
        close: void 0 === close ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
        start: void 0 === start ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
        write: void 0 === write ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
        type
       };
      }(rawUnderlyingSink, "First parameter");
      if (InitializeWritableStream(this), void 0 !== underlyingSink.type) throw new RangeError("Invalid type is specified");
      const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
      !function(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
       const controller = Object.create(WritableStreamDefaultController.prototype);
       let startAlgorithm = () => {}, writeAlgorithm = () => promiseResolvedWith(void 0), closeAlgorithm = () => promiseResolvedWith(void 0), abortAlgorithm = () => promiseResolvedWith(void 0);
       void 0 !== underlyingSink.start && (startAlgorithm = () => underlyingSink.start(controller)), 
       void 0 !== underlyingSink.write && (writeAlgorithm = chunk => underlyingSink.write(chunk, controller)), 
       void 0 !== underlyingSink.close && (closeAlgorithm = () => underlyingSink.close()), 
       void 0 !== underlyingSink.abort && (abortAlgorithm = reason => underlyingSink.abort(reason)), 
       SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      }(this, underlyingSink, ExtractHighWaterMark(strategy, 1), sizeAlgorithm);
     }
     get locked() {
      if (!IsWritableStream(this)) throw streamBrandCheckException$2("locked");
      return IsWritableStreamLocked(this);
     }
     abort(reason = void 0) {
      return IsWritableStream(this) ? IsWritableStreamLocked(this) ? promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer")) : WritableStreamAbort(this, reason) : promiseRejectedWith(streamBrandCheckException$2("abort"));
     }
     close() {
      return IsWritableStream(this) ? IsWritableStreamLocked(this) ? promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer")) : WritableStreamCloseQueuedOrInFlight(this) ? promiseRejectedWith(new TypeError("Cannot close an already-closing stream")) : WritableStreamClose(this) : promiseRejectedWith(streamBrandCheckException$2("close"));
     }
     getWriter() {
      if (!IsWritableStream(this)) throw streamBrandCheckException$2("getWriter");
      return AcquireWritableStreamDefaultWriter(this);
     }
    }
    function AcquireWritableStreamDefaultWriter(stream) {
     return new WritableStreamDefaultWriter(stream);
    }
    function InitializeWritableStream(stream) {
     stream._state = "writable", stream._storedError = void 0, stream._writer = void 0, 
     stream._writableStreamController = void 0, stream._writeRequests = new SimpleQueue, 
     stream._inFlightWriteRequest = void 0, stream._closeRequest = void 0, stream._inFlightCloseRequest = void 0, 
     stream._pendingAbortRequest = void 0, stream._backpressure = !1;
    }
    function IsWritableStream(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_writableStreamController") && x instanceof WritableStream;
    }
    function IsWritableStreamLocked(stream) {
     return void 0 !== stream._writer;
    }
    function WritableStreamAbort(stream, reason) {
     var _a;
     if ("closed" === stream._state || "errored" === stream._state) return promiseResolvedWith(void 0);
     stream._writableStreamController._abortReason = reason, null === (_a = stream._writableStreamController._abortController) || void 0 === _a || _a.abort();
     const state = stream._state;
     if ("closed" === state || "errored" === state) return promiseResolvedWith(void 0);
     if (void 0 !== stream._pendingAbortRequest) return stream._pendingAbortRequest._promise;
     let wasAlreadyErroring = !1;
     "erroring" === state && (wasAlreadyErroring = !0, reason = void 0);
     const promise = newPromise(((resolve, reject) => {
      stream._pendingAbortRequest = {
       _promise: void 0,
       _resolve: resolve,
       _reject: reject,
       _reason: reason,
       _wasAlreadyErroring: wasAlreadyErroring
      };
     }));
     return stream._pendingAbortRequest._promise = promise, wasAlreadyErroring || WritableStreamStartErroring(stream, reason), 
     promise;
    }
    function WritableStreamClose(stream) {
     const state = stream._state;
     if ("closed" === state || "errored" === state) return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
     const promise = newPromise(((resolve, reject) => {
      const closeRequest = {
       _resolve: resolve,
       _reject: reject
      };
      stream._closeRequest = closeRequest;
     })), writer = stream._writer;
     var controller;
     return void 0 !== writer && stream._backpressure && "writable" === state && defaultWriterReadyPromiseResolve(writer), 
     EnqueueValueWithSize(controller = stream._writableStreamController, closeSentinel, 0), 
     WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller), promise;
    }
    function WritableStreamDealWithRejection(stream, error) {
     "writable" !== stream._state ? WritableStreamFinishErroring(stream) : WritableStreamStartErroring(stream, error);
    }
    function WritableStreamStartErroring(stream, reason) {
     const controller = stream._writableStreamController;
     stream._state = "erroring", stream._storedError = reason;
     const writer = stream._writer;
     void 0 !== writer && WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason), 
     !function(stream) {
      return void 0 !== stream._inFlightWriteRequest || void 0 !== stream._inFlightCloseRequest;
     }(stream) && controller._started && WritableStreamFinishErroring(stream);
    }
    function WritableStreamFinishErroring(stream) {
     stream._state = "errored", stream._writableStreamController[ErrorSteps]();
     const storedError = stream._storedError;
     if (stream._writeRequests.forEach((writeRequest => {
      writeRequest._reject(storedError);
     })), stream._writeRequests = new SimpleQueue, void 0 === stream._pendingAbortRequest) return void WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
     const abortRequest = stream._pendingAbortRequest;
     if (stream._pendingAbortRequest = void 0, abortRequest._wasAlreadyErroring) return abortRequest._reject(storedError), 
     void WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
     uponPromise(stream._writableStreamController[AbortSteps](abortRequest._reason), (() => {
      abortRequest._resolve(), WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
     }), (reason => {
      abortRequest._reject(reason), WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
     }));
    }
    function WritableStreamCloseQueuedOrInFlight(stream) {
     return void 0 !== stream._closeRequest || void 0 !== stream._inFlightCloseRequest;
    }
    function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
     void 0 !== stream._closeRequest && (stream._closeRequest._reject(stream._storedError), 
     stream._closeRequest = void 0);
     const writer = stream._writer;
     void 0 !== writer && defaultWriterClosedPromiseReject(writer, stream._storedError);
    }
    function WritableStreamUpdateBackpressure(stream, backpressure) {
     const writer = stream._writer;
     void 0 !== writer && backpressure !== stream._backpressure && (backpressure ? function(writer) {
      defaultWriterReadyPromiseInitialize(writer);
     }(writer) : defaultWriterReadyPromiseResolve(writer)), stream._backpressure = backpressure;
    }
    Object.defineProperties(WritableStream.prototype, {
     abort: {
      enumerable: !0
     },
     close: {
      enumerable: !0
     },
     getWriter: {
      enumerable: !0
     },
     locked: {
      enumerable: !0
     }
    }), "symbol" == typeof SymbolPolyfill.toStringTag && Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
     value: "WritableStream",
     configurable: !0
    });
    class WritableStreamDefaultWriter {
     constructor(stream) {
      if (assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter"), assertWritableStream(stream, "First parameter"), 
      IsWritableStreamLocked(stream)) throw new TypeError("This stream has already been locked for exclusive writing by another writer");
      this._ownerWritableStream = stream, stream._writer = this;
      const state = stream._state;
      if ("writable" === state) !WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure ? defaultWriterReadyPromiseInitialize(this) : defaultWriterReadyPromiseInitializeAsResolved(this), 
      defaultWriterClosedPromiseInitialize(this); else if ("erroring" === state) defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError), 
      defaultWriterClosedPromiseInitialize(this); else if ("closed" === state) defaultWriterReadyPromiseInitializeAsResolved(this), 
      defaultWriterClosedPromiseInitialize(writer = this), defaultWriterClosedPromiseResolve(writer); else {
       const storedError = stream._storedError;
       defaultWriterReadyPromiseInitializeAsRejected(this, storedError), defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
      }
      var writer;
     }
     get closed() {
      return IsWritableStreamDefaultWriter(this) ? this._closedPromise : promiseRejectedWith(defaultWriterBrandCheckException("closed"));
     }
     get desiredSize() {
      if (!IsWritableStreamDefaultWriter(this)) throw defaultWriterBrandCheckException("desiredSize");
      if (void 0 === this._ownerWritableStream) throw defaultWriterLockException("desiredSize");
      return function(writer) {
       const stream = writer._ownerWritableStream, state = stream._state;
       return "errored" === state || "erroring" === state ? null : "closed" === state ? 0 : WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
      }(this);
     }
     get ready() {
      return IsWritableStreamDefaultWriter(this) ? this._readyPromise : promiseRejectedWith(defaultWriterBrandCheckException("ready"));
     }
     abort(reason = void 0) {
      return IsWritableStreamDefaultWriter(this) ? void 0 === this._ownerWritableStream ? promiseRejectedWith(defaultWriterLockException("abort")) : function(writer, reason) {
       return WritableStreamAbort(writer._ownerWritableStream, reason);
      }(this, reason) : promiseRejectedWith(defaultWriterBrandCheckException("abort"));
     }
     close() {
      if (!IsWritableStreamDefaultWriter(this)) return promiseRejectedWith(defaultWriterBrandCheckException("close"));
      const stream = this._ownerWritableStream;
      return void 0 === stream ? promiseRejectedWith(defaultWriterLockException("close")) : WritableStreamCloseQueuedOrInFlight(stream) ? promiseRejectedWith(new TypeError("Cannot close an already-closing stream")) : WritableStreamDefaultWriterClose(this);
     }
     releaseLock() {
      if (!IsWritableStreamDefaultWriter(this)) throw defaultWriterBrandCheckException("releaseLock");
      void 0 !== this._ownerWritableStream && WritableStreamDefaultWriterRelease(this);
     }
     write(chunk = void 0) {
      return IsWritableStreamDefaultWriter(this) ? void 0 === this._ownerWritableStream ? promiseRejectedWith(defaultWriterLockException("write to")) : WritableStreamDefaultWriterWrite(this, chunk) : promiseRejectedWith(defaultWriterBrandCheckException("write"));
     }
    }
    function IsWritableStreamDefaultWriter(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream") && x instanceof WritableStreamDefaultWriter;
    }
    function WritableStreamDefaultWriterClose(writer) {
     return WritableStreamClose(writer._ownerWritableStream);
    }
    function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
     "pending" === writer._closedPromiseState ? defaultWriterClosedPromiseReject(writer, error) : function(writer, reason) {
      defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
     }(writer, error);
    }
    function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
     "pending" === writer._readyPromiseState ? defaultWriterReadyPromiseReject(writer, error) : function(writer, reason) {
      defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
     }(writer, error);
    }
    function WritableStreamDefaultWriterRelease(writer) {
     const stream = writer._ownerWritableStream, releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
     WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError), WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError), 
     stream._writer = void 0, writer._ownerWritableStream = void 0;
    }
    function WritableStreamDefaultWriterWrite(writer, chunk) {
     const stream = writer._ownerWritableStream, controller = stream._writableStreamController, chunkSize = function(controller, chunk) {
      try {
       return controller._strategySizeAlgorithm(chunk);
      } catch (chunkSizeE) {
       return WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE), 1;
      }
     }(controller, chunk);
     if (stream !== writer._ownerWritableStream) return promiseRejectedWith(defaultWriterLockException("write to"));
     const state = stream._state;
     if ("errored" === state) return promiseRejectedWith(stream._storedError);
     if (WritableStreamCloseQueuedOrInFlight(stream) || "closed" === state) return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
     if ("erroring" === state) return promiseRejectedWith(stream._storedError);
     const promise = function(stream) {
      return newPromise(((resolve, reject) => {
       const writeRequest = {
        _resolve: resolve,
        _reject: reject
       };
       stream._writeRequests.push(writeRequest);
      }));
     }(stream);
     return function(controller, chunk, chunkSize) {
      try {
       EnqueueValueWithSize(controller, chunk, chunkSize);
      } catch (enqueueE) {
       return void WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
      }
      const stream = controller._controlledWritableStream;
      WritableStreamCloseQueuedOrInFlight(stream) || "writable" !== stream._state || WritableStreamUpdateBackpressure(stream, WritableStreamDefaultControllerGetBackpressure(controller)), 
      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
     }(controller, chunk, chunkSize), promise;
    }
    Object.defineProperties(WritableStreamDefaultWriter.prototype, {
     abort: {
      enumerable: !0
     },
     close: {
      enumerable: !0
     },
     releaseLock: {
      enumerable: !0
     },
     write: {
      enumerable: !0
     },
     closed: {
      enumerable: !0
     },
     desiredSize: {
      enumerable: !0
     },
     ready: {
      enumerable: !0
     }
    }), "symbol" == typeof SymbolPolyfill.toStringTag && Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
     value: "WritableStreamDefaultWriter",
     configurable: !0
    });
    const closeSentinel = {};
    class WritableStreamDefaultController {
     constructor() {
      throw new TypeError("Illegal constructor");
     }
     get abortReason() {
      if (!IsWritableStreamDefaultController(this)) throw defaultControllerBrandCheckException$2("abortReason");
      return this._abortReason;
     }
     get signal() {
      if (!IsWritableStreamDefaultController(this)) throw defaultControllerBrandCheckException$2("signal");
      if (void 0 === this._abortController) throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
      return this._abortController.signal;
     }
     error(e = void 0) {
      if (!IsWritableStreamDefaultController(this)) throw defaultControllerBrandCheckException$2("error");
      "writable" === this._controlledWritableStream._state && WritableStreamDefaultControllerError(this, e);
     }
     [AbortSteps](reason) {
      const result = this._abortAlgorithm(reason);
      return WritableStreamDefaultControllerClearAlgorithms(this), result;
     }
     [ErrorSteps]() {
      ResetQueue(this);
     }
    }
    function IsWritableStreamDefaultController(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream") && x instanceof WritableStreamDefaultController;
    }
    function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
     controller._controlledWritableStream = stream, stream._writableStreamController = controller, 
     controller._queue = void 0, controller._queueTotalSize = void 0, ResetQueue(controller), 
     controller._abortReason = void 0, controller._abortController = function() {
      if (supportsAbortController) return new AbortController;
     }(), controller._started = !1, controller._strategySizeAlgorithm = sizeAlgorithm, 
     controller._strategyHWM = highWaterMark, controller._writeAlgorithm = writeAlgorithm, 
     controller._closeAlgorithm = closeAlgorithm, controller._abortAlgorithm = abortAlgorithm;
     const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
     WritableStreamUpdateBackpressure(stream, backpressure), uponPromise(promiseResolvedWith(startAlgorithm()), (() => {
      controller._started = !0, WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
     }), (r => {
      controller._started = !0, WritableStreamDealWithRejection(stream, r);
     }));
    }
    function WritableStreamDefaultControllerClearAlgorithms(controller) {
     controller._writeAlgorithm = void 0, controller._closeAlgorithm = void 0, controller._abortAlgorithm = void 0, 
     controller._strategySizeAlgorithm = void 0;
    }
    function WritableStreamDefaultControllerGetDesiredSize(controller) {
     return controller._strategyHWM - controller._queueTotalSize;
    }
    function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
     const stream = controller._controlledWritableStream;
     if (!controller._started) return;
     if (void 0 !== stream._inFlightWriteRequest) return;
     if ("erroring" === stream._state) return void WritableStreamFinishErroring(stream);
     if (0 === controller._queue.length) return;
     const value = controller._queue.peek().value;
     value === closeSentinel ? function(controller) {
      const stream = controller._controlledWritableStream;
      (function(stream) {
       stream._inFlightCloseRequest = stream._closeRequest, stream._closeRequest = void 0;
      })(stream), DequeueValue(controller);
      const sinkClosePromise = controller._closeAlgorithm();
      WritableStreamDefaultControllerClearAlgorithms(controller), uponPromise(sinkClosePromise, (() => {
       !function(stream) {
        stream._inFlightCloseRequest._resolve(void 0), stream._inFlightCloseRequest = void 0, 
        "erroring" === stream._state && (stream._storedError = void 0, void 0 !== stream._pendingAbortRequest && (stream._pendingAbortRequest._resolve(), 
        stream._pendingAbortRequest = void 0)), stream._state = "closed";
        const writer = stream._writer;
        void 0 !== writer && defaultWriterClosedPromiseResolve(writer);
       }(stream);
      }), (reason => {
       !function(stream, error) {
        stream._inFlightCloseRequest._reject(error), stream._inFlightCloseRequest = void 0, 
        void 0 !== stream._pendingAbortRequest && (stream._pendingAbortRequest._reject(error), 
        stream._pendingAbortRequest = void 0), WritableStreamDealWithRejection(stream, error);
       }(stream, reason);
      }));
     }(controller) : function(controller, chunk) {
      const stream = controller._controlledWritableStream;
      !function(stream) {
       stream._inFlightWriteRequest = stream._writeRequests.shift();
      }(stream);
      const sinkWritePromise = controller._writeAlgorithm(chunk);
      uponPromise(sinkWritePromise, (() => {
       !function(stream) {
        stream._inFlightWriteRequest._resolve(void 0), stream._inFlightWriteRequest = void 0;
       }(stream);
       const state = stream._state;
       if (DequeueValue(controller), !WritableStreamCloseQueuedOrInFlight(stream) && "writable" === state) {
        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
       }
       WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }), (reason => {
       "writable" === stream._state && WritableStreamDefaultControllerClearAlgorithms(controller), 
       function(stream, error) {
        stream._inFlightWriteRequest._reject(error), stream._inFlightWriteRequest = void 0, 
        WritableStreamDealWithRejection(stream, error);
       }(stream, reason);
      }));
     }(controller, value);
    }
    function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
     "writable" === controller._controlledWritableStream._state && WritableStreamDefaultControllerError(controller, error);
    }
    function WritableStreamDefaultControllerGetBackpressure(controller) {
     return WritableStreamDefaultControllerGetDesiredSize(controller) <= 0;
    }
    function WritableStreamDefaultControllerError(controller, error) {
     const stream = controller._controlledWritableStream;
     WritableStreamDefaultControllerClearAlgorithms(controller), WritableStreamStartErroring(stream, error);
    }
    function streamBrandCheckException$2(name) {
     return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
    }
    function defaultControllerBrandCheckException$2(name) {
     return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
    }
    function defaultWriterBrandCheckException(name) {
     return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
    }
    function defaultWriterLockException(name) {
     return new TypeError("Cannot " + name + " a stream using a released writer");
    }
    function defaultWriterClosedPromiseInitialize(writer) {
     writer._closedPromise = newPromise(((resolve, reject) => {
      writer._closedPromise_resolve = resolve, writer._closedPromise_reject = reject, 
      writer._closedPromiseState = "pending";
     }));
    }
    function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
     defaultWriterClosedPromiseInitialize(writer), defaultWriterClosedPromiseReject(writer, reason);
    }
    function defaultWriterClosedPromiseReject(writer, reason) {
     void 0 !== writer._closedPromise_reject && (setPromiseIsHandledToTrue(writer._closedPromise), 
     writer._closedPromise_reject(reason), writer._closedPromise_resolve = void 0, writer._closedPromise_reject = void 0, 
     writer._closedPromiseState = "rejected");
    }
    function defaultWriterClosedPromiseResolve(writer) {
     void 0 !== writer._closedPromise_resolve && (writer._closedPromise_resolve(void 0), 
     writer._closedPromise_resolve = void 0, writer._closedPromise_reject = void 0, writer._closedPromiseState = "resolved");
    }
    function defaultWriterReadyPromiseInitialize(writer) {
     writer._readyPromise = newPromise(((resolve, reject) => {
      writer._readyPromise_resolve = resolve, writer._readyPromise_reject = reject;
     })), writer._readyPromiseState = "pending";
    }
    function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
     defaultWriterReadyPromiseInitialize(writer), defaultWriterReadyPromiseReject(writer, reason);
    }
    function defaultWriterReadyPromiseInitializeAsResolved(writer) {
     defaultWriterReadyPromiseInitialize(writer), defaultWriterReadyPromiseResolve(writer);
    }
    function defaultWriterReadyPromiseReject(writer, reason) {
     void 0 !== writer._readyPromise_reject && (setPromiseIsHandledToTrue(writer._readyPromise), 
     writer._readyPromise_reject(reason), writer._readyPromise_resolve = void 0, writer._readyPromise_reject = void 0, 
     writer._readyPromiseState = "rejected");
    }
    function defaultWriterReadyPromiseResolve(writer) {
     void 0 !== writer._readyPromise_resolve && (writer._readyPromise_resolve(void 0), 
     writer._readyPromise_resolve = void 0, writer._readyPromise_reject = void 0, writer._readyPromiseState = "fulfilled");
    }
    Object.defineProperties(WritableStreamDefaultController.prototype, {
     abortReason: {
      enumerable: !0
     },
     signal: {
      enumerable: !0
     },
     error: {
      enumerable: !0
     }
    }), "symbol" == typeof SymbolPolyfill.toStringTag && Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
     value: "WritableStreamDefaultController",
     configurable: !0
    });
    const NativeDOMException = "undefined" != typeof DOMException ? DOMException : void 0, DOMException$1 = function(ctor) {
     if ("function" != typeof ctor && "object" != typeof ctor) return !1;
     try {
      return new ctor, !0;
     } catch (_a) {
      return !1;
     }
    }(NativeDOMException) ? NativeDOMException : function() {
     const ctor = function(message, name) {
      this.message = message || "", this.name = name || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
     };
     return ctor.prototype = Object.create(Error.prototype), Object.defineProperty(ctor.prototype, "constructor", {
      value: ctor,
      writable: !0,
      configurable: !0
     }), ctor;
    }();
    function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
     const reader = AcquireReadableStreamDefaultReader(source), writer = AcquireWritableStreamDefaultWriter(dest);
     source._disturbed = !0;
     let shuttingDown = !1, currentWrite = promiseResolvedWith(void 0);
     return newPromise(((resolve, reject) => {
      let abortAlgorithm;
      if (void 0 !== signal) {
       if (abortAlgorithm = () => {
        const error = new DOMException$1("Aborted", "AbortError"), actions = [];
        preventAbort || actions.push((() => "writable" === dest._state ? WritableStreamAbort(dest, error) : promiseResolvedWith(void 0))), 
        preventCancel || actions.push((() => "readable" === source._state ? ReadableStreamCancel(source, error) : promiseResolvedWith(void 0))), 
        shutdownWithAction((() => Promise.all(actions.map((action => action())))), !0, error);
       }, signal.aborted) return void abortAlgorithm();
       signal.addEventListener("abort", abortAlgorithm);
      }
      var stream, promise, action;
      if (isOrBecomesErrored(source, reader._closedPromise, (storedError => {
       preventAbort ? shutdown(!0, storedError) : shutdownWithAction((() => WritableStreamAbort(dest, storedError)), !0, storedError);
      })), isOrBecomesErrored(dest, writer._closedPromise, (storedError => {
       preventCancel ? shutdown(!0, storedError) : shutdownWithAction((() => ReadableStreamCancel(source, storedError)), !0, storedError);
      })), stream = source, promise = reader._closedPromise, action = () => {
       preventClose ? shutdown() : shutdownWithAction((() => function(writer) {
        const stream = writer._ownerWritableStream, state = stream._state;
        return WritableStreamCloseQueuedOrInFlight(stream) || "closed" === state ? promiseResolvedWith(void 0) : "errored" === state ? promiseRejectedWith(stream._storedError) : WritableStreamDefaultWriterClose(writer);
       }(writer)));
      }, "closed" === stream._state ? action() : uponFulfillment(promise, action), WritableStreamCloseQueuedOrInFlight(dest) || "closed" === dest._state) {
       const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
       preventCancel ? shutdown(!0, destClosed) : shutdownWithAction((() => ReadableStreamCancel(source, destClosed)), !0, destClosed);
      }
      function waitForWritesToFinish() {
       const oldCurrentWrite = currentWrite;
       return PerformPromiseThen(currentWrite, (() => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0));
      }
      function isOrBecomesErrored(stream, promise, action) {
       "errored" === stream._state ? action(stream._storedError) : uponRejection(promise, action);
      }
      function shutdownWithAction(action, originalIsError, originalError) {
       function doTheRest() {
        uponPromise(action(), (() => finalize(originalIsError, originalError)), (newError => finalize(!0, newError)));
       }
       shuttingDown || (shuttingDown = !0, "writable" !== dest._state || WritableStreamCloseQueuedOrInFlight(dest) ? doTheRest() : uponFulfillment(waitForWritesToFinish(), doTheRest));
      }
      function shutdown(isError, error) {
       shuttingDown || (shuttingDown = !0, "writable" !== dest._state || WritableStreamCloseQueuedOrInFlight(dest) ? finalize(isError, error) : uponFulfillment(waitForWritesToFinish(), (() => finalize(isError, error))));
      }
      function finalize(isError, error) {
       WritableStreamDefaultWriterRelease(writer), ReadableStreamReaderGenericRelease(reader), 
       void 0 !== signal && signal.removeEventListener("abort", abortAlgorithm), isError ? reject(error) : resolve(void 0);
      }
      setPromiseIsHandledToTrue(newPromise(((resolveLoop, rejectLoop) => {
       !function next(done) {
        done ? resolveLoop() : PerformPromiseThen(shuttingDown ? promiseResolvedWith(!0) : PerformPromiseThen(writer._readyPromise, (() => newPromise(((resolveRead, rejectRead) => {
         ReadableStreamDefaultReaderRead(reader, {
          _chunkSteps: chunk => {
           currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop), 
           resolveRead(!1);
          },
          _closeSteps: () => resolveRead(!0),
          _errorSteps: rejectRead
         });
        })))), next, rejectLoop);
       }(!1);
      })));
     }));
    }
    class ReadableStreamDefaultController {
     constructor() {
      throw new TypeError("Illegal constructor");
     }
     get desiredSize() {
      if (!IsReadableStreamDefaultController(this)) throw defaultControllerBrandCheckException$1("desiredSize");
      return ReadableStreamDefaultControllerGetDesiredSize(this);
     }
     close() {
      if (!IsReadableStreamDefaultController(this)) throw defaultControllerBrandCheckException$1("close");
      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) throw new TypeError("The stream is not in a state that permits close");
      ReadableStreamDefaultControllerClose(this);
     }
     enqueue(chunk = void 0) {
      if (!IsReadableStreamDefaultController(this)) throw defaultControllerBrandCheckException$1("enqueue");
      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) throw new TypeError("The stream is not in a state that permits enqueue");
      return ReadableStreamDefaultControllerEnqueue(this, chunk);
     }
     error(e = void 0) {
      if (!IsReadableStreamDefaultController(this)) throw defaultControllerBrandCheckException$1("error");
      ReadableStreamDefaultControllerError(this, e);
     }
     [CancelSteps](reason) {
      ResetQueue(this);
      const result = this._cancelAlgorithm(reason);
      return ReadableStreamDefaultControllerClearAlgorithms(this), result;
     }
     [PullSteps](readRequest) {
      const stream = this._controlledReadableStream;
      if (this._queue.length > 0) {
       const chunk = DequeueValue(this);
       this._closeRequested && 0 === this._queue.length ? (ReadableStreamDefaultControllerClearAlgorithms(this), 
       ReadableStreamClose(stream)) : ReadableStreamDefaultControllerCallPullIfNeeded(this), 
       readRequest._chunkSteps(chunk);
      } else ReadableStreamAddReadRequest(stream, readRequest), ReadableStreamDefaultControllerCallPullIfNeeded(this);
     }
    }
    function IsReadableStreamDefaultController(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream") && x instanceof ReadableStreamDefaultController;
    }
    function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
     ReadableStreamDefaultControllerShouldCallPull(controller) && (controller._pulling ? controller._pullAgain = !0 : (controller._pulling = !0, 
     uponPromise(controller._pullAlgorithm(), (() => {
      controller._pulling = !1, controller._pullAgain && (controller._pullAgain = !1, 
      ReadableStreamDefaultControllerCallPullIfNeeded(controller));
     }), (e => {
      ReadableStreamDefaultControllerError(controller, e);
     }))));
    }
    function ReadableStreamDefaultControllerShouldCallPull(controller) {
     const stream = controller._controlledReadableStream;
     return !!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) && (!!controller._started && (!!(IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) || ReadableStreamDefaultControllerGetDesiredSize(controller) > 0));
    }
    function ReadableStreamDefaultControllerClearAlgorithms(controller) {
     controller._pullAlgorithm = void 0, controller._cancelAlgorithm = void 0, controller._strategySizeAlgorithm = void 0;
    }
    function ReadableStreamDefaultControllerClose(controller) {
     if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) return;
     const stream = controller._controlledReadableStream;
     controller._closeRequested = !0, 0 === controller._queue.length && (ReadableStreamDefaultControllerClearAlgorithms(controller), 
     ReadableStreamClose(stream));
    }
    function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
     if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) return;
     const stream = controller._controlledReadableStream;
     if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) ReadableStreamFulfillReadRequest(stream, chunk, !1); else {
      let chunkSize;
      try {
       chunkSize = controller._strategySizeAlgorithm(chunk);
      } catch (chunkSizeE) {
       throw ReadableStreamDefaultControllerError(controller, chunkSizeE), chunkSizeE;
      }
      try {
       EnqueueValueWithSize(controller, chunk, chunkSize);
      } catch (enqueueE) {
       throw ReadableStreamDefaultControllerError(controller, enqueueE), enqueueE;
      }
     }
     ReadableStreamDefaultControllerCallPullIfNeeded(controller);
    }
    function ReadableStreamDefaultControllerError(controller, e) {
     const stream = controller._controlledReadableStream;
     "readable" === stream._state && (ResetQueue(controller), ReadableStreamDefaultControllerClearAlgorithms(controller), 
     ReadableStreamError(stream, e));
    }
    function ReadableStreamDefaultControllerGetDesiredSize(controller) {
     const state = controller._controlledReadableStream._state;
     return "errored" === state ? null : "closed" === state ? 0 : controller._strategyHWM - controller._queueTotalSize;
    }
    function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
     const state = controller._controlledReadableStream._state;
     return !controller._closeRequested && "readable" === state;
    }
    function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
     controller._controlledReadableStream = stream, controller._queue = void 0, controller._queueTotalSize = void 0, 
     ResetQueue(controller), controller._started = !1, controller._closeRequested = !1, 
     controller._pullAgain = !1, controller._pulling = !1, controller._strategySizeAlgorithm = sizeAlgorithm, 
     controller._strategyHWM = highWaterMark, controller._pullAlgorithm = pullAlgorithm, 
     controller._cancelAlgorithm = cancelAlgorithm, stream._readableStreamController = controller, 
     uponPromise(promiseResolvedWith(startAlgorithm()), (() => {
      controller._started = !0, ReadableStreamDefaultControllerCallPullIfNeeded(controller);
     }), (r => {
      ReadableStreamDefaultControllerError(controller, r);
     }));
    }
    function defaultControllerBrandCheckException$1(name) {
     return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
    }
    function ReadableStreamTee(stream, cloneForBranch2) {
     return IsReadableByteStreamController(stream._readableStreamController) ? function(stream) {
      let reason1, reason2, branch1, branch2, resolveCancelPromise, reader = AcquireReadableStreamDefaultReader(stream), reading = !1, readAgainForBranch1 = !1, readAgainForBranch2 = !1, canceled1 = !1, canceled2 = !1;
      const cancelPromise = newPromise((resolve => {
       resolveCancelPromise = resolve;
      }));
      function forwardReaderError(thisReader) {
       uponRejection(thisReader._closedPromise, (r => {
        thisReader === reader && (ReadableByteStreamControllerError(branch1._readableStreamController, r), 
        ReadableByteStreamControllerError(branch2._readableStreamController, r), canceled1 && canceled2 || resolveCancelPromise(void 0));
       }));
      }
      function pullWithDefaultReader() {
       IsReadableStreamBYOBReader(reader) && (ReadableStreamReaderGenericRelease(reader), 
       reader = AcquireReadableStreamDefaultReader(stream), forwardReaderError(reader)), 
       ReadableStreamDefaultReaderRead(reader, {
        _chunkSteps: chunk => {
         queueMicrotask((() => {
          readAgainForBranch1 = !1, readAgainForBranch2 = !1;
          const chunk1 = chunk;
          let chunk2 = chunk;
          if (!canceled1 && !canceled2) try {
           chunk2 = CloneAsUint8Array(chunk);
          } catch (cloneE) {
           return ReadableByteStreamControllerError(branch1._readableStreamController, cloneE), 
           ReadableByteStreamControllerError(branch2._readableStreamController, cloneE), void resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
          }
          canceled1 || ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1), 
          canceled2 || ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2), 
          reading = !1, readAgainForBranch1 ? pull1Algorithm() : readAgainForBranch2 && pull2Algorithm();
         }));
        },
        _closeSteps: () => {
         reading = !1, canceled1 || ReadableByteStreamControllerClose(branch1._readableStreamController), 
         canceled2 || ReadableByteStreamControllerClose(branch2._readableStreamController), 
         branch1._readableStreamController._pendingPullIntos.length > 0 && ReadableByteStreamControllerRespond(branch1._readableStreamController, 0), 
         branch2._readableStreamController._pendingPullIntos.length > 0 && ReadableByteStreamControllerRespond(branch2._readableStreamController, 0), 
         canceled1 && canceled2 || resolveCancelPromise(void 0);
        },
        _errorSteps: () => {
         reading = !1;
        }
       });
      }
      function pullWithBYOBReader(view, forBranch2) {
       IsReadableStreamDefaultReader(reader) && (ReadableStreamReaderGenericRelease(reader), 
       reader = AcquireReadableStreamBYOBReader(stream), forwardReaderError(reader));
       const byobBranch = forBranch2 ? branch2 : branch1, otherBranch = forBranch2 ? branch1 : branch2;
       ReadableStreamBYOBReaderRead(reader, view, {
        _chunkSteps: chunk => {
         queueMicrotask((() => {
          readAgainForBranch1 = !1, readAgainForBranch2 = !1;
          const byobCanceled = forBranch2 ? canceled2 : canceled1;
          if (forBranch2 ? canceled1 : canceled2) byobCanceled || ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk); else {
           let clonedChunk;
           try {
            clonedChunk = CloneAsUint8Array(chunk);
           } catch (cloneE) {
            return ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE), 
            ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE), 
            void resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
           }
           byobCanceled || ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk), 
           ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
          }
          reading = !1, readAgainForBranch1 ? pull1Algorithm() : readAgainForBranch2 && pull2Algorithm();
         }));
        },
        _closeSteps: chunk => {
         reading = !1;
         const byobCanceled = forBranch2 ? canceled2 : canceled1, otherCanceled = forBranch2 ? canceled1 : canceled2;
         byobCanceled || ReadableByteStreamControllerClose(byobBranch._readableStreamController), 
         otherCanceled || ReadableByteStreamControllerClose(otherBranch._readableStreamController), 
         void 0 !== chunk && (byobCanceled || ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk), 
         !otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0 && ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0)), 
         byobCanceled && otherCanceled || resolveCancelPromise(void 0);
        },
        _errorSteps: () => {
         reading = !1;
        }
       });
      }
      function pull1Algorithm() {
       if (reading) return readAgainForBranch1 = !0, promiseResolvedWith(void 0);
       reading = !0;
       const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
       return null === byobRequest ? pullWithDefaultReader() : pullWithBYOBReader(byobRequest._view, !1), 
       promiseResolvedWith(void 0);
      }
      function pull2Algorithm() {
       if (reading) return readAgainForBranch2 = !0, promiseResolvedWith(void 0);
       reading = !0;
       const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
       return null === byobRequest ? pullWithDefaultReader() : pullWithBYOBReader(byobRequest._view, !0), 
       promiseResolvedWith(void 0);
      }
      function cancel1Algorithm(reason) {
       if (canceled1 = !0, reason1 = reason, canceled2) {
        const compositeReason = CreateArrayFromList([ reason1, reason2 ]), cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolveCancelPromise(cancelResult);
       }
       return cancelPromise;
      }
      function cancel2Algorithm(reason) {
       if (canceled2 = !0, reason2 = reason, canceled1) {
        const compositeReason = CreateArrayFromList([ reason1, reason2 ]), cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolveCancelPromise(cancelResult);
       }
       return cancelPromise;
      }
      function startAlgorithm() {}
      return branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm), 
      branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm), 
      forwardReaderError(reader), [ branch1, branch2 ];
     }(stream) : function(stream, cloneForBranch2) {
      const reader = AcquireReadableStreamDefaultReader(stream);
      let reason1, reason2, branch1, branch2, resolveCancelPromise, reading = !1, readAgain = !1, canceled1 = !1, canceled2 = !1;
      const cancelPromise = newPromise((resolve => {
       resolveCancelPromise = resolve;
      }));
      function pullAlgorithm() {
       return reading ? (readAgain = !0, promiseResolvedWith(void 0)) : (reading = !0, 
       ReadableStreamDefaultReaderRead(reader, {
        _chunkSteps: chunk => {
         queueMicrotask((() => {
          readAgain = !1;
          const chunk1 = chunk, chunk2 = chunk;
          canceled1 || ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1), 
          canceled2 || ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2), 
          reading = !1, readAgain && pullAlgorithm();
         }));
        },
        _closeSteps: () => {
         reading = !1, canceled1 || ReadableStreamDefaultControllerClose(branch1._readableStreamController), 
         canceled2 || ReadableStreamDefaultControllerClose(branch2._readableStreamController), 
         canceled1 && canceled2 || resolveCancelPromise(void 0);
        },
        _errorSteps: () => {
         reading = !1;
        }
       }), promiseResolvedWith(void 0));
      }
      function cancel1Algorithm(reason) {
       if (canceled1 = !0, reason1 = reason, canceled2) {
        const compositeReason = CreateArrayFromList([ reason1, reason2 ]), cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolveCancelPromise(cancelResult);
       }
       return cancelPromise;
      }
      function cancel2Algorithm(reason) {
       if (canceled2 = !0, reason2 = reason, canceled1) {
        const compositeReason = CreateArrayFromList([ reason1, reason2 ]), cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolveCancelPromise(cancelResult);
       }
       return cancelPromise;
      }
      function startAlgorithm() {}
      return branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm), 
      branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm), 
      uponRejection(reader._closedPromise, (r => {
       ReadableStreamDefaultControllerError(branch1._readableStreamController, r), ReadableStreamDefaultControllerError(branch2._readableStreamController, r), 
       canceled1 && canceled2 || resolveCancelPromise(void 0);
      })), [ branch1, branch2 ];
     }(stream);
    }
    function convertUnderlyingSourceCancelCallback(fn, original, context) {
     return assertFunction(fn, context), reason => promiseCall(fn, original, [ reason ]);
    }
    function convertUnderlyingSourcePullCallback(fn, original, context) {
     return assertFunction(fn, context), controller => promiseCall(fn, original, [ controller ]);
    }
    function convertUnderlyingSourceStartCallback(fn, original, context) {
     return assertFunction(fn, context), controller => reflectCall(fn, original, [ controller ]);
    }
    function convertReadableStreamType(type, context) {
     if ("bytes" != (type = `${type}`)) throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
     return type;
    }
    function convertReadableStreamReaderMode(mode, context) {
     if ("byob" != (mode = `${mode}`)) throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
     return mode;
    }
    function convertPipeOptions(options, context) {
     assertDictionary(options, context);
     const preventAbort = null == options ? void 0 : options.preventAbort, preventCancel = null == options ? void 0 : options.preventCancel, preventClose = null == options ? void 0 : options.preventClose, signal = null == options ? void 0 : options.signal;
     return void 0 !== signal && function assertAbortSignal(signal, context) {
      if (!function isAbortSignal(value) {
       if ("object" != typeof value || null === value) return !1;
       try {
        return "boolean" == typeof value.aborted;
       } catch (_a) {
        return !1;
       }
      }(signal)) throw new TypeError(`${context} is not an AbortSignal.`);
     }(signal, `${context} has member 'signal' that`), {
      preventAbort: Boolean(preventAbort),
      preventCancel: Boolean(preventCancel),
      preventClose: Boolean(preventClose),
      signal
     };
    }
    Object.defineProperties(ReadableStreamDefaultController.prototype, {
     close: {
      enumerable: !0
     },
     enqueue: {
      enumerable: !0
     },
     error: {
      enumerable: !0
     },
     desiredSize: {
      enumerable: !0
     }
    }), "symbol" == typeof SymbolPolyfill.toStringTag && Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
     value: "ReadableStreamDefaultController",
     configurable: !0
    });
    class ReadableStream {
     constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
      void 0 === rawUnderlyingSource ? rawUnderlyingSource = null : assertObject(rawUnderlyingSource, "First parameter");
      const strategy = convertQueuingStrategy(rawStrategy, "Second parameter"), underlyingSource = function(source, context) {
       assertDictionary(source, context);
       const original = source, autoAllocateChunkSize = null == original ? void 0 : original.autoAllocateChunkSize, cancel = null == original ? void 0 : original.cancel, pull = null == original ? void 0 : original.pull, start = null == original ? void 0 : original.start, type = null == original ? void 0 : original.type;
       return {
        autoAllocateChunkSize: void 0 === autoAllocateChunkSize ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
        cancel: void 0 === cancel ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
        pull: void 0 === pull ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
        start: void 0 === start ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
        type: void 0 === type ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
       };
      }(rawUnderlyingSource, "First parameter");
      if (InitializeReadableStream(this), "bytes" === underlyingSource.type) {
       if (void 0 !== strategy.size) throw new RangeError("The strategy for a byte stream cannot have a size function");
       !function(stream, underlyingByteSource, highWaterMark) {
        const controller = Object.create(ReadableByteStreamController.prototype);
        let startAlgorithm = () => {}, pullAlgorithm = () => promiseResolvedWith(void 0), cancelAlgorithm = () => promiseResolvedWith(void 0);
        void 0 !== underlyingByteSource.start && (startAlgorithm = () => underlyingByteSource.start(controller)), 
        void 0 !== underlyingByteSource.pull && (pullAlgorithm = () => underlyingByteSource.pull(controller)), 
        void 0 !== underlyingByteSource.cancel && (cancelAlgorithm = reason => underlyingByteSource.cancel(reason));
        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (0 === autoAllocateChunkSize) throw new TypeError("autoAllocateChunkSize must be greater than 0");
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
       }(this, underlyingSource, ExtractHighWaterMark(strategy, 0));
      } else {
       const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
       !function(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        let startAlgorithm = () => {}, pullAlgorithm = () => promiseResolvedWith(void 0), cancelAlgorithm = () => promiseResolvedWith(void 0);
        void 0 !== underlyingSource.start && (startAlgorithm = () => underlyingSource.start(controller)), 
        void 0 !== underlyingSource.pull && (pullAlgorithm = () => underlyingSource.pull(controller)), 
        void 0 !== underlyingSource.cancel && (cancelAlgorithm = reason => underlyingSource.cancel(reason)), 
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
       }(this, underlyingSource, ExtractHighWaterMark(strategy, 1), sizeAlgorithm);
      }
     }
     get locked() {
      if (!IsReadableStream(this)) throw streamBrandCheckException$1("locked");
      return IsReadableStreamLocked(this);
     }
     cancel(reason = void 0) {
      return IsReadableStream(this) ? IsReadableStreamLocked(this) ? promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader")) : ReadableStreamCancel(this, reason) : promiseRejectedWith(streamBrandCheckException$1("cancel"));
     }
     getReader(rawOptions = void 0) {
      if (!IsReadableStream(this)) throw streamBrandCheckException$1("getReader");
      return void 0 === function(options, context) {
       assertDictionary(options, context);
       const mode = null == options ? void 0 : options.mode;
       return {
        mode: void 0 === mode ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
       };
      }(rawOptions, "First parameter").mode ? AcquireReadableStreamDefaultReader(this) : AcquireReadableStreamBYOBReader(this);
     }
     pipeThrough(rawTransform, rawOptions = {}) {
      if (!IsReadableStream(this)) throw streamBrandCheckException$1("pipeThrough");
      assertRequiredArgument(rawTransform, 1, "pipeThrough");
      const transform = function(pair, context) {
       assertDictionary(pair, context);
       const readable = null == pair ? void 0 : pair.readable;
       assertRequiredField(readable, "readable", "ReadableWritablePair"), assertReadableStream(readable, `${context} has member 'readable' that`);
       const writable = null == pair ? void 0 : pair.writable;
       return assertRequiredField(writable, "writable", "ReadableWritablePair"), assertWritableStream(writable, `${context} has member 'writable' that`), 
       {
        readable,
        writable
       };
      }(rawTransform, "First parameter"), options = convertPipeOptions(rawOptions, "Second parameter");
      if (IsReadableStreamLocked(this)) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
      if (IsWritableStreamLocked(transform.writable)) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
      return setPromiseIsHandledToTrue(ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal)), 
      transform.readable;
     }
     pipeTo(destination, rawOptions = {}) {
      if (!IsReadableStream(this)) return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
      if (void 0 === destination) return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");
      if (!IsWritableStream(destination)) return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
      let options;
      try {
       options = convertPipeOptions(rawOptions, "Second parameter");
      } catch (e) {
       return promiseRejectedWith(e);
      }
      return IsReadableStreamLocked(this) ? promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : IsWritableStreamLocked(destination) ? promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
     }
     tee() {
      if (!IsReadableStream(this)) throw streamBrandCheckException$1("tee");
      return CreateArrayFromList(ReadableStreamTee(this));
     }
     values(rawOptions = void 0) {
      if (!IsReadableStream(this)) throw streamBrandCheckException$1("values");
      return function(stream, preventCancel) {
       const reader = AcquireReadableStreamDefaultReader(stream), impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel), iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
       return iterator._asyncIteratorImpl = impl, iterator;
      }(this, function(options, context) {
       assertDictionary(options, context);
       const preventCancel = null == options ? void 0 : options.preventCancel;
       return {
        preventCancel: Boolean(preventCancel)
       };
      }(rawOptions, "First parameter").preventCancel);
     }
    }
    function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = (() => 1)) {
     const stream = Object.create(ReadableStream.prototype);
     return InitializeReadableStream(stream), SetUpReadableStreamDefaultController(stream, Object.create(ReadableStreamDefaultController.prototype), startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm), 
     stream;
    }
    function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
     const stream = Object.create(ReadableStream.prototype);
     return InitializeReadableStream(stream), SetUpReadableByteStreamController(stream, Object.create(ReadableByteStreamController.prototype), startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0), 
     stream;
    }
    function InitializeReadableStream(stream) {
     stream._state = "readable", stream._reader = void 0, stream._storedError = void 0, 
     stream._disturbed = !1;
    }
    function IsReadableStream(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_readableStreamController") && x instanceof ReadableStream;
    }
    function IsReadableStreamLocked(stream) {
     return void 0 !== stream._reader;
    }
    function ReadableStreamCancel(stream, reason) {
     if (stream._disturbed = !0, "closed" === stream._state) return promiseResolvedWith(void 0);
     if ("errored" === stream._state) return promiseRejectedWith(stream._storedError);
     ReadableStreamClose(stream);
     const reader = stream._reader;
     return void 0 !== reader && IsReadableStreamBYOBReader(reader) && (reader._readIntoRequests.forEach((readIntoRequest => {
      readIntoRequest._closeSteps(void 0);
     })), reader._readIntoRequests = new SimpleQueue), transformPromiseWith(stream._readableStreamController[CancelSteps](reason), noop);
    }
    function ReadableStreamClose(stream) {
     stream._state = "closed";
     const reader = stream._reader;
     void 0 !== reader && (defaultReaderClosedPromiseResolve(reader), IsReadableStreamDefaultReader(reader) && (reader._readRequests.forEach((readRequest => {
      readRequest._closeSteps();
     })), reader._readRequests = new SimpleQueue));
    }
    function ReadableStreamError(stream, e) {
     stream._state = "errored", stream._storedError = e;
     const reader = stream._reader;
     void 0 !== reader && (defaultReaderClosedPromiseReject(reader, e), IsReadableStreamDefaultReader(reader) ? (reader._readRequests.forEach((readRequest => {
      readRequest._errorSteps(e);
     })), reader._readRequests = new SimpleQueue) : (reader._readIntoRequests.forEach((readIntoRequest => {
      readIntoRequest._errorSteps(e);
     })), reader._readIntoRequests = new SimpleQueue));
    }
    function streamBrandCheckException$1(name) {
     return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
    }
    function convertQueuingStrategyInit(init, context) {
     assertDictionary(init, context);
     const highWaterMark = null == init ? void 0 : init.highWaterMark;
     return assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit"), 
     {
      highWaterMark: convertUnrestrictedDouble(highWaterMark)
     };
    }
    Object.defineProperties(ReadableStream.prototype, {
     cancel: {
      enumerable: !0
     },
     getReader: {
      enumerable: !0
     },
     pipeThrough: {
      enumerable: !0
     },
     pipeTo: {
      enumerable: !0
     },
     tee: {
      enumerable: !0
     },
     values: {
      enumerable: !0
     },
     locked: {
      enumerable: !0
     }
    }), "symbol" == typeof SymbolPolyfill.toStringTag && Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {
     value: "ReadableStream",
     configurable: !0
    }), "symbol" == typeof SymbolPolyfill.asyncIterator && Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {
     value: ReadableStream.prototype.values,
     writable: !0,
     configurable: !0
    });
    const byteLengthSizeFunction = chunk => chunk.byteLength;
    try {
     Object.defineProperty(byteLengthSizeFunction, "name", {
      value: "size",
      configurable: !0
     });
    } catch (_a) {}
    class ByteLengthQueuingStrategy {
     constructor(options) {
      assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy"), options = convertQueuingStrategyInit(options, "First parameter"), 
      this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
     }
     get highWaterMark() {
      if (!IsByteLengthQueuingStrategy(this)) throw byteLengthBrandCheckException("highWaterMark");
      return this._byteLengthQueuingStrategyHighWaterMark;
     }
     get size() {
      if (!IsByteLengthQueuingStrategy(this)) throw byteLengthBrandCheckException("size");
      return byteLengthSizeFunction;
     }
    }
    function byteLengthBrandCheckException(name) {
     return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
    }
    function IsByteLengthQueuingStrategy(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_byteLengthQueuingStrategyHighWaterMark") && x instanceof ByteLengthQueuingStrategy;
    }
    Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
     highWaterMark: {
      enumerable: !0
     },
     size: {
      enumerable: !0
     }
    }), "symbol" == typeof SymbolPolyfill.toStringTag && Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
     value: "ByteLengthQueuingStrategy",
     configurable: !0
    });
    const countSizeFunction = () => 1;
    try {
     Object.defineProperty(countSizeFunction, "name", {
      value: "size",
      configurable: !0
     });
    } catch (_a) {}
    class CountQueuingStrategy {
     constructor(options) {
      assertRequiredArgument(options, 1, "CountQueuingStrategy"), options = convertQueuingStrategyInit(options, "First parameter"), 
      this._countQueuingStrategyHighWaterMark = options.highWaterMark;
     }
     get highWaterMark() {
      if (!IsCountQueuingStrategy(this)) throw countBrandCheckException("highWaterMark");
      return this._countQueuingStrategyHighWaterMark;
     }
     get size() {
      if (!IsCountQueuingStrategy(this)) throw countBrandCheckException("size");
      return countSizeFunction;
     }
    }
    function countBrandCheckException(name) {
     return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
    }
    function IsCountQueuingStrategy(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_countQueuingStrategyHighWaterMark") && x instanceof CountQueuingStrategy;
    }
    function convertTransformerFlushCallback(fn, original, context) {
     return assertFunction(fn, context), controller => promiseCall(fn, original, [ controller ]);
    }
    function convertTransformerStartCallback(fn, original, context) {
     return assertFunction(fn, context), controller => reflectCall(fn, original, [ controller ]);
    }
    function convertTransformerTransformCallback(fn, original, context) {
     return assertFunction(fn, context), (chunk, controller) => promiseCall(fn, original, [ chunk, controller ]);
    }
    Object.defineProperties(CountQueuingStrategy.prototype, {
     highWaterMark: {
      enumerable: !0
     },
     size: {
      enumerable: !0
     }
    }), "symbol" == typeof SymbolPolyfill.toStringTag && Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
     value: "CountQueuingStrategy",
     configurable: !0
    });
    class TransformStream {
     constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
      void 0 === rawTransformer && (rawTransformer = null);
      const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter"), readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter"), transformer = function(original, context) {
       assertDictionary(original, context);
       const flush = null == original ? void 0 : original.flush, readableType = null == original ? void 0 : original.readableType, start = null == original ? void 0 : original.start, transform = null == original ? void 0 : original.transform, writableType = null == original ? void 0 : original.writableType;
       return {
        flush: void 0 === flush ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
        readableType,
        start: void 0 === start ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
        transform: void 0 === transform ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
        writableType
       };
      }(rawTransformer, "First parameter");
      if (void 0 !== transformer.readableType) throw new RangeError("Invalid readableType specified");
      if (void 0 !== transformer.writableType) throw new RangeError("Invalid writableType specified");
      const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0), readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy), writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1), writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
      let startPromise_resolve;
      !function(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
       function startAlgorithm() {
        return startPromise;
       }
       function writeAlgorithm(chunk) {
        return function(stream, chunk) {
         const controller = stream._transformStreamController;
         return stream._backpressure ? transformPromiseWith(stream._backpressureChangePromise, (() => {
          const writable = stream._writable;
          if ("erroring" === writable._state) throw writable._storedError;
          return TransformStreamDefaultControllerPerformTransform(controller, chunk);
         })) : TransformStreamDefaultControllerPerformTransform(controller, chunk);
        }(stream, chunk);
       }
       function abortAlgorithm(reason) {
        return function(stream, reason) {
         return TransformStreamError(stream, reason), promiseResolvedWith(void 0);
        }(stream, reason);
       }
       function closeAlgorithm() {
        return function(stream) {
         const readable = stream._readable, controller = stream._transformStreamController, flushPromise = controller._flushAlgorithm();
         return TransformStreamDefaultControllerClearAlgorithms(controller), transformPromiseWith(flushPromise, (() => {
          if ("errored" === readable._state) throw readable._storedError;
          ReadableStreamDefaultControllerClose(readable._readableStreamController);
         }), (r => {
          throw TransformStreamError(stream, r), readable._storedError;
         }));
        }(stream);
       }
       function pullAlgorithm() {
        return function(stream) {
         return TransformStreamSetBackpressure(stream, !1), stream._backpressureChangePromise;
        }(stream);
       }
       function cancelAlgorithm(reason) {
        return TransformStreamErrorWritableAndUnblockWrite(stream, reason), promiseResolvedWith(void 0);
       }
       stream._writable = function(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = (() => 1)) {
        const stream = Object.create(WritableStream.prototype);
        return InitializeWritableStream(stream), SetUpWritableStreamDefaultController(stream, Object.create(WritableStreamDefaultController.prototype), startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm), 
        stream;
       }(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm), 
       stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm), 
       stream._backpressure = void 0, stream._backpressureChangePromise = void 0, stream._backpressureChangePromise_resolve = void 0, 
       TransformStreamSetBackpressure(stream, !0), stream._transformStreamController = void 0;
      }(this, newPromise((resolve => {
       startPromise_resolve = resolve;
      })), writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm), 
      function(stream, transformer) {
       const controller = Object.create(TransformStreamDefaultController.prototype);
       let transformAlgorithm = chunk => {
        try {
         return TransformStreamDefaultControllerEnqueue(controller, chunk), promiseResolvedWith(void 0);
        } catch (transformResultE) {
         return promiseRejectedWith(transformResultE);
        }
       }, flushAlgorithm = () => promiseResolvedWith(void 0);
       void 0 !== transformer.transform && (transformAlgorithm = chunk => transformer.transform(chunk, controller)), 
       void 0 !== transformer.flush && (flushAlgorithm = () => transformer.flush(controller)), 
       function(stream, controller, transformAlgorithm, flushAlgorithm) {
        controller._controlledTransformStream = stream, stream._transformStreamController = controller, 
        controller._transformAlgorithm = transformAlgorithm, controller._flushAlgorithm = flushAlgorithm;
       }(stream, controller, transformAlgorithm, flushAlgorithm);
      }(this, transformer), void 0 !== transformer.start ? startPromise_resolve(transformer.start(this._transformStreamController)) : startPromise_resolve(void 0);
     }
     get readable() {
      if (!IsTransformStream(this)) throw streamBrandCheckException("readable");
      return this._readable;
     }
     get writable() {
      if (!IsTransformStream(this)) throw streamBrandCheckException("writable");
      return this._writable;
     }
    }
    function IsTransformStream(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_transformStreamController") && x instanceof TransformStream;
    }
    function TransformStreamError(stream, e) {
     ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e), 
     TransformStreamErrorWritableAndUnblockWrite(stream, e);
    }
    function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
     TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController), 
     WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e), 
     stream._backpressure && TransformStreamSetBackpressure(stream, !1);
    }
    function TransformStreamSetBackpressure(stream, backpressure) {
     void 0 !== stream._backpressureChangePromise && stream._backpressureChangePromise_resolve(), 
     stream._backpressureChangePromise = newPromise((resolve => {
      stream._backpressureChangePromise_resolve = resolve;
     })), stream._backpressure = backpressure;
    }
    Object.defineProperties(TransformStream.prototype, {
     readable: {
      enumerable: !0
     },
     writable: {
      enumerable: !0
     }
    }), "symbol" == typeof SymbolPolyfill.toStringTag && Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
     value: "TransformStream",
     configurable: !0
    });
    class TransformStreamDefaultController {
     constructor() {
      throw new TypeError("Illegal constructor");
     }
     get desiredSize() {
      if (!IsTransformStreamDefaultController(this)) throw defaultControllerBrandCheckException("desiredSize");
      return ReadableStreamDefaultControllerGetDesiredSize(this._controlledTransformStream._readable._readableStreamController);
     }
     enqueue(chunk = void 0) {
      if (!IsTransformStreamDefaultController(this)) throw defaultControllerBrandCheckException("enqueue");
      TransformStreamDefaultControllerEnqueue(this, chunk);
     }
     error(reason = void 0) {
      if (!IsTransformStreamDefaultController(this)) throw defaultControllerBrandCheckException("error");
      var e;
      e = reason, TransformStreamError(this._controlledTransformStream, e);
     }
     terminate() {
      if (!IsTransformStreamDefaultController(this)) throw defaultControllerBrandCheckException("terminate");
      !function(controller) {
       const stream = controller._controlledTransformStream;
       ReadableStreamDefaultControllerClose(stream._readable._readableStreamController);
       const error = new TypeError("TransformStream terminated");
       TransformStreamErrorWritableAndUnblockWrite(stream, error);
      }(this);
     }
    }
    function IsTransformStreamDefaultController(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream") && x instanceof TransformStreamDefaultController;
    }
    function TransformStreamDefaultControllerClearAlgorithms(controller) {
     controller._transformAlgorithm = void 0, controller._flushAlgorithm = void 0;
    }
    function TransformStreamDefaultControllerEnqueue(controller, chunk) {
     const stream = controller._controlledTransformStream, readableController = stream._readable._readableStreamController;
     if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) throw new TypeError("Readable side is not in a state that permits enqueue");
     try {
      ReadableStreamDefaultControllerEnqueue(readableController, chunk);
     } catch (e) {
      throw TransformStreamErrorWritableAndUnblockWrite(stream, e), stream._readable._storedError;
     }
     const backpressure = function(controller) {
      return !ReadableStreamDefaultControllerShouldCallPull(controller);
     }(readableController);
     backpressure !== stream._backpressure && TransformStreamSetBackpressure(stream, !0);
    }
    function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
     return transformPromiseWith(controller._transformAlgorithm(chunk), void 0, (r => {
      throw TransformStreamError(controller._controlledTransformStream, r), r;
     }));
    }
    function defaultControllerBrandCheckException(name) {
     return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
    }
    function streamBrandCheckException(name) {
     return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
    }
    Object.defineProperties(TransformStreamDefaultController.prototype, {
     enqueue: {
      enumerable: !0
     },
     error: {
      enumerable: !0
     },
     terminate: {
      enumerable: !0
     },
     desiredSize: {
      enumerable: !0
     }
    }), "symbol" == typeof SymbolPolyfill.toStringTag && Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
     value: "TransformStreamDefaultController",
     configurable: !0
    }), exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy, exports.CountQueuingStrategy = CountQueuingStrategy, 
    exports.ReadableByteStreamController = ReadableByteStreamController, exports.ReadableStream = ReadableStream, 
    exports.ReadableStreamBYOBReader = ReadableStreamBYOBReader, exports.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest, 
    exports.ReadableStreamDefaultController = ReadableStreamDefaultController, exports.ReadableStreamDefaultReader = ReadableStreamDefaultReader, 
    exports.TransformStream = TransformStream, exports.TransformStreamDefaultController = TransformStreamDefaultController, 
    exports.WritableStream = WritableStream, exports.WritableStreamDefaultController = WritableStreamDefaultController, 
    exports.WritableStreamDefaultWriter = WritableStreamDefaultWriter, Object.defineProperty(exports, "__esModule", {
     value: !0
    });
   }, factory(exports);
  },
  22674: (module, __unused_webpack_exports, __webpack_require__) => {
   const {isexe, sync: isexeSync} = __webpack_require__(74951), {join, delimiter, sep, posix} = __webpack_require__(71017), isWindows = "win32" === process.platform, rSlash = new RegExp(`[${posix.sep}${sep === posix.sep ? "" : sep}]`.replace(/(\\)/g, "\\$1")), rRel = new RegExp(`^\\.${rSlash.source}`), getNotFoundError = cmd => Object.assign(new Error(`not found: ${cmd}`), {
    code: "ENOENT"
   }), getPathInfo = (cmd, {path: optPath = process.env.PATH, pathExt: optPathExt = process.env.PATHEXT, delimiter: optDelimiter = delimiter}) => {
    const pathEnv = cmd.match(rSlash) ? [ "" ] : [ ...isWindows ? [ process.cwd() ] : [], ...(optPath || "").split(optDelimiter) ];
    if (isWindows) {
     const pathExtExe = optPathExt || [ ".EXE", ".CMD", ".BAT", ".COM" ].join(optDelimiter), pathExt = pathExtExe.split(optDelimiter).flatMap((item => [ item, item.toLowerCase() ]));
     return cmd.includes(".") && "" !== pathExt[0] && pathExt.unshift(""), {
      pathEnv,
      pathExt,
      pathExtExe
     };
    }
    return {
     pathEnv,
     pathExt: [ "" ]
    };
   }, getPathPart = (raw, cmd) => {
    const pathPart = /^".*"$/.test(raw) ? raw.slice(1, -1) : raw;
    return (!pathPart && rRel.test(cmd) ? cmd.slice(0, 2) : "") + join(pathPart, cmd);
   }, which = async (cmd, opt = {}) => {
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt), found = [];
    for (const envPart of pathEnv) {
     const p = getPathPart(envPart, cmd);
     for (const ext of pathExt) {
      const withExt = p + ext;
      if (await isexe(withExt, {
       pathExt: pathExtExe,
       ignoreErrors: !0
      })) {
       if (!opt.all) return withExt;
       found.push(withExt);
      }
     }
    }
    if (opt.all && found.length) return found;
    if (opt.nothrow) return null;
    throw getNotFoundError(cmd);
   };
   module.exports = which, which.sync = (cmd, opt = {}) => {
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt), found = [];
    for (const pathEnvPart of pathEnv) {
     const p = getPathPart(pathEnvPart, cmd);
     for (const ext of pathExt) {
      const withExt = p + ext;
      if (isexeSync(withExt, {
       pathExt: pathExtExe,
       ignoreErrors: !0
      })) {
       if (!opt.all) return withExt;
       found.push(withExt);
      }
     }
    }
    if (opt.all && found.length) return found;
    if (opt.nothrow) return null;
    throw getNotFoundError(cmd);
   };
  },
  49602: module => {
   "use strict";
   module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function*() {
     for (let walker = this.head; walker; walker = walker.next) yield walker.value;
    };
   };
  },
  34411: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   function Yallist(list) {
    var self = this;
    if (self instanceof Yallist || (self = new Yallist), self.tail = null, self.head = null, 
    self.length = 0, list && "function" == typeof list.forEach) list.forEach((function(item) {
     self.push(item);
    })); else if (arguments.length > 0) for (var i = 0, l = arguments.length; i < l; i++) self.push(arguments[i]);
    return self;
   }
   function insert(self, node, value) {
    var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
    return null === inserted.next && (self.tail = inserted), null === inserted.prev && (self.head = inserted), 
    self.length++, inserted;
   }
   function push(self, item) {
    self.tail = new Node(item, self.tail, null, self), self.head || (self.head = self.tail), 
    self.length++;
   }
   function unshift(self, item) {
    self.head = new Node(item, null, self.head, self), self.tail || (self.tail = self.head), 
    self.length++;
   }
   function Node(value, prev, next, list) {
    if (!(this instanceof Node)) return new Node(value, prev, next, list);
    this.list = list, this.value = value, prev ? (prev.next = this, this.prev = prev) : this.prev = null, 
    next ? (next.prev = this, this.next = next) : this.next = null;
   }
   module.exports = Yallist, Yallist.Node = Node, Yallist.create = Yallist, Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) throw new Error("removing node which does not belong to this list");
    var next = node.next, prev = node.prev;
    return next && (next.prev = prev), prev && (prev.next = next), node === this.head && (this.head = next), 
    node === this.tail && (this.tail = prev), node.list.length--, node.next = null, 
    node.prev = null, node.list = null, next;
   }, Yallist.prototype.unshiftNode = function(node) {
    if (node !== this.head) {
     node.list && node.list.removeNode(node);
     var head = this.head;
     node.list = this, node.next = head, head && (head.prev = node), this.head = node, 
     this.tail || (this.tail = node), this.length++;
    }
   }, Yallist.prototype.pushNode = function(node) {
    if (node !== this.tail) {
     node.list && node.list.removeNode(node);
     var tail = this.tail;
     node.list = this, node.prev = tail, tail && (tail.next = node), this.tail = node, 
     this.head || (this.head = node), this.length++;
    }
   }, Yallist.prototype.push = function() {
    for (var i = 0, l = arguments.length; i < l; i++) push(this, arguments[i]);
    return this.length;
   }, Yallist.prototype.unshift = function() {
    for (var i = 0, l = arguments.length; i < l; i++) unshift(this, arguments[i]);
    return this.length;
   }, Yallist.prototype.pop = function() {
    if (this.tail) {
     var res = this.tail.value;
     return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, 
     this.length--, res;
    }
   }, Yallist.prototype.shift = function() {
    if (this.head) {
     var res = this.head.value;
     return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, 
     this.length--, res;
    }
   }, Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0; null !== walker; i++) fn.call(thisp, walker.value, i, this), 
    walker = walker.next;
   }, Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1; null !== walker; i--) fn.call(thisp, walker.value, i, this), 
    walker = walker.prev;
   }, Yallist.prototype.get = function(n) {
    for (var i = 0, walker = this.head; null !== walker && i < n; i++) walker = walker.next;
    if (i === n && null !== walker) return walker.value;
   }, Yallist.prototype.getReverse = function(n) {
    for (var i = 0, walker = this.tail; null !== walker && i < n; i++) walker = walker.prev;
    if (i === n && null !== walker) return walker.value;
   }, Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    for (var res = new Yallist, walker = this.head; null !== walker; ) res.push(fn.call(thisp, walker.value, this)), 
    walker = walker.next;
    return res;
   }, Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var res = new Yallist, walker = this.tail; null !== walker; ) res.push(fn.call(thisp, walker.value, this)), 
    walker = walker.prev;
    return res;
   }, Yallist.prototype.reduce = function(fn, initial) {
    var acc, walker = this.head;
    if (arguments.length > 1) acc = initial; else {
     if (!this.head) throw new TypeError("Reduce of empty list with no initial value");
     walker = this.head.next, acc = this.head.value;
    }
    for (var i = 0; null !== walker; i++) acc = fn(acc, walker.value, i), walker = walker.next;
    return acc;
   }, Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc, walker = this.tail;
    if (arguments.length > 1) acc = initial; else {
     if (!this.tail) throw new TypeError("Reduce of empty list with no initial value");
     walker = this.tail.prev, acc = this.tail.value;
    }
    for (var i = this.length - 1; null !== walker; i--) acc = fn(acc, walker.value, i), 
    walker = walker.prev;
    return acc;
   }, Yallist.prototype.toArray = function() {
    for (var arr = new Array(this.length), i = 0, walker = this.head; null !== walker; i++) arr[i] = walker.value, 
    walker = walker.next;
    return arr;
   }, Yallist.prototype.toArrayReverse = function() {
    for (var arr = new Array(this.length), i = 0, walker = this.tail; null !== walker; i++) arr[i] = walker.value, 
    walker = walker.prev;
    return arr;
   }, Yallist.prototype.slice = function(from, to) {
    (to = to || this.length) < 0 && (to += this.length), (from = from || 0) < 0 && (from += this.length);
    var ret = new Yallist;
    if (to < from || to < 0) return ret;
    from < 0 && (from = 0), to > this.length && (to = this.length);
    for (var i = 0, walker = this.head; null !== walker && i < from; i++) walker = walker.next;
    for (;null !== walker && i < to; i++, walker = walker.next) ret.push(walker.value);
    return ret;
   }, Yallist.prototype.sliceReverse = function(from, to) {
    (to = to || this.length) < 0 && (to += this.length), (from = from || 0) < 0 && (from += this.length);
    var ret = new Yallist;
    if (to < from || to < 0) return ret;
    from < 0 && (from = 0), to > this.length && (to = this.length);
    for (var i = this.length, walker = this.tail; null !== walker && i > to; i--) walker = walker.prev;
    for (;null !== walker && i > from; i--, walker = walker.prev) ret.push(walker.value);
    return ret;
   }, Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    start > this.length && (start = this.length - 1), start < 0 && (start = this.length + start);
    for (var i = 0, walker = this.head; null !== walker && i < start; i++) walker = walker.next;
    var ret = [];
    for (i = 0; walker && i < deleteCount; i++) ret.push(walker.value), walker = this.removeNode(walker);
    null === walker && (walker = this.tail), walker !== this.head && walker !== this.tail && (walker = walker.prev);
    for (i = 0; i < nodes.length; i++) walker = insert(this, walker, nodes[i]);
    return ret;
   }, Yallist.prototype.reverse = function() {
    for (var head = this.head, tail = this.tail, walker = head; null !== walker; walker = walker.prev) {
     var p = walker.prev;
     walker.prev = walker.next, walker.next = p;
    }
    return this.head = tail, this.tail = head, this;
   };
   try {
    __webpack_require__(49602)(Yallist);
   } catch (er) {}
  },
  19605: module => {
   "use strict";
   module.exports = require("@azure/functions-core");
  },
  87913: module => {
   "use strict";
   module.exports = require("@azure/opentelemetry-instrumentation-azure-sdk");
  },
  30874: module => {
   "use strict";
   module.exports = require("@opentelemetry/instrumentation");
  },
  32220: module => {
   "use strict";
   module.exports = require("applicationinsights-native-metrics");
  },
  66828: module => {
   "use strict";
   module.exports = require("vscode");
  },
  39491: module => {
   "use strict";
   module.exports = require("assert");
  },
  50852: module => {
   "use strict";
   module.exports = require("async_hooks");
  },
  14300: module => {
   "use strict";
   module.exports = require("buffer");
  },
  32081: module => {
   "use strict";
   module.exports = require("child_process");
  },
  96206: module => {
   "use strict";
   module.exports = require("console");
  },
  22057: module => {
   "use strict";
   module.exports = require("constants");
  },
  6113: module => {
   "use strict";
   module.exports = require("crypto");
  },
  9523: module => {
   "use strict";
   module.exports = require("dns");
  },
  82361: module => {
   "use strict";
   module.exports = require("events");
  },
  57147: module => {
   "use strict";
   module.exports = require("fs");
  },
  73292: module => {
   "use strict";
   module.exports = require("fs/promises");
  },
  13685: module => {
   "use strict";
   module.exports = require("http");
  },
  95687: module => {
   "use strict";
   module.exports = require("https");
  },
  98188: module => {
   "use strict";
   module.exports = require("module");
  },
  41808: module => {
   "use strict";
   module.exports = require("net");
  },
  97742: module => {
   "use strict";
   module.exports = require("node:process");
  },
  72477: module => {
   "use strict";
   module.exports = require("node:stream/web");
  },
  22037: module => {
   "use strict";
   module.exports = require("os");
  },
  71017: module => {
   "use strict";
   module.exports = require("path");
  },
  12781: module => {
   "use strict";
   module.exports = require("stream");
  },
  39512: module => {
   "use strict";
   module.exports = require("timers");
  },
  24404: module => {
   "use strict";
   module.exports = require("tls");
  },
  76224: module => {
   "use strict";
   module.exports = require("tty");
  },
  57310: module => {
   "use strict";
   module.exports = require("url");
  },
  73837: module => {
   "use strict";
   module.exports = require("util");
  },
  71267: module => {
   "use strict";
   module.exports = require("worker_threads");
  },
  59796: module => {
   "use strict";
   module.exports = require("zlib");
  },
  47135: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
   if (!globalThis.ReadableStream) try {
    const process = __webpack_require__(97742), {emitWarning} = process;
    try {
     process.emitWarning = () => {}, Object.assign(globalThis, __webpack_require__(72477)), 
     process.emitWarning = emitWarning;
    } catch (error) {
     throw process.emitWarning = emitWarning, error;
    }
   } catch (error) {
    Object.assign(globalThis, __webpack_require__(42660));
   }
   try {
    const {Blob} = __webpack_require__(14300);
    Blob && !Blob.prototype.stream && (Blob.prototype.stream = function(params) {
     let position = 0;
     const blob = this;
     return new ReadableStream({
      type: "bytes",
      async pull(ctrl) {
       const chunk = blob.slice(position, Math.min(blob.size, position + 65536)), buffer = await chunk.arrayBuffer();
       position += buffer.byteLength, ctrl.enqueue(new Uint8Array(buffer)), position === blob.size && ctrl.close();
      }
     });
    });
   } catch (error) {}
  },
  74951: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    }), Object.defineProperty(o, k2, desc);
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
     enumerable: !0,
     value: v
    });
   } : function(o, v) {
    o.default = v;
   }), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
   }, __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.sync = exports.isexe = exports.posix = exports.win32 = void 0;
   const posix = __importStar(__webpack_require__(39370));
   exports.posix = posix;
   const win32 = __importStar(__webpack_require__(45975));
   exports.win32 = win32, __exportStar(__webpack_require__(24141), exports);
   const impl = "win32" === (process.env._ISEXE_TEST_PLATFORM_ || process.platform) ? win32 : posix;
   exports.isexe = impl.isexe, exports.sync = impl.sync;
  },
  24141: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  39370: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.sync = exports.isexe = void 0;
   const fs_1 = __webpack_require__(57147), promises_1 = __webpack_require__(73292);
   exports.isexe = async (path, options = {}) => {
    const {ignoreErrors = !1} = options;
    try {
     return checkStat(await (0, promises_1.stat)(path), options);
    } catch (e) {
     const er = e;
     if (ignoreErrors || "EACCES" === er.code) return !1;
     throw er;
    }
   };
   exports.sync = (path, options = {}) => {
    const {ignoreErrors = !1} = options;
    try {
     return checkStat((0, fs_1.statSync)(path), options);
    } catch (e) {
     const er = e;
     if (ignoreErrors || "EACCES" === er.code) return !1;
     throw er;
    }
   };
   const checkStat = (stat, options) => stat.isFile() && checkMode(stat, options), checkMode = (stat, options) => {
    const myUid = options.uid ?? process.getuid?.(), myGroups = options.groups ?? process.getgroups?.() ?? [], myGid = options.gid ?? process.getgid?.() ?? myGroups[0];
    if (void 0 === myUid || void 0 === myGid) throw new Error("cannot get uid or gid");
    const groups = new Set([ myGid, ...myGroups ]), mod = stat.mode, uid = stat.uid, gid = stat.gid, u = parseInt("100", 8), g = parseInt("010", 8), ug = u | g;
    return !!(mod & parseInt("001", 8) || mod & g && groups.has(gid) || mod & u && uid === myUid || mod & ug && 0 === myUid);
   };
  },
  45975: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.sync = exports.isexe = void 0;
   const fs_1 = __webpack_require__(57147), promises_1 = __webpack_require__(73292);
   exports.isexe = async (path, options = {}) => {
    const {ignoreErrors = !1} = options;
    try {
     return checkStat(await (0, promises_1.stat)(path), path, options);
    } catch (e) {
     const er = e;
     if (ignoreErrors || "EACCES" === er.code) return !1;
     throw er;
    }
   };
   exports.sync = (path, options = {}) => {
    const {ignoreErrors = !1} = options;
    try {
     return checkStat((0, fs_1.statSync)(path), path, options);
    } catch (e) {
     const er = e;
     if (ignoreErrors || "EACCES" === er.code) return !1;
     throw er;
    }
   };
   const checkStat = (stat, path, options) => stat.isFile() && ((path, options) => {
    const {pathExt = process.env.PATHEXT || ""} = options, peSplit = pathExt.split(";");
    if (-1 !== peSplit.indexOf("")) return !0;
    for (let i = 0; i < peSplit.length; i++) {
     const p = peSplit[i].toLowerCase(), ext = path.substring(path.length - p.length).toLowerCase();
     if (p && ext === p) return !0;
    }
    return !1;
   })(path, options);
  },
  14139: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(60163), Scalar = __webpack_require__(58844), YAMLMap = __webpack_require__(56575), YAMLSeq = __webpack_require__(13798), resolveBlockMap = __webpack_require__(76933), resolveBlockSeq = __webpack_require__(83179), resolveFlowCollection = __webpack_require__(94658);
   function resolveCollection(CN, ctx, token, onError, tagName, tag) {
    const coll = "block-map" === token.type ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : "block-seq" === token.type ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag), Coll = coll.constructor;
    return "!" === tagName || tagName === Coll.tagName ? (coll.tag = Coll.tagName, coll) : (tagName && (coll.tag = tagName), 
    coll);
   }
   exports.composeCollection = function(CN, ctx, token, tagToken, onError) {
    const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg => onError(tagToken, "TAG_RESOLVE_FAILED", msg))) : null, expType = "block-map" === token.type ? "map" : "block-seq" === token.type ? "seq" : "{" === token.start.source ? "map" : "seq";
    if (!tagToken || !tagName || "!" === tagName || tagName === YAMLMap.YAMLMap.tagName && "map" === expType || tagName === YAMLSeq.YAMLSeq.tagName && "seq" === expType || !expType) return resolveCollection(CN, ctx, token, onError, tagName);
    let tag = ctx.schema.tags.find((t => t.tag === tagName && t.collection === expType));
    if (!tag) {
     const kt = ctx.schema.knownTags[tagName];
     if (!kt || kt.collection !== expType) return kt?.collection ? onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, !0) : onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, !0), 
     resolveCollection(CN, ctx, token, onError, tagName);
     ctx.schema.tags.push(Object.assign({}, kt, {
      default: !1
     })), tag = kt;
    }
    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag), res = tag.resolve?.(coll, (msg => onError(tagToken, "TAG_RESOLVE_FAILED", msg)), ctx.options) ?? coll, node = identity.isNode(res) ? res : new Scalar.Scalar(res);
    return node.range = coll.range, node.tag = tagName, tag?.format && (node.format = tag.format), 
    node;
   };
  },
  83138: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Document = __webpack_require__(86068), composeNode = __webpack_require__(90081), resolveEnd = __webpack_require__(7655), resolveProps = __webpack_require__(5920);
   exports.composeDoc = function(options, directives, {offset, start, value, end}, onError) {
    const opts = Object.assign({
     _directives: directives
    }, options), doc = new Document.Document(void 0, opts), ctx = {
     atRoot: !0,
     directives: doc.directives,
     options: doc.options,
     schema: doc.schema
    }, props = resolveProps.resolveProps(start, {
     indicator: "doc-start",
     next: value ?? end?.[0],
     offset,
     onError,
     startOnNewline: !0
    });
    props.found && (doc.directives.docStart = !0, !value || "block-map" !== value.type && "block-seq" !== value.type || props.hasNewline || onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")), 
    doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2], re = resolveEnd.resolveEnd(end, contentEnd, !1, onError);
    return re.comment && (doc.comment = re.comment), doc.range = [ offset, contentEnd, re.offset ], 
    doc;
   };
  },
  90081: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Alias = __webpack_require__(12055), composeCollection = __webpack_require__(14139), composeScalar = __webpack_require__(76548), resolveEnd = __webpack_require__(7655), utilEmptyScalarPosition = __webpack_require__(7154);
   const CN = {
    composeNode,
    composeEmptyNode
   };
   function composeNode(ctx, token, props, onError) {
    const {spaceBefore, comment, anchor, tag} = props;
    let node, isSrcToken = !0;
    switch (token.type) {
    case "alias":
     node = function({options}, {offset, source, end}, onError) {
      const alias = new Alias.Alias(source.substring(1));
      "" === alias.source && onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
      alias.source.endsWith(":") && onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", !0);
      const valueEnd = offset + source.length, re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
      alias.range = [ offset, valueEnd, re.offset ], re.comment && (alias.comment = re.comment);
      return alias;
     }(ctx, token, onError), (anchor || tag) && onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
     break;

    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
     node = composeScalar.composeScalar(ctx, token, tag, onError), anchor && (node.anchor = anchor.source.substring(1));
     break;

    case "block-map":
    case "block-seq":
    case "flow-collection":
     node = composeCollection.composeCollection(CN, ctx, token, tag, onError), anchor && (node.anchor = anchor.source.substring(1));
     break;

    default:
     onError(token, "UNEXPECTED_TOKEN", "error" === token.type ? token.message : `Unsupported token (type: ${token.type})`), 
     node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError), isSrcToken = !1;
    }
    return anchor && "" === node.anchor && onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string"), 
    spaceBefore && (node.spaceBefore = !0), comment && ("scalar" === token.type && "" === token.source ? node.comment = comment : node.commentBefore = comment), 
    ctx.options.keepSourceTokens && isSrcToken && (node.srcToken = token), node;
   }
   function composeEmptyNode(ctx, offset, before, pos, {spaceBefore, comment, anchor, tag, end}, onError) {
    const token = {
     type: "scalar",
     offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
     indent: -1,
     source: ""
    }, node = composeScalar.composeScalar(ctx, token, tag, onError);
    return anchor && (node.anchor = anchor.source.substring(1), "" === node.anchor && onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string")), 
    spaceBefore && (node.spaceBefore = !0), comment && (node.comment = comment, node.range[2] = end), 
    node;
   }
   exports.composeEmptyNode = composeEmptyNode, exports.composeNode = composeNode;
  },
  76548: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(60163), Scalar = __webpack_require__(58844), resolveBlockScalar = __webpack_require__(51328), resolveFlowScalar = __webpack_require__(7876);
   exports.composeScalar = function(ctx, token, tagToken, onError) {
    const {value, type, comment, range} = "block-scalar" === token.type ? resolveBlockScalar.resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError), tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg => onError(tagToken, "TAG_RESOLVE_FAILED", msg))) : null, tag = tagToken && tagName ? function(schema, value, tagName, tagToken, onError) {
     if ("!" === tagName) return schema[identity.SCALAR];
     const matchWithTest = [];
     for (const tag of schema.tags) if (!tag.collection && tag.tag === tagName) {
      if (!tag.default || !tag.test) return tag;
      matchWithTest.push(tag);
     }
     for (const tag of matchWithTest) if (tag.test?.test(value)) return tag;
     const kt = schema.knownTags[tagName];
     if (kt && !kt.collection) return schema.tags.push(Object.assign({}, kt, {
      default: !1,
      test: void 0
     })), kt;
     return onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, "tag:yaml.org,2002:str" !== tagName), 
     schema[identity.SCALAR];
    }(ctx.schema, value, tagName, tagToken, onError) : "scalar" === token.type ? function({directives, schema}, value, token, onError) {
     const tag = schema.tags.find((tag => tag.default && tag.test?.test(value))) || schema[identity.SCALAR];
     if (schema.compat) {
      const compat = schema.compat.find((tag => tag.default && tag.test?.test(value))) ?? schema[identity.SCALAR];
      if (tag.tag !== compat.tag) {
       onError(token, "TAG_RESOLVE_FAILED", `Value may be parsed as either ${directives.tagString(tag.tag)} or ${directives.tagString(compat.tag)}`, !0);
      }
     }
     return tag;
    }(ctx, value, token, onError) : ctx.schema[identity.SCALAR];
    let scalar;
    try {
     const res = tag.resolve(value, (msg => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg)), ctx.options);
     scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
    } catch (error) {
     const msg = error instanceof Error ? error.message : String(error);
     onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), scalar = new Scalar.Scalar(value);
    }
    return scalar.range = range, scalar.source = value, type && (scalar.type = type), 
    tagName && (scalar.tag = tagName), tag.format && (scalar.format = tag.format), comment && (scalar.comment = comment), 
    scalar;
   };
  },
  5281: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var directives = __webpack_require__(99226), Document = __webpack_require__(86068), errors = __webpack_require__(2394), identity = __webpack_require__(60163), composeDoc = __webpack_require__(83138), resolveEnd = __webpack_require__(7655);
   function getErrorPos(src) {
    if ("number" == typeof src) return [ src, src + 1 ];
    if (Array.isArray(src)) return 2 === src.length ? src : [ src[0], src[1] ];
    const {offset, source} = src;
    return [ offset, offset + ("string" == typeof source ? source.length : 1) ];
   }
   function parsePrelude(prelude) {
    let comment = "", atComment = !1, afterEmptyLine = !1;
    for (let i = 0; i < prelude.length; ++i) {
     const source = prelude[i];
     switch (source[0]) {
     case "#":
      comment += ("" === comment ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " "), 
      atComment = !0, afterEmptyLine = !1;
      break;

     case "%":
      "#" !== prelude[i + 1]?.[0] && (i += 1), atComment = !1;
      break;

     default:
      atComment || (afterEmptyLine = !0), atComment = !1;
     }
    }
    return {
     comment,
     afterEmptyLine
    };
   }
   exports.Composer = class {
    constructor(options = {}) {
     this.doc = null, this.atDirectives = !1, this.prelude = [], this.errors = [], this.warnings = [], 
     this.onError = (source, code, message, warning) => {
      const pos = getErrorPos(source);
      warning ? this.warnings.push(new errors.YAMLWarning(pos, code, message)) : this.errors.push(new errors.YAMLParseError(pos, code, message));
     }, this.directives = new directives.Directives({
      version: options.version || "1.2"
     }), this.options = options;
    }
    decorate(doc, afterDoc) {
     const {comment, afterEmptyLine} = parsePrelude(this.prelude);
     if (comment) {
      const dc = doc.contents;
      if (afterDoc) doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment; else if (afterEmptyLine || doc.directives.docStart || !dc) doc.commentBefore = comment; else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
       let it = dc.items[0];
       identity.isPair(it) && (it = it.key);
       const cb = it.commentBefore;
       it.commentBefore = cb ? `${comment}\n${cb}` : comment;
      } else {
       const cb = dc.commentBefore;
       dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
      }
     }
     afterDoc ? (Array.prototype.push.apply(doc.errors, this.errors), Array.prototype.push.apply(doc.warnings, this.warnings)) : (doc.errors = this.errors, 
     doc.warnings = this.warnings), this.prelude = [], this.errors = [], this.warnings = [];
    }
    streamInfo() {
     return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
     };
    }
    * compose(tokens, forceDoc = !1, endOffset = -1) {
     for (const token of tokens) yield* this.next(token);
     yield* this.end(forceDoc, endOffset);
    }
    * next(token) {
     switch (process.env.LOG_STREAM && console.dir(token, {
      depth: null
     }), token.type) {
     case "directive":
      this.directives.add(token.source, ((offset, message, warning) => {
       const pos = getErrorPos(token);
       pos[0] += offset, this.onError(pos, "BAD_DIRECTIVE", message, warning);
      })), this.prelude.push(token.source), this.atDirectives = !0;
      break;

     case "document":
      {
       const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
       this.atDirectives && !doc.directives.docStart && this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"), 
       this.decorate(doc, !1), this.doc && (yield this.doc), this.doc = doc, this.atDirectives = !1;
       break;
      }

     case "byte-order-mark":
     case "space":
      break;

     case "comment":
     case "newline":
      this.prelude.push(token.source);
      break;

     case "error":
      {
       const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message, error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
       this.atDirectives || !this.doc ? this.errors.push(error) : this.doc.errors.push(error);
       break;
      }

     case "doc-end":
      {
       if (!this.doc) {
        const msg = "Unexpected doc-end without preceding document";
        this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
        break;
       }
       this.doc.directives.docEnd = !0;
       const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
       if (this.decorate(this.doc, !0), end.comment) {
        const dc = this.doc.comment;
        this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
       }
       this.doc.range[2] = end.offset;
       break;
      }

     default:
      this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
     }
    }
    * end(forceDoc = !1, endOffset = -1) {
     if (this.doc) this.decorate(this.doc, !0), yield this.doc, this.doc = null; else if (forceDoc) {
      const opts = Object.assign({
       _directives: this.directives
      }, this.options), doc = new Document.Document(void 0, opts);
      this.atDirectives && this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line"), 
      doc.range = [ 0, endOffset, endOffset ], this.decorate(doc, !1), yield doc;
     }
    }
   };
  },
  76933: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Pair = __webpack_require__(10394), YAMLMap = __webpack_require__(56575), resolveProps = __webpack_require__(5920), utilContainsNewline = __webpack_require__(93094), utilFlowIndentCheck = __webpack_require__(72566), utilMapIncludes = __webpack_require__(96493);
   const startColMsg = "All mapping items must start at the same column";
   exports.resolveBlockMap = function({composeNode, composeEmptyNode}, ctx, bm, onError, tag) {
    const map = new (tag?.nodeClass ?? YAMLMap.YAMLMap)(ctx.schema);
    ctx.atRoot && (ctx.atRoot = !1);
    let offset = bm.offset, commentEnd = null;
    for (const collItem of bm.items) {
     const {start, key, sep, value} = collItem, keyProps = resolveProps.resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key ?? sep?.[0],
      offset,
      onError,
      startOnNewline: !0
     }), implicitKey = !keyProps.found;
     if (implicitKey) {
      if (key && ("block-seq" === key.type ? onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key") : "indent" in key && key.indent !== bm.indent && onError(offset, "BAD_INDENT", startColMsg)), 
      !keyProps.anchor && !keyProps.tag && !sep) {
       commentEnd = keyProps.end, keyProps.comment && (map.comment ? map.comment += "\n" + keyProps.comment : map.comment = keyProps.comment);
       continue;
      }
      (keyProps.hasNewlineAfterProp || utilContainsNewline.containsNewline(key)) && onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
     } else keyProps.found?.indent !== bm.indent && onError(offset, "BAD_INDENT", startColMsg);
     const keyStart = keyProps.end, keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
     ctx.schema.compat && utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError), 
     utilMapIncludes.mapIncludes(ctx, map.items, keyNode) && onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
     const valueProps = resolveProps.resolveProps(sep ?? [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      startOnNewline: !key || "block-scalar" === key.type
     });
     if (offset = valueProps.end, valueProps.found) {
      implicitKey && ("block-map" !== value?.type || valueProps.hasNewline || onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"), 
      ctx.options.strict && keyProps.start < valueProps.found.offset - 1024 && onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));
      const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
      ctx.schema.compat && utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError), 
      offset = valueNode.range[2];
      const pair = new Pair.Pair(keyNode, valueNode);
      ctx.options.keepSourceTokens && (pair.srcToken = collItem), map.items.push(pair);
     } else {
      implicitKey && onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"), 
      valueProps.comment && (keyNode.comment ? keyNode.comment += "\n" + valueProps.comment : keyNode.comment = valueProps.comment);
      const pair = new Pair.Pair(keyNode);
      ctx.options.keepSourceTokens && (pair.srcToken = collItem), map.items.push(pair);
     }
    }
    return commentEnd && commentEnd < offset && onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content"), 
    map.range = [ bm.offset, offset, commentEnd ?? offset ], map;
   };
  },
  51328: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Scalar = __webpack_require__(58844);
   exports.resolveBlockScalar = function(scalar, strict, onError) {
    const start = scalar.offset, header = function({offset, props}, strict, onError) {
     if ("block-scalar-header" !== props[0].type) return onError(props[0], "IMPOSSIBLE", "Block scalar header not found"), 
     null;
     const {source} = props[0], mode = source[0];
     let indent = 0, chomp = "", error = -1;
     for (let i = 1; i < source.length; ++i) {
      const ch = source[i];
      if (chomp || "-" !== ch && "+" !== ch) {
       const n = Number(ch);
       !indent && n ? indent = n : -1 === error && (error = offset + i);
      } else chomp = ch;
     }
     -1 !== error && onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
     let hasSpace = !1, comment = "", length = source.length;
     for (let i = 1; i < props.length; ++i) {
      const token = props[i];
      switch (token.type) {
      case "space":
       hasSpace = !0;

      case "newline":
       length += token.source.length;
       break;

      case "comment":
       if (strict && !hasSpace) {
        onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
       }
       length += token.source.length, comment = token.source.substring(1);
       break;

      case "error":
       onError(token, "UNEXPECTED_TOKEN", token.message), length += token.source.length;
       break;

      default:
       {
        onError(token, "UNEXPECTED_TOKEN", `Unexpected token in block scalar header: ${token.type}`);
        const ts = token.source;
        ts && "string" == typeof ts && (length += ts.length);
       }
      }
     }
     return {
      mode,
      indent,
      chomp,
      comment,
      length
     };
    }(scalar, strict, onError);
    if (!header) return {
     value: "",
     type: null,
     comment: "",
     range: [ start, start, start ]
    };
    const type = ">" === header.mode ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL, lines = scalar.source ? function(source) {
     const split = source.split(/\n( *)/), first = split[0], m = first.match(/^( *)/), lines = [ m?.[1] ? [ m[1], first.slice(m[1].length) ] : [ "", first ] ];
     for (let i = 1; i < split.length; i += 2) lines.push([ split[i], split[i + 1] ]);
     return lines;
    }(scalar.source) : [];
    let chompStart = lines.length;
    for (let i = lines.length - 1; i >= 0; --i) {
     const content = lines[i][1];
     if ("" !== content && "\r" !== content) break;
     chompStart = i;
    }
    if (0 === chompStart) {
     const value = "+" === header.chomp && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
     let end = start + header.length;
     return scalar.source && (end += scalar.source.length), {
      value,
      type,
      comment: header.comment,
      range: [ start, end, end ]
     };
    }
    let trimIndent = scalar.indent + header.indent, offset = scalar.offset + header.length, contentStart = 0;
    for (let i = 0; i < chompStart; ++i) {
     const [indent, content] = lines[i];
     if ("" !== content && "\r" !== content) {
      if (indent.length < trimIndent) {
       const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
       onError(offset + indent.length, "MISSING_CHAR", message);
      }
      0 === header.indent && (trimIndent = indent.length), contentStart = i;
      break;
     }
     0 === header.indent && indent.length > trimIndent && (trimIndent = indent.length), 
     offset += indent.length + content.length + 1;
    }
    for (let i = lines.length - 1; i >= chompStart; --i) lines[i][0].length > trimIndent && (chompStart = i + 1);
    let value = "", sep = "", prevMoreIndented = !1;
    for (let i = 0; i < contentStart; ++i) value += lines[i][0].slice(trimIndent) + "\n";
    for (let i = contentStart; i < chompStart; ++i) {
     let [indent, content] = lines[i];
     offset += indent.length + content.length + 1;
     const crlf = "\r" === content[content.length - 1];
     if (crlf && (content = content.slice(0, -1)), content && indent.length < trimIndent) {
      const message = `Block scalar lines must not be less indented than their ${header.indent ? "explicit indentation indicator" : "first line"}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message), indent = "";
     }
     type === Scalar.Scalar.BLOCK_LITERAL ? (value += sep + indent.slice(trimIndent) + content, 
     sep = "\n") : indent.length > trimIndent || "\t" === content[0] ? (" " === sep ? sep = "\n" : prevMoreIndented || "\n" !== sep || (sep = "\n\n"), 
     value += sep + indent.slice(trimIndent) + content, sep = "\n", prevMoreIndented = !0) : "" === content ? "\n" === sep ? value += "\n" : sep = "\n" : (value += sep + content, 
     sep = " ", prevMoreIndented = !1);
    }
    switch (header.chomp) {
    case "-":
     break;

    case "+":
     for (let i = chompStart; i < lines.length; ++i) value += "\n" + lines[i][0].slice(trimIndent);
     "\n" !== value[value.length - 1] && (value += "\n");
     break;

    default:
     value += "\n";
    }
    const end = start + header.length + scalar.source.length;
    return {
     value,
     type,
     comment: header.comment,
     range: [ start, end, end ]
    };
   };
  },
  83179: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var YAMLSeq = __webpack_require__(13798), resolveProps = __webpack_require__(5920), utilFlowIndentCheck = __webpack_require__(72566);
   exports.resolveBlockSeq = function({composeNode, composeEmptyNode}, ctx, bs, onError, tag) {
    const seq = new (tag?.nodeClass ?? YAMLSeq.YAMLSeq)(ctx.schema);
    ctx.atRoot && (ctx.atRoot = !1);
    let offset = bs.offset, commentEnd = null;
    for (const {start, value} of bs.items) {
     const props = resolveProps.resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      startOnNewline: !0
     });
     if (!props.found) {
      if (!(props.anchor || props.tag || value)) {
       commentEnd = props.end, props.comment && (seq.comment = props.comment);
       continue;
      }
      value && "block-seq" === value.type ? onError(props.end, "BAD_INDENT", "All sequence items must start at the same column") : onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
     }
     const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
     ctx.schema.compat && utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError), 
     offset = node.range[2], seq.items.push(node);
    }
    return seq.range = [ bs.offset, offset, commentEnd ?? offset ], seq;
   };
  },
  7655: (__unused_webpack_module, exports) => {
   "use strict";
   exports.resolveEnd = function(end, offset, reqSpace, onError) {
    let comment = "";
    if (end) {
     let hasSpace = !1, sep = "";
     for (const token of end) {
      const {source, type} = token;
      switch (type) {
      case "space":
       hasSpace = !0;
       break;

      case "comment":
       {
        reqSpace && !hasSpace && onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = source.substring(1) || " ";
        comment ? comment += sep + cb : comment = cb, sep = "";
        break;
       }

      case "newline":
       comment && (sep += source), hasSpace = !0;
       break;

      default:
       onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
     }
    }
    return {
     comment,
     offset
    };
   };
  },
  94658: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(60163), Pair = __webpack_require__(10394), YAMLMap = __webpack_require__(56575), YAMLSeq = __webpack_require__(13798), resolveEnd = __webpack_require__(7655), resolveProps = __webpack_require__(5920), utilContainsNewline = __webpack_require__(93094), utilMapIncludes = __webpack_require__(96493);
   const blockMsg = "Block collections are not allowed within flow collections", isBlock = token => token && ("block-map" === token.type || "block-seq" === token.type);
   exports.resolveFlowCollection = function({composeNode, composeEmptyNode}, ctx, fc, onError, tag) {
    const isMap = "{" === fc.start.source, fcName = isMap ? "flow map" : "flow sequence", coll = new (tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq))(ctx.schema);
    coll.flow = !0;
    const atRoot = ctx.atRoot;
    atRoot && (ctx.atRoot = !1);
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0; i < fc.items.length; ++i) {
     const collItem = fc.items[i], {start, key, sep, value} = collItem, props = resolveProps.resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key ?? sep?.[0],
      offset,
      onError,
      startOnNewline: !1
     });
     if (!props.found) {
      if (!(props.anchor || props.tag || sep || value)) {
       0 === i && props.comma ? onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`) : i < fc.items.length - 1 && onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`), 
       props.comment && (coll.comment ? coll.comment += "\n" + props.comment : coll.comment = props.comment), 
       offset = props.end;
       continue;
      }
      !isMap && ctx.options.strict && utilContainsNewline.containsNewline(key) && onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
     }
     if (0 === i) props.comma && onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`); else if (props.comma || onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`), 
     props.comment) {
      let prevItemComment = "";
      loop: for (const st of start) switch (st.type) {
      case "comma":
      case "space":
       break;

      case "comment":
       prevItemComment = st.source.substring(1);
       break loop;

      default:
       break loop;
      }
      if (prevItemComment) {
       let prev = coll.items[coll.items.length - 1];
       identity.isPair(prev) && (prev = prev.value ?? prev.key), prev.comment ? prev.comment += "\n" + prevItemComment : prev.comment = prevItemComment, 
       props.comment = props.comment.substring(prevItemComment.length + 1);
      }
     }
     if (isMap || sep || props.found) {
      const keyStart = props.end, keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
      isBlock(key) && onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      const valueProps = resolveProps.resolveProps(sep ?? [], {
       flow: fcName,
       indicator: "map-value-ind",
       next: value,
       offset: keyNode.range[2],
       onError,
       startOnNewline: !1
      });
      if (valueProps.found) {
       if (!isMap && !props.found && ctx.options.strict) {
        if (sep) for (const st of sep) {
         if (st === valueProps.found) break;
         if ("newline" === st.type) {
          onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
          break;
         }
        }
        props.start < valueProps.found.offset - 1024 && onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
       }
      } else value && ("source" in value && value.source && ":" === value.source[0] ? onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`) : onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`));
      const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      valueNode ? isBlock(value) && onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg) : valueProps.comment && (keyNode.comment ? keyNode.comment += "\n" + valueProps.comment : keyNode.comment = valueProps.comment);
      const pair = new Pair.Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens && (pair.srcToken = collItem), isMap) {
       const map = coll;
       utilMapIncludes.mapIncludes(ctx, map.items, keyNode) && onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique"), 
       map.items.push(pair);
      } else {
       const map = new YAMLMap.YAMLMap(ctx.schema);
       map.flow = !0, map.items.push(pair), coll.items.push(map);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
     } else {
      const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode), offset = valueNode.range[2], isBlock(value) && onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
     }
    }
    const expectedEnd = isMap ? "}" : "]", [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd) cePos = ce.offset + ce.source.length; else {
     const name = fcName[0].toUpperCase() + fcName.substring(1);
     onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`), 
     ce && 1 !== ce.source.length && ee.unshift(ce);
    }
    if (ee.length > 0) {
     const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
     end.comment && (coll.comment ? coll.comment += "\n" + end.comment : coll.comment = end.comment), 
     coll.range = [ fc.offset, cePos, end.offset ];
    } else coll.range = [ fc.offset, cePos, cePos ];
    return coll;
   };
  },
  7876: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Scalar = __webpack_require__(58844), resolveEnd = __webpack_require__(7655);
   function foldLines(source) {
    let first, line;
    try {
     first = new RegExp("(.*?)(?<![ \t])[ \t]*\r?\n", "sy"), line = new RegExp("[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n", "sy");
    } catch (_) {
     first = /(.*?)[ \t]*\r?\n/sy, line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match) return source;
    let res = match[1], sep = " ", pos = first.lastIndex;
    for (line.lastIndex = pos; match = line.exec(source); ) "" === match[1] ? "\n" === sep ? res += sep : sep = "\n" : (res += sep + match[1], 
    sep = " "), pos = line.lastIndex;
    const last = /[ \t]*(.*)/sy;
    return last.lastIndex = pos, match = last.exec(source), res + sep + (match?.[1] ?? "");
   }
   function foldNewline(source, offset) {
    let fold = "", ch = source[offset + 1];
    for (;!(" " !== ch && "\t" !== ch && "\n" !== ch && "\r" !== ch || "\r" === ch && "\n" !== source[offset + 2]); ) "\n" === ch && (fold += "\n"), 
    ch = source[(offset += 1) + 1];
    return fold || (fold = " "), {
     fold,
     offset
    };
   }
   const escapeCodes = {
    0: "\0",
    a: "",
    b: "\b",
    e: "",
    f: "\f",
    n: "\n",
    r: "\r",
    t: "\t",
    v: "\v",
    N: "",
    _: " ",
    L: "\u2028",
    P: "\u2029",
    " ": " ",
    '"': '"',
    "/": "/",
    "\\": "\\",
    "\t": "\t"
   };
   function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length), code = cc.length === length && /^[0-9a-fA-F]+$/.test(cc) ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
     const raw = source.substr(offset - 2, length + 2);
     return onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`), raw;
    }
    return String.fromCodePoint(code);
   }
   exports.resolveFlowScalar = function(scalar, strict, onError) {
    const {offset, type, source, end} = scalar;
    let _type, value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
    case "scalar":
     _type = Scalar.Scalar.PLAIN, value = function(source, onError) {
      let badChar = "";
      switch (source[0]) {
      case "\t":
       badChar = "a tab character";
       break;

      case ",":
       badChar = "flow indicator character ,";
       break;

      case "%":
       badChar = "directive indicator character %";
       break;

      case "|":
      case ">":
       badChar = `block scalar indicator ${source[0]}`;
       break;

      case "@":
      case "`":
       badChar = `reserved character ${source[0]}`;
      }
      badChar && onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
      return foldLines(source);
     }(source, _onError);
     break;

    case "single-quoted-scalar":
     _type = Scalar.Scalar.QUOTE_SINGLE, value = function(source, onError) {
      "'" === source[source.length - 1] && 1 !== source.length || onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
      return foldLines(source.slice(1, -1)).replace(/''/g, "'");
     }(source, _onError);
     break;

    case "double-quoted-scalar":
     _type = Scalar.Scalar.QUOTE_DOUBLE, value = function(source, onError) {
      let res = "";
      for (let i = 1; i < source.length - 1; ++i) {
       const ch = source[i];
       if ("\r" !== ch || "\n" !== source[i + 1]) if ("\n" === ch) {
        const {fold, offset} = foldNewline(source, i);
        res += fold, i = offset;
       } else if ("\\" === ch) {
        let next = source[++i];
        const cc = escapeCodes[next];
        if (cc) res += cc; else if ("\n" === next) for (next = source[i + 1]; " " === next || "\t" === next; ) next = source[1 + ++i]; else if ("\r" === next && "\n" === source[i + 1]) for (next = source[1 + ++i]; " " === next || "\t" === next; ) next = source[1 + ++i]; else if ("x" === next || "u" === next || "U" === next) {
         const length = {
          x: 2,
          u: 4,
          U: 8
         }[next];
         res += parseCharCode(source, i + 1, length, onError), i += length;
        } else {
         const raw = source.substr(i - 1, 2);
         onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`), res += raw;
        }
       } else if (" " === ch || "\t" === ch) {
        const wsStart = i;
        let next = source[i + 1];
        for (;" " === next || "\t" === next; ) next = source[1 + ++i];
        "\n" === next || "\r" === next && "\n" === source[i + 2] || (res += i > wsStart ? source.slice(wsStart, i + 1) : ch);
       } else res += ch;
      }
      '"' === source[source.length - 1] && 1 !== source.length || onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
      return res;
     }(source, _onError);
     break;

    default:
     return onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`), 
     {
      value: "",
      type: null,
      comment: "",
      range: [ offset, offset + source.length, offset + source.length ]
     };
    }
    const valueEnd = offset + source.length, re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
    return {
     value,
     type: _type,
     comment: re.comment,
     range: [ offset, valueEnd, re.offset ]
    };
   };
  },
  5920: (__unused_webpack_module, exports) => {
   "use strict";
   exports.resolveProps = function(tokens, {flow, indicator, next, offset, onError, startOnNewline}) {
    let spaceBefore = !1, atNewline = startOnNewline, hasSpace = startOnNewline, comment = "", commentSep = "", hasNewline = !1, hasNewlineAfterProp = !1, reqSpace = !1, anchor = null, tag = null, comma = null, found = null, start = null;
    for (const token of tokens) switch (reqSpace && ("space" !== token.type && "newline" !== token.type && "comma" !== token.type && onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), 
    reqSpace = !1), token.type) {
    case "space":
     !flow && atNewline && "doc-start" !== indicator && "\t" === token.source[0] && onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), 
     hasSpace = !0;
     break;

    case "comment":
     {
      hasSpace || onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
      const cb = token.source.substring(1) || " ";
      comment ? comment += commentSep + cb : comment = cb, commentSep = "", atNewline = !1;
      break;
     }

    case "newline":
     atNewline ? comment ? comment += token.source : spaceBefore = !0 : commentSep += token.source, 
     atNewline = !0, hasNewline = !0, (anchor || tag) && (hasNewlineAfterProp = !0), 
     hasSpace = !0;
     break;

    case "anchor":
     anchor && onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor"), 
     token.source.endsWith(":") && onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", !0), 
     anchor = token, null === start && (start = token.offset), atNewline = !1, hasSpace = !1, 
     reqSpace = !0;
     break;

    case "tag":
     tag && onError(token, "MULTIPLE_TAGS", "A node can have at most one tag"), tag = token, 
     null === start && (start = token.offset), atNewline = !1, hasSpace = !1, reqSpace = !0;
     break;

    case indicator:
     (anchor || tag) && onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`), 
     found && onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`), 
     found = token, atNewline = !1, hasSpace = !1;
     break;

    case "comma":
     if (flow) {
      comma && onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`), comma = token, 
      atNewline = !1, hasSpace = !1;
      break;
     }

    default:
     onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`), atNewline = !1, 
     hasSpace = !1;
    }
    const last = tokens[tokens.length - 1], end = last ? last.offset + last.source.length : offset;
    return reqSpace && next && "space" !== next.type && "newline" !== next.type && "comma" !== next.type && ("scalar" !== next.type || "" !== next.source) && onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), 
    {
     comma,
     found,
     spaceBefore,
     comment,
     hasNewline,
     hasNewlineAfterProp,
     anchor,
     tag,
     end,
     start: start ?? end
    };
   };
  },
  93094: (__unused_webpack_module, exports) => {
   "use strict";
   exports.containsNewline = function containsNewline(key) {
    if (!key) return null;
    switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
     if (key.source.includes("\n")) return !0;
     if (key.end) for (const st of key.end) if ("newline" === st.type) return !0;
     return !1;

    case "flow-collection":
     for (const it of key.items) {
      for (const st of it.start) if ("newline" === st.type) return !0;
      if (it.sep) for (const st of it.sep) if ("newline" === st.type) return !0;
      if (containsNewline(it.key) || containsNewline(it.value)) return !0;
     }
     return !1;

    default:
     return !0;
    }
   };
  },
  7154: (__unused_webpack_module, exports) => {
   "use strict";
   exports.emptyScalarPosition = function(offset, before, pos) {
    if (before) {
     null === pos && (pos = before.length);
     for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
      case "space":
      case "comment":
      case "newline":
       offset -= st.source.length;
       continue;
      }
      for (st = before[++i]; "space" === st?.type; ) offset += st.source.length, st = before[++i];
      break;
     }
    }
    return offset;
   };
  },
  72566: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var utilContainsNewline = __webpack_require__(93094);
   exports.flowIndentCheck = function(indent, fc, onError) {
    if ("flow-collection" === fc?.type) {
     const end = fc.end[0];
     if (end.indent === indent && ("]" === end.source || "}" === end.source) && utilContainsNewline.containsNewline(fc)) {
      onError(end, "BAD_INDENT", "Flow end indicator should be more indented than parent", !0);
     }
    }
   };
  },
  96493: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(60163);
   exports.mapIncludes = function(ctx, items, search) {
    const {uniqueKeys} = ctx.options;
    if (!1 === uniqueKeys) return !1;
    const isEqual = "function" == typeof uniqueKeys ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value && !("<<" === a.value && ctx.schema.merge);
    return items.some((pair => isEqual(pair.key, search)));
   };
  },
  86068: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Alias = __webpack_require__(12055), Collection = __webpack_require__(43365), identity = __webpack_require__(60163), Pair = __webpack_require__(10394), toJS = __webpack_require__(93257), Schema = __webpack_require__(23673), stringifyDocument = __webpack_require__(89957), anchors = __webpack_require__(21903), applyReviver = __webpack_require__(33085), createNode = __webpack_require__(87581), directives = __webpack_require__(99226);
   class Document {
    constructor(value, replacer, options) {
     this.commentBefore = null, this.comment = null, this.errors = [], this.warnings = [], 
     Object.defineProperty(this, identity.NODE_TYPE, {
      value: identity.DOC
     });
     let _replacer = null;
     "function" == typeof replacer || Array.isArray(replacer) ? _replacer = replacer : void 0 === options && replacer && (options = replacer, 
     replacer = void 0);
     const opt = Object.assign({
      intAsBigInt: !1,
      keepSourceTokens: !1,
      logLevel: "warn",
      prettyErrors: !0,
      strict: !0,
      uniqueKeys: !0,
      version: "1.2"
     }, options);
     this.options = opt;
     let {version} = opt;
     options?._directives ? (this.directives = options._directives.atDocument(), this.directives.yaml.explicit && (version = this.directives.yaml.version)) : this.directives = new directives.Directives({
      version
     }), this.setSchema(version, options), this.contents = void 0 === value ? null : this.createNode(value, _replacer, options);
    }
    clone() {
     const copy = Object.create(Document.prototype, {
      [identity.NODE_TYPE]: {
       value: identity.DOC
      }
     });
     return copy.commentBefore = this.commentBefore, copy.comment = this.comment, copy.errors = this.errors.slice(), 
     copy.warnings = this.warnings.slice(), copy.options = Object.assign({}, this.options), 
     this.directives && (copy.directives = this.directives.clone()), copy.schema = this.schema.clone(), 
     copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents, 
     this.range && (copy.range = this.range.slice()), copy;
    }
    add(value) {
     assertCollection(this.contents) && this.contents.add(value);
    }
    addIn(path, value) {
     assertCollection(this.contents) && this.contents.addIn(path, value);
    }
    createAlias(node, name) {
     if (!node.anchor) {
      const prev = anchors.anchorNames(this);
      node.anchor = !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
     }
     return new Alias.Alias(node.anchor);
    }
    createNode(value, replacer, options) {
     let _replacer;
     if ("function" == typeof replacer) value = replacer.call({
      "": value
     }, "", value), _replacer = replacer; else if (Array.isArray(replacer)) {
      const keyToStr = v => "number" == typeof v || v instanceof String || v instanceof Number, asStr = replacer.filter(keyToStr).map(String);
      asStr.length > 0 && (replacer = replacer.concat(asStr)), _replacer = replacer;
     } else void 0 === options && replacer && (options = replacer, replacer = void 0);
     const {aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag} = options ?? {}, {onAnchor, setAnchors, sourceObjects} = anchors.createNodeAnchors(this, anchorPrefix || "a"), ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects ?? !0,
      keepUndefined: keepUndefined ?? !1,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
     }, node = createNode.createNode(value, tag, ctx);
     return flow && identity.isCollection(node) && (node.flow = !0), setAnchors(), node;
    }
    createPair(key, value, options = {}) {
     const k = this.createNode(key, null, options), v = this.createNode(value, null, options);
     return new Pair.Pair(k, v);
    }
    delete(key) {
     return !!assertCollection(this.contents) && this.contents.delete(key);
    }
    deleteIn(path) {
     return Collection.isEmptyPath(path) ? null != this.contents && (this.contents = null, 
     !0) : !!assertCollection(this.contents) && this.contents.deleteIn(path);
    }
    get(key, keepScalar) {
     return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
    }
    getIn(path, keepScalar) {
     return Collection.isEmptyPath(path) ? !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents : identity.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
    }
    has(key) {
     return !!identity.isCollection(this.contents) && this.contents.has(key);
    }
    hasIn(path) {
     return Collection.isEmptyPath(path) ? void 0 !== this.contents : !!identity.isCollection(this.contents) && this.contents.hasIn(path);
    }
    set(key, value) {
     null == this.contents ? this.contents = Collection.collectionFromPath(this.schema, [ key ], value) : assertCollection(this.contents) && this.contents.set(key, value);
    }
    setIn(path, value) {
     Collection.isEmptyPath(path) ? this.contents = value : null == this.contents ? this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value) : assertCollection(this.contents) && this.contents.setIn(path, value);
    }
    setSchema(version, options = {}) {
     let opt;
     switch ("number" == typeof version && (version = String(version)), version) {
     case "1.1":
      this.directives ? this.directives.yaml.version = "1.1" : this.directives = new directives.Directives({
       version: "1.1"
      }), opt = {
       merge: !0,
       resolveKnownTags: !1,
       schema: "yaml-1.1"
      };
      break;

     case "1.2":
     case "next":
      this.directives ? this.directives.yaml.version = version : this.directives = new directives.Directives({
       version
      }), opt = {
       merge: !1,
       resolveKnownTags: !0,
       schema: "core"
      };
      break;

     case null:
      this.directives && delete this.directives, opt = null;
      break;

     default:
      {
       const sv = JSON.stringify(version);
       throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
     }
     if (options.schema instanceof Object) this.schema = options.schema; else {
      if (!opt) throw new Error("With a null YAML version, the { schema: Schema } option is required");
      this.schema = new Schema.Schema(Object.assign(opt, options));
     }
    }
    toJS({json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver} = {}) {
     const ctx = {
      anchors: new Map,
      doc: this,
      keep: !json,
      mapAsMap: !0 === mapAsMap,
      mapKeyWarned: !1,
      maxAliasCount: "number" == typeof maxAliasCount ? maxAliasCount : 100
     }, res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
     if ("function" == typeof onAnchor) for (const {count, res} of ctx.anchors.values()) onAnchor(res, count);
     return "function" == typeof reviver ? applyReviver.applyReviver(reviver, {
      "": res
     }, "", res) : res;
    }
    toJSON(jsonArg, onAnchor) {
     return this.toJS({
      json: !0,
      jsonArg,
      mapAsMap: !1,
      onAnchor
     });
    }
    toString(options = {}) {
     if (this.errors.length > 0) throw new Error("Document with errors cannot be stringified");
     if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
      const s = JSON.stringify(options.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
     }
     return stringifyDocument.stringifyDocument(this, options);
    }
   }
   function assertCollection(contents) {
    if (identity.isCollection(contents)) return !0;
    throw new Error("Expected a YAML collection as document contents");
   }
   exports.Document = Document;
  },
  21903: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(60163), visit = __webpack_require__(81381);
   function anchorNames(root) {
    const anchors = new Set;
    return visit.visit(root, {
     Value(_key, node) {
      node.anchor && anchors.add(node.anchor);
     }
    }), anchors;
   }
   function findNewAnchor(prefix, exclude) {
    for (let i = 1; ;++i) {
     const name = `${prefix}${i}`;
     if (!exclude.has(name)) return name;
    }
   }
   exports.anchorIsValid = function(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
     const sa = JSON.stringify(anchor);
     throw new Error(`Anchor must not contain whitespace or control characters: ${sa}`);
    }
    return !0;
   }, exports.anchorNames = anchorNames, exports.createNodeAnchors = function(doc, prefix) {
    const aliasObjects = [], sourceObjects = new Map;
    let prevAnchors = null;
    return {
     onAnchor: source => {
      aliasObjects.push(source), prevAnchors || (prevAnchors = anchorNames(doc));
      const anchor = findNewAnchor(prefix, prevAnchors);
      return prevAnchors.add(anchor), anchor;
     },
     setAnchors: () => {
      for (const source of aliasObjects) {
       const ref = sourceObjects.get(source);
       if ("object" != typeof ref || !ref.anchor || !identity.isScalar(ref.node) && !identity.isCollection(ref.node)) {
        const error = new Error("Failed to resolve repeated object (this should not happen)");
        throw error.source = source, error;
       }
       ref.node.anchor = ref.anchor;
      }
     },
     sourceObjects
    };
   }, exports.findNewAnchor = findNewAnchor;
  },
  33085: (__unused_webpack_module, exports) => {
   "use strict";
   exports.applyReviver = function applyReviver(reviver, obj, key, val) {
    if (val && "object" == typeof val) if (Array.isArray(val)) for (let i = 0, len = val.length; i < len; ++i) {
     const v0 = val[i], v1 = applyReviver(reviver, val, String(i), v0);
     void 0 === v1 ? delete val[i] : v1 !== v0 && (val[i] = v1);
    } else if (val instanceof Map) for (const k of Array.from(val.keys())) {
     const v0 = val.get(k), v1 = applyReviver(reviver, val, k, v0);
     void 0 === v1 ? val.delete(k) : v1 !== v0 && val.set(k, v1);
    } else if (val instanceof Set) for (const v0 of Array.from(val)) {
     const v1 = applyReviver(reviver, val, v0, v0);
     void 0 === v1 ? val.delete(v0) : v1 !== v0 && (val.delete(v0), val.add(v1));
    } else for (const [k, v0] of Object.entries(val)) {
     const v1 = applyReviver(reviver, val, k, v0);
     void 0 === v1 ? delete val[k] : v1 !== v0 && (val[k] = v1);
    }
    return reviver.call(obj, key, val);
   };
  },
  87581: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Alias = __webpack_require__(12055), identity = __webpack_require__(60163), Scalar = __webpack_require__(58844);
   exports.createNode = function(value, tagName, ctx) {
    if (identity.isDocument(value) && (value = value.contents), identity.isNode(value)) return value;
    if (identity.isPair(value)) {
     const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
     return map.items.push(value), map;
    }
    (value instanceof String || value instanceof Number || value instanceof Boolean || "undefined" != typeof BigInt && value instanceof BigInt) && (value = value.valueOf());
    const {aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects} = ctx;
    let ref;
    if (aliasDuplicateObjects && value && "object" == typeof value) {
     if (ref = sourceObjects.get(value), ref) return ref.anchor || (ref.anchor = onAnchor(value)), 
     new Alias.Alias(ref.anchor);
     ref = {
      anchor: null,
      node: null
     }, sourceObjects.set(value, ref);
    }
    tagName?.startsWith("!!") && (tagName = "tag:yaml.org,2002:" + tagName.slice(2));
    let tagObj = function(value, tagName, tags) {
     if (tagName) {
      const match = tags.filter((t => t.tag === tagName)), tagObj = match.find((t => !t.format)) ?? match[0];
      if (!tagObj) throw new Error(`Tag ${tagName} not found`);
      return tagObj;
     }
     return tags.find((t => t.identify?.(value) && !t.format));
    }(value, tagName, schema.tags);
    if (!tagObj) {
     if (value && "function" == typeof value.toJSON && (value = value.toJSON()), !value || "object" != typeof value) {
      const node = new Scalar.Scalar(value);
      return ref && (ref.node = node), node;
     }
     tagObj = value instanceof Map ? schema[identity.MAP] : Symbol.iterator in Object(value) ? schema[identity.SEQ] : schema[identity.MAP];
    }
    onTagObj && (onTagObj(tagObj), delete ctx.onTagObj);
    const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : "function" == typeof tagObj?.nodeClass?.from ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
    return tagName ? node.tag = tagName : tagObj.default || (node.tag = tagObj.tag), 
    ref && (ref.node = node), node;
   };
  },
  99226: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(60163), visit = __webpack_require__(81381);
   const escapeChars = {
    "!": "%21",
    ",": "%2C",
    "[": "%5B",
    "]": "%5D",
    "{": "%7B",
    "}": "%7D"
   };
   class Directives {
    constructor(yaml, tags) {
     this.docStart = null, this.docEnd = !1, this.yaml = Object.assign({}, Directives.defaultYaml, yaml), 
     this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
     const copy = new Directives(this.yaml, this.tags);
     return copy.docStart = this.docStart, copy;
    }
    atDocument() {
     const res = new Directives(this.yaml, this.tags);
     switch (this.yaml.version) {
     case "1.1":
      this.atNextDocument = !0;
      break;

     case "1.2":
      this.atNextDocument = !1, this.yaml = {
       explicit: Directives.defaultYaml.explicit,
       version: "1.2"
      }, this.tags = Object.assign({}, Directives.defaultTags);
     }
     return res;
    }
    add(line, onError) {
     this.atNextDocument && (this.yaml = {
      explicit: Directives.defaultYaml.explicit,
      version: "1.1"
     }, this.tags = Object.assign({}, Directives.defaultTags), this.atNextDocument = !1);
     const parts = line.trim().split(/[ \t]+/), name = parts.shift();
     switch (name) {
     case "%TAG":
      {
       if (2 !== parts.length && (onError(0, "%TAG directive should contain exactly two parts"), 
       parts.length < 2)) return !1;
       const [handle, prefix] = parts;
       return this.tags[handle] = prefix, !0;
      }

     case "%YAML":
      {
       if (this.yaml.explicit = !0, 1 !== parts.length) return onError(0, "%YAML directive should contain exactly one part"), 
       !1;
       const [version] = parts;
       if ("1.1" === version || "1.2" === version) return this.yaml.version = version, 
       !0;
       return onError(6, `Unsupported YAML version ${version}`, /^\d+\.\d+$/.test(version)), 
       !1;
      }

     default:
      return onError(0, `Unknown directive ${name}`, !0), !1;
     }
    }
    tagName(source, onError) {
     if ("!" === source) return "!";
     if ("!" !== source[0]) return onError(`Not a valid tag: ${source}`), null;
     if ("<" === source[1]) {
      const verbatim = source.slice(2, -1);
      return "!" === verbatim || "!!" === verbatim ? (onError(`Verbatim tags aren't resolved, so ${source} is invalid.`), 
      null) : (">" !== source[source.length - 1] && onError("Verbatim tags must end with a >"), 
      verbatim);
     }
     const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
     suffix || onError(`The ${source} tag has no suffix`);
     const prefix = this.tags[handle];
     if (prefix) try {
      return prefix + decodeURIComponent(suffix);
     } catch (error) {
      return onError(String(error)), null;
     }
     return "!" === handle ? source : (onError(`Could not resolve tag: ${source}`), null);
    }
    tagString(tag) {
     for (const [handle, prefix] of Object.entries(this.tags)) if (tag.startsWith(prefix)) return handle + tag.substring(prefix.length).replace(/[!,[\]{}]/g, (ch => escapeChars[ch]));
     return "!" === tag[0] ? tag : `!<${tag}>`;
    }
    toString(doc) {
     const lines = this.yaml.explicit ? [ `%YAML ${this.yaml.version || "1.2"}` ] : [], tagEntries = Object.entries(this.tags);
     let tagNames;
     if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
      const tags = {};
      visit.visit(doc.contents, ((_key, node) => {
       identity.isNode(node) && node.tag && (tags[node.tag] = !0);
      })), tagNames = Object.keys(tags);
     } else tagNames = [];
     for (const [handle, prefix] of tagEntries) "!!" === handle && "tag:yaml.org,2002:" === prefix || doc && !tagNames.some((tn => tn.startsWith(prefix))) || lines.push(`%TAG ${handle} ${prefix}`);
     return lines.join("\n");
    }
   }
   Directives.defaultYaml = {
    explicit: !1,
    version: "1.2"
   }, Directives.defaultTags = {
    "!!": "tag:yaml.org,2002:"
   }, exports.Directives = Directives;
  },
  2394: (__unused_webpack_module, exports) => {
   "use strict";
   class YAMLError extends Error {
    constructor(name, pos, code, message) {
     super(), this.name = name, this.code = code, this.message = message, this.pos = pos;
    }
   }
   exports.YAMLError = YAMLError, exports.YAMLParseError = class extends YAMLError {
    constructor(pos, code, message) {
     super("YAMLParseError", pos, code, message);
    }
   }, exports.YAMLWarning = class extends YAMLError {
    constructor(pos, code, message) {
     super("YAMLWarning", pos, code, message);
    }
   }, exports.prettifyError = (src, lc) => error => {
    if (-1 === error.pos[0]) return;
    error.linePos = error.pos.map((pos => lc.linePos(pos)));
    const {line, col} = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1, lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
    if (ci >= 60 && lineStr.length > 80) {
     const trimStart = Math.min(ci - 39, lineStr.length - 79);
     lineStr = "…" + lineStr.substring(trimStart), ci -= trimStart - 1;
    }
    if (lineStr.length > 80 && (lineStr = lineStr.substring(0, 79) + "…"), line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
     let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
     prev.length > 80 && (prev = prev.substring(0, 79) + "…\n"), lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
     let count = 1;
     const end = error.linePos[1];
     end && end.line === line && end.col > col && (count = Math.max(1, Math.min(end.col - col, 80 - ci)));
     const pointer = " ".repeat(ci) + "^".repeat(count);
     error.message += `:\n\n${lineStr}\n${pointer}\n`;
    }
   };
  },
  93419: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var composer = __webpack_require__(5281), Document = __webpack_require__(86068), Schema = __webpack_require__(23673), errors = __webpack_require__(2394), Alias = __webpack_require__(12055), identity = __webpack_require__(60163), Pair = __webpack_require__(10394), Scalar = __webpack_require__(58844), YAMLMap = __webpack_require__(56575), YAMLSeq = __webpack_require__(13798), cst = __webpack_require__(75208), lexer = __webpack_require__(87135), lineCounter = __webpack_require__(94708), parser = __webpack_require__(69369), publicApi = __webpack_require__(68011), visit = __webpack_require__(81381);
   exports.Composer = composer.Composer, exports.Document = Document.Document, exports.Schema = Schema.Schema, 
   exports.YAMLError = errors.YAMLError, exports.YAMLParseError = errors.YAMLParseError, 
   exports.YAMLWarning = errors.YAMLWarning, exports.Alias = Alias.Alias, exports.isAlias = identity.isAlias, 
   exports.isCollection = identity.isCollection, exports.isDocument = identity.isDocument, 
   exports.isMap = identity.isMap, exports.isNode = identity.isNode, exports.isPair = identity.isPair, 
   exports.isScalar = identity.isScalar, exports.isSeq = identity.isSeq, exports.Pair = Pair.Pair, 
   exports.Scalar = Scalar.Scalar, exports.YAMLMap = YAMLMap.YAMLMap, exports.YAMLSeq = YAMLSeq.YAMLSeq, 
   exports.CST = cst, exports.Lexer = lexer.Lexer, exports.LineCounter = lineCounter.LineCounter, 
   exports.Parser = parser.Parser, exports.parse = publicApi.parse, exports.parseAllDocuments = publicApi.parseAllDocuments, 
   exports.parseDocument = publicApi.parseDocument, exports.stringify = publicApi.stringify, 
   exports.visit = visit.visit, exports.visitAsync = visit.visitAsync;
  },
  95441: (__unused_webpack_module, exports) => {
   "use strict";
   exports.debug = function(logLevel, ...messages) {
    "debug" === logLevel && console.log(...messages);
   }, exports.warn = function(logLevel, warning) {
    "debug" !== logLevel && "warn" !== logLevel || ("undefined" != typeof process && process.emitWarning ? process.emitWarning(warning) : console.warn(warning));
   };
  },
  12055: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var anchors = __webpack_require__(21903), visit = __webpack_require__(81381), identity = __webpack_require__(60163), Node = __webpack_require__(10466), toJS = __webpack_require__(93257);
   class Alias extends Node.NodeBase {
    constructor(source) {
     super(identity.ALIAS), this.source = source, Object.defineProperty(this, "tag", {
      set() {
       throw new Error("Alias nodes cannot have tags");
      }
     });
    }
    resolve(doc) {
     let found;
     return visit.visit(doc, {
      Node: (_key, node) => {
       if (node === this) return visit.visit.BREAK;
       node.anchor === this.source && (found = node);
      }
     }), found;
    }
    toJSON(_arg, ctx) {
     if (!ctx) return {
      source: this.source
     };
     const {anchors, doc, maxAliasCount} = ctx, source = this.resolve(doc);
     if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
     }
     let data = anchors.get(source);
     if (data || (toJS.toJS(source, null, ctx), data = anchors.get(source)), !data || void 0 === data.res) {
      throw new ReferenceError("This should not happen: Alias anchor was not resolved?");
     }
     if (maxAliasCount >= 0 && (data.count += 1, 0 === data.aliasCount && (data.aliasCount = getAliasCount(doc, source, anchors)), 
     data.count * data.aliasCount > maxAliasCount)) {
      throw new ReferenceError("Excessive alias count indicates a resource exhaustion attack");
     }
     return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
     const src = `*${this.source}`;
     if (ctx) {
      if (anchors.anchorIsValid(this.source), ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
       const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
       throw new Error(msg);
      }
      if (ctx.implicitKey) return `${src} `;
     }
     return src;
    }
   }
   function getAliasCount(doc, node, anchors) {
    if (identity.isAlias(node)) {
     const source = node.resolve(doc), anchor = anchors && source && anchors.get(source);
     return anchor ? anchor.count * anchor.aliasCount : 0;
    }
    if (identity.isCollection(node)) {
     let count = 0;
     for (const item of node.items) {
      const c = getAliasCount(doc, item, anchors);
      c > count && (count = c);
     }
     return count;
    }
    if (identity.isPair(node)) {
     const kc = getAliasCount(doc, node.key, anchors), vc = getAliasCount(doc, node.value, anchors);
     return Math.max(kc, vc);
    }
    return 1;
   }
   exports.Alias = Alias;
  },
  43365: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var createNode = __webpack_require__(87581), identity = __webpack_require__(60163), Node = __webpack_require__(10466);
   function collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1; i >= 0; --i) {
     const k = path[i];
     if ("number" == typeof k && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v, v = a;
     } else v = new Map([ [ k, v ] ]);
    }
    return createNode.createNode(v, void 0, {
     aliasDuplicateObjects: !1,
     keepUndefined: !1,
     onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
     },
     schema,
     sourceObjects: new Map
    });
   }
   const isEmptyPath = path => null == path || "object" == typeof path && !!path[Symbol.iterator]().next().done;
   class Collection extends Node.NodeBase {
    constructor(type, schema) {
     super(type), Object.defineProperty(this, "schema", {
      value: schema,
      configurable: !0,
      enumerable: !1,
      writable: !0
     });
    }
    clone(schema) {
     const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
     return schema && (copy.schema = schema), copy.items = copy.items.map((it => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it)), 
     this.range && (copy.range = this.range.slice()), copy;
    }
    addIn(path, value) {
     if (isEmptyPath(path)) this.add(value); else {
      const [key, ...rest] = path, node = this.get(key, !0);
      if (identity.isCollection(node)) node.addIn(rest, value); else {
       if (void 0 !== node || !this.schema) throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
       this.set(key, collectionFromPath(this.schema, rest, value));
      }
     }
    }
    deleteIn(path) {
     const [key, ...rest] = path;
     if (0 === rest.length) return this.delete(key);
     const node = this.get(key, !0);
     if (identity.isCollection(node)) return node.deleteIn(rest);
     throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    getIn(path, keepScalar) {
     const [key, ...rest] = path, node = this.get(key, !0);
     return 0 === rest.length ? !keepScalar && identity.isScalar(node) ? node.value : node : identity.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
    }
    hasAllNullValues(allowScalar) {
     return this.items.every((node => {
      if (!identity.isPair(node)) return !1;
      const n = node.value;
      return null == n || allowScalar && identity.isScalar(n) && null == n.value && !n.commentBefore && !n.comment && !n.tag;
     }));
    }
    hasIn(path) {
     const [key, ...rest] = path;
     if (0 === rest.length) return this.has(key);
     const node = this.get(key, !0);
     return !!identity.isCollection(node) && node.hasIn(rest);
    }
    setIn(path, value) {
     const [key, ...rest] = path;
     if (0 === rest.length) this.set(key, value); else {
      const node = this.get(key, !0);
      if (identity.isCollection(node)) node.setIn(rest, value); else {
       if (void 0 !== node || !this.schema) throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
       this.set(key, collectionFromPath(this.schema, rest, value));
      }
     }
    }
   }
   Collection.maxFlowStringSingleLineLength = 60, exports.Collection = Collection, 
   exports.collectionFromPath = collectionFromPath, exports.isEmptyPath = isEmptyPath;
  },
  10466: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var applyReviver = __webpack_require__(33085), identity = __webpack_require__(60163), toJS = __webpack_require__(93257);
   exports.NodeBase = class {
    constructor(type) {
     Object.defineProperty(this, identity.NODE_TYPE, {
      value: type
     });
    }
    clone() {
     const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
     return this.range && (copy.range = this.range.slice()), copy;
    }
    toJS(doc, {mapAsMap, maxAliasCount, onAnchor, reviver} = {}) {
     if (!identity.isDocument(doc)) throw new TypeError("A document argument is required");
     const ctx = {
      anchors: new Map,
      doc,
      keep: !0,
      mapAsMap: !0 === mapAsMap,
      mapKeyWarned: !1,
      maxAliasCount: "number" == typeof maxAliasCount ? maxAliasCount : 100
     }, res = toJS.toJS(this, "", ctx);
     if ("function" == typeof onAnchor) for (const {count, res} of ctx.anchors.values()) onAnchor(res, count);
     return "function" == typeof reviver ? applyReviver.applyReviver(reviver, {
      "": res
     }, "", res) : res;
    }
   };
  },
  10394: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var createNode = __webpack_require__(87581), stringifyPair = __webpack_require__(38843), addPairToJSMap = __webpack_require__(13567), identity = __webpack_require__(60163);
   class Pair {
    constructor(key, value = null) {
     Object.defineProperty(this, identity.NODE_TYPE, {
      value: identity.PAIR
     }), this.key = key, this.value = value;
    }
    clone(schema) {
     let {key, value} = this;
     return identity.isNode(key) && (key = key.clone(schema)), identity.isNode(value) && (value = value.clone(schema)), 
     new Pair(key, value);
    }
    toJSON(_, ctx) {
     const pair = ctx?.mapAsMap ? new Map : {};
     return addPairToJSMap.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
     return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
    }
   }
   exports.Pair = Pair, exports.createPair = function(key, value, ctx) {
    const k = createNode.createNode(key, void 0, ctx), v = createNode.createNode(value, void 0, ctx);
    return new Pair(k, v);
   };
  },
  58844: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(60163), Node = __webpack_require__(10466), toJS = __webpack_require__(93257);
   class Scalar extends Node.NodeBase {
    constructor(value) {
     super(identity.SCALAR), this.value = value;
    }
    toJSON(arg, ctx) {
     return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
    }
    toString() {
     return String(this.value);
    }
   }
   Scalar.BLOCK_FOLDED = "BLOCK_FOLDED", Scalar.BLOCK_LITERAL = "BLOCK_LITERAL", Scalar.PLAIN = "PLAIN", 
   Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE", Scalar.QUOTE_SINGLE = "QUOTE_SINGLE", exports.Scalar = Scalar, 
   exports.isScalarValue = value => !value || "function" != typeof value && "object" != typeof value;
  },
  56575: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var stringifyCollection = __webpack_require__(40240), addPairToJSMap = __webpack_require__(13567), Collection = __webpack_require__(43365), identity = __webpack_require__(60163), Pair = __webpack_require__(10394), Scalar = __webpack_require__(58844);
   function findPair(items, key) {
    const k = identity.isScalar(key) ? key.value : key;
    for (const it of items) if (identity.isPair(it)) {
     if (it.key === key || it.key === k) return it;
     if (identity.isScalar(it.key) && it.key.value === k) return it;
    }
   }
   class YAMLMap extends Collection.Collection {
    static get tagName() {
     return "tag:yaml.org,2002:map";
    }
    constructor(schema) {
     super(identity.MAP, schema), this.items = [];
    }
    static from(schema, obj, ctx) {
     const {keepUndefined, replacer} = ctx, map = new this(schema), add = (key, value) => {
      if ("function" == typeof replacer) value = replacer.call(obj, key, value); else if (Array.isArray(replacer) && !replacer.includes(key)) return;
      (void 0 !== value || keepUndefined) && map.items.push(Pair.createPair(key, value, ctx));
     };
     if (obj instanceof Map) for (const [key, value] of obj) add(key, value); else if (obj && "object" == typeof obj) for (const key of Object.keys(obj)) add(key, obj[key]);
     return "function" == typeof schema.sortMapEntries && map.items.sort(schema.sortMapEntries), 
     map;
    }
    add(pair, overwrite) {
     let _pair;
     _pair = identity.isPair(pair) ? pair : pair && "object" == typeof pair && "key" in pair ? new Pair.Pair(pair.key, pair.value) : new Pair.Pair(pair, pair?.value);
     const prev = findPair(this.items, _pair.key), sortEntries = this.schema?.sortMapEntries;
     if (prev) {
      if (!overwrite) throw new Error(`Key ${_pair.key} already set`);
      identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value) ? prev.value.value = _pair.value : prev.value = _pair.value;
     } else if (sortEntries) {
      const i = this.items.findIndex((item => sortEntries(_pair, item) < 0));
      -1 === i ? this.items.push(_pair) : this.items.splice(i, 0, _pair);
     } else this.items.push(_pair);
    }
    delete(key) {
     const it = findPair(this.items, key);
     if (!it) return !1;
     return this.items.splice(this.items.indexOf(it), 1).length > 0;
    }
    get(key, keepScalar) {
     const it = findPair(this.items, key), node = it?.value;
     return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? void 0;
    }
    has(key) {
     return !!findPair(this.items, key);
    }
    set(key, value) {
     this.add(new Pair.Pair(key, value), !0);
    }
    toJSON(_, ctx, Type) {
     const map = Type ? new Type : ctx?.mapAsMap ? new Map : {};
     ctx?.onCreate && ctx.onCreate(map);
     for (const item of this.items) addPairToJSMap.addPairToJSMap(ctx, map, item);
     return map;
    }
    toString(ctx, onComment, onChompKeep) {
     if (!ctx) return JSON.stringify(this);
     for (const item of this.items) if (!identity.isPair(item)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
     return !ctx.allNullValues && this.hasAllNullValues(!1) && (ctx = Object.assign({}, ctx, {
      allNullValues: !0
     })), stringifyCollection.stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: {
       start: "{",
       end: "}"
      },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
     });
    }
   }
   exports.YAMLMap = YAMLMap, exports.findPair = findPair;
  },
  13798: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var createNode = __webpack_require__(87581), stringifyCollection = __webpack_require__(40240), Collection = __webpack_require__(43365), identity = __webpack_require__(60163), Scalar = __webpack_require__(58844), toJS = __webpack_require__(93257);
   class YAMLSeq extends Collection.Collection {
    static get tagName() {
     return "tag:yaml.org,2002:seq";
    }
    constructor(schema) {
     super(identity.SEQ, schema), this.items = [];
    }
    add(value) {
     this.items.push(value);
    }
    delete(key) {
     const idx = asItemIndex(key);
     if ("number" != typeof idx) return !1;
     return this.items.splice(idx, 1).length > 0;
    }
    get(key, keepScalar) {
     const idx = asItemIndex(key);
     if ("number" != typeof idx) return;
     const it = this.items[idx];
     return !keepScalar && identity.isScalar(it) ? it.value : it;
    }
    has(key) {
     const idx = asItemIndex(key);
     return "number" == typeof idx && idx < this.items.length;
    }
    set(key, value) {
     const idx = asItemIndex(key);
     if ("number" != typeof idx) throw new Error(`Expected a valid index, not ${key}.`);
     const prev = this.items[idx];
     identity.isScalar(prev) && Scalar.isScalarValue(value) ? prev.value = value : this.items[idx] = value;
    }
    toJSON(_, ctx) {
     const seq = [];
     ctx?.onCreate && ctx.onCreate(seq);
     let i = 0;
     for (const item of this.items) seq.push(toJS.toJS(item, String(i++), ctx));
     return seq;
    }
    toString(ctx, onComment, onChompKeep) {
     return ctx ? stringifyCollection.stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: {
       start: "[",
       end: "]"
      },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
     }) : JSON.stringify(this);
    }
    static from(schema, obj, ctx) {
     const {replacer} = ctx, seq = new this(schema);
     if (obj && Symbol.iterator in Object(obj)) {
      let i = 0;
      for (let it of obj) {
       if ("function" == typeof replacer) {
        const key = obj instanceof Set ? it : String(i++);
        it = replacer.call(obj, key, it);
       }
       seq.items.push(createNode.createNode(it, void 0, ctx));
      }
     }
     return seq;
    }
   }
   function asItemIndex(key) {
    let idx = identity.isScalar(key) ? key.value : key;
    return idx && "string" == typeof idx && (idx = Number(idx)), "number" == typeof idx && Number.isInteger(idx) && idx >= 0 ? idx : null;
   }
   exports.YAMLSeq = YAMLSeq;
  },
  13567: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var log = __webpack_require__(95441), stringify = __webpack_require__(20611), identity = __webpack_require__(60163), Scalar = __webpack_require__(58844), toJS = __webpack_require__(93257);
   const isMergeKey = key => "<<" === key || identity.isScalar(key) && "<<" === key.value && (!key.type || key.type === Scalar.Scalar.PLAIN);
   function mergeToJSMap(ctx, map, value) {
    const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!identity.isMap(source)) throw new Error("Merge sources must be maps or map aliases");
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value] of srcMap) map instanceof Map ? map.has(key) || map.set(key, value) : map instanceof Set ? map.add(key) : Object.prototype.hasOwnProperty.call(map, key) || Object.defineProperty(map, key, {
     value,
     writable: !0,
     enumerable: !0,
     configurable: !0
    });
    return map;
   }
   exports.addPairToJSMap = function(ctx, map, {key, value}) {
    if (ctx?.doc.schema.merge && isMergeKey(key)) if (value = identity.isAlias(value) ? value.resolve(ctx.doc) : value, 
    identity.isSeq(value)) for (const it of value.items) mergeToJSMap(ctx, map, it); else if (Array.isArray(value)) for (const it of value) mergeToJSMap(ctx, map, it); else mergeToJSMap(ctx, map, value); else {
     const jsKey = toJS.toJS(key, "", ctx);
     if (map instanceof Map) map.set(jsKey, toJS.toJS(value, jsKey, ctx)); else if (map instanceof Set) map.add(jsKey); else {
      const stringKey = function(key, jsKey, ctx) {
       if (null === jsKey) return "";
       if ("object" != typeof jsKey) return String(jsKey);
       if (identity.isNode(key) && ctx?.doc) {
        const strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = new Set;
        for (const node of ctx.anchors.keys()) strCtx.anchors.add(node.anchor);
        strCtx.inFlow = !0, strCtx.inStringifyKey = !0;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
         let jsonStr = JSON.stringify(strKey);
         jsonStr.length > 40 && (jsonStr = jsonStr.substring(0, 36) + '..."'), log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`), 
         ctx.mapKeyWarned = !0;
        }
        return strKey;
       }
       return JSON.stringify(jsKey);
      }(key, jsKey, ctx), jsValue = toJS.toJS(value, stringKey, ctx);
      stringKey in map ? Object.defineProperty(map, stringKey, {
       value: jsValue,
       writable: !0,
       enumerable: !0,
       configurable: !0
      }) : map[stringKey] = jsValue;
     }
    }
    return map;
   };
  },
  60163: (__unused_webpack_module, exports) => {
   "use strict";
   const ALIAS = Symbol.for("yaml.alias"), DOC = Symbol.for("yaml.document"), MAP = Symbol.for("yaml.map"), PAIR = Symbol.for("yaml.pair"), SCALAR = Symbol.for("yaml.scalar"), SEQ = Symbol.for("yaml.seq"), NODE_TYPE = Symbol.for("yaml.node.type"), isScalar = node => !!node && "object" == typeof node && node[NODE_TYPE] === SCALAR;
   function isCollection(node) {
    if (node && "object" == typeof node) switch (node[NODE_TYPE]) {
    case MAP:
    case SEQ:
     return !0;
    }
    return !1;
   }
   exports.ALIAS = ALIAS, exports.DOC = DOC, exports.MAP = MAP, exports.NODE_TYPE = NODE_TYPE, 
   exports.PAIR = PAIR, exports.SCALAR = SCALAR, exports.SEQ = SEQ, exports.hasAnchor = node => (isScalar(node) || isCollection(node)) && !!node.anchor, 
   exports.isAlias = node => !!node && "object" == typeof node && node[NODE_TYPE] === ALIAS, 
   exports.isCollection = isCollection, exports.isDocument = node => !!node && "object" == typeof node && node[NODE_TYPE] === DOC, 
   exports.isMap = node => !!node && "object" == typeof node && node[NODE_TYPE] === MAP, 
   exports.isNode = function(node) {
    if (node && "object" == typeof node) switch (node[NODE_TYPE]) {
    case ALIAS:
    case MAP:
    case SCALAR:
    case SEQ:
     return !0;
    }
    return !1;
   }, exports.isPair = node => !!node && "object" == typeof node && node[NODE_TYPE] === PAIR, 
   exports.isScalar = isScalar, exports.isSeq = node => !!node && "object" == typeof node && node[NODE_TYPE] === SEQ;
  },
  93257: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(60163);
   exports.toJS = function toJS(value, arg, ctx) {
    if (Array.isArray(value)) return value.map(((v, i) => toJS(v, String(i), ctx)));
    if (value && "function" == typeof value.toJSON) {
     if (!ctx || !identity.hasAnchor(value)) return value.toJSON(arg, ctx);
     const data = {
      aliasCount: 0,
      count: 1,
      res: void 0
     };
     ctx.anchors.set(value, data), ctx.onCreate = res => {
      data.res = res, delete ctx.onCreate;
     };
     const res = value.toJSON(arg, ctx);
     return ctx.onCreate && ctx.onCreate(res), res;
    }
    return "bigint" != typeof value || ctx?.keep ? value : Number(value);
   };
  },
  47084: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var resolveBlockScalar = __webpack_require__(51328), resolveFlowScalar = __webpack_require__(7876), errors = __webpack_require__(2394), stringifyString = __webpack_require__(98431);
   function addEndtoBlockProps(props, end) {
    if (end) for (const st of end) switch (st.type) {
    case "space":
    case "comment":
     props.push(st);
     break;

    case "newline":
     return props.push(st), !0;
    }
    return !1;
   }
   function setFlowScalarValue(token, source, type) {
    switch (token.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
     token.type = type, token.source = source;
     break;

    case "block-scalar":
     {
      const end = token.props.slice(1);
      let oa = source.length;
      "block-scalar-header" === token.props[0].type && (oa -= token.props[0].source.length);
      for (const tok of end) tok.offset += oa;
      delete token.props, Object.assign(token, {
       type,
       source,
       end
      });
      break;
     }

    case "block-map":
    case "block-seq":
     {
      const nl = {
       type: "newline",
       offset: token.offset + source.length,
       indent: token.indent,
       source: "\n"
      };
      delete token.items, Object.assign(token, {
       type,
       source,
       end: [ nl ]
      });
      break;
     }

    default:
     {
      const indent = "indent" in token ? token.indent : -1, end = "end" in token && Array.isArray(token.end) ? token.end.filter((st => "space" === st.type || "comment" === st.type || "newline" === st.type)) : [];
      for (const key of Object.keys(token)) "type" !== key && "offset" !== key && delete token[key];
      Object.assign(token, {
       type,
       indent,
       source,
       end
      });
     }
    }
   }
   exports.createScalarToken = function(value, context) {
    const {implicitKey = !1, indent, inFlow = !1, offset = -1, type = "PLAIN"} = context, source = stringifyString.stringifyString({
     type,
     value
    }, {
     implicitKey,
     indent: indent > 0 ? " ".repeat(indent) : "",
     inFlow,
     options: {
      blockQuote: !0,
      lineWidth: -1
     }
    }), end = context.end ?? [ {
     type: "newline",
     offset: -1,
     indent,
     source: "\n"
    } ];
    switch (source[0]) {
    case "|":
    case ">":
     {
      const he = source.indexOf("\n"), head = source.substring(0, he), body = source.substring(he + 1) + "\n", props = [ {
       type: "block-scalar-header",
       offset,
       indent,
       source: head
      } ];
      return addEndtoBlockProps(props, end) || props.push({
       type: "newline",
       offset: -1,
       indent,
       source: "\n"
      }), {
       type: "block-scalar",
       offset,
       indent,
       props,
       source: body
      };
     }

    case '"':
     return {
      type: "double-quoted-scalar",
      offset,
      indent,
      source,
      end
     };

    case "'":
     return {
      type: "single-quoted-scalar",
      offset,
      indent,
      source,
      end
     };

    default:
     return {
      type: "scalar",
      offset,
      indent,
      source,
      end
     };
    }
   }, exports.resolveAsScalar = function(token, strict = !0, onError) {
    if (token) {
     const _onError = (pos, code, message) => {
      const offset = "number" == typeof pos ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
      if (!onError) throw new errors.YAMLParseError([ offset, offset + 1 ], code, message);
      onError(offset, code, message);
     };
     switch (token.type) {
     case "scalar":
     case "single-quoted-scalar":
     case "double-quoted-scalar":
      return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);

     case "block-scalar":
      return resolveBlockScalar.resolveBlockScalar(token, strict, _onError);
     }
    }
    return null;
   }, exports.setScalarValue = function(token, value, context = {}) {
    let {afterKey = !1, implicitKey = !1, inFlow = !1, type} = context, indent = "indent" in token ? token.indent : null;
    if (afterKey && "number" == typeof indent && (indent += 2), !type) switch (token.type) {
    case "single-quoted-scalar":
     type = "QUOTE_SINGLE";
     break;

    case "double-quoted-scalar":
     type = "QUOTE_DOUBLE";
     break;

    case "block-scalar":
     {
      const header = token.props[0];
      if ("block-scalar-header" !== header.type) throw new Error("Invalid block scalar header");
      type = ">" === header.source[0] ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
      break;
     }

    default:
     type = "PLAIN";
    }
    const source = stringifyString.stringifyString({
     type,
     value
    }, {
     implicitKey: implicitKey || null === indent,
     indent: null !== indent && indent > 0 ? " ".repeat(indent) : "",
     inFlow,
     options: {
      blockQuote: !0,
      lineWidth: -1
     }
    });
    switch (source[0]) {
    case "|":
    case ">":
     !function(token, source) {
      const he = source.indexOf("\n"), head = source.substring(0, he), body = source.substring(he + 1) + "\n";
      if ("block-scalar" === token.type) {
       const header = token.props[0];
       if ("block-scalar-header" !== header.type) throw new Error("Invalid block scalar header");
       header.source = head, token.source = body;
      } else {
       const {offset} = token, indent = "indent" in token ? token.indent : -1, props = [ {
        type: "block-scalar-header",
        offset,
        indent,
        source: head
       } ];
       addEndtoBlockProps(props, "end" in token ? token.end : void 0) || props.push({
        type: "newline",
        offset: -1,
        indent,
        source: "\n"
       });
       for (const key of Object.keys(token)) "type" !== key && "offset" !== key && delete token[key];
       Object.assign(token, {
        type: "block-scalar",
        indent,
        props,
        source: body
       });
      }
     }(token, source);
     break;

    case '"':
     setFlowScalarValue(token, source, "double-quoted-scalar");
     break;

    case "'":
     setFlowScalarValue(token, source, "single-quoted-scalar");
     break;

    default:
     setFlowScalarValue(token, source, "scalar");
    }
   };
  },
  84453: (__unused_webpack_module, exports) => {
   "use strict";
   function stringifyToken(token) {
    switch (token.type) {
    case "block-scalar":
     {
      let res = "";
      for (const tok of token.props) res += stringifyToken(tok);
      return res + token.source;
     }

    case "block-map":
    case "block-seq":
     {
      let res = "";
      for (const item of token.items) res += stringifyItem(item);
      return res;
     }

    case "flow-collection":
     {
      let res = token.start.source;
      for (const item of token.items) res += stringifyItem(item);
      for (const st of token.end) res += st.source;
      return res;
     }

    case "document":
     {
      let res = stringifyItem(token);
      if (token.end) for (const st of token.end) res += st.source;
      return res;
     }

    default:
     {
      let res = token.source;
      if ("end" in token && token.end) for (const st of token.end) res += st.source;
      return res;
     }
    }
   }
   function stringifyItem({start, key, sep, value}) {
    let res = "";
    for (const st of start) res += st.source;
    if (key && (res += stringifyToken(key)), sep) for (const st of sep) res += st.source;
    return value && (res += stringifyToken(value)), res;
   }
   exports.stringify = cst => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
  },
  28318: (__unused_webpack_module, exports) => {
   "use strict";
   const BREAK = Symbol("break visit"), SKIP = Symbol("skip children"), REMOVE = Symbol("remove item");
   function visit(cst, visitor) {
    "type" in cst && "document" === cst.type && (cst = {
     start: cst.start,
     value: cst.value
    }), _visit(Object.freeze([]), cst, visitor);
   }
   function _visit(path, item, visitor) {
    let ctrl = visitor(item, path);
    if ("symbol" == typeof ctrl) return ctrl;
    for (const field of [ "key", "value" ]) {
     const token = item[field];
     if (token && "items" in token) {
      for (let i = 0; i < token.items.length; ++i) {
       const ci = _visit(Object.freeze(path.concat([ [ field, i ] ])), token.items[i], visitor);
       if ("number" == typeof ci) i = ci - 1; else {
        if (ci === BREAK) return BREAK;
        ci === REMOVE && (token.items.splice(i, 1), i -= 1);
       }
      }
      "function" == typeof ctrl && "key" === field && (ctrl = ctrl(item, path));
     }
    }
    return "function" == typeof ctrl ? ctrl(item, path) : ctrl;
   }
   visit.BREAK = BREAK, visit.SKIP = SKIP, visit.REMOVE = REMOVE, visit.itemAtPath = (cst, path) => {
    let item = cst;
    for (const [field, index] of path) {
     const tok = item?.[field];
     if (!tok || !("items" in tok)) return;
     item = tok.items[index];
    }
    return item;
   }, visit.parentCollection = (cst, path) => {
    const parent = visit.itemAtPath(cst, path.slice(0, -1)), field = path[path.length - 1][0], coll = parent?.[field];
    if (coll && "items" in coll) return coll;
    throw new Error("Parent collection not found");
   }, exports.visit = visit;
  },
  75208: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var cstScalar = __webpack_require__(47084), cstStringify = __webpack_require__(84453), cstVisit = __webpack_require__(28318);
   exports.createScalarToken = cstScalar.createScalarToken, exports.resolveAsScalar = cstScalar.resolveAsScalar, 
   exports.setScalarValue = cstScalar.setScalarValue, exports.stringify = cstStringify.stringify, 
   exports.visit = cstVisit.visit, exports.BOM = "\ufeff", exports.DOCUMENT = "", 
   exports.FLOW_END = "", exports.SCALAR = "", exports.isCollection = token => !!token && "items" in token, 
   exports.isScalar = token => !!token && ("scalar" === token.type || "single-quoted-scalar" === token.type || "double-quoted-scalar" === token.type || "block-scalar" === token.type), 
   exports.prettyToken = function(token) {
    switch (token) {
    case "\ufeff":
     return "<BOM>";

    case "":
     return "<DOC>";

    case "":
     return "<FLOW_END>";

    case "":
     return "<SCALAR>";

    default:
     return JSON.stringify(token);
    }
   }, exports.tokenType = function(source) {
    switch (source) {
    case "\ufeff":
     return "byte-order-mark";

    case "":
     return "doc-mode";

    case "":
     return "flow-error-end";

    case "":
     return "scalar";

    case "---":
     return "doc-start";

    case "...":
     return "doc-end";

    case "":
    case "\n":
    case "\r\n":
     return "newline";

    case "-":
     return "seq-item-ind";

    case "?":
     return "explicit-key-ind";

    case ":":
     return "map-value-ind";

    case "{":
     return "flow-map-start";

    case "}":
     return "flow-map-end";

    case "[":
     return "flow-seq-start";

    case "]":
     return "flow-seq-end";

    case ",":
     return "comma";
    }
    switch (source[0]) {
    case " ":
    case "\t":
     return "space";

    case "#":
     return "comment";

    case "%":
     return "directive-line";

    case "*":
     return "alias";

    case "&":
     return "anchor";

    case "!":
     return "tag";

    case "'":
     return "single-quoted-scalar";

    case '"':
     return "double-quoted-scalar";

    case "|":
    case ">":
     return "block-scalar-header";
    }
    return null;
   };
  },
  87135: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var cst = __webpack_require__(75208);
   function isEmpty(ch) {
    switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "\t":
     return !0;

    default:
     return !1;
    }
   }
   const hexDigits = "0123456789ABCDEFabcdef".split(""), tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split(""), invalidFlowScalarChars = ",[]{}".split(""), invalidAnchorChars = " ,[]{}\n\r\t".split(""), isNotAnchorChar = ch => !ch || invalidAnchorChars.includes(ch);
   exports.Lexer = class {
    constructor() {
     this.atEnd = !1, this.blockScalarIndent = -1, this.blockScalarKeep = !1, this.buffer = "", 
     this.flowKey = !1, this.flowLevel = 0, this.indentNext = 0, this.indentValue = 0, 
     this.lineEndPos = null, this.next = null, this.pos = 0;
    }
    * lex(source, incomplete = !1) {
     source && (this.buffer = this.buffer ? this.buffer + source : source, this.lineEndPos = null), 
     this.atEnd = !incomplete;
     let next = this.next ?? "stream";
     for (;next && (incomplete || this.hasChars(1)); ) next = yield* this.parseNext(next);
    }
    atLineEnd() {
     let i = this.pos, ch = this.buffer[i];
     for (;" " === ch || "\t" === ch; ) ch = this.buffer[++i];
     return !ch || "#" === ch || "\n" === ch || "\r" === ch && "\n" === this.buffer[i + 1];
    }
    charAt(n) {
     return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
     let ch = this.buffer[offset];
     if (this.indentNext > 0) {
      let indent = 0;
      for (;" " === ch; ) ch = this.buffer[++indent + offset];
      if ("\r" === ch) {
       const next = this.buffer[indent + offset + 1];
       if ("\n" === next || !next && !this.atEnd) return offset + indent + 1;
      }
      return "\n" === ch || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
     }
     if ("-" === ch || "." === ch) {
      const dt = this.buffer.substr(offset, 3);
      if (("---" === dt || "..." === dt) && isEmpty(this.buffer[offset + 3])) return -1;
     }
     return offset;
    }
    getLine() {
     let end = this.lineEndPos;
     return ("number" != typeof end || -1 !== end && end < this.pos) && (end = this.buffer.indexOf("\n", this.pos), 
     this.lineEndPos = end), -1 === end ? this.atEnd ? this.buffer.substring(this.pos) : null : ("\r" === this.buffer[end - 1] && (end -= 1), 
     this.buffer.substring(this.pos, end));
    }
    hasChars(n) {
     return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
     return this.buffer = this.buffer.substring(this.pos), this.pos = 0, this.lineEndPos = null, 
     this.next = state, null;
    }
    peek(n) {
     return this.buffer.substr(this.pos, n);
    }
    * parseNext(next) {
     switch (next) {
     case "stream":
      return yield* this.parseStream();

     case "line-start":
      return yield* this.parseLineStart();

     case "block-start":
      return yield* this.parseBlockStart();

     case "doc":
      return yield* this.parseDocument();

     case "flow":
      return yield* this.parseFlowCollection();

     case "quoted-scalar":
      return yield* this.parseQuotedScalar();

     case "block-scalar":
      return yield* this.parseBlockScalar();

     case "plain-scalar":
      return yield* this.parsePlainScalar();
     }
    }
    * parseStream() {
     let line = this.getLine();
     if (null === line) return this.setNext("stream");
     if (line[0] === cst.BOM && (yield* this.pushCount(1), line = line.substring(1)), 
     "%" === line[0]) {
      let dirEnd = line.length;
      const cs = line.indexOf("#");
      if (-1 !== cs) {
       const ch = line[cs - 1];
       " " !== ch && "\t" !== ch || (dirEnd = cs - 1);
      }
      for (;;) {
       const ch = line[dirEnd - 1];
       if (" " !== ch && "\t" !== ch) break;
       dirEnd -= 1;
      }
      const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(!0));
      return yield* this.pushCount(line.length - n), this.pushNewline(), "stream";
     }
     if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(!0);
      return yield* this.pushCount(line.length - sp), yield* this.pushNewline(), "stream";
     }
     return yield cst.DOCUMENT, yield* this.parseLineStart();
    }
    * parseLineStart() {
     const ch = this.charAt(0);
     if (!ch && !this.atEnd) return this.setNext("line-start");
     if ("-" === ch || "." === ch) {
      if (!this.atEnd && !this.hasChars(4)) return this.setNext("line-start");
      const s = this.peek(3);
      if ("---" === s && isEmpty(this.charAt(3))) return yield* this.pushCount(3), this.indentValue = 0, 
      this.indentNext = 0, "doc";
      if ("..." === s && isEmpty(this.charAt(3))) return yield* this.pushCount(3), "stream";
     }
     return this.indentValue = yield* this.pushSpaces(!1), this.indentNext > this.indentValue && !isEmpty(this.charAt(1)) && (this.indentNext = this.indentValue), 
     yield* this.parseBlockStart();
    }
    * parseBlockStart() {
     const [ch0, ch1] = this.peek(2);
     if (!ch1 && !this.atEnd) return this.setNext("block-start");
     if (("-" === ch0 || "?" === ch0 || ":" === ch0) && isEmpty(ch1)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0));
      return this.indentNext = this.indentValue + 1, this.indentValue += n, yield* this.parseBlockStart();
     }
     return "doc";
    }
    * parseDocument() {
     yield* this.pushSpaces(!0);
     const line = this.getLine();
     if (null === line) return this.setNext("doc");
     let n = yield* this.pushIndicators();
     switch (line[n]) {
     case "#":
      yield* this.pushCount(line.length - n);

     case void 0:
      return yield* this.pushNewline(), yield* this.parseLineStart();

     case "{":
     case "[":
      return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel = 1, "flow";

     case "}":
     case "]":
      return yield* this.pushCount(1), "doc";

     case "*":
      return yield* this.pushUntil(isNotAnchorChar), "doc";

     case '"':
     case "'":
      return yield* this.parseQuotedScalar();

     case "|":
     case ">":
      return n += (yield* this.parseBlockScalarHeader()), n += (yield* this.pushSpaces(!0)), 
      yield* this.pushCount(line.length - n), yield* this.pushNewline(), yield* this.parseBlockScalar();

     default:
      return yield* this.parsePlainScalar();
     }
    }
    * parseFlowCollection() {
     let nl, sp, indent = -1;
     do {
      nl = yield* this.pushNewline(), nl > 0 ? (sp = yield* this.pushSpaces(!1), this.indentValue = indent = sp) : sp = 0, 
      sp += (yield* this.pushSpaces(!0));
     } while (nl + sp > 0);
     const line = this.getLine();
     if (null === line) return this.setNext("flow");
     if (-1 !== indent && indent < this.indentNext && "#" !== line[0] || 0 === indent && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
      if (!(indent === this.indentNext - 1 && 1 === this.flowLevel && ("]" === line[0] || "}" === line[0]))) return this.flowLevel = 0, 
      yield cst.FLOW_END, yield* this.parseLineStart();
     }
     let n = 0;
     for (;"," === line[n]; ) n += (yield* this.pushCount(1)), n += (yield* this.pushSpaces(!0)), 
     this.flowKey = !1;
     switch (n += (yield* this.pushIndicators()), line[n]) {
     case void 0:
      return "flow";

     case "#":
      return yield* this.pushCount(line.length - n), "flow";

     case "{":
     case "[":
      return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel += 1, "flow";

     case "}":
     case "]":
      return yield* this.pushCount(1), this.flowKey = !0, this.flowLevel -= 1, this.flowLevel ? "flow" : "doc";

     case "*":
      return yield* this.pushUntil(isNotAnchorChar), "flow";

     case '"':
     case "'":
      return this.flowKey = !0, yield* this.parseQuotedScalar();

     case ":":
      {
       const next = this.charAt(1);
       if (this.flowKey || isEmpty(next) || "," === next) return this.flowKey = !1, yield* this.pushCount(1), 
       yield* this.pushSpaces(!0), "flow";
      }

     default:
      return this.flowKey = !1, yield* this.parsePlainScalar();
     }
    }
    * parseQuotedScalar() {
     const quote = this.charAt(0);
     let end = this.buffer.indexOf(quote, this.pos + 1);
     if ("'" === quote) for (;-1 !== end && "'" === this.buffer[end + 1]; ) end = this.buffer.indexOf("'", end + 2); else for (;-1 !== end; ) {
      let n = 0;
      for (;"\\" === this.buffer[end - 1 - n]; ) n += 1;
      if (n % 2 == 0) break;
      end = this.buffer.indexOf('"', end + 1);
     }
     const qb = this.buffer.substring(0, end);
     let nl = qb.indexOf("\n", this.pos);
     if (-1 !== nl) {
      for (;-1 !== nl; ) {
       const cs = this.continueScalar(nl + 1);
       if (-1 === cs) break;
       nl = qb.indexOf("\n", cs);
      }
      -1 !== nl && (end = nl - ("\r" === qb[nl - 1] ? 2 : 1));
     }
     if (-1 === end) {
      if (!this.atEnd) return this.setNext("quoted-scalar");
      end = this.buffer.length;
     }
     return yield* this.pushToIndex(end + 1, !1), this.flowLevel ? "flow" : "doc";
    }
    * parseBlockScalarHeader() {
     this.blockScalarIndent = -1, this.blockScalarKeep = !1;
     let i = this.pos;
     for (;;) {
      const ch = this.buffer[++i];
      if ("+" === ch) this.blockScalarKeep = !0; else if (ch > "0" && ch <= "9") this.blockScalarIndent = Number(ch) - 1; else if ("-" !== ch) break;
     }
     return yield* this.pushUntil((ch => isEmpty(ch) || "#" === ch));
    }
    * parseBlockScalar() {
     let ch, nl = this.pos - 1, indent = 0;
     loop: for (let i = this.pos; ch = this.buffer[i]; ++i) switch (ch) {
     case " ":
      indent += 1;
      break;

     case "\n":
      nl = i, indent = 0;
      break;

     case "\r":
      {
       const next = this.buffer[i + 1];
       if (!next && !this.atEnd) return this.setNext("block-scalar");
       if ("\n" === next) break;
      }

     default:
      break loop;
     }
     if (!ch && !this.atEnd) return this.setNext("block-scalar");
     if (indent >= this.indentNext) {
      -1 === this.blockScalarIndent ? this.indentNext = indent : this.indentNext += this.blockScalarIndent;
      do {
       const cs = this.continueScalar(nl + 1);
       if (-1 === cs) break;
       nl = this.buffer.indexOf("\n", cs);
      } while (-1 !== nl);
      if (-1 === nl) {
       if (!this.atEnd) return this.setNext("block-scalar");
       nl = this.buffer.length;
      }
     }
     if (!this.blockScalarKeep) for (;;) {
      let i = nl - 1, ch = this.buffer[i];
      "\r" === ch && (ch = this.buffer[--i]);
      const lastChar = i;
      for (;" " === ch || "\t" === ch; ) ch = this.buffer[--i];
      if (!("\n" === ch && i >= this.pos && i + 1 + indent > lastChar)) break;
      nl = i;
     }
     return yield cst.SCALAR, yield* this.pushToIndex(nl + 1, !0), yield* this.parseLineStart();
    }
    * parsePlainScalar() {
     const inFlow = this.flowLevel > 0;
     let ch, end = this.pos - 1, i = this.pos - 1;
     for (;ch = this.buffer[++i]; ) if (":" === ch) {
      const next = this.buffer[i + 1];
      if (isEmpty(next) || inFlow && "," === next) break;
      end = i;
     } else if (isEmpty(ch)) {
      let next = this.buffer[i + 1];
      if ("\r" === ch && ("\n" === next ? (i += 1, ch = "\n", next = this.buffer[i + 1]) : end = i), 
      "#" === next || inFlow && invalidFlowScalarChars.includes(next)) break;
      if ("\n" === ch) {
       const cs = this.continueScalar(i + 1);
       if (-1 === cs) break;
       i = Math.max(i, cs - 2);
      }
     } else {
      if (inFlow && invalidFlowScalarChars.includes(ch)) break;
      end = i;
     }
     return ch || this.atEnd ? (yield cst.SCALAR, yield* this.pushToIndex(end + 1, !0), 
     inFlow ? "flow" : "doc") : this.setNext("plain-scalar");
    }
    * pushCount(n) {
     return n > 0 ? (yield this.buffer.substr(this.pos, n), this.pos += n, n) : 0;
    }
    * pushToIndex(i, allowEmpty) {
     const s = this.buffer.slice(this.pos, i);
     return s ? (yield s, this.pos += s.length, s.length) : (allowEmpty && (yield ""), 
     0);
    }
    * pushIndicators() {
     switch (this.charAt(0)) {
     case "!":
      return (yield* this.pushTag()) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());

     case "&":
      return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());

     case "-":
     case "?":
     case ":":
      {
       const inFlow = this.flowLevel > 0, ch1 = this.charAt(1);
       if (isEmpty(ch1) || inFlow && invalidFlowScalarChars.includes(ch1)) return inFlow ? this.flowKey && (this.flowKey = !1) : this.indentNext = this.indentValue + 1, 
       (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      }
     }
     return 0;
    }
    * pushTag() {
     if ("<" === this.charAt(1)) {
      let i = this.pos + 2, ch = this.buffer[i];
      for (;!isEmpty(ch) && ">" !== ch; ) ch = this.buffer[++i];
      return yield* this.pushToIndex(">" === ch ? i + 1 : i, !1);
     }
     {
      let i = this.pos + 1, ch = this.buffer[i];
      for (;ch; ) if (tagChars.includes(ch)) ch = this.buffer[++i]; else {
       if ("%" !== ch || !hexDigits.includes(this.buffer[i + 1]) || !hexDigits.includes(this.buffer[i + 2])) break;
       ch = this.buffer[i += 3];
      }
      return yield* this.pushToIndex(i, !1);
     }
    }
    * pushNewline() {
     const ch = this.buffer[this.pos];
     return "\n" === ch ? yield* this.pushCount(1) : "\r" === ch && "\n" === this.charAt(1) ? yield* this.pushCount(2) : 0;
    }
    * pushSpaces(allowTabs) {
     let ch, i = this.pos - 1;
     do {
      ch = this.buffer[++i];
     } while (" " === ch || allowTabs && "\t" === ch);
     const n = i - this.pos;
     return n > 0 && (yield this.buffer.substr(this.pos, n), this.pos = i), n;
    }
    * pushUntil(test) {
     let i = this.pos, ch = this.buffer[i];
     for (;!test(ch); ) ch = this.buffer[++i];
     return yield* this.pushToIndex(i, !1);
    }
   };
  },
  94708: (__unused_webpack_module, exports) => {
   "use strict";
   exports.LineCounter = class {
    constructor() {
     this.lineStarts = [], this.addNewLine = offset => this.lineStarts.push(offset), 
     this.linePos = offset => {
      let low = 0, high = this.lineStarts.length;
      for (;low < high; ) {
       const mid = low + high >> 1;
       this.lineStarts[mid] < offset ? low = mid + 1 : high = mid;
      }
      if (this.lineStarts[low] === offset) return {
       line: low + 1,
       col: 1
      };
      if (0 === low) return {
       line: 0,
       col: offset
      };
      return {
       line: low,
       col: offset - this.lineStarts[low - 1] + 1
      };
     };
    }
   };
  },
  69369: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var cst = __webpack_require__(75208), lexer = __webpack_require__(87135);
   function includesToken(list, type) {
    for (let i = 0; i < list.length; ++i) if (list[i].type === type) return !0;
    return !1;
   }
   function findNonEmptyIndex(list) {
    for (let i = 0; i < list.length; ++i) switch (list[i].type) {
    case "space":
    case "comment":
    case "newline":
     break;

    default:
     return i;
    }
    return -1;
   }
   function isFlowToken(token) {
    switch (token?.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
     return !0;

    default:
     return !1;
    }
   }
   function getPrevProps(parent) {
    switch (parent.type) {
    case "document":
     return parent.start;

    case "block-map":
     {
      const it = parent.items[parent.items.length - 1];
      return it.sep ?? it.start;
     }

    case "block-seq":
     return parent.items[parent.items.length - 1].start;

    default:
     return [];
    }
   }
   function getFirstKeyStartProps(prev) {
    if (0 === prev.length) return [];
    let i = prev.length;
    loop: for (;--i >= 0; ) switch (prev[i].type) {
    case "doc-start":
    case "explicit-key-ind":
    case "map-value-ind":
    case "seq-item-ind":
    case "newline":
     break loop;
    }
    for (;"space" === prev[++i]?.type; ) ;
    return prev.splice(i, prev.length);
   }
   function fixFlowSeqItems(fc) {
    if ("flow-seq-start" === fc.start.type) for (const it of fc.items) !it.sep || it.value || includesToken(it.start, "explicit-key-ind") || includesToken(it.sep, "map-value-ind") || (it.key && (it.value = it.key), 
    delete it.key, isFlowToken(it.value) ? it.value.end ? Array.prototype.push.apply(it.value.end, it.sep) : it.value.end = it.sep : Array.prototype.push.apply(it.start, it.sep), 
    delete it.sep);
   }
   exports.Parser = class {
    constructor(onNewLine) {
     this.atNewLine = !0, this.atScalar = !1, this.indent = 0, this.offset = 0, this.onKeyLine = !1, 
     this.stack = [], this.source = "", this.type = "", this.lexer = new lexer.Lexer, 
     this.onNewLine = onNewLine;
    }
    * parse(source, incomplete = !1) {
     this.onNewLine && 0 === this.offset && this.onNewLine(0);
     for (const lexeme of this.lexer.lex(source, incomplete)) yield* this.next(lexeme);
     incomplete || (yield* this.end());
    }
    * next(source) {
     if (this.source = source, process.env.LOG_TOKENS && console.log("|", cst.prettyToken(source)), 
     this.atScalar) return this.atScalar = !1, yield* this.step(), void (this.offset += source.length);
     const type = cst.tokenType(source);
     if (type) if ("scalar" === type) this.atNewLine = !1, this.atScalar = !0, this.type = "scalar"; else {
      switch (this.type = type, yield* this.step(), type) {
      case "newline":
       this.atNewLine = !0, this.indent = 0, this.onNewLine && this.onNewLine(this.offset + source.length);
       break;

      case "space":
       this.atNewLine && " " === source[0] && (this.indent += source.length);
       break;

      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
       this.atNewLine && (this.indent += source.length);
       break;

      case "doc-mode":
      case "flow-error-end":
       return;

      default:
       this.atNewLine = !1;
      }
      this.offset += source.length;
     } else {
      const message = `Not a YAML token: ${source}`;
      yield* this.pop({
       type: "error",
       offset: this.offset,
       message,
       source
      }), this.offset += source.length;
     }
    }
    * end() {
     for (;this.stack.length > 0; ) yield* this.pop();
    }
    get sourceToken() {
     return {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
     };
    }
    * step() {
     const top = this.peek(1);
     if ("doc-end" !== this.type || top && "doc-end" === top.type) {
      if (!top) return yield* this.stream();
      switch (top.type) {
      case "document":
       return yield* this.document(top);

      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
       return yield* this.scalar(top);

      case "block-scalar":
       return yield* this.blockScalar(top);

      case "block-map":
       return yield* this.blockMap(top);

      case "block-seq":
       return yield* this.blockSequence(top);

      case "flow-collection":
       return yield* this.flowCollection(top);

      case "doc-end":
       return yield* this.documentEnd(top);
      }
      yield* this.pop();
     } else {
      for (;this.stack.length > 0; ) yield* this.pop();
      this.stack.push({
       type: "doc-end",
       offset: this.offset,
       source: this.source
      });
     }
    }
    peek(n) {
     return this.stack[this.stack.length - n];
    }
    * pop(error) {
     const token = error ?? this.stack.pop();
     if (token) if (0 === this.stack.length) yield token; else {
      const top = this.peek(1);
      switch ("block-scalar" === token.type ? token.indent = "indent" in top ? top.indent : 0 : "flow-collection" === token.type && "document" === top.type && (token.indent = 0), 
      "flow-collection" === token.type && fixFlowSeqItems(token), top.type) {
      case "document":
       top.value = token;
       break;

      case "block-scalar":
       top.props.push(token);
       break;

      case "block-map":
       {
        const it = top.items[top.items.length - 1];
        if (it.value) return top.items.push({
         start: [],
         key: token,
         sep: []
        }), void (this.onKeyLine = !0);
        if (!it.sep) return Object.assign(it, {
         key: token,
         sep: []
        }), void (this.onKeyLine = !includesToken(it.start, "explicit-key-ind"));
        it.value = token;
        break;
       }

      case "block-seq":
       {
        const it = top.items[top.items.length - 1];
        it.value ? top.items.push({
         start: [],
         value: token
        }) : it.value = token;
        break;
       }

      case "flow-collection":
       {
        const it = top.items[top.items.length - 1];
        return void (!it || it.value ? top.items.push({
         start: [],
         key: token,
         sep: []
        }) : it.sep ? it.value = token : Object.assign(it, {
         key: token,
         sep: []
        }));
       }

      default:
       yield* this.pop(), yield* this.pop(token);
      }
      if (!("document" !== top.type && "block-map" !== top.type && "block-seq" !== top.type || "block-map" !== token.type && "block-seq" !== token.type)) {
       const last = token.items[token.items.length - 1];
       last && !last.sep && !last.value && last.start.length > 0 && -1 === findNonEmptyIndex(last.start) && (0 === token.indent || last.start.every((st => "comment" !== st.type || st.indent < token.indent))) && ("document" === top.type ? top.end = last.start : top.items.push({
        start: last.start
       }), token.items.splice(-1, 1));
      }
     } else {
      const message = "Tried to pop an empty stack";
      yield {
       type: "error",
       offset: this.offset,
       source: "",
       message
      };
     }
    }
    * stream() {
     switch (this.type) {
     case "directive-line":
      return void (yield {
       type: "directive",
       offset: this.offset,
       source: this.source
      });

     case "byte-order-mark":
     case "space":
     case "comment":
     case "newline":
      return void (yield this.sourceToken);

     case "doc-mode":
     case "doc-start":
      {
       const doc = {
        type: "document",
        offset: this.offset,
        start: []
       };
       return "doc-start" === this.type && doc.start.push(this.sourceToken), void this.stack.push(doc);
      }
     }
     yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
     };
    }
    * document(doc) {
     if (doc.value) return yield* this.lineEnd(doc);
     switch (this.type) {
     case "doc-start":
      return void (-1 !== findNonEmptyIndex(doc.start) ? (yield* this.pop(), yield* this.step()) : doc.start.push(this.sourceToken));

     case "anchor":
     case "tag":
     case "space":
     case "comment":
     case "newline":
      return void doc.start.push(this.sourceToken);
     }
     const bv = this.startBlockValue(doc);
     bv ? this.stack.push(bv) : yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML document`,
      source: this.source
     };
    }
    * scalar(scalar) {
     if ("map-value-ind" === this.type) {
      const start = getFirstKeyStartProps(getPrevProps(this.peek(2)));
      let sep;
      scalar.end ? (sep = scalar.end, sep.push(this.sourceToken), delete scalar.end) : sep = [ this.sourceToken ];
      const map = {
       type: "block-map",
       offset: scalar.offset,
       indent: scalar.indent,
       items: [ {
        start,
        key: scalar,
        sep
       } ]
      };
      this.onKeyLine = !0, this.stack[this.stack.length - 1] = map;
     } else yield* this.lineEnd(scalar);
    }
    * blockScalar(scalar) {
     switch (this.type) {
     case "space":
     case "comment":
     case "newline":
      return void scalar.props.push(this.sourceToken);

     case "scalar":
      if (scalar.source = this.source, this.atNewLine = !0, this.indent = 0, this.onNewLine) {
       let nl = this.source.indexOf("\n") + 1;
       for (;0 !== nl; ) this.onNewLine(this.offset + nl), nl = this.source.indexOf("\n", nl) + 1;
      }
      yield* this.pop();
      break;

     default:
      yield* this.pop(), yield* this.step();
     }
    }
    * blockMap(map) {
     const it = map.items[map.items.length - 1];
     switch (this.type) {
     case "newline":
      if (this.onKeyLine = !1, it.value) {
       const end = "end" in it.value ? it.value.end : void 0, last = Array.isArray(end) ? end[end.length - 1] : void 0;
       "comment" === last?.type ? end?.push(this.sourceToken) : map.items.push({
        start: [ this.sourceToken ]
       });
      } else it.sep ? it.sep.push(this.sourceToken) : it.start.push(this.sourceToken);
      return;

     case "space":
     case "comment":
      if (it.value) map.items.push({
       start: [ this.sourceToken ]
      }); else if (it.sep) it.sep.push(this.sourceToken); else {
       if (this.atIndentedComment(it.start, map.indent)) {
        const prev = map.items[map.items.length - 2], end = prev?.value?.end;
        if (Array.isArray(end)) return Array.prototype.push.apply(end, it.start), end.push(this.sourceToken), 
        void map.items.pop();
       }
       it.start.push(this.sourceToken);
      }
      return;
     }
     if (this.indent >= map.indent) {
      const atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep;
      let start = [];
      if (atNextItem && it.sep && !it.value) {
       const nl = [];
       for (let i = 0; i < it.sep.length; ++i) {
        const st = it.sep[i];
        switch (st.type) {
        case "newline":
         nl.push(i);
         break;

        case "space":
         break;

        case "comment":
         st.indent > map.indent && (nl.length = 0);
         break;

        default:
         nl.length = 0;
        }
       }
       nl.length >= 2 && (start = it.sep.splice(nl[1]));
      }
      switch (this.type) {
      case "anchor":
      case "tag":
       return void (atNextItem || it.value ? (start.push(this.sourceToken), map.items.push({
        start
       }), this.onKeyLine = !0) : it.sep ? it.sep.push(this.sourceToken) : it.start.push(this.sourceToken));

      case "explicit-key-ind":
       return it.sep || includesToken(it.start, "explicit-key-ind") ? atNextItem || it.value ? (start.push(this.sourceToken), 
       map.items.push({
        start
       })) : this.stack.push({
        type: "block-map",
        offset: this.offset,
        indent: this.indent,
        items: [ {
         start: [ this.sourceToken ]
        } ]
       }) : it.start.push(this.sourceToken), void (this.onKeyLine = !0);

      case "map-value-ind":
       if (includesToken(it.start, "explicit-key-ind")) if (it.sep) if (it.value) map.items.push({
        start: [],
        key: null,
        sep: [ this.sourceToken ]
       }); else if (includesToken(it.sep, "map-value-ind")) this.stack.push({
        type: "block-map",
        offset: this.offset,
        indent: this.indent,
        items: [ {
         start,
         key: null,
         sep: [ this.sourceToken ]
        } ]
       }); else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
        const start = getFirstKeyStartProps(it.start), key = it.key, sep = it.sep;
        sep.push(this.sourceToken), delete it.key, delete it.sep, this.stack.push({
         type: "block-map",
         offset: this.offset,
         indent: this.indent,
         items: [ {
          start,
          key,
          sep
         } ]
        });
       } else start.length > 0 ? it.sep = it.sep.concat(start, this.sourceToken) : it.sep.push(this.sourceToken); else if (includesToken(it.start, "newline")) Object.assign(it, {
        key: null,
        sep: [ this.sourceToken ]
       }); else {
        const start = getFirstKeyStartProps(it.start);
        this.stack.push({
         type: "block-map",
         offset: this.offset,
         indent: this.indent,
         items: [ {
          start,
          key: null,
          sep: [ this.sourceToken ]
         } ]
        });
       } else it.sep ? it.value || atNextItem ? map.items.push({
        start,
        key: null,
        sep: [ this.sourceToken ]
       }) : includesToken(it.sep, "map-value-ind") ? this.stack.push({
        type: "block-map",
        offset: this.offset,
        indent: this.indent,
        items: [ {
         start: [],
         key: null,
         sep: [ this.sourceToken ]
        } ]
       }) : it.sep.push(this.sourceToken) : Object.assign(it, {
        key: null,
        sep: [ this.sourceToken ]
       });
       return void (this.onKeyLine = !0);

      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
       {
        const fs = this.flowScalar(this.type);
        return void (atNextItem || it.value ? (map.items.push({
         start,
         key: fs,
         sep: []
        }), this.onKeyLine = !0) : it.sep ? this.stack.push(fs) : (Object.assign(it, {
         key: fs,
         sep: []
        }), this.onKeyLine = !0));
       }

      default:
       {
        const bv = this.startBlockValue(map);
        if (bv) return atNextItem && "block-seq" !== bv.type && includesToken(it.start, "explicit-key-ind") && map.items.push({
         start
        }), void this.stack.push(bv);
       }
      }
     }
     yield* this.pop(), yield* this.step();
    }
    * blockSequence(seq) {
     const it = seq.items[seq.items.length - 1];
     switch (this.type) {
     case "newline":
      if (it.value) {
       const end = "end" in it.value ? it.value.end : void 0, last = Array.isArray(end) ? end[end.length - 1] : void 0;
       "comment" === last?.type ? end?.push(this.sourceToken) : seq.items.push({
        start: [ this.sourceToken ]
       });
      } else it.start.push(this.sourceToken);
      return;

     case "space":
     case "comment":
      if (it.value) seq.items.push({
       start: [ this.sourceToken ]
      }); else {
       if (this.atIndentedComment(it.start, seq.indent)) {
        const prev = seq.items[seq.items.length - 2], end = prev?.value?.end;
        if (Array.isArray(end)) return Array.prototype.push.apply(end, it.start), end.push(this.sourceToken), 
        void seq.items.pop();
       }
       it.start.push(this.sourceToken);
      }
      return;

     case "anchor":
     case "tag":
      if (it.value || this.indent <= seq.indent) break;
      return void it.start.push(this.sourceToken);

     case "seq-item-ind":
      if (this.indent !== seq.indent) break;
      return void (it.value || includesToken(it.start, "seq-item-ind") ? seq.items.push({
       start: [ this.sourceToken ]
      }) : it.start.push(this.sourceToken));
     }
     if (this.indent > seq.indent) {
      const bv = this.startBlockValue(seq);
      if (bv) return void this.stack.push(bv);
     }
     yield* this.pop(), yield* this.step();
    }
    * flowCollection(fc) {
     const it = fc.items[fc.items.length - 1];
     if ("flow-error-end" === this.type) {
      let top;
      do {
       yield* this.pop(), top = this.peek(1);
      } while (top && "flow-collection" === top.type);
     } else if (0 === fc.end.length) {
      switch (this.type) {
      case "comma":
      case "explicit-key-ind":
       return void (!it || it.sep ? fc.items.push({
        start: [ this.sourceToken ]
       }) : it.start.push(this.sourceToken));

      case "map-value-ind":
       return void (!it || it.value ? fc.items.push({
        start: [],
        key: null,
        sep: [ this.sourceToken ]
       }) : it.sep ? it.sep.push(this.sourceToken) : Object.assign(it, {
        key: null,
        sep: [ this.sourceToken ]
       }));

      case "space":
      case "comment":
      case "newline":
      case "anchor":
      case "tag":
       return void (!it || it.value ? fc.items.push({
        start: [ this.sourceToken ]
       }) : it.sep ? it.sep.push(this.sourceToken) : it.start.push(this.sourceToken));

      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
       {
        const fs = this.flowScalar(this.type);
        return void (!it || it.value ? fc.items.push({
         start: [],
         key: fs,
         sep: []
        }) : it.sep ? this.stack.push(fs) : Object.assign(it, {
         key: fs,
         sep: []
        }));
       }

      case "flow-map-end":
      case "flow-seq-end":
       return void fc.end.push(this.sourceToken);
      }
      const bv = this.startBlockValue(fc);
      bv ? this.stack.push(bv) : (yield* this.pop(), yield* this.step());
     } else {
      const parent = this.peek(2);
      if ("block-map" === parent.type && ("map-value-ind" === this.type && parent.indent === fc.indent || "newline" === this.type && !parent.items[parent.items.length - 1].sep)) yield* this.pop(), 
      yield* this.step(); else if ("map-value-ind" === this.type && "flow-collection" !== parent.type) {
       const start = getFirstKeyStartProps(getPrevProps(parent));
       fixFlowSeqItems(fc);
       const sep = fc.end.splice(1, fc.end.length);
       sep.push(this.sourceToken);
       const map = {
        type: "block-map",
        offset: fc.offset,
        indent: fc.indent,
        items: [ {
         start,
         key: fc,
         sep
        } ]
       };
       this.onKeyLine = !0, this.stack[this.stack.length - 1] = map;
      } else yield* this.lineEnd(fc);
     }
    }
    flowScalar(type) {
     if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      for (;0 !== nl; ) this.onNewLine(this.offset + nl), nl = this.source.indexOf("\n", nl) + 1;
     }
     return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
     };
    }
    startBlockValue(parent) {
     switch (this.type) {
     case "alias":
     case "scalar":
     case "single-quoted-scalar":
     case "double-quoted-scalar":
      return this.flowScalar(this.type);

     case "block-scalar-header":
      return {
       type: "block-scalar",
       offset: this.offset,
       indent: this.indent,
       props: [ this.sourceToken ],
       source: ""
      };

     case "flow-map-start":
     case "flow-seq-start":
      return {
       type: "flow-collection",
       offset: this.offset,
       indent: this.indent,
       start: this.sourceToken,
       items: [],
       end: []
      };

     case "seq-item-ind":
      return {
       type: "block-seq",
       offset: this.offset,
       indent: this.indent,
       items: [ {
        start: [ this.sourceToken ]
       } ]
      };

     case "explicit-key-ind":
      {
       this.onKeyLine = !0;
       const start = getFirstKeyStartProps(getPrevProps(parent));
       return start.push(this.sourceToken), {
        type: "block-map",
        offset: this.offset,
        indent: this.indent,
        items: [ {
         start
        } ]
       };
      }

     case "map-value-ind":
      {
       this.onKeyLine = !0;
       const start = getFirstKeyStartProps(getPrevProps(parent));
       return {
        type: "block-map",
        offset: this.offset,
        indent: this.indent,
        items: [ {
         start,
         key: null,
         sep: [ this.sourceToken ]
        } ]
       };
      }
     }
     return null;
    }
    atIndentedComment(start, indent) {
     return "comment" === this.type && (!(this.indent <= indent) && start.every((st => "newline" === st.type || "space" === st.type)));
    }
    * documentEnd(docEnd) {
     "doc-mode" !== this.type && (docEnd.end ? docEnd.end.push(this.sourceToken) : docEnd.end = [ this.sourceToken ], 
     "newline" === this.type && (yield* this.pop()));
    }
    * lineEnd(token) {
     switch (this.type) {
     case "comma":
     case "doc-start":
     case "doc-end":
     case "flow-seq-end":
     case "flow-map-end":
     case "map-value-ind":
      yield* this.pop(), yield* this.step();
      break;

     case "newline":
      this.onKeyLine = !1;

     default:
      token.end ? token.end.push(this.sourceToken) : token.end = [ this.sourceToken ], 
      "newline" === this.type && (yield* this.pop());
     }
    }
   };
  },
  68011: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var composer = __webpack_require__(5281), Document = __webpack_require__(86068), errors = __webpack_require__(2394), log = __webpack_require__(95441), lineCounter = __webpack_require__(94708), parser = __webpack_require__(69369);
   function parseOptions(options) {
    const prettyErrors = !1 !== options.prettyErrors;
    return {
     lineCounter: options.lineCounter || prettyErrors && new lineCounter.LineCounter || null,
     prettyErrors
    };
   }
   function parseDocument(source, options = {}) {
    const {lineCounter, prettyErrors} = parseOptions(options), parser$1 = new parser.Parser(lineCounter?.addNewLine), composer$1 = new composer.Composer(options);
    let doc = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), !0, source.length)) if (doc) {
     if ("silent" !== doc.options.logLevel) {
      doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
     }
    } else doc = _doc;
    return prettyErrors && lineCounter && (doc.errors.forEach(errors.prettifyError(source, lineCounter)), 
    doc.warnings.forEach(errors.prettifyError(source, lineCounter))), doc;
   }
   exports.parse = function(src, reviver, options) {
    let _reviver;
    "function" == typeof reviver ? _reviver = reviver : void 0 === options && reviver && "object" == typeof reviver && (options = reviver);
    const doc = parseDocument(src, options);
    if (!doc) return null;
    if (doc.warnings.forEach((warning => log.warn(doc.options.logLevel, warning))), 
    doc.errors.length > 0) {
     if ("silent" !== doc.options.logLevel) throw doc.errors[0];
     doc.errors = [];
    }
    return doc.toJS(Object.assign({
     reviver: _reviver
    }, options));
   }, exports.parseAllDocuments = function(source, options = {}) {
    const {lineCounter, prettyErrors} = parseOptions(options), parser$1 = new parser.Parser(lineCounter?.addNewLine), composer$1 = new composer.Composer(options), docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors && lineCounter) for (const doc of docs) doc.errors.forEach(errors.prettifyError(source, lineCounter)), 
    doc.warnings.forEach(errors.prettifyError(source, lineCounter));
    return docs.length > 0 ? docs : Object.assign([], {
     empty: !0
    }, composer$1.streamInfo());
   }, exports.parseDocument = parseDocument, exports.stringify = function(value, replacer, options) {
    let _replacer = null;
    if ("function" == typeof replacer || Array.isArray(replacer) ? _replacer = replacer : void 0 === options && replacer && (options = replacer), 
    "string" == typeof options && (options = options.length), "number" == typeof options) {
     const indent = Math.round(options);
     options = indent < 1 ? void 0 : indent > 8 ? {
      indent: 8
     } : {
      indent
     };
    }
    if (void 0 === value) {
     const {keepUndefined} = options ?? replacer ?? {};
     if (!keepUndefined) return;
    }
    return new Document.Document(value, _replacer, options).toString(options);
   };
  },
  23673: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(60163), map = __webpack_require__(92744), seq = __webpack_require__(52360), string = __webpack_require__(73042), tags = __webpack_require__(76524);
   const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
   class Schema {
    constructor({compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults}) {
     this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null, 
     this.merge = !!merge, this.name = "string" == typeof schema && schema || "core", 
     this.knownTags = resolveKnownTags ? tags.coreKnownTags : {}, this.tags = tags.getTags(customTags, this.name), 
     this.toStringOptions = toStringDefaults ?? null, Object.defineProperty(this, identity.MAP, {
      value: map.map
     }), Object.defineProperty(this, identity.SCALAR, {
      value: string.string
     }), Object.defineProperty(this, identity.SEQ, {
      value: seq.seq
     }), this.sortMapEntries = "function" == typeof sortMapEntries ? sortMapEntries : !0 === sortMapEntries ? sortMapEntriesByKey : null;
    }
    clone() {
     const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
     return copy.tags = this.tags.slice(), copy;
    }
   }
   exports.Schema = Schema;
  },
  92744: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(60163), YAMLMap = __webpack_require__(56575);
   const map = {
    collection: "map",
    default: !0,
    nodeClass: YAMLMap.YAMLMap,
    tag: "tag:yaml.org,2002:map",
    resolve: (map, onError) => (identity.isMap(map) || onError("Expected a mapping for this tag"), 
    map),
    createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
   };
   exports.map = map;
  },
  25397: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Scalar = __webpack_require__(58844);
   const nullTag = {
    identify: value => null == value,
    createNode: () => new Scalar.Scalar(null),
    default: !0,
    tag: "tag:yaml.org,2002:null",
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar.Scalar(null),
    stringify: ({source}, ctx) => "string" == typeof source && nullTag.test.test(source) ? source : ctx.options.nullStr
   };
   exports.nullTag = nullTag;
  },
  52360: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(60163), YAMLSeq = __webpack_require__(13798);
   const seq = {
    collection: "seq",
    default: !0,
    nodeClass: YAMLSeq.YAMLSeq,
    tag: "tag:yaml.org,2002:seq",
    resolve: (seq, onError) => (identity.isSeq(seq) || onError("Expected a sequence for this tag"), 
    seq),
    createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
   };
   exports.seq = seq;
  },
  73042: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var stringifyString = __webpack_require__(98431);
   const string = {
    identify: value => "string" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:str",
    resolve: str => str,
    stringify: (item, ctx, onComment, onChompKeep) => (ctx = Object.assign({
     actualString: !0
    }, ctx), stringifyString.stringifyString(item, ctx, onComment, onChompKeep))
   };
   exports.string = string;
  },
  50976: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Scalar = __webpack_require__(58844);
   const boolTag = {
    identify: value => "boolean" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: str => new Scalar.Scalar("t" === str[0] || "T" === str[0]),
    stringify({source, value}, ctx) {
     if (source && boolTag.test.test(source)) {
      if (value === ("t" === source[0] || "T" === source[0])) return source;
     }
     return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
   };
   exports.boolTag = boolTag;
  },
  13398: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Scalar = __webpack_require__(58844), stringifyNumber = __webpack_require__(15260);
   const floatNaN = {
    identify: value => "number" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
    resolve: str => "nan" === str.slice(-3).toLowerCase() ? NaN : "-" === str[0] ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
   }, floatExp = {
    identify: value => "number" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: str => parseFloat(str),
    stringify(node) {
     const num = Number(node.value);
     return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
   }, float = {
    identify: value => "number" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
     const node = new Scalar.Scalar(parseFloat(str)), dot = str.indexOf(".");
     return -1 !== dot && "0" === str[str.length - 1] && (node.minFractionDigits = str.length - dot - 1), 
     node;
    },
    stringify: stringifyNumber.stringifyNumber
   };
   exports.float = float, exports.floatExp = floatExp, exports.floatNaN = floatNaN;
  },
  64723: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var stringifyNumber = __webpack_require__(15260);
   const intIdentify = value => "bigint" == typeof value || Number.isInteger(value), intResolve = (str, offset, radix, {intAsBigInt}) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
   function intStringify(node, radix, prefix) {
    const {value} = node;
    return intIdentify(value) && value >= 0 ? prefix + value.toString(radix) : stringifyNumber.stringifyNumber(node);
   }
   const intOct = {
    identify: value => intIdentify(value) && value >= 0,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
    stringify: node => intStringify(node, 8, "0o")
   }, int = {
    identify: intIdentify,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
   }, intHex = {
    identify: value => intIdentify(value) && value >= 0,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, "0x")
   };
   exports.int = int, exports.intHex = intHex, exports.intOct = intOct;
  },
  63305: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var map = __webpack_require__(92744), _null = __webpack_require__(25397), seq = __webpack_require__(52360), string = __webpack_require__(73042), bool = __webpack_require__(50976), float = __webpack_require__(13398), int = __webpack_require__(64723);
   const schema = [ map.map, seq.seq, string.string, _null.nullTag, bool.boolTag, int.intOct, int.int, int.intHex, float.floatNaN, float.floatExp, float.float ];
   exports.schema = schema;
  },
  27854: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Scalar = __webpack_require__(58844), map = __webpack_require__(92744), seq = __webpack_require__(52360);
   function intIdentify(value) {
    return "bigint" == typeof value || Number.isInteger(value);
   }
   const stringifyJSON = ({value}) => JSON.stringify(value), jsonScalars = [ {
    identify: value => "string" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:str",
    resolve: str => str,
    stringify: stringifyJSON
   }, {
    identify: value => null == value,
    createNode: () => new Scalar.Scalar(null),
    default: !0,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
   }, {
    identify: value => "boolean" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:bool",
    test: /^true|false$/,
    resolve: str => "true" === str,
    stringify: stringifyJSON
   }, {
    identify: intIdentify,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, {intAsBigInt}) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({value}) => intIdentify(value) ? value.toString() : JSON.stringify(value)
   }, {
    identify: value => "number" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: str => parseFloat(str),
    stringify: stringifyJSON
   } ], jsonError = {
    default: !0,
    tag: "",
    test: /^/,
    resolve: (str, onError) => (onError(`Unresolved plain scalar ${JSON.stringify(str)}`), 
    str)
   }, schema = [ map.map, seq.seq ].concat(jsonScalars, jsonError);
   exports.schema = schema;
  },
  76524: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var map = __webpack_require__(92744), _null = __webpack_require__(25397), seq = __webpack_require__(52360), string = __webpack_require__(73042), bool = __webpack_require__(50976), float = __webpack_require__(13398), int = __webpack_require__(64723), schema = __webpack_require__(63305), schema$1 = __webpack_require__(27854), binary = __webpack_require__(38798), omap = __webpack_require__(71367), pairs = __webpack_require__(63879), schema$2 = __webpack_require__(10163), set = __webpack_require__(87559), timestamp = __webpack_require__(67714);
   const schemas = new Map([ [ "core", schema.schema ], [ "failsafe", [ map.map, seq.seq, string.string ] ], [ "json", schema$1.schema ], [ "yaml11", schema$2.schema ], [ "yaml-1.1", schema$2.schema ] ]), tagsByName = {
    binary: binary.binary,
    bool: bool.boolTag,
    float: float.float,
    floatExp: float.floatExp,
    floatNaN: float.floatNaN,
    floatTime: timestamp.floatTime,
    int: int.int,
    intHex: int.intHex,
    intOct: int.intOct,
    intTime: timestamp.intTime,
    map: map.map,
    null: _null.nullTag,
    omap: omap.omap,
    pairs: pairs.pairs,
    seq: seq.seq,
    set: set.set,
    timestamp: timestamp.timestamp
   }, coreKnownTags = {
    "tag:yaml.org,2002:binary": binary.binary,
    "tag:yaml.org,2002:omap": omap.omap,
    "tag:yaml.org,2002:pairs": pairs.pairs,
    "tag:yaml.org,2002:set": set.set,
    "tag:yaml.org,2002:timestamp": timestamp.timestamp
   };
   exports.coreKnownTags = coreKnownTags, exports.getTags = function(customTags, schemaName) {
    let tags = schemas.get(schemaName);
    if (!tags) {
     if (!Array.isArray(customTags)) {
      const keys = Array.from(schemas.keys()).filter((key => "yaml11" !== key)).map((key => JSON.stringify(key))).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
     }
     tags = [];
    }
    if (Array.isArray(customTags)) for (const tag of customTags) tags = tags.concat(tag); else "function" == typeof customTags && (tags = customTags(tags.slice()));
    return tags.map((tag => {
     if ("string" != typeof tag) return tag;
     const tagObj = tagsByName[tag];
     if (tagObj) return tagObj;
     const keys = Object.keys(tagsByName).map((key => JSON.stringify(key))).join(", ");
     throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
    }));
   };
  },
  38798: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Scalar = __webpack_require__(58844), stringifyString = __webpack_require__(98431);
   const binary = {
    identify: value => value instanceof Uint8Array,
    default: !1,
    tag: "tag:yaml.org,2002:binary",
    resolve(src, onError) {
     if ("function" == typeof Buffer) return Buffer.from(src, "base64");
     if ("function" == typeof atob) {
      const str = atob(src.replace(/[\n\r]/g, "")), buffer = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);
      return buffer;
     }
     return onError("This environment does not support reading binary tags; either Buffer or atob is required"), 
     src;
    },
    stringify({comment, type, value}, ctx, onComment, onChompKeep) {
     const buf = value;
     let str;
     if ("function" == typeof Buffer) str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64"); else {
      if ("function" != typeof btoa) throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
      {
       let s = "";
       for (let i = 0; i < buf.length; ++i) s += String.fromCharCode(buf[i]);
       str = btoa(s);
      }
     }
     if (type || (type = Scalar.Scalar.BLOCK_LITERAL), type !== Scalar.Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth), n = Math.ceil(str.length / lineWidth), lines = new Array(n);
      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) lines[i] = str.substr(o, lineWidth);
      str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
     }
     return stringifyString.stringifyString({
      comment,
      type,
      value: str
     }, ctx, onComment, onChompKeep);
    }
   };
   exports.binary = binary;
  },
  69466: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Scalar = __webpack_require__(58844);
   function boolStringify({value, source}, ctx) {
    return source && (value ? trueTag : falseTag).test.test(source) ? source : value ? ctx.options.trueStr : ctx.options.falseStr;
   }
   const trueTag = {
    identify: value => !0 === value,
    default: !0,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar.Scalar(!0),
    stringify: boolStringify
   }, falseTag = {
    identify: value => !1 === value,
    default: !0,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
    resolve: () => new Scalar.Scalar(!1),
    stringify: boolStringify
   };
   exports.falseTag = falseTag, exports.trueTag = trueTag;
  },
  13922: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Scalar = __webpack_require__(58844), stringifyNumber = __webpack_require__(15260);
   const floatNaN = {
    identify: value => "number" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
    resolve: str => "nan" === str.slice(-3).toLowerCase() ? NaN : "-" === str[0] ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
   }, floatExp = {
    identify: value => "number" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: str => parseFloat(str.replace(/_/g, "")),
    stringify(node) {
     const num = Number(node.value);
     return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
   }, float = {
    identify: value => "number" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
     const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, ""))), dot = str.indexOf(".");
     if (-1 !== dot) {
      const f = str.substring(dot + 1).replace(/_/g, "");
      "0" === f[f.length - 1] && (node.minFractionDigits = f.length);
     }
     return node;
    },
    stringify: stringifyNumber.stringifyNumber
   };
   exports.float = float, exports.floatExp = floatExp, exports.floatNaN = floatNaN;
  },
  5563: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var stringifyNumber = __webpack_require__(15260);
   const intIdentify = value => "bigint" == typeof value || Number.isInteger(value);
   function intResolve(str, offset, radix, {intAsBigInt}) {
    const sign = str[0];
    if ("-" !== sign && "+" !== sign || (offset += 1), str = str.substring(offset).replace(/_/g, ""), 
    intAsBigInt) {
     switch (radix) {
     case 2:
      str = `0b${str}`;
      break;

     case 8:
      str = `0o${str}`;
      break;

     case 16:
      str = `0x${str}`;
     }
     const n = BigInt(str);
     return "-" === sign ? BigInt(-1) * n : n;
    }
    const n = parseInt(str, radix);
    return "-" === sign ? -1 * n : n;
   }
   function intStringify(node, radix, prefix) {
    const {value} = node;
    if (intIdentify(value)) {
     const str = value.toString(radix);
     return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber.stringifyNumber(node);
   }
   const intBin = {
    identify: intIdentify,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    format: "BIN",
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: node => intStringify(node, 2, "0b")
   }, intOct = {
    identify: intIdentify,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: node => intStringify(node, 8, "0")
   }, int = {
    identify: intIdentify,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
   }, intHex = {
    identify: intIdentify,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, "0x")
   };
   exports.int = int, exports.intBin = intBin, exports.intHex = intHex, exports.intOct = intOct;
  },
  71367: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(60163), toJS = __webpack_require__(93257), YAMLMap = __webpack_require__(56575), YAMLSeq = __webpack_require__(13798), pairs = __webpack_require__(63879);
   class YAMLOMap extends YAMLSeq.YAMLSeq {
    constructor() {
     super(), this.add = YAMLMap.YAMLMap.prototype.add.bind(this), this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this), 
     this.get = YAMLMap.YAMLMap.prototype.get.bind(this), this.has = YAMLMap.YAMLMap.prototype.has.bind(this), 
     this.set = YAMLMap.YAMLMap.prototype.set.bind(this), this.tag = YAMLOMap.tag;
    }
    toJSON(_, ctx) {
     if (!ctx) return super.toJSON(_);
     const map = new Map;
     ctx?.onCreate && ctx.onCreate(map);
     for (const pair of this.items) {
      let key, value;
      if (identity.isPair(pair) ? (key = toJS.toJS(pair.key, "", ctx), value = toJS.toJS(pair.value, key, ctx)) : key = toJS.toJS(pair, "", ctx), 
      map.has(key)) throw new Error("Ordered maps must not include duplicate keys");
      map.set(key, value);
     }
     return map;
    }
    static from(schema, iterable, ctx) {
     const pairs$1 = pairs.createPairs(schema, iterable, ctx), omap = new this;
     return omap.items = pairs$1.items, omap;
    }
   }
   YAMLOMap.tag = "tag:yaml.org,2002:omap";
   const omap = {
    collection: "seq",
    identify: value => value instanceof Map,
    nodeClass: YAMLOMap,
    default: !1,
    tag: "tag:yaml.org,2002:omap",
    resolve(seq, onError) {
     const pairs$1 = pairs.resolvePairs(seq, onError), seenKeys = [];
     for (const {key} of pairs$1.items) identity.isScalar(key) && (seenKeys.includes(key.value) ? onError(`Ordered maps must not include duplicate keys: ${key.value}`) : seenKeys.push(key.value));
     return Object.assign(new YAMLOMap, pairs$1);
    },
    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
   };
   exports.YAMLOMap = YAMLOMap, exports.omap = omap;
  },
  63879: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(60163), Pair = __webpack_require__(10394), Scalar = __webpack_require__(58844), YAMLSeq = __webpack_require__(13798);
   function resolvePairs(seq, onError) {
    if (identity.isSeq(seq)) for (let i = 0; i < seq.items.length; ++i) {
     let item = seq.items[i];
     if (!identity.isPair(item)) {
      if (identity.isMap(item)) {
       item.items.length > 1 && onError("Each pair must have its own sequence indicator");
       const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
       if (item.commentBefore && (pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}\n${pair.key.commentBefore}` : item.commentBefore), 
       item.comment) {
        const cn = pair.value ?? pair.key;
        cn.comment = cn.comment ? `${item.comment}\n${cn.comment}` : item.comment;
       }
       item = pair;
      }
      seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
     }
    } else onError("Expected a sequence for this tag");
    return seq;
   }
   function createPairs(schema, iterable, ctx) {
    const {replacer} = ctx, pairs = new YAMLSeq.YAMLSeq(schema);
    pairs.tag = "tag:yaml.org,2002:pairs";
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable)) for (let it of iterable) {
     let key, value;
     if ("function" == typeof replacer && (it = replacer.call(iterable, String(i++), it)), 
     Array.isArray(it)) {
      if (2 !== it.length) throw new TypeError(`Expected [key, value] tuple: ${it}`);
      key = it[0], value = it[1];
     } else if (it && it instanceof Object) {
      const keys = Object.keys(it);
      if (1 !== keys.length) throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
      key = keys[0], value = it[key];
     } else key = it;
     pairs.items.push(Pair.createPair(key, value, ctx));
    }
    return pairs;
   }
   const pairs = {
    collection: "seq",
    default: !1,
    tag: "tag:yaml.org,2002:pairs",
    resolve: resolvePairs,
    createNode: createPairs
   };
   exports.createPairs = createPairs, exports.pairs = pairs, exports.resolvePairs = resolvePairs;
  },
  10163: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var map = __webpack_require__(92744), _null = __webpack_require__(25397), seq = __webpack_require__(52360), string = __webpack_require__(73042), binary = __webpack_require__(38798), bool = __webpack_require__(69466), float = __webpack_require__(13922), int = __webpack_require__(5563), omap = __webpack_require__(71367), pairs = __webpack_require__(63879), set = __webpack_require__(87559), timestamp = __webpack_require__(67714);
   const schema = [ map.map, seq.seq, string.string, _null.nullTag, bool.trueTag, bool.falseTag, int.intBin, int.intOct, int.int, int.intHex, float.floatNaN, float.floatExp, float.float, binary.binary, omap.omap, pairs.pairs, set.set, timestamp.intTime, timestamp.floatTime, timestamp.timestamp ];
   exports.schema = schema;
  },
  87559: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(60163), Pair = __webpack_require__(10394), YAMLMap = __webpack_require__(56575);
   class YAMLSet extends YAMLMap.YAMLMap {
    constructor(schema) {
     super(schema), this.tag = YAMLSet.tag;
    }
    add(key) {
     let pair;
     pair = identity.isPair(key) ? key : key && "object" == typeof key && "key" in key && "value" in key && null === key.value ? new Pair.Pair(key.key, null) : new Pair.Pair(key, null);
     YAMLMap.findPair(this.items, pair.key) || this.items.push(pair);
    }
    get(key, keepPair) {
     const pair = YAMLMap.findPair(this.items, key);
     return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
    }
    set(key, value) {
     if ("boolean" != typeof value) throw new Error("Expected boolean value for set(key, value) in a YAML set, not " + typeof value);
     const prev = YAMLMap.findPair(this.items, key);
     prev && !value ? this.items.splice(this.items.indexOf(prev), 1) : !prev && value && this.items.push(new Pair.Pair(key));
    }
    toJSON(_, ctx) {
     return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
     if (!ctx) return JSON.stringify(this);
     if (this.hasAllNullValues(!0)) return super.toString(Object.assign({}, ctx, {
      allNullValues: !0
     }), onComment, onChompKeep);
     throw new Error("Set items must all have null values");
    }
    static from(schema, iterable, ctx) {
     const {replacer} = ctx, set = new this(schema);
     if (iterable && Symbol.iterator in Object(iterable)) for (let value of iterable) "function" == typeof replacer && (value = replacer.call(iterable, value, value)), 
     set.items.push(Pair.createPair(value, null, ctx));
     return set;
    }
   }
   YAMLSet.tag = "tag:yaml.org,2002:set";
   const set = {
    collection: "map",
    identify: value => value instanceof Set,
    nodeClass: YAMLSet,
    default: !1,
    tag: "tag:yaml.org,2002:set",
    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
    resolve(map, onError) {
     if (identity.isMap(map)) {
      if (map.hasAllNullValues(!0)) return Object.assign(new YAMLSet, map);
      onError("Set items must all have null values");
     } else onError("Expected a mapping for this tag");
     return map;
    }
   };
   exports.YAMLSet = YAMLSet, exports.set = set;
  },
  67714: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var stringifyNumber = __webpack_require__(15260);
   function parseSexagesimal(str, asBigInt) {
    const sign = str[0], parts = "-" === sign || "+" === sign ? str.substring(1) : str, num = n => asBigInt ? BigInt(n) : Number(n), res = parts.replace(/_/g, "").split(":").reduce(((res, p) => res * num(60) + num(p)), num(0));
    return "-" === sign ? num(-1) * res : res;
   }
   function stringifySexagesimal(node) {
    let {value} = node, num = n => n;
    if ("bigint" == typeof value) num = n => BigInt(n); else if (isNaN(value) || !isFinite(value)) return stringifyNumber.stringifyNumber(node);
    let sign = "";
    value < 0 && (sign = "-", value *= num(-1));
    const _60 = num(60), parts = [ value % _60 ];
    return value < 60 ? parts.unshift(0) : (value = (value - parts[0]) / _60, parts.unshift(value % _60), 
    value >= 60 && (value = (value - parts[0]) / _60, parts.unshift(value))), sign + parts.map((n => String(n).padStart(2, "0"))).join(":").replace(/000000\d*$/, "");
   }
   const intTime = {
    identify: value => "bigint" == typeof value || Number.isInteger(value),
    default: !0,
    tag: "tag:yaml.org,2002:int",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, {intAsBigInt}) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
   }, floatTime = {
    identify: value => "number" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:float",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: str => parseSexagesimal(str, !1),
    stringify: stringifySexagesimal
   }, timestamp = {
    identify: value => value instanceof Date,
    default: !0,
    tag: "tag:yaml.org,2002:timestamp",
    test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
    resolve(str) {
     const match = str.match(timestamp.test);
     if (!match) throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
     const [, year, month, day, hour, minute, second] = match.map(Number), millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
     let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
     const tz = match[8];
     if (tz && "Z" !== tz) {
      let d = parseSexagesimal(tz, !1);
      Math.abs(d) < 30 && (d *= 60), date -= 6e4 * d;
     }
     return new Date(date);
    },
    stringify: ({value}) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
   };
   exports.floatTime = floatTime, exports.intTime = intTime, exports.timestamp = timestamp;
  },
  94112: (__unused_webpack_module, exports) => {
   "use strict";
   function consumeMoreIndentedLines(text, i) {
    let ch = text[i + 1];
    for (;" " === ch || "\t" === ch; ) {
     do {
      ch = text[i += 1];
     } while (ch && "\n" !== ch);
     ch = text[i + 1];
    }
    return i;
   }
   exports.FOLD_BLOCK = "block", exports.FOLD_FLOW = "flow", exports.FOLD_QUOTED = "quoted", 
   exports.foldFlowLines = function(text, indent, mode = "flow", {indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow} = {}) {
    if (!lineWidth || lineWidth < 0) return text;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep) return text;
    const folds = [], escapedFolds = {};
    let split, prev, end = lineWidth - indent.length;
    "number" == typeof indentAtStart && (indentAtStart > lineWidth - Math.max(2, minContentWidth) ? folds.push(0) : end = lineWidth - indentAtStart);
    let overflow = !1, i = -1, escStart = -1, escEnd = -1;
    "block" === mode && (i = consumeMoreIndentedLines(text, i), -1 !== i && (end = i + endStep));
    for (let ch; ch = text[i += 1]; ) {
     if ("quoted" === mode && "\\" === ch) {
      switch (escStart = i, text[i + 1]) {
      case "x":
       i += 3;
       break;

      case "u":
       i += 5;
       break;

      case "U":
       i += 9;
       break;

      default:
       i += 1;
      }
      escEnd = i;
     }
     if ("\n" === ch) "block" === mode && (i = consumeMoreIndentedLines(text, i)), end = i + endStep, 
     split = void 0; else {
      if (" " === ch && prev && " " !== prev && "\n" !== prev && "\t" !== prev) {
       const next = text[i + 1];
       next && " " !== next && "\n" !== next && "\t" !== next && (split = i);
      }
      if (i >= end) if (split) folds.push(split), end = split + endStep, split = void 0; else if ("quoted" === mode) {
       for (;" " === prev || "\t" === prev; ) prev = ch, ch = text[i += 1], overflow = !0;
       const j = i > escEnd + 1 ? i - 2 : escStart - 1;
       if (escapedFolds[j]) return text;
       folds.push(j), escapedFolds[j] = !0, end = j + endStep, split = void 0;
      } else overflow = !0;
     }
     prev = ch;
    }
    if (overflow && onOverflow && onOverflow(), 0 === folds.length) return text;
    onFold && onFold();
    let res = text.slice(0, folds[0]);
    for (let i = 0; i < folds.length; ++i) {
     const fold = folds[i], end = folds[i + 1] || text.length;
     0 === fold ? res = `\n${indent}${text.slice(0, end)}` : ("quoted" === mode && escapedFolds[fold] && (res += `${text[fold]}\\`), 
     res += `\n${indent}${text.slice(fold + 1, end)}`);
    }
    return res;
   };
  },
  20611: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var anchors = __webpack_require__(21903), identity = __webpack_require__(60163), stringifyComment = __webpack_require__(28463), stringifyString = __webpack_require__(98431);
   exports.createStringifyContext = function(doc, options) {
    const opt = Object.assign({
     blockQuote: !0,
     commentString: stringifyComment.stringifyComment,
     defaultKeyType: null,
     defaultStringType: "PLAIN",
     directives: null,
     doubleQuotedAsJSON: !1,
     doubleQuotedMinMultiLineLength: 40,
     falseStr: "false",
     flowCollectionPadding: !0,
     indentSeq: !0,
     lineWidth: 80,
     minContentWidth: 20,
     nullStr: "null",
     simpleKeys: !1,
     singleQuote: null,
     trueStr: "true",
     verifyAliasOrder: !0
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
    case "block":
     inFlow = !1;
     break;

    case "flow":
     inFlow = !0;
     break;

    default:
     inFlow = null;
    }
    return {
     anchors: new Set,
     doc,
     flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
     indent: "",
     indentStep: "number" == typeof opt.indent ? " ".repeat(opt.indent) : "  ",
     inFlow,
     options: opt
    };
   }, exports.stringify = function(item, ctx, onComment, onChompKeep) {
    if (identity.isPair(item)) return item.toString(ctx, onComment, onChompKeep);
    if (identity.isAlias(item)) {
     if (ctx.doc.directives) return item.toString(ctx);
     if (ctx.resolvedAliases?.has(item)) throw new TypeError("Cannot stringify circular structure without alias nodes");
     ctx.resolvedAliases ? ctx.resolvedAliases.add(item) : ctx.resolvedAliases = new Set([ item ]), 
     item = item.resolve(ctx.doc);
    }
    let tagObj;
    const node = identity.isNode(item) ? item : ctx.doc.createNode(item, {
     onTagObj: o => tagObj = o
    });
    tagObj || (tagObj = function(tags, item) {
     if (item.tag) {
      const match = tags.filter((t => t.tag === item.tag));
      if (match.length > 0) return match.find((t => t.format === item.format)) ?? match[0];
     }
     let tagObj, obj;
     if (identity.isScalar(item)) {
      obj = item.value;
      const match = tags.filter((t => t.identify?.(obj)));
      tagObj = match.find((t => t.format === item.format)) ?? match.find((t => !t.format));
     } else obj = item, tagObj = tags.find((t => t.nodeClass && obj instanceof t.nodeClass));
     if (!tagObj) throw new Error(`Tag not resolved for ${obj?.constructor?.name ?? typeof obj} value`);
     return tagObj;
    }(ctx.doc.schema.tags, node));
    const props = function(node, tagObj, {anchors: anchors$1, doc}) {
     if (!doc.directives) return "";
     const props = [], anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
     anchor && anchors.anchorIsValid(anchor) && (anchors$1.add(anchor), props.push(`&${anchor}`));
     const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
     return tag && props.push(doc.directives.tagString(tag)), props.join(" ");
    }(node, tagObj, ctx);
    props.length > 0 && (ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1);
    const str = "function" == typeof tagObj.stringify ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
    return props ? identity.isScalar(node) || "{" === str[0] || "[" === str[0] ? `${props} ${str}` : `${props}\n${ctx.indent}${str}` : str;
   };
  },
  40240: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Collection = __webpack_require__(43365), identity = __webpack_require__(60163), stringify = __webpack_require__(20611), stringifyComment = __webpack_require__(28463);
   function stringifyBlockCollection({comment, items}, ctx, {blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment}) {
    const {indent, options: {commentString}} = ctx, itemCtx = Object.assign({}, ctx, {
     indent: itemIndent,
     type: null
    });
    let chompKeep = !1;
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
     const item = items[i];
     let comment = null;
     if (identity.isNode(item)) !chompKeep && item.spaceBefore && lines.push(""), addCommentBefore(ctx, lines, item.commentBefore, chompKeep), 
     item.comment && (comment = item.comment); else if (identity.isPair(item)) {
      const ik = identity.isNode(item.key) ? item.key : null;
      ik && (!chompKeep && ik.spaceBefore && lines.push(""), addCommentBefore(ctx, lines, ik.commentBefore, chompKeep));
     }
     chompKeep = !1;
     let str = stringify.stringify(item, itemCtx, (() => comment = null), (() => chompKeep = !0));
     comment && (str += stringifyComment.lineComment(str, itemIndent, commentString(comment))), 
     chompKeep && comment && (chompKeep = !1), lines.push(blockItemPrefix + str);
    }
    let str;
    if (0 === lines.length) str = flowChars.start + flowChars.end; else {
     str = lines[0];
     for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `\n${indent}${line}` : "\n";
     }
    }
    return comment ? (str += "\n" + stringifyComment.indentComment(commentString(comment), indent), 
    onComment && onComment()) : chompKeep && onChompKeep && onChompKeep(), str;
   }
   function stringifyFlowCollection({comment, items}, ctx, {flowChars, itemIndent, onComment}) {
    const {indent, indentStep, flowCollectionPadding: fcPadding, options: {commentString}} = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
     indent: itemIndent,
     inFlow: !0,
     type: null
    });
    let reqNewline = !1, linesAtValue = 0;
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
     const item = items[i];
     let comment = null;
     if (identity.isNode(item)) item.spaceBefore && lines.push(""), addCommentBefore(ctx, lines, item.commentBefore, !1), 
     item.comment && (comment = item.comment); else if (identity.isPair(item)) {
      const ik = identity.isNode(item.key) ? item.key : null;
      ik && (ik.spaceBefore && lines.push(""), addCommentBefore(ctx, lines, ik.commentBefore, !1), 
      ik.comment && (reqNewline = !0));
      const iv = identity.isNode(item.value) ? item.value : null;
      iv ? (iv.comment && (comment = iv.comment), iv.commentBefore && (reqNewline = !0)) : null == item.value && ik?.comment && (comment = ik.comment);
     }
     comment && (reqNewline = !0);
     let str = stringify.stringify(item, itemCtx, (() => comment = null));
     i < items.length - 1 && (str += ","), comment && (str += stringifyComment.lineComment(str, itemIndent, commentString(comment))), 
     !reqNewline && (lines.length > linesAtValue || str.includes("\n")) && (reqNewline = !0), 
     lines.push(str), linesAtValue = lines.length;
    }
    let str;
    const {start, end} = flowChars;
    if (0 === lines.length) str = start + end; else {
     if (!reqNewline) {
      reqNewline = lines.reduce(((sum, line) => sum + line.length + 2), 2) > Collection.Collection.maxFlowStringSingleLineLength;
     }
     if (reqNewline) {
      str = start;
      for (const line of lines) str += line ? `\n${indentStep}${indent}${line}` : "\n";
      str += `\n${indent}${end}`;
     } else str = `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
    return comment && (str += stringifyComment.lineComment(str, indent, commentString(comment)), 
    onComment && onComment()), str;
   }
   function addCommentBefore({indent, options: {commentString}}, lines, comment, chompKeep) {
    if (comment && chompKeep && (comment = comment.replace(/^\n+/, "")), comment) {
     const ic = stringifyComment.indentComment(commentString(comment), indent);
     lines.push(ic.trimStart());
    }
   }
   exports.stringifyCollection = function(collection, ctx, options) {
    return (ctx.inFlow ?? collection.flow ? stringifyFlowCollection : stringifyBlockCollection)(collection, ctx, options);
   };
  },
  28463: (__unused_webpack_module, exports) => {
   "use strict";
   function indentComment(comment, indent) {
    return /^\n+$/.test(comment) ? comment.substring(1) : indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
   }
   exports.indentComment = indentComment, exports.lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment, 
   exports.stringifyComment = str => str.replace(/^(?!$)(?: $)?/gm, "#");
  },
  89957: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(60163), stringify = __webpack_require__(20611), stringifyComment = __webpack_require__(28463);
   exports.stringifyDocument = function(doc, options) {
    const lines = [];
    let hasDirectives = !0 === options.directives;
    if (!1 !== options.directives && doc.directives) {
     const dir = doc.directives.toString(doc);
     dir ? (lines.push(dir), hasDirectives = !0) : doc.directives.docStart && (hasDirectives = !0);
    }
    hasDirectives && lines.push("---");
    const ctx = stringify.createStringifyContext(doc, options), {commentString} = ctx.options;
    if (doc.commentBefore) {
     1 !== lines.length && lines.unshift("");
     const cs = commentString(doc.commentBefore);
     lines.unshift(stringifyComment.indentComment(cs, ""));
    }
    let chompKeep = !1, contentComment = null;
    if (doc.contents) {
     if (identity.isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives && lines.push(""), doc.contents.commentBefore) {
       const cs = commentString(doc.contents.commentBefore);
       lines.push(stringifyComment.indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment, contentComment = doc.contents.comment;
     }
     const onChompKeep = contentComment ? void 0 : () => chompKeep = !0;
     let body = stringify.stringify(doc.contents, ctx, (() => contentComment = null), onChompKeep);
     contentComment && (body += stringifyComment.lineComment(body, "", commentString(contentComment))), 
     "|" !== body[0] && ">" !== body[0] || "---" !== lines[lines.length - 1] ? lines.push(body) : lines[lines.length - 1] = `--- ${body}`;
    } else lines.push(stringify.stringify(doc.contents, ctx));
    if (doc.directives?.docEnd) if (doc.comment) {
     const cs = commentString(doc.comment);
     cs.includes("\n") ? (lines.push("..."), lines.push(stringifyComment.indentComment(cs, ""))) : lines.push(`... ${cs}`);
    } else lines.push("..."); else {
     let dc = doc.comment;
     dc && chompKeep && (dc = dc.replace(/^\n+/, "")), dc && (chompKeep && !contentComment || "" === lines[lines.length - 1] || lines.push(""), 
     lines.push(stringifyComment.indentComment(commentString(dc), "")));
    }
    return lines.join("\n") + "\n";
   };
  },
  15260: (__unused_webpack_module, exports) => {
   "use strict";
   exports.stringifyNumber = function({format, minFractionDigits, tag, value}) {
    if ("bigint" == typeof value) return String(value);
    const num = "number" == typeof value ? value : Number(value);
    if (!isFinite(num)) return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
    let n = JSON.stringify(value);
    if (!format && minFractionDigits && (!tag || "tag:yaml.org,2002:float" === tag) && /^\d/.test(n)) {
     let i = n.indexOf(".");
     i < 0 && (i = n.length, n += ".");
     let d = minFractionDigits - (n.length - i - 1);
     for (;d-- > 0; ) n += "0";
    }
    return n;
   };
  },
  38843: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(60163), Scalar = __webpack_require__(58844), stringify = __webpack_require__(20611), stringifyComment = __webpack_require__(28463);
   exports.stringifyPair = function({key, value}, ctx, onComment, onChompKeep) {
    const {allNullValues, doc, indent, indentStep, options: {commentString, indentSeq, simpleKeys}} = ctx;
    let keyComment = identity.isNode(key) && key.comment || null;
    if (simpleKeys) {
     if (keyComment) throw new Error("With simple keys, key nodes cannot have comments");
     if (identity.isCollection(key)) {
      throw new Error("With simple keys, collection cannot be used as a key value");
     }
    }
    let explicitKey = !simpleKeys && (!key || keyComment && null == value && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : "object" == typeof key));
    ctx = Object.assign({}, ctx, {
     allNullValues: !1,
     implicitKey: !explicitKey && (simpleKeys || !allNullValues),
     indent: indent + indentStep
    });
    let vsb, vcb, valueComment, keyCommentDone = !1, chompKeep = !1, str = stringify.stringify(key, ctx, (() => keyCommentDone = !0), (() => chompKeep = !0));
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
     if (simpleKeys) throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
     explicitKey = !0;
    }
    if (ctx.inFlow) {
     if (allNullValues || null == value) return keyCommentDone && onComment && onComment(), 
     "" === str ? "?" : explicitKey ? `? ${str}` : str;
    } else if (allNullValues && !simpleKeys || null == value && explicitKey) return str = `? ${str}`, 
    keyComment && !keyCommentDone ? str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment)) : chompKeep && onChompKeep && onChompKeep(), 
    str;
    keyCommentDone && (keyComment = null), explicitKey ? (keyComment && (str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment))), 
    str = `? ${str}\n${indent}:`) : (str = `${str}:`, keyComment && (str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment)))), 
    identity.isNode(value) ? (vsb = !!value.spaceBefore, vcb = value.commentBefore, 
    valueComment = value.comment) : (vsb = !1, vcb = null, valueComment = null, value && "object" == typeof value && (value = doc.createNode(value))), 
    ctx.implicitKey = !1, explicitKey || keyComment || !identity.isScalar(value) || (ctx.indentAtStart = str.length + 1), 
    chompKeep = !1, indentSeq || !(indentStep.length >= 2) || ctx.inFlow || explicitKey || !identity.isSeq(value) || value.flow || value.tag || value.anchor || (ctx.indent = ctx.indent.substring(2));
    let valueCommentDone = !1;
    const valueStr = stringify.stringify(value, ctx, (() => valueCommentDone = !0), (() => chompKeep = !0));
    let ws = " ";
    if (keyComment || vsb || vcb) {
     if (ws = vsb ? "\n" : "", vcb) {
      const cs = commentString(vcb);
      ws += `\n${stringifyComment.indentComment(cs, ctx.indent)}`;
     }
     "" !== valueStr || ctx.inFlow ? ws += `\n${ctx.indent}` : "\n" === ws && (ws = "\n\n");
    } else if (!explicitKey && identity.isCollection(value)) {
     const vs0 = valueStr[0], nl0 = valueStr.indexOf("\n"), hasNewline = -1 !== nl0, flow = ctx.inFlow ?? value.flow ?? 0 === value.items.length;
     if (hasNewline || !flow) {
      let hasPropsLine = !1;
      if (hasNewline && ("&" === vs0 || "!" === vs0)) {
       let sp0 = valueStr.indexOf(" ");
       "&" === vs0 && -1 !== sp0 && sp0 < nl0 && "!" === valueStr[sp0 + 1] && (sp0 = valueStr.indexOf(" ", sp0 + 1)), 
       (-1 === sp0 || nl0 < sp0) && (hasPropsLine = !0);
      }
      hasPropsLine || (ws = `\n${ctx.indent}`);
     }
    } else "" !== valueStr && "\n" !== valueStr[0] || (ws = "");
    return str += ws + valueStr, ctx.inFlow ? valueCommentDone && onComment && onComment() : valueComment && !valueCommentDone ? str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment)) : chompKeep && onChompKeep && onChompKeep(), 
    str;
   };
  },
  98431: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Scalar = __webpack_require__(58844), foldFlowLines = __webpack_require__(94112);
   const getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
   }), containsDocumentMarker = str => /^(%|---|\.\.\.)/m.test(str);
   function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON) return json;
    const {implicitKey} = ctx, minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength, indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    let str = "", start = 0;
    for (let i = 0, ch = json[i]; ch; ch = json[++i]) if (" " === ch && "\\" === json[i + 1] && "n" === json[i + 2] && (str += json.slice(start, i) + "\\ ", 
    i += 1, start = i, ch = "\\"), "\\" === ch) switch (json[i + 1]) {
    case "u":
     {
      str += json.slice(start, i);
      const code = json.substr(i + 2, 4);
      switch (code) {
      case "0000":
       str += "\\0";
       break;

      case "0007":
       str += "\\a";
       break;

      case "000b":
       str += "\\v";
       break;

      case "001b":
       str += "\\e";
       break;

      case "0085":
       str += "\\N";
       break;

      case "00a0":
       str += "\\_";
       break;

      case "2028":
       str += "\\L";
       break;

      case "2029":
       str += "\\P";
       break;

      default:
       "00" === code.substr(0, 2) ? str += "\\x" + code.substr(2) : str += json.substr(i, 6);
      }
      i += 5, start = i + 1;
     }
     break;

    case "n":
     if (implicitKey || '"' === json[i + 2] || json.length < minMultiLineLength) i += 1; else {
      for (str += json.slice(start, i) + "\n\n"; "\\" === json[i + 2] && "n" === json[i + 3] && '"' !== json[i + 4]; ) str += "\n", 
      i += 2;
      str += indent, " " === json[i + 2] && (str += "\\"), i += 1, start = i + 1;
     }
     break;

    default:
     i += 1;
    }
    return str = start ? str + json.slice(start) : json, implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, !1));
   }
   function singleQuotedString(value, ctx) {
    if (!1 === ctx.options.singleQuote || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value)) return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : ""), res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
    return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, !1));
   }
   function quotedString(value, ctx) {
    const {singleQuote} = ctx.options;
    let qs;
    if (!1 === singleQuote) qs = doubleQuotedString; else {
     const hasDouble = value.includes('"'), hasSingle = value.includes("'");
     qs = hasDouble && !hasSingle ? singleQuotedString : hasSingle && !hasDouble ? doubleQuotedString : singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
   }
   let blockEndNewlines;
   try {
    blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
   } catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
   }
   function blockString({comment, type, value}, ctx, onComment, onChompKeep) {
    const {blockQuote, commentString, lineWidth} = ctx.options;
    if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) return quotedString(value, ctx);
    const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : ""), literal = "literal" === blockQuote || "folded" !== blockQuote && type !== Scalar.Scalar.BLOCK_FOLDED && (type === Scalar.Scalar.BLOCK_LITERAL || !function(str, lineWidth, indentLength) {
     if (!lineWidth || lineWidth < 0) return !1;
     const limit = lineWidth - indentLength, strLen = str.length;
     if (strLen <= limit) return !1;
     for (let i = 0, start = 0; i < strLen; ++i) if ("\n" === str[i]) {
      if (i - start > limit) return !0;
      if (start = i + 1, strLen - start <= limit) return !1;
     }
     return !0;
    }(value, lineWidth, indent.length));
    if (!value) return literal ? "|\n" : ">\n";
    let chomp, endStart;
    for (endStart = value.length; endStart > 0; --endStart) {
     const ch = value[endStart - 1];
     if ("\n" !== ch && "\t" !== ch && " " !== ch) break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf("\n");
    -1 === endNlPos ? chomp = "-" : value === end || endNlPos !== end.length - 1 ? (chomp = "+", 
    onChompKeep && onChompKeep()) : chomp = "", end && (value = value.slice(0, -end.length), 
    "\n" === end[end.length - 1] && (end = end.slice(0, -1)), end = end.replace(blockEndNewlines, `$&${indent}`));
    let startEnd, startWithSpace = !1, startNlPos = -1;
    for (startEnd = 0; startEnd < value.length; ++startEnd) {
     const ch = value[startEnd];
     if (" " === ch) startWithSpace = !0; else {
      if ("\n" !== ch) break;
      startNlPos = startEnd;
     }
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    start && (value = value.substring(start.length), start = start.replace(/\n+/g, `$&${indent}`));
    let header = (literal ? "|" : ">") + (startWithSpace ? indent ? "2" : "1" : "") + chomp;
    if (comment && (header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " ")), 
    onComment && onComment()), literal) return `${header}\n${indent}${start}${value = value.replace(/\n+/g, `$&${indent}`)}${end}`;
    value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
    return `${header}\n${indent}${foldFlowLines.foldFlowLines(`${start}${value}${end}`, indent, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx, !0))}`;
   }
   exports.stringifyString = function(item, ctx, onComment, onChompKeep) {
    const {implicitKey, inFlow} = ctx, ss = "string" == typeof item.value ? item : Object.assign({}, item, {
     value: String(item.value)
    });
    let {type} = item;
    type !== Scalar.Scalar.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value) && (type = Scalar.Scalar.QUOTE_DOUBLE);
    const _stringify = _type => {
     switch (_type) {
     case Scalar.Scalar.BLOCK_FOLDED:
     case Scalar.Scalar.BLOCK_LITERAL:
      return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);

     case Scalar.Scalar.QUOTE_DOUBLE:
      return doubleQuotedString(ss.value, ctx);

     case Scalar.Scalar.QUOTE_SINGLE:
      return singleQuotedString(ss.value, ctx);

     case Scalar.Scalar.PLAIN:
      return function(item, ctx, onComment, onChompKeep) {
       const {type, value} = item, {actualString, implicitKey, indent, indentStep, inFlow} = ctx;
       if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) return quotedString(value, ctx);
       if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
       if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes("\n")) return blockString(item, ctx, onComment, onChompKeep);
       if (containsDocumentMarker(value)) {
        if ("" === indent) return ctx.forceBlockIndent = !0, blockString(item, ctx, onComment, onChompKeep);
        if (implicitKey && indent === indentStep) return quotedString(value, ctx);
       }
       const str = value.replace(/\n+/g, `$&\n${indent}`);
       if (actualString) {
        const test = tag => tag.default && "tag:yaml.org,2002:str" !== tag.tag && tag.test?.test(str), {compat, tags} = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test)) return quotedString(value, ctx);
       }
       return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, !1));
      }(ss, ctx, onComment, onChompKeep);

     default:
      return null;
     }
    };
    let res = _stringify(type);
    if (null === res) {
     const {defaultKeyType, defaultStringType} = ctx.options, t = implicitKey && defaultKeyType || defaultStringType;
     if (res = _stringify(t), null === res) throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
   };
  },
  81381: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(60163);
   const BREAK = Symbol("break visit"), SKIP = Symbol("skip children"), REMOVE = Symbol("remove node");
   function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
     visit_(null, node.contents, visitor_, Object.freeze([ node ])) === REMOVE && (node.contents = null);
    } else visit_(null, node, visitor_, Object.freeze([]));
   }
   function visit_(key, node, visitor, path) {
    const ctrl = callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) return replaceNode(key, path, ctrl), 
    visit_(key, ctrl, visitor, path);
    if ("symbol" != typeof ctrl) if (identity.isCollection(node)) {
     path = Object.freeze(path.concat(node));
     for (let i = 0; i < node.items.length; ++i) {
      const ci = visit_(i, node.items[i], visitor, path);
      if ("number" == typeof ci) i = ci - 1; else {
       if (ci === BREAK) return BREAK;
       ci === REMOVE && (node.items.splice(i, 1), i -= 1);
      }
     }
    } else if (identity.isPair(node)) {
     path = Object.freeze(path.concat(node));
     const ck = visit_("key", node.key, visitor, path);
     if (ck === BREAK) return BREAK;
     ck === REMOVE && (node.key = null);
     const cv = visit_("value", node.value, visitor, path);
     if (cv === BREAK) return BREAK;
     cv === REMOVE && (node.value = null);
    }
    return ctrl;
   }
   async function visitAsync(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
     await visitAsync_(null, node.contents, visitor_, Object.freeze([ node ])) === REMOVE && (node.contents = null);
    } else await visitAsync_(null, node, visitor_, Object.freeze([]));
   }
   async function visitAsync_(key, node, visitor, path) {
    const ctrl = await callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) return replaceNode(key, path, ctrl), 
    visitAsync_(key, ctrl, visitor, path);
    if ("symbol" != typeof ctrl) if (identity.isCollection(node)) {
     path = Object.freeze(path.concat(node));
     for (let i = 0; i < node.items.length; ++i) {
      const ci = await visitAsync_(i, node.items[i], visitor, path);
      if ("number" == typeof ci) i = ci - 1; else {
       if (ci === BREAK) return BREAK;
       ci === REMOVE && (node.items.splice(i, 1), i -= 1);
      }
     }
    } else if (identity.isPair(node)) {
     path = Object.freeze(path.concat(node));
     const ck = await visitAsync_("key", node.key, visitor, path);
     if (ck === BREAK) return BREAK;
     ck === REMOVE && (node.key = null);
     const cv = await visitAsync_("value", node.value, visitor, path);
     if (cv === BREAK) return BREAK;
     cv === REMOVE && (node.value = null);
    }
    return ctrl;
   }
   function initVisitor(visitor) {
    return "object" == typeof visitor && (visitor.Collection || visitor.Node || visitor.Value) ? Object.assign({
     Alias: visitor.Node,
     Map: visitor.Node,
     Scalar: visitor.Node,
     Seq: visitor.Node
    }, visitor.Value && {
     Map: visitor.Value,
     Scalar: visitor.Value,
     Seq: visitor.Value
    }, visitor.Collection && {
     Map: visitor.Collection,
     Seq: visitor.Collection
    }, visitor) : visitor;
   }
   function callVisitor(key, node, visitor, path) {
    return "function" == typeof visitor ? visitor(key, node, path) : identity.isMap(node) ? visitor.Map?.(key, node, path) : identity.isSeq(node) ? visitor.Seq?.(key, node, path) : identity.isPair(node) ? visitor.Pair?.(key, node, path) : identity.isScalar(node) ? visitor.Scalar?.(key, node, path) : identity.isAlias(node) ? visitor.Alias?.(key, node, path) : void 0;
   }
   function replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if (identity.isCollection(parent)) parent.items[key] = node; else if (identity.isPair(parent)) "key" === key ? parent.key = node : parent.value = node; else {
     if (!identity.isDocument(parent)) {
      const pt = identity.isAlias(parent) ? "alias" : "scalar";
      throw new Error(`Cannot replace node with ${pt} parent`);
     }
     parent.contents = node;
    }
   }
   visit.BREAK = BREAK, visit.SKIP = SKIP, visit.REMOVE = REMOVE, visitAsync.BREAK = BREAK, 
   visitAsync.SKIP = SKIP, visitAsync.REMOVE = REMOVE, exports.visit = visit, exports.visitAsync = visitAsync;
  },
  14193: (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Z: () => __WEBPACK_DEFAULT_EXPORT__
   });
   var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55006);
   const __WEBPACK_DEFAULT_EXPORT__ = class extends _index_js__WEBPACK_IMPORTED_MODULE_0__.Z {
    #lastModified=0;
    #name="";
    constructor(fileBits, fileName, options = {}) {
     if (arguments.length < 2) throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
     super(fileBits, options), null === options && (options = {});
     const lastModified = void 0 === options.lastModified ? Date.now() : Number(options.lastModified);
     Number.isNaN(lastModified) || (this.#lastModified = lastModified), this.#name = String(fileName);
    }
    get name() {
     return this.#name;
    }
    get lastModified() {
     return this.#lastModified;
    }
    get [Symbol.toStringTag]() {
     return "File";
    }
    static [Symbol.hasInstance](object) {
     return !!object && object instanceof _index_js__WEBPACK_IMPORTED_MODULE_0__.Z && /^(File)$/.test(object[Symbol.toStringTag]);
    }
   };
  },
  40749: (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    t6: () => fetch_blob.Z,
    $B: () => file.Z,
    xB: () => blobFrom,
    SX: () => blobFromSync,
    e2: () => fileFrom,
    RA: () => fileFromSync
   });
   const external_node_fs_namespaceObject = require("node:fs"), external_node_path_namespaceObject = require("node:path");
   var node_domexception = __webpack_require__(73414), file = __webpack_require__(14193), fetch_blob = __webpack_require__(55006);
   const {stat} = external_node_fs_namespaceObject.promises, blobFromSync = (path, type) => fromBlob((0, 
   external_node_fs_namespaceObject.statSync)(path), path, type), blobFrom = (path, type) => stat(path).then((stat => fromBlob(stat, path, type))), fileFrom = (path, type) => stat(path).then((stat => fromFile(stat, path, type))), fileFromSync = (path, type) => fromFile((0, 
   external_node_fs_namespaceObject.statSync)(path), path, type), fromBlob = (stat, path, type = "") => new fetch_blob.Z([ new BlobDataItem({
    path,
    size: stat.size,
    lastModified: stat.mtimeMs,
    start: 0
   }) ], {
    type
   }), fromFile = (stat, path, type = "") => new file.Z([ new BlobDataItem({
    path,
    size: stat.size,
    lastModified: stat.mtimeMs,
    start: 0
   }) ], (0, external_node_path_namespaceObject.basename)(path), {
    type,
    lastModified: stat.mtimeMs
   });
   class BlobDataItem {
    #path;
    #start;
    constructor(options) {
     this.#path = options.path, this.#start = options.start, this.size = options.size, 
     this.lastModified = options.lastModified;
    }
    slice(start, end) {
     return new BlobDataItem({
      path: this.#path,
      lastModified: this.lastModified,
      size: end - start,
      start: this.#start + start
     });
    }
    async* stream() {
     const {mtimeMs} = await stat(this.#path);
     if (mtimeMs > this.lastModified) throw new node_domexception("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.", "NotReadableError");
     yield* (0, external_node_fs_namespaceObject.createReadStream)(this.#path, {
      start: this.#start,
      end: this.#start + this.size - 1
     });
    }
    get [Symbol.toStringTag]() {
     return "Blob";
    }
   }
  },
  55006: (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Z: () => __WEBPACK_DEFAULT_EXPORT__
   });
   __webpack_require__(47135);
   async function* toIterator(parts, clone = !0) {
    for (const part of parts) if ("stream" in part) yield* part.stream(); else if (ArrayBuffer.isView(part)) if (clone) {
     let position = part.byteOffset;
     const end = part.byteOffset + part.byteLength;
     for (;position !== end; ) {
      const size = Math.min(end - position, 65536), chunk = part.buffer.slice(position, position + size);
      position += chunk.byteLength, yield new Uint8Array(chunk);
     }
    } else yield part; else {
     let position = 0, b = part;
     for (;position !== b.size; ) {
      const chunk = b.slice(position, Math.min(b.size, position + 65536)), buffer = await chunk.arrayBuffer();
      position += buffer.byteLength, yield new Uint8Array(buffer);
     }
    }
   }
   const _Blob = class Blob {
    #parts=[];
    #type="";
    #size=0;
    #endings="transparent";
    constructor(blobParts = [], options = {}) {
     if ("object" != typeof blobParts || null === blobParts) throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
     if ("function" != typeof blobParts[Symbol.iterator]) throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
     if ("object" != typeof options && "function" != typeof options) throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
     null === options && (options = {});
     const encoder = new TextEncoder;
     for (const element of blobParts) {
      let part;
      part = ArrayBuffer.isView(element) ? new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength)) : element instanceof ArrayBuffer ? new Uint8Array(element.slice(0)) : element instanceof Blob ? element : encoder.encode(`${element}`), 
      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size, this.#parts.push(part);
     }
     this.#endings = `${void 0 === options.endings ? "transparent" : options.endings}`;
     const type = void 0 === options.type ? "" : String(options.type);
     this.#type = /^[\x20-\x7E]*$/.test(type) ? type : "";
    }
    get size() {
     return this.#size;
    }
    get type() {
     return this.#type;
    }
    async text() {
     const decoder = new TextDecoder;
     let str = "";
     for await (const part of toIterator(this.#parts, !1)) str += decoder.decode(part, {
      stream: !0
     });
     return str += decoder.decode(), str;
    }
    async arrayBuffer() {
     const data = new Uint8Array(this.size);
     let offset = 0;
     for await (const chunk of toIterator(this.#parts, !1)) data.set(chunk, offset), 
     offset += chunk.length;
     return data.buffer;
    }
    stream() {
     const it = toIterator(this.#parts, !0);
     return new globalThis.ReadableStream({
      type: "bytes",
      async pull(ctrl) {
       const chunk = await it.next();
       chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
      },
      async cancel() {
       await it.return();
      }
     });
    }
    slice(start = 0, end = this.size, type = "") {
     const {size} = this;
     let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size), relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
     const span = Math.max(relativeEnd - relativeStart, 0), parts = this.#parts, blobParts = [];
     let added = 0;
     for (const part of parts) {
      if (added >= span) break;
      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;
      if (relativeStart && size <= relativeStart) relativeStart -= size, relativeEnd -= size; else {
       let chunk;
       ArrayBuffer.isView(part) ? (chunk = part.subarray(relativeStart, Math.min(size, relativeEnd)), 
       added += chunk.byteLength) : (chunk = part.slice(relativeStart, Math.min(size, relativeEnd)), 
       added += chunk.size), relativeEnd -= size, blobParts.push(chunk), relativeStart = 0;
      }
     }
     const blob = new Blob([], {
      type: String(type).toLowerCase()
     });
     return blob.#size = span, blob.#parts = blobParts, blob;
    }
    get [Symbol.toStringTag]() {
     return "Blob";
    }
    static [Symbol.hasInstance](object) {
     return object && "object" == typeof object && "function" == typeof object.constructor && ("function" == typeof object.stream || "function" == typeof object.arrayBuffer) && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
    }
   };
   Object.defineProperties(_Blob.prototype, {
    size: {
     enumerable: !0
    },
    type: {
     enumerable: !0
    },
    slice: {
     enumerable: !0
    }
   });
   const __WEBPACK_DEFAULT_EXPORT__ = _Blob;
  },
  39951: (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Ct: () => FormData,
    au: () => formDataToBlob
   });
   var fetch_blob__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55006), fetch_blob_file_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14193), {toStringTag: t, iterator: i, hasInstance: h} = Symbol, r = Math.random, m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(","), f = (a, b, c) => (a += "", 
   /^(Blob|File)$/.test(b && b[t]) ? [ (c = void 0 !== c ? c + "" : "File" == b[t] ? b.name : "blob", 
   a), b.name !== c || "blob" == b[t] ? new fetch_blob_file_js__WEBPACK_IMPORTED_MODULE_1__.Z([ b ], c, b) : b ] : [ a, b + "" ]), e = (c, f) => (f ? c : c.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), x = (n, a, e) => {
    if (a.length < e) throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`);
   };
   const FormData = class {
    #d=[];
    constructor(...a) {
     if (a.length) throw new TypeError("Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.");
    }
    get [t]() {
     return "FormData";
    }
    [i]() {
     return this.entries();
    }
    static [h](o) {
     return o && "object" == typeof o && "FormData" === o[t] && !m.some((m => "function" != typeof o[m]));
    }
    append(...a) {
     x("append", arguments, 2), this.#d.push(f(...a));
    }
    delete(a) {
     x("delete", arguments, 1), a += "", this.#d = this.#d.filter((([b]) => b !== a));
    }
    get(a) {
     x("get", arguments, 1), a += "";
     for (var b = this.#d, l = b.length, c = 0; c < l; c++) if (b[c][0] === a) return b[c][1];
     return null;
    }
    getAll(a, b) {
     return x("getAll", arguments, 1), b = [], a += "", this.#d.forEach((c => c[0] === a && b.push(c[1]))), 
     b;
    }
    has(a) {
     return x("has", arguments, 1), a += "", this.#d.some((b => b[0] === a));
    }
    forEach(a, b) {
     for (var [c, d] of (x("forEach", arguments, 1), this)) a.call(b, d, c, this);
    }
    set(...a) {
     x("set", arguments, 2);
     var b = [], c = !0;
     a = f(...a), this.#d.forEach((d => {
      d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
     })), c && b.push(a), this.#d = b;
    }
    * entries() {
     yield* this.#d;
    }
    * keys() {
     for (var [a] of this) yield a;
    }
    * values() {
     for (var [, a] of this) yield a;
    }
   };
   function formDataToBlob(F, B = fetch_blob__WEBPACK_IMPORTED_MODULE_0__.Z) {
    var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c = [], p = `--${b}\r\nContent-Disposition: form-data; name="`;
    return F.forEach(((v, n) => "string" == typeof v ? c.push(p + e(n) + `"\r\n\r\n${v.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r\n`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r\nContent-Type: ${v.type || "application/octet-stream"}\r\n\r\n`, v, "\r\n"))), 
    c.push(`--${b}--`), new B(c, {
     type: "multipart/form-data; boundary=" + b
    });
   }
  },
  74126: (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    AbortError: () => AbortError,
    Blob: () => from.t6,
    FetchError: () => FetchError,
    File: () => from.$B,
    FormData: () => esm_min.Ct,
    Headers: () => Headers,
    Request: () => Request,
    Response: () => Response,
    blobFrom: () => from.xB,
    blobFromSync: () => from.SX,
    default: () => fetch,
    fileFrom: () => from.e2,
    fileFromSync: () => from.RA,
    isRedirect: () => isRedirect
   });
   const external_node_http_namespaceObject = require("node:http"), external_node_https_namespaceObject = require("node:https"), external_node_zlib_namespaceObject = require("node:zlib"), external_node_stream_namespaceObject = require("node:stream"), external_node_buffer_namespaceObject = require("node:buffer");
   const dist = function(uri) {
    if (!/^data:/i.test(uri)) throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
    const firstComma = (uri = uri.replace(/\r?\n/g, "")).indexOf(",");
    if (-1 === firstComma || firstComma <= 4) throw new TypeError("malformed data: URI");
    const meta = uri.substring(5, firstComma).split(";");
    let charset = "", base64 = !1;
    const type = meta[0] || "text/plain";
    let typeFull = type;
    for (let i = 1; i < meta.length; i++) "base64" === meta[i] ? base64 = !0 : meta[i] && (typeFull += `;${meta[i]}`, 
    0 === meta[i].indexOf("charset=") && (charset = meta[i].substring(8)));
    meta[0] || charset.length || (typeFull += ";charset=US-ASCII", charset = "US-ASCII");
    const encoding = base64 ? "base64" : "ascii", data = unescape(uri.substring(firstComma + 1)), buffer = Buffer.from(data, encoding);
    return buffer.type = type, buffer.typeFull = typeFull, buffer.charset = charset, 
    buffer;
   }, external_node_util_namespaceObject = require("node:util");
   var fetch_blob = __webpack_require__(55006), esm_min = __webpack_require__(39951);
   class FetchBaseError extends Error {
    constructor(message, type) {
     super(message), Error.captureStackTrace(this, this.constructor), this.type = type;
    }
    get name() {
     return this.constructor.name;
    }
    get [Symbol.toStringTag]() {
     return this.constructor.name;
    }
   }
   class FetchError extends FetchBaseError {
    constructor(message, type, systemError) {
     super(message, type), systemError && (this.code = this.errno = systemError.code, 
     this.erroredSysCall = systemError.syscall);
    }
   }
   const NAME = Symbol.toStringTag, isURLSearchParameters = object => "object" == typeof object && "function" == typeof object.append && "function" == typeof object.delete && "function" == typeof object.get && "function" == typeof object.getAll && "function" == typeof object.has && "function" == typeof object.set && "function" == typeof object.sort && "URLSearchParams" === object[NAME], isBlob = object => object && "object" == typeof object && "function" == typeof object.arrayBuffer && "string" == typeof object.type && "function" == typeof object.stream && "function" == typeof object.constructor && /^(Blob|File)$/.test(object[NAME]), isDomainOrSubdomain = (destination, original) => {
    const orig = new URL(original).hostname, dest = new URL(destination).hostname;
    return orig === dest || orig.endsWith(`.${dest}`);
   }, isSameProtocol = (destination, original) => new URL(original).protocol === new URL(destination).protocol, pipeline = (0, 
   external_node_util_namespaceObject.promisify)(external_node_stream_namespaceObject.pipeline), INTERNALS = Symbol("Body internals");
   class Body {
    constructor(body, {size = 0} = {}) {
     let boundary = null;
     null === body ? body = null : isURLSearchParameters(body) ? body = external_node_buffer_namespaceObject.Buffer.from(body.toString()) : isBlob(body) || external_node_buffer_namespaceObject.Buffer.isBuffer(body) || (external_node_util_namespaceObject.types.isAnyArrayBuffer(body) ? body = external_node_buffer_namespaceObject.Buffer.from(body) : ArrayBuffer.isView(body) ? body = external_node_buffer_namespaceObject.Buffer.from(body.buffer, body.byteOffset, body.byteLength) : body instanceof external_node_stream_namespaceObject || (body instanceof esm_min.Ct ? boundary = (body = (0, 
     esm_min.au)(body)).type.split("=")[1] : body = external_node_buffer_namespaceObject.Buffer.from(String(body))));
     let stream = body;
     external_node_buffer_namespaceObject.Buffer.isBuffer(body) ? stream = external_node_stream_namespaceObject.Readable.from(body) : isBlob(body) && (stream = external_node_stream_namespaceObject.Readable.from(body.stream())), 
     this[INTERNALS] = {
      body,
      stream,
      boundary,
      disturbed: !1,
      error: null
     }, this.size = size, body instanceof external_node_stream_namespaceObject && body.on("error", (error_ => {
      const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
      this[INTERNALS].error = error;
     }));
    }
    get body() {
     return this[INTERNALS].stream;
    }
    get bodyUsed() {
     return this[INTERNALS].disturbed;
    }
    async arrayBuffer() {
     const {buffer, byteOffset, byteLength} = await consumeBody(this);
     return buffer.slice(byteOffset, byteOffset + byteLength);
    }
    async formData() {
     const ct = this.headers.get("content-type");
     if (ct.startsWith("application/x-www-form-urlencoded")) {
      const formData = new esm_min.Ct, parameters = new URLSearchParams(await this.text());
      for (const [name, value] of parameters) formData.append(name, value);
      return formData;
     }
     const {toFormData} = await __webpack_require__.e(713).then(__webpack_require__.bind(__webpack_require__, 51713));
     return toFormData(this.body, ct);
    }
    async blob() {
     const ct = this.headers && this.headers.get("content-type") || this[INTERNALS].body && this[INTERNALS].body.type || "", buf = await this.arrayBuffer();
     return new fetch_blob.Z([ buf ], {
      type: ct
     });
    }
    async json() {
     const text = await this.text();
     return JSON.parse(text);
    }
    async text() {
     const buffer = await consumeBody(this);
     return (new TextDecoder).decode(buffer);
    }
    buffer() {
     return consumeBody(this);
    }
   }
   async function consumeBody(data) {
    if (data[INTERNALS].disturbed) throw new TypeError(`body used already for: ${data.url}`);
    if (data[INTERNALS].disturbed = !0, data[INTERNALS].error) throw data[INTERNALS].error;
    const {body} = data;
    if (null === body) return external_node_buffer_namespaceObject.Buffer.alloc(0);
    if (!(body instanceof external_node_stream_namespaceObject)) return external_node_buffer_namespaceObject.Buffer.alloc(0);
    const accum = [];
    let accumBytes = 0;
    try {
     for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
       const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
       throw body.destroy(error), error;
      }
      accumBytes += chunk.length, accum.push(chunk);
     }
    } catch (error) {
     throw error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, "system", error);
    }
    if (!0 !== body.readableEnded && !0 !== body._readableState.ended) throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
    try {
     return accum.every((c => "string" == typeof c)) ? external_node_buffer_namespaceObject.Buffer.from(accum.join("")) : external_node_buffer_namespaceObject.Buffer.concat(accum, accumBytes);
    } catch (error) {
     throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, "system", error);
    }
   }
   Body.prototype.buffer = (0, external_node_util_namespaceObject.deprecate)(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer"), 
   Object.defineProperties(Body.prototype, {
    body: {
     enumerable: !0
    },
    bodyUsed: {
     enumerable: !0
    },
    arrayBuffer: {
     enumerable: !0
    },
    blob: {
     enumerable: !0
    },
    json: {
     enumerable: !0
    },
    text: {
     enumerable: !0
    },
    data: {
     get: (0, external_node_util_namespaceObject.deprecate)((() => {}), "data doesn't exist, use json(), text(), arrayBuffer(), or body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (response)")
    }
   });
   const clone = (instance, highWaterMark) => {
    let p1, p2, {body} = instance[INTERNALS];
    if (instance.bodyUsed) throw new Error("cannot clone body after it is used");
    return body instanceof external_node_stream_namespaceObject && "function" != typeof body.getBoundary && (p1 = new external_node_stream_namespaceObject.PassThrough({
     highWaterMark
    }), p2 = new external_node_stream_namespaceObject.PassThrough({
     highWaterMark
    }), body.pipe(p1), body.pipe(p2), instance[INTERNALS].stream = p1, body = p2), body;
   }, getNonSpecFormDataBoundary = (0, external_node_util_namespaceObject.deprecate)((body => body.getBoundary()), "form-data doesn't follow the spec and requires special treatment. Use alternative package", "https://github.com/node-fetch/node-fetch/issues/1167"), extractContentType = (body, request) => null === body ? null : "string" == typeof body ? "text/plain;charset=UTF-8" : isURLSearchParameters(body) ? "application/x-www-form-urlencoded;charset=UTF-8" : isBlob(body) ? body.type || null : external_node_buffer_namespaceObject.Buffer.isBuffer(body) || external_node_util_namespaceObject.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body) ? null : body instanceof esm_min.Ct ? `multipart/form-data; boundary=${request[INTERNALS].boundary}` : body && "function" == typeof body.getBoundary ? `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}` : body instanceof external_node_stream_namespaceObject ? null : "text/plain;charset=UTF-8", writeToStream = async (dest, {body}) => {
    null === body ? dest.end() : await pipeline(body, dest);
   }, validateHeaderName = "function" == typeof external_node_http_namespaceObject.validateHeaderName ? external_node_http_namespaceObject.validateHeaderName : name => {
    if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
     const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);
     throw Object.defineProperty(error, "code", {
      value: "ERR_INVALID_HTTP_TOKEN"
     }), error;
    }
   }, validateHeaderValue = "function" == typeof external_node_http_namespaceObject.validateHeaderValue ? external_node_http_namespaceObject.validateHeaderValue : (name, value) => {
    if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
     const error = new TypeError(`Invalid character in header content ["${name}"]`);
     throw Object.defineProperty(error, "code", {
      value: "ERR_INVALID_CHAR"
     }), error;
    }
   };
   class Headers extends URLSearchParams {
    constructor(init) {
     let result = [];
     if (init instanceof Headers) {
      const raw = init.raw();
      for (const [name, values] of Object.entries(raw)) result.push(...values.map((value => [ name, value ])));
     } else if (null == init) ; else {
      if ("object" != typeof init || external_node_util_namespaceObject.types.isBoxedPrimitive(init)) throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
      {
       const method = init[Symbol.iterator];
       if (null == method) result.push(...Object.entries(init)); else {
        if ("function" != typeof method) throw new TypeError("Header pairs must be iterable");
        result = [ ...init ].map((pair => {
         if ("object" != typeof pair || external_node_util_namespaceObject.types.isBoxedPrimitive(pair)) throw new TypeError("Each header pair must be an iterable object");
         return [ ...pair ];
        })).map((pair => {
         if (2 !== pair.length) throw new TypeError("Each header pair must be a name/value tuple");
         return [ ...pair ];
        }));
       }
      }
     }
     return result = result.length > 0 ? result.map((([name, value]) => (validateHeaderName(name), 
     validateHeaderValue(name, String(value)), [ String(name).toLowerCase(), String(value) ]))) : void 0, 
     super(result), new Proxy(this, {
      get(target, p, receiver) {
       switch (p) {
       case "append":
       case "set":
        return (name, value) => (validateHeaderName(name), validateHeaderValue(name, String(value)), 
        URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value)));

       case "delete":
       case "has":
       case "getAll":
        return name => (validateHeaderName(name), URLSearchParams.prototype[p].call(target, String(name).toLowerCase()));

       case "keys":
        return () => (target.sort(), new Set(URLSearchParams.prototype.keys.call(target)).keys());

       default:
        return Reflect.get(target, p, receiver);
       }
      }
     });
    }
    get [Symbol.toStringTag]() {
     return this.constructor.name;
    }
    toString() {
     return Object.prototype.toString.call(this);
    }
    get(name) {
     const values = this.getAll(name);
     if (0 === values.length) return null;
     let value = values.join(", ");
     return /^content-encoding$/i.test(name) && (value = value.toLowerCase()), value;
    }
    forEach(callback, thisArg = void 0) {
     for (const name of this.keys()) Reflect.apply(callback, thisArg, [ this.get(name), name, this ]);
    }
    * values() {
     for (const name of this.keys()) yield this.get(name);
    }
    * entries() {
     for (const name of this.keys()) yield [ name, this.get(name) ];
    }
    [Symbol.iterator]() {
     return this.entries();
    }
    raw() {
     return [ ...this.keys() ].reduce(((result, key) => (result[key] = this.getAll(key), 
     result)), {});
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
     return [ ...this.keys() ].reduce(((result, key) => {
      const values = this.getAll(key);
      return result[key] = "host" === key ? values[0] : values.length > 1 ? values : values[0], 
      result;
     }), {});
    }
   }
   Object.defineProperties(Headers.prototype, [ "get", "entries", "forEach", "values" ].reduce(((result, property) => (result[property] = {
    enumerable: !0
   }, result)), {}));
   const redirectStatus = new Set([ 301, 302, 303, 307, 308 ]), isRedirect = code => redirectStatus.has(code), response_INTERNALS = Symbol("Response internals");
   class Response extends Body {
    constructor(body = null, options = {}) {
     super(body, options);
     const status = null != options.status ? options.status : 200, headers = new Headers(options.headers);
     if (null !== body && !headers.has("Content-Type")) {
      const contentType = extractContentType(body, this);
      contentType && headers.append("Content-Type", contentType);
     }
     this[response_INTERNALS] = {
      type: "default",
      url: options.url,
      status,
      statusText: options.statusText || "",
      headers,
      counter: options.counter,
      highWaterMark: options.highWaterMark
     };
    }
    get type() {
     return this[response_INTERNALS].type;
    }
    get url() {
     return this[response_INTERNALS].url || "";
    }
    get status() {
     return this[response_INTERNALS].status;
    }
    get ok() {
     return this[response_INTERNALS].status >= 200 && this[response_INTERNALS].status < 300;
    }
    get redirected() {
     return this[response_INTERNALS].counter > 0;
    }
    get statusText() {
     return this[response_INTERNALS].statusText;
    }
    get headers() {
     return this[response_INTERNALS].headers;
    }
    get highWaterMark() {
     return this[response_INTERNALS].highWaterMark;
    }
    clone() {
     return new Response(clone(this, this.highWaterMark), {
      type: this.type,
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected,
      size: this.size,
      highWaterMark: this.highWaterMark
     });
    }
    static redirect(url, status = 302) {
     if (!isRedirect(status)) throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
     return new Response(null, {
      headers: {
       location: new URL(url).toString()
      },
      status
     });
    }
    static error() {
     const response = new Response(null, {
      status: 0,
      statusText: ""
     });
     return response[response_INTERNALS].type = "error", response;
    }
    static json(data = void 0, init = {}) {
     const body = JSON.stringify(data);
     if (void 0 === body) throw new TypeError("data is not JSON serializable");
     const headers = new Headers(init && init.headers);
     return headers.has("content-type") || headers.set("content-type", "application/json"), 
     new Response(body, {
      ...init,
      headers
     });
    }
    get [Symbol.toStringTag]() {
     return "Response";
    }
   }
   Object.defineProperties(Response.prototype, {
    type: {
     enumerable: !0
    },
    url: {
     enumerable: !0
    },
    status: {
     enumerable: !0
    },
    ok: {
     enumerable: !0
    },
    redirected: {
     enumerable: !0
    },
    statusText: {
     enumerable: !0
    },
    headers: {
     enumerable: !0
    },
    clone: {
     enumerable: !0
    }
   });
   const external_node_url_namespaceObject = require("node:url"), external_node_net_namespaceObject = require("node:net");
   function stripURLForUseAsAReferrer(url, originOnly = !1) {
    return null == url ? "no-referrer" : (url = new URL(url), /^(about|blob|data):$/.test(url.protocol) ? "no-referrer" : (url.username = "", 
    url.password = "", url.hash = "", originOnly && (url.pathname = "", url.search = ""), 
    url));
   }
   const ReferrerPolicy = new Set([ "", "no-referrer", "no-referrer-when-downgrade", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin", "unsafe-url" ]);
   function isUrlPotentiallyTrustworthy(url) {
    return !!/^about:(blank|srcdoc)$/.test(url) || ("data:" === url.protocol || (!!/^(blob|filesystem):$/.test(url.protocol) || function(url) {
     if (/^(http|ws)s:$/.test(url.protocol)) return !0;
     const hostIp = url.host.replace(/(^\[)|(]$)/g, ""), hostIPVersion = (0, external_node_net_namespaceObject.isIP)(hostIp);
     return !(4 !== hostIPVersion || !/^127\./.test(hostIp)) || !(6 !== hostIPVersion || !/^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) || "localhost" !== url.host && !url.host.endsWith(".localhost") && "file:" === url.protocol;
    }(url)));
   }
   const request_INTERNALS = Symbol("Request internals"), isRequest = object => "object" == typeof object && "object" == typeof object[request_INTERNALS], doBadDataWarn = (0, 
   external_node_util_namespaceObject.deprecate)((() => {}), ".data is not a valid RequestInit property, use .body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (request)");
   class Request extends Body {
    constructor(input, init = {}) {
     let parsedURL;
     if (isRequest(input) ? parsedURL = new URL(input.url) : (parsedURL = new URL(input), 
     input = {}), "" !== parsedURL.username || "" !== parsedURL.password) throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
     let method = init.method || input.method || "GET";
     if (/^(delete|get|head|options|post|put)$/i.test(method) && (method = method.toUpperCase()), 
     !isRequest(init) && "data" in init && doBadDataWarn(), (null != init.body || isRequest(input) && null !== input.body) && ("GET" === method || "HEAD" === method)) throw new TypeError("Request with GET/HEAD method cannot have body");
     const inputBody = init.body ? init.body : isRequest(input) && null !== input.body ? clone(input) : null;
     super(inputBody, {
      size: init.size || input.size || 0
     });
     const headers = new Headers(init.headers || input.headers || {});
     if (null !== inputBody && !headers.has("Content-Type")) {
      const contentType = extractContentType(inputBody, this);
      contentType && headers.set("Content-Type", contentType);
     }
     let signal = isRequest(input) ? input.signal : null;
     if ("signal" in init && (signal = init.signal), null != signal && ("object" != typeof (object = signal) || "AbortSignal" !== object[NAME] && "EventTarget" !== object[NAME])) throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
     var object;
     let referrer = null == init.referrer ? input.referrer : init.referrer;
     if ("" === referrer) referrer = "no-referrer"; else if (referrer) {
      const parsedReferrer = new URL(referrer);
      referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
     } else referrer = void 0;
     this[request_INTERNALS] = {
      method,
      redirect: init.redirect || input.redirect || "follow",
      headers,
      parsedURL,
      signal,
      referrer
     }, this.follow = void 0 === init.follow ? void 0 === input.follow ? 20 : input.follow : init.follow, 
     this.compress = void 0 === init.compress ? void 0 === input.compress || input.compress : init.compress, 
     this.counter = init.counter || input.counter || 0, this.agent = init.agent || input.agent, 
     this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384, this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || !1, 
     this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || "";
    }
    get method() {
     return this[request_INTERNALS].method;
    }
    get url() {
     return (0, external_node_url_namespaceObject.format)(this[request_INTERNALS].parsedURL);
    }
    get headers() {
     return this[request_INTERNALS].headers;
    }
    get redirect() {
     return this[request_INTERNALS].redirect;
    }
    get signal() {
     return this[request_INTERNALS].signal;
    }
    get referrer() {
     return "no-referrer" === this[request_INTERNALS].referrer ? "" : "client" === this[request_INTERNALS].referrer ? "about:client" : this[request_INTERNALS].referrer ? this[request_INTERNALS].referrer.toString() : void 0;
    }
    get referrerPolicy() {
     return this[request_INTERNALS].referrerPolicy;
    }
    set referrerPolicy(referrerPolicy) {
     this[request_INTERNALS].referrerPolicy = function(referrerPolicy) {
      if (!ReferrerPolicy.has(referrerPolicy)) throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
      return referrerPolicy;
     }(referrerPolicy);
    }
    clone() {
     return new Request(this);
    }
    get [Symbol.toStringTag]() {
     return "Request";
    }
   }
   Object.defineProperties(Request.prototype, {
    method: {
     enumerable: !0
    },
    url: {
     enumerable: !0
    },
    headers: {
     enumerable: !0
    },
    redirect: {
     enumerable: !0
    },
    clone: {
     enumerable: !0
    },
    signal: {
     enumerable: !0
    },
    referrer: {
     enumerable: !0
    },
    referrerPolicy: {
     enumerable: !0
    }
   });
   const getNodeRequestOptions = request => {
    const {parsedURL} = request[request_INTERNALS], headers = new Headers(request[request_INTERNALS].headers);
    headers.has("Accept") || headers.set("Accept", "*/*");
    let contentLengthValue = null;
    if (null === request.body && /^(post|put)$/i.test(request.method) && (contentLengthValue = "0"), 
    null !== request.body) {
     const totalBytes = (request => {
      const {body} = request[INTERNALS];
      return null === body ? 0 : isBlob(body) ? body.size : external_node_buffer_namespaceObject.Buffer.isBuffer(body) ? body.length : body && "function" == typeof body.getLengthSync && body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
     })(request);
     "number" != typeof totalBytes || Number.isNaN(totalBytes) || (contentLengthValue = String(totalBytes));
    }
    contentLengthValue && headers.set("Content-Length", contentLengthValue), "" === request.referrerPolicy && (request.referrerPolicy = "strict-origin-when-cross-origin"), 
    request.referrer && "no-referrer" !== request.referrer ? request[request_INTERNALS].referrer = function(request, {referrerURLCallback, referrerOriginCallback} = {}) {
     if ("no-referrer" === request.referrer || "" === request.referrerPolicy) return null;
     const policy = request.referrerPolicy;
     if ("about:client" === request.referrer) return "no-referrer";
     const referrerSource = request.referrer;
     let referrerURL = stripURLForUseAsAReferrer(referrerSource), referrerOrigin = stripURLForUseAsAReferrer(referrerSource, !0);
     referrerURL.toString().length > 4096 && (referrerURL = referrerOrigin), referrerURLCallback && (referrerURL = referrerURLCallback(referrerURL)), 
     referrerOriginCallback && (referrerOrigin = referrerOriginCallback(referrerOrigin));
     const currentURL = new URL(request.url);
     switch (policy) {
     case "no-referrer":
      return "no-referrer";

     case "origin":
      return referrerOrigin;

     case "unsafe-url":
      return referrerURL;

     case "strict-origin":
      return isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL) ? "no-referrer" : referrerOrigin.toString();

     case "strict-origin-when-cross-origin":
      return referrerURL.origin === currentURL.origin ? referrerURL : isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL) ? "no-referrer" : referrerOrigin;

     case "same-origin":
      return referrerURL.origin === currentURL.origin ? referrerURL : "no-referrer";

     case "origin-when-cross-origin":
      return referrerURL.origin === currentURL.origin ? referrerURL : referrerOrigin;

     case "no-referrer-when-downgrade":
      return isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL) ? "no-referrer" : referrerURL;

     default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
     }
    }(request) : request[request_INTERNALS].referrer = "no-referrer", request[request_INTERNALS].referrer instanceof URL && headers.set("Referer", request.referrer), 
    headers.has("User-Agent") || headers.set("User-Agent", "node-fetch"), request.compress && !headers.has("Accept-Encoding") && headers.set("Accept-Encoding", "gzip, deflate, br");
    let {agent} = request;
    "function" == typeof agent && (agent = agent(parsedURL));
    const search = (parsedURL => {
     if (parsedURL.search) return parsedURL.search;
     const lastOffset = parsedURL.href.length - 1, hash = parsedURL.hash || ("#" === parsedURL.href[lastOffset] ? "#" : "");
     return "?" === parsedURL.href[lastOffset - hash.length] ? "?" : "";
    })(parsedURL);
    return {
     parsedURL,
     options: {
      path: parsedURL.pathname + search,
      method: request.method,
      headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
      insecureHTTPParser: request.insecureHTTPParser,
      agent
     }
    };
   };
   class AbortError extends FetchBaseError {
    constructor(message, type = "aborted") {
     super(message, type);
    }
   }
   var from = __webpack_require__(40749);
   const supportedSchemas = new Set([ "data:", "http:", "https:" ]);
   async function fetch(url, options_) {
    return new Promise(((resolve, reject) => {
     const request = new Request(url, options_), {parsedURL, options} = getNodeRequestOptions(request);
     if (!supportedSchemas.has(parsedURL.protocol)) throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
     if ("data:" === parsedURL.protocol) {
      const data = dist(request.url), response = new Response(data, {
       headers: {
        "Content-Type": data.typeFull
       }
      });
      return void resolve(response);
     }
     const send = ("https:" === parsedURL.protocol ? external_node_https_namespaceObject : external_node_http_namespaceObject).request, {signal} = request;
     let response = null;
     const abort = () => {
      const error = new AbortError("The operation was aborted.");
      reject(error), request.body && request.body instanceof external_node_stream_namespaceObject.Readable && request.body.destroy(error), 
      response && response.body && response.body.emit("error", error);
     };
     if (signal && signal.aborted) return void abort();
     const abortAndFinalize = () => {
      abort(), finalize();
     }, request_ = send(parsedURL.toString(), options);
     signal && signal.addEventListener("abort", abortAndFinalize);
     const finalize = () => {
      request_.abort(), signal && signal.removeEventListener("abort", abortAndFinalize);
     };
     request_.on("error", (error => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, "system", error)), 
      finalize();
     })), function(request, errorCallback) {
      const LAST_CHUNK = external_node_buffer_namespaceObject.Buffer.from("0\r\n\r\n");
      let previousChunk, isChunkedTransfer = !1, properLastChunkReceived = !1;
      request.on("response", (response => {
       const {headers} = response;
       isChunkedTransfer = "chunked" === headers["transfer-encoding"] && !headers["content-length"];
      })), request.on("socket", (socket => {
       const onSocketClose = () => {
        if (isChunkedTransfer && !properLastChunkReceived) {
         const error = new Error("Premature close");
         error.code = "ERR_STREAM_PREMATURE_CLOSE", errorCallback(error);
        }
       }, onData = buf => {
        properLastChunkReceived = 0 === external_node_buffer_namespaceObject.Buffer.compare(buf.slice(-5), LAST_CHUNK), 
        !properLastChunkReceived && previousChunk && (properLastChunkReceived = 0 === external_node_buffer_namespaceObject.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) && 0 === external_node_buffer_namespaceObject.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3))), 
        previousChunk = buf;
       };
       socket.prependListener("close", onSocketClose), socket.on("data", onData), request.on("close", (() => {
        socket.removeListener("close", onSocketClose), socket.removeListener("data", onData);
       }));
      }));
     }(request_, (error => {
      response && response.body && response.body.destroy(error);
     })), process.version < "v14" && request_.on("socket", (s => {
      let endedWithEventsCount;
      s.prependListener("end", (() => {
       endedWithEventsCount = s._eventsCount;
      })), s.prependListener("close", (hadError => {
       if (response && endedWithEventsCount < s._eventsCount && !hadError) {
        const error = new Error("Premature close");
        error.code = "ERR_STREAM_PREMATURE_CLOSE", response.body.emit("error", error);
       }
      }));
     })), request_.on("response", (response_ => {
      request_.setTimeout(0);
      const headers = function(headers = []) {
       return new Headers(headers.reduce(((result, value, index, array) => (index % 2 == 0 && result.push(array.slice(index, index + 2)), 
       result)), []).filter((([name, value]) => {
        try {
         return validateHeaderName(name), validateHeaderValue(name, String(value)), !0;
        } catch {
         return !1;
        }
       })));
      }(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
       const location = headers.get("Location");
       let locationURL = null;
       try {
        locationURL = null === location ? null : new URL(location, request.url);
       } catch {
        if ("manual" !== request.redirect) return reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect")), 
        void finalize();
       }
       switch (request.redirect) {
       case "error":
        return reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect")), 
        void finalize();

       case "manual":
        break;

       case "follow":
        {
         if (null === locationURL) break;
         if (request.counter >= request.follow) return reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect")), 
         void finalize();
         const requestOptions = {
          headers: new Headers(request.headers),
          follow: request.follow,
          counter: request.counter + 1,
          agent: request.agent,
          compress: request.compress,
          method: request.method,
          body: clone(request),
          signal: request.signal,
          size: request.size,
          referrer: request.referrer,
          referrerPolicy: request.referrerPolicy
         };
         if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) for (const name of [ "authorization", "www-authenticate", "cookie", "cookie2" ]) requestOptions.headers.delete(name);
         if (303 !== response_.statusCode && request.body && options_.body instanceof external_node_stream_namespaceObject.Readable) return reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect")), 
         void finalize();
         303 !== response_.statusCode && (301 !== response_.statusCode && 302 !== response_.statusCode || "POST" !== request.method) || (requestOptions.method = "GET", 
         requestOptions.body = void 0, requestOptions.headers.delete("content-length"));
         const responseReferrerPolicy = function(headers) {
          const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
          let policy = "";
          for (const token of policyTokens) token && ReferrerPolicy.has(token) && (policy = token);
          return policy;
         }(headers);
         return responseReferrerPolicy && (requestOptions.referrerPolicy = responseReferrerPolicy), 
         resolve(fetch(new Request(locationURL, requestOptions))), void finalize();
        }

       default:
        return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
       }
      }
      signal && response_.once("end", (() => {
       signal.removeEventListener("abort", abortAndFinalize);
      }));
      let body = (0, external_node_stream_namespaceObject.pipeline)(response_, new external_node_stream_namespaceObject.PassThrough, (error => {
       error && reject(error);
      }));
      process.version < "v12.10" && response_.on("aborted", abortAndFinalize);
      const responseOptions = {
       url: request.url,
       status: response_.statusCode,
       statusText: response_.statusMessage,
       headers,
       size: request.size,
       counter: request.counter,
       highWaterMark: request.highWaterMark
      }, codings = headers.get("Content-Encoding");
      if (!request.compress || "HEAD" === request.method || null === codings || 204 === response_.statusCode || 304 === response_.statusCode) return response = new Response(body, responseOptions), 
      void resolve(response);
      const zlibOptions = {
       flush: external_node_zlib_namespaceObject.Z_SYNC_FLUSH,
       finishFlush: external_node_zlib_namespaceObject.Z_SYNC_FLUSH
      };
      if ("gzip" === codings || "x-gzip" === codings) return body = (0, external_node_stream_namespaceObject.pipeline)(body, external_node_zlib_namespaceObject.createGunzip(zlibOptions), (error => {
       error && reject(error);
      })), response = new Response(body, responseOptions), void resolve(response);
      if ("deflate" === codings || "x-deflate" === codings) {
       const raw = (0, external_node_stream_namespaceObject.pipeline)(response_, new external_node_stream_namespaceObject.PassThrough, (error => {
        error && reject(error);
       }));
       return raw.once("data", (chunk => {
        body = 8 == (15 & chunk[0]) ? (0, external_node_stream_namespaceObject.pipeline)(body, external_node_zlib_namespaceObject.createInflate(), (error => {
         error && reject(error);
        })) : (0, external_node_stream_namespaceObject.pipeline)(body, external_node_zlib_namespaceObject.createInflateRaw(), (error => {
         error && reject(error);
        })), response = new Response(body, responseOptions), resolve(response);
       })), void raw.once("end", (() => {
        response || (response = new Response(body, responseOptions), resolve(response));
       }));
      }
      if ("br" === codings) return body = (0, external_node_stream_namespaceObject.pipeline)(body, external_node_zlib_namespaceObject.createBrotliDecompress(), (error => {
       error && reject(error);
      })), response = new Response(body, responseOptions), void resolve(response);
      response = new Response(body, responseOptions), resolve(response);
     })), writeToStream(request_, request).catch(reject);
    }));
   }
  },
  26157: module => {
   "use strict";
   module.exports = {
    i8: "1.7.6"
   };
  },
  130: module => {
   "use strict";
   module.exports = {
    i8: "1.1.1"
   };
  },
  53765: module => {
   "use strict";
   module.exports = JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');
  },
  32301: module => {
   "use strict";
   module.exports = {
    i8: "1.3.7"
   };
  }
 }, __webpack_module_cache__ = {}, installedChunks;
 function __webpack_require__(moduleId) {
  var cachedModule = __webpack_module_cache__[moduleId];
  if (void 0 !== cachedModule) return cachedModule.exports;
  var module = __webpack_module_cache__[moduleId] = {
   exports: {}
  };
  return __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
  module.exports;
 }
 __webpack_require__.m = __webpack_modules__, __webpack_require__.n = module => {
  var getter = module && module.__esModule ? () => module.default : () => module;
  return __webpack_require__.d(getter, {
   a: getter
  }), getter;
 }, __webpack_require__.d = (exports, definition) => {
  for (var key in definition) __webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key) && Object.defineProperty(exports, key, {
   enumerable: !0,
   get: definition[key]
  });
 }, __webpack_require__.f = {}, __webpack_require__.e = chunkId => Promise.all(Object.keys(__webpack_require__.f).reduce(((promises, key) => (__webpack_require__.f[key](chunkId, promises), 
 promises)), [])), __webpack_require__.u = chunkId => chunkId + ".extension.js", 
 __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop), 
 __webpack_require__.r = exports => {
  "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
   value: "Module"
  }), Object.defineProperty(exports, "__esModule", {
   value: !0
  });
 }, installedChunks = {
  179: 1
 }, __webpack_require__.f.require = (chunkId, promises) => {
  installedChunks[chunkId] || (chunk => {
   var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
   for (var moduleId in moreModules) __webpack_require__.o(moreModules, moduleId) && (__webpack_require__.m[moduleId] = moreModules[moduleId]);
   runtime && runtime(__webpack_require__);
   for (var i = 0; i < chunkIds.length; i++) installedChunks[chunkIds[i]] = 1;
  })(require("./" + __webpack_require__.u(chunkId)));
 };
 var __webpack_exports__ = {};
 (() => {
  "use strict";
  var exports = __webpack_exports__;
  Object.defineProperty(exports, "__esModule", {
   value: !0
  }), exports.deactivate = exports.activate = void 0;
  const tslib_1 = __webpack_require__(70655);
  __webpack_require__(28660);
  const dbtPowerUserExtension_1 = __webpack_require__(92182), inversify_config_1 = __webpack_require__(81908);
  exports.activate = function(context) {
   return tslib_1.__awaiter(this, void 0, void 0, (function*() {
    const dbtPowerUserExtension = inversify_config_1.container.get(dbtPowerUserExtension_1.DBTPowerUserExtension);
    context.subscriptions.push(dbtPowerUserExtension), yield dbtPowerUserExtension.activate(context);
   }));
  }, exports.deactivate = function() {};
 })(), module.exports = __webpack_exports__;
})();
//# sourceMappingURL=extension.js.map